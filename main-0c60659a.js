var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
function _mergeNamespaces(n2, m2) {
  for (var i2 = 0; i2 < m2.length; i2++) {
    const e2 = m2[i2];
    if (typeof e2 !== "string" && !Array.isArray(e2)) {
      for (const k2 in e2) {
        if (k2 !== "default" && !(k2 in n2)) {
          const d2 = Object.getOwnPropertyDescriptor(e2, k2);
          if (d2) {
            Object.defineProperty(n2, k2, d2.get ? d2 : {
              enumerable: true,
              get: () => e2[k2]
            });
          }
        }
      }
    }
  }
  return Object.freeze(Object.defineProperty(n2, Symbol.toStringTag, { value: "Module" }));
}
(function polyfill() {
  const relList = document.createElement("link").relList;
  if (relList && relList.supports && relList.supports("modulepreload")) {
    return;
  }
  for (const link of document.querySelectorAll('link[rel="modulepreload"]')) {
    processPreload(link);
  }
  new MutationObserver((mutations) => {
    for (const mutation of mutations) {
      if (mutation.type !== "childList") {
        continue;
      }
      for (const node of mutation.addedNodes) {
        if (node.tagName === "LINK" && node.rel === "modulepreload")
          processPreload(node);
      }
    }
  }).observe(document, { childList: true, subtree: true });
  function getFetchOpts(link) {
    const fetchOpts = {};
    if (link.integrity)
      fetchOpts.integrity = link.integrity;
    if (link.referrerPolicy)
      fetchOpts.referrerPolicy = link.referrerPolicy;
    if (link.crossOrigin === "use-credentials")
      fetchOpts.credentials = "include";
    else if (link.crossOrigin === "anonymous")
      fetchOpts.credentials = "omit";
    else
      fetchOpts.credentials = "same-origin";
    return fetchOpts;
  }
  function processPreload(link) {
    if (link.ep)
      return;
    link.ep = true;
    const fetchOpts = getFetchOpts(link);
    fetch(link.href, fetchOpts);
  }
})();
function getDefaultExportFromCjs(x) {
  return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, "default") ? x["default"] : x;
}
var jsxRuntime = { exports: {} };
var reactJsxRuntime_production_min = {};
var react = { exports: {} };
var react_production_min = {};
/**
 * @license React
 * react.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var l$5 = Symbol.for("react.element"), n$5 = Symbol.for("react.portal"), p$5 = Symbol.for("react.fragment"), q$4 = Symbol.for("react.strict_mode"), r$4 = Symbol.for("react.profiler"), t$2 = Symbol.for("react.provider"), u$2 = Symbol.for("react.context"), v$4 = Symbol.for("react.forward_ref"), w$2 = Symbol.for("react.suspense"), x$3 = Symbol.for("react.memo"), y$3 = Symbol.for("react.lazy"), z$4 = Symbol.iterator;
function A$4(a2) {
  if (null === a2 || "object" !== typeof a2)
    return null;
  a2 = z$4 && a2[z$4] || a2["@@iterator"];
  return "function" === typeof a2 ? a2 : null;
}
var B$3 = { isMounted: function() {
  return false;
}, enqueueForceUpdate: function() {
}, enqueueReplaceState: function() {
}, enqueueSetState: function() {
} }, C$3 = Object.assign, D$3 = {};
function E$3(a2, b2, e2) {
  this.props = a2;
  this.context = b2;
  this.refs = D$3;
  this.updater = e2 || B$3;
}
E$3.prototype.isReactComponent = {};
E$3.prototype.setState = function(a2, b2) {
  if ("object" !== typeof a2 && "function" !== typeof a2 && null != a2)
    throw Error("setState(...): takes an object of state variables to update or a function which returns an object of state variables.");
  this.updater.enqueueSetState(this, a2, b2, "setState");
};
E$3.prototype.forceUpdate = function(a2) {
  this.updater.enqueueForceUpdate(this, a2, "forceUpdate");
};
function F$2() {
}
F$2.prototype = E$3.prototype;
function G$3(a2, b2, e2) {
  this.props = a2;
  this.context = b2;
  this.refs = D$3;
  this.updater = e2 || B$3;
}
var H$3 = G$3.prototype = new F$2();
H$3.constructor = G$3;
C$3(H$3, E$3.prototype);
H$3.isPureReactComponent = true;
var I$3 = Array.isArray, J$1 = Object.prototype.hasOwnProperty, K$2 = { current: null }, L$2 = { key: true, ref: true, __self: true, __source: true };
function M$2(a2, b2, e2) {
  var d2, c2 = {}, k2 = null, h2 = null;
  if (null != b2)
    for (d2 in void 0 !== b2.ref && (h2 = b2.ref), void 0 !== b2.key && (k2 = "" + b2.key), b2)
      J$1.call(b2, d2) && !L$2.hasOwnProperty(d2) && (c2[d2] = b2[d2]);
  var g2 = arguments.length - 2;
  if (1 === g2)
    c2.children = e2;
  else if (1 < g2) {
    for (var f2 = Array(g2), m2 = 0; m2 < g2; m2++)
      f2[m2] = arguments[m2 + 2];
    c2.children = f2;
  }
  if (a2 && a2.defaultProps)
    for (d2 in g2 = a2.defaultProps, g2)
      void 0 === c2[d2] && (c2[d2] = g2[d2]);
  return { $$typeof: l$5, type: a2, key: k2, ref: h2, props: c2, _owner: K$2.current };
}
function N$2(a2, b2) {
  return { $$typeof: l$5, type: a2.type, key: b2, ref: a2.ref, props: a2.props, _owner: a2._owner };
}
function O$2(a2) {
  return "object" === typeof a2 && null !== a2 && a2.$$typeof === l$5;
}
function escape$1(a2) {
  var b2 = { "=": "=0", ":": "=2" };
  return "$" + a2.replace(/[=:]/g, function(a3) {
    return b2[a3];
  });
}
var P$2 = /\/+/g;
function Q$2(a2, b2) {
  return "object" === typeof a2 && null !== a2 && null != a2.key ? escape$1("" + a2.key) : b2.toString(36);
}
function R$2(a2, b2, e2, d2, c2) {
  var k2 = typeof a2;
  if ("undefined" === k2 || "boolean" === k2)
    a2 = null;
  var h2 = false;
  if (null === a2)
    h2 = true;
  else
    switch (k2) {
      case "string":
      case "number":
        h2 = true;
        break;
      case "object":
        switch (a2.$$typeof) {
          case l$5:
          case n$5:
            h2 = true;
        }
    }
  if (h2)
    return h2 = a2, c2 = c2(h2), a2 = "" === d2 ? "." + Q$2(h2, 0) : d2, I$3(c2) ? (e2 = "", null != a2 && (e2 = a2.replace(P$2, "$&/") + "/"), R$2(c2, b2, e2, "", function(a3) {
      return a3;
    })) : null != c2 && (O$2(c2) && (c2 = N$2(c2, e2 + (!c2.key || h2 && h2.key === c2.key ? "" : ("" + c2.key).replace(P$2, "$&/") + "/") + a2)), b2.push(c2)), 1;
  h2 = 0;
  d2 = "" === d2 ? "." : d2 + ":";
  if (I$3(a2))
    for (var g2 = 0; g2 < a2.length; g2++) {
      k2 = a2[g2];
      var f2 = d2 + Q$2(k2, g2);
      h2 += R$2(k2, b2, e2, f2, c2);
    }
  else if (f2 = A$4(a2), "function" === typeof f2)
    for (a2 = f2.call(a2), g2 = 0; !(k2 = a2.next()).done; )
      k2 = k2.value, f2 = d2 + Q$2(k2, g2++), h2 += R$2(k2, b2, e2, f2, c2);
  else if ("object" === k2)
    throw b2 = String(a2), Error("Objects are not valid as a React child (found: " + ("[object Object]" === b2 ? "object with keys {" + Object.keys(a2).join(", ") + "}" : b2) + "). If you meant to render a collection of children, use an array instead.");
  return h2;
}
function S$2(a2, b2, e2) {
  if (null == a2)
    return a2;
  var d2 = [], c2 = 0;
  R$2(a2, d2, "", "", function(a3) {
    return b2.call(e2, a3, c2++);
  });
  return d2;
}
function T$2(a2) {
  if (-1 === a2._status) {
    var b2 = a2._result;
    b2 = b2();
    b2.then(function(b3) {
      if (0 === a2._status || -1 === a2._status)
        a2._status = 1, a2._result = b3;
    }, function(b3) {
      if (0 === a2._status || -1 === a2._status)
        a2._status = 2, a2._result = b3;
    });
    -1 === a2._status && (a2._status = 0, a2._result = b2);
  }
  if (1 === a2._status)
    return a2._result.default;
  throw a2._result;
}
var U$2 = { current: null }, V$2 = { transition: null }, W$2 = { ReactCurrentDispatcher: U$2, ReactCurrentBatchConfig: V$2, ReactCurrentOwner: K$2 };
react_production_min.Children = { map: S$2, forEach: function(a2, b2, e2) {
  S$2(a2, function() {
    b2.apply(this, arguments);
  }, e2);
}, count: function(a2) {
  var b2 = 0;
  S$2(a2, function() {
    b2++;
  });
  return b2;
}, toArray: function(a2) {
  return S$2(a2, function(a3) {
    return a3;
  }) || [];
}, only: function(a2) {
  if (!O$2(a2))
    throw Error("React.Children.only expected to receive a single React element child.");
  return a2;
} };
react_production_min.Component = E$3;
react_production_min.Fragment = p$5;
react_production_min.Profiler = r$4;
react_production_min.PureComponent = G$3;
react_production_min.StrictMode = q$4;
react_production_min.Suspense = w$2;
react_production_min.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = W$2;
react_production_min.cloneElement = function(a2, b2, e2) {
  if (null === a2 || void 0 === a2)
    throw Error("React.cloneElement(...): The argument must be a React element, but you passed " + a2 + ".");
  var d2 = C$3({}, a2.props), c2 = a2.key, k2 = a2.ref, h2 = a2._owner;
  if (null != b2) {
    void 0 !== b2.ref && (k2 = b2.ref, h2 = K$2.current);
    void 0 !== b2.key && (c2 = "" + b2.key);
    if (a2.type && a2.type.defaultProps)
      var g2 = a2.type.defaultProps;
    for (f2 in b2)
      J$1.call(b2, f2) && !L$2.hasOwnProperty(f2) && (d2[f2] = void 0 === b2[f2] && void 0 !== g2 ? g2[f2] : b2[f2]);
  }
  var f2 = arguments.length - 2;
  if (1 === f2)
    d2.children = e2;
  else if (1 < f2) {
    g2 = Array(f2);
    for (var m2 = 0; m2 < f2; m2++)
      g2[m2] = arguments[m2 + 2];
    d2.children = g2;
  }
  return { $$typeof: l$5, type: a2.type, key: c2, ref: k2, props: d2, _owner: h2 };
};
react_production_min.createContext = function(a2) {
  a2 = { $$typeof: u$2, _currentValue: a2, _currentValue2: a2, _threadCount: 0, Provider: null, Consumer: null, _defaultValue: null, _globalName: null };
  a2.Provider = { $$typeof: t$2, _context: a2 };
  return a2.Consumer = a2;
};
react_production_min.createElement = M$2;
react_production_min.createFactory = function(a2) {
  var b2 = M$2.bind(null, a2);
  b2.type = a2;
  return b2;
};
react_production_min.createRef = function() {
  return { current: null };
};
react_production_min.forwardRef = function(a2) {
  return { $$typeof: v$4, render: a2 };
};
react_production_min.isValidElement = O$2;
react_production_min.lazy = function(a2) {
  return { $$typeof: y$3, _payload: { _status: -1, _result: a2 }, _init: T$2 };
};
react_production_min.memo = function(a2, b2) {
  return { $$typeof: x$3, type: a2, compare: void 0 === b2 ? null : b2 };
};
react_production_min.startTransition = function(a2) {
  var b2 = V$2.transition;
  V$2.transition = {};
  try {
    a2();
  } finally {
    V$2.transition = b2;
  }
};
react_production_min.unstable_act = function() {
  throw Error("act(...) is not supported in production builds of React.");
};
react_production_min.useCallback = function(a2, b2) {
  return U$2.current.useCallback(a2, b2);
};
react_production_min.useContext = function(a2) {
  return U$2.current.useContext(a2);
};
react_production_min.useDebugValue = function() {
};
react_production_min.useDeferredValue = function(a2) {
  return U$2.current.useDeferredValue(a2);
};
react_production_min.useEffect = function(a2, b2) {
  return U$2.current.useEffect(a2, b2);
};
react_production_min.useId = function() {
  return U$2.current.useId();
};
react_production_min.useImperativeHandle = function(a2, b2, e2) {
  return U$2.current.useImperativeHandle(a2, b2, e2);
};
react_production_min.useInsertionEffect = function(a2, b2) {
  return U$2.current.useInsertionEffect(a2, b2);
};
react_production_min.useLayoutEffect = function(a2, b2) {
  return U$2.current.useLayoutEffect(a2, b2);
};
react_production_min.useMemo = function(a2, b2) {
  return U$2.current.useMemo(a2, b2);
};
react_production_min.useReducer = function(a2, b2, e2) {
  return U$2.current.useReducer(a2, b2, e2);
};
react_production_min.useRef = function(a2) {
  return U$2.current.useRef(a2);
};
react_production_min.useState = function(a2) {
  return U$2.current.useState(a2);
};
react_production_min.useSyncExternalStore = function(a2, b2, e2) {
  return U$2.current.useSyncExternalStore(a2, b2, e2);
};
react_production_min.useTransition = function() {
  return U$2.current.useTransition();
};
react_production_min.version = "18.2.0";
{
  react.exports = react_production_min;
}
var reactExports = react.exports;
const React = /* @__PURE__ */ getDefaultExportFromCjs(reactExports);
const React$1 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: React
}, [reactExports]);
/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var f$3 = reactExports, k$3 = Symbol.for("react.element"), l$4 = Symbol.for("react.fragment"), m$4 = Object.prototype.hasOwnProperty, n$4 = f$3.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner, p$4 = { key: true, ref: true, __self: true, __source: true };
function q$3(c2, a2, g2) {
  var b2, d2 = {}, e2 = null, h2 = null;
  void 0 !== g2 && (e2 = "" + g2);
  void 0 !== a2.key && (e2 = "" + a2.key);
  void 0 !== a2.ref && (h2 = a2.ref);
  for (b2 in a2)
    m$4.call(a2, b2) && !p$4.hasOwnProperty(b2) && (d2[b2] = a2[b2]);
  if (c2 && c2.defaultProps)
    for (b2 in a2 = c2.defaultProps, a2)
      void 0 === d2[b2] && (d2[b2] = a2[b2]);
  return { $$typeof: k$3, type: c2, key: e2, ref: h2, props: d2, _owner: n$4.current };
}
reactJsxRuntime_production_min.Fragment = l$4;
reactJsxRuntime_production_min.jsx = q$3;
reactJsxRuntime_production_min.jsxs = q$3;
{
  jsxRuntime.exports = reactJsxRuntime_production_min;
}
var jsxRuntimeExports = jsxRuntime.exports;
var client = {};
var reactDom = { exports: {} };
var reactDom_production_min = {};
var scheduler = { exports: {} };
var scheduler_production_min = {};
/**
 * @license React
 * scheduler.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
(function(exports) {
  function f2(a2, b2) {
    var c2 = a2.length;
    a2.push(b2);
    a:
      for (; 0 < c2; ) {
        var d2 = c2 - 1 >>> 1, e2 = a2[d2];
        if (0 < g2(e2, b2))
          a2[d2] = b2, a2[c2] = e2, c2 = d2;
        else
          break a;
      }
  }
  function h2(a2) {
    return 0 === a2.length ? null : a2[0];
  }
  function k2(a2) {
    if (0 === a2.length)
      return null;
    var b2 = a2[0], c2 = a2.pop();
    if (c2 !== b2) {
      a2[0] = c2;
      a:
        for (var d2 = 0, e2 = a2.length, w2 = e2 >>> 1; d2 < w2; ) {
          var m2 = 2 * (d2 + 1) - 1, C2 = a2[m2], n2 = m2 + 1, x = a2[n2];
          if (0 > g2(C2, c2))
            n2 < e2 && 0 > g2(x, C2) ? (a2[d2] = x, a2[n2] = c2, d2 = n2) : (a2[d2] = C2, a2[m2] = c2, d2 = m2);
          else if (n2 < e2 && 0 > g2(x, c2))
            a2[d2] = x, a2[n2] = c2, d2 = n2;
          else
            break a;
        }
    }
    return b2;
  }
  function g2(a2, b2) {
    var c2 = a2.sortIndex - b2.sortIndex;
    return 0 !== c2 ? c2 : a2.id - b2.id;
  }
  if ("object" === typeof performance && "function" === typeof performance.now) {
    var l2 = performance;
    exports.unstable_now = function() {
      return l2.now();
    };
  } else {
    var p2 = Date, q2 = p2.now();
    exports.unstable_now = function() {
      return p2.now() - q2;
    };
  }
  var r2 = [], t2 = [], u2 = 1, v2 = null, y2 = 3, z2 = false, A2 = false, B2 = false, D2 = "function" === typeof setTimeout ? setTimeout : null, E2 = "function" === typeof clearTimeout ? clearTimeout : null, F2 = "undefined" !== typeof setImmediate ? setImmediate : null;
  "undefined" !== typeof navigator && void 0 !== navigator.scheduling && void 0 !== navigator.scheduling.isInputPending && navigator.scheduling.isInputPending.bind(navigator.scheduling);
  function G2(a2) {
    for (var b2 = h2(t2); null !== b2; ) {
      if (null === b2.callback)
        k2(t2);
      else if (b2.startTime <= a2)
        k2(t2), b2.sortIndex = b2.expirationTime, f2(r2, b2);
      else
        break;
      b2 = h2(t2);
    }
  }
  function H2(a2) {
    B2 = false;
    G2(a2);
    if (!A2)
      if (null !== h2(r2))
        A2 = true, I2(J2);
      else {
        var b2 = h2(t2);
        null !== b2 && K2(H2, b2.startTime - a2);
      }
  }
  function J2(a2, b2) {
    A2 = false;
    B2 && (B2 = false, E2(L2), L2 = -1);
    z2 = true;
    var c2 = y2;
    try {
      G2(b2);
      for (v2 = h2(r2); null !== v2 && (!(v2.expirationTime > b2) || a2 && !M2()); ) {
        var d2 = v2.callback;
        if ("function" === typeof d2) {
          v2.callback = null;
          y2 = v2.priorityLevel;
          var e2 = d2(v2.expirationTime <= b2);
          b2 = exports.unstable_now();
          "function" === typeof e2 ? v2.callback = e2 : v2 === h2(r2) && k2(r2);
          G2(b2);
        } else
          k2(r2);
        v2 = h2(r2);
      }
      if (null !== v2)
        var w2 = true;
      else {
        var m2 = h2(t2);
        null !== m2 && K2(H2, m2.startTime - b2);
        w2 = false;
      }
      return w2;
    } finally {
      v2 = null, y2 = c2, z2 = false;
    }
  }
  var N2 = false, O2 = null, L2 = -1, P2 = 5, Q2 = -1;
  function M2() {
    return exports.unstable_now() - Q2 < P2 ? false : true;
  }
  function R2() {
    if (null !== O2) {
      var a2 = exports.unstable_now();
      Q2 = a2;
      var b2 = true;
      try {
        b2 = O2(true, a2);
      } finally {
        b2 ? S2() : (N2 = false, O2 = null);
      }
    } else
      N2 = false;
  }
  var S2;
  if ("function" === typeof F2)
    S2 = function() {
      F2(R2);
    };
  else if ("undefined" !== typeof MessageChannel) {
    var T2 = new MessageChannel(), U2 = T2.port2;
    T2.port1.onmessage = R2;
    S2 = function() {
      U2.postMessage(null);
    };
  } else
    S2 = function() {
      D2(R2, 0);
    };
  function I2(a2) {
    O2 = a2;
    N2 || (N2 = true, S2());
  }
  function K2(a2, b2) {
    L2 = D2(function() {
      a2(exports.unstable_now());
    }, b2);
  }
  exports.unstable_IdlePriority = 5;
  exports.unstable_ImmediatePriority = 1;
  exports.unstable_LowPriority = 4;
  exports.unstable_NormalPriority = 3;
  exports.unstable_Profiling = null;
  exports.unstable_UserBlockingPriority = 2;
  exports.unstable_cancelCallback = function(a2) {
    a2.callback = null;
  };
  exports.unstable_continueExecution = function() {
    A2 || z2 || (A2 = true, I2(J2));
  };
  exports.unstable_forceFrameRate = function(a2) {
    0 > a2 || 125 < a2 ? console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported") : P2 = 0 < a2 ? Math.floor(1e3 / a2) : 5;
  };
  exports.unstable_getCurrentPriorityLevel = function() {
    return y2;
  };
  exports.unstable_getFirstCallbackNode = function() {
    return h2(r2);
  };
  exports.unstable_next = function(a2) {
    switch (y2) {
      case 1:
      case 2:
      case 3:
        var b2 = 3;
        break;
      default:
        b2 = y2;
    }
    var c2 = y2;
    y2 = b2;
    try {
      return a2();
    } finally {
      y2 = c2;
    }
  };
  exports.unstable_pauseExecution = function() {
  };
  exports.unstable_requestPaint = function() {
  };
  exports.unstable_runWithPriority = function(a2, b2) {
    switch (a2) {
      case 1:
      case 2:
      case 3:
      case 4:
      case 5:
        break;
      default:
        a2 = 3;
    }
    var c2 = y2;
    y2 = a2;
    try {
      return b2();
    } finally {
      y2 = c2;
    }
  };
  exports.unstable_scheduleCallback = function(a2, b2, c2) {
    var d2 = exports.unstable_now();
    "object" === typeof c2 && null !== c2 ? (c2 = c2.delay, c2 = "number" === typeof c2 && 0 < c2 ? d2 + c2 : d2) : c2 = d2;
    switch (a2) {
      case 1:
        var e2 = -1;
        break;
      case 2:
        e2 = 250;
        break;
      case 5:
        e2 = 1073741823;
        break;
      case 4:
        e2 = 1e4;
        break;
      default:
        e2 = 5e3;
    }
    e2 = c2 + e2;
    a2 = { id: u2++, callback: b2, priorityLevel: a2, startTime: c2, expirationTime: e2, sortIndex: -1 };
    c2 > d2 ? (a2.sortIndex = c2, f2(t2, a2), null === h2(r2) && a2 === h2(t2) && (B2 ? (E2(L2), L2 = -1) : B2 = true, K2(H2, c2 - d2))) : (a2.sortIndex = e2, f2(r2, a2), A2 || z2 || (A2 = true, I2(J2)));
    return a2;
  };
  exports.unstable_shouldYield = M2;
  exports.unstable_wrapCallback = function(a2) {
    var b2 = y2;
    return function() {
      var c2 = y2;
      y2 = b2;
      try {
        return a2.apply(this, arguments);
      } finally {
        y2 = c2;
      }
    };
  };
})(scheduler_production_min);
{
  scheduler.exports = scheduler_production_min;
}
var schedulerExports = scheduler.exports;
/**
 * @license React
 * react-dom.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var aa = reactExports, ca = schedulerExports;
function p$3(a2) {
  for (var b2 = "https://reactjs.org/docs/error-decoder.html?invariant=" + a2, c2 = 1; c2 < arguments.length; c2++)
    b2 += "&args[]=" + encodeURIComponent(arguments[c2]);
  return "Minified React error #" + a2 + "; visit " + b2 + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings.";
}
var da = /* @__PURE__ */ new Set(), ea = {};
function fa(a2, b2) {
  ha(a2, b2);
  ha(a2 + "Capture", b2);
}
function ha(a2, b2) {
  ea[a2] = b2;
  for (a2 = 0; a2 < b2.length; a2++)
    da.add(b2[a2]);
}
var ia = !("undefined" === typeof window || "undefined" === typeof window.document || "undefined" === typeof window.document.createElement), ja = Object.prototype.hasOwnProperty, ka = /^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/, la = {}, ma = {};
function oa(a2) {
  if (ja.call(ma, a2))
    return true;
  if (ja.call(la, a2))
    return false;
  if (ka.test(a2))
    return ma[a2] = true;
  la[a2] = true;
  return false;
}
function pa(a2, b2, c2, d2) {
  if (null !== c2 && 0 === c2.type)
    return false;
  switch (typeof b2) {
    case "function":
    case "symbol":
      return true;
    case "boolean":
      if (d2)
        return false;
      if (null !== c2)
        return !c2.acceptsBooleans;
      a2 = a2.toLowerCase().slice(0, 5);
      return "data-" !== a2 && "aria-" !== a2;
    default:
      return false;
  }
}
function qa(a2, b2, c2, d2) {
  if (null === b2 || "undefined" === typeof b2 || pa(a2, b2, c2, d2))
    return true;
  if (d2)
    return false;
  if (null !== c2)
    switch (c2.type) {
      case 3:
        return !b2;
      case 4:
        return false === b2;
      case 5:
        return isNaN(b2);
      case 6:
        return isNaN(b2) || 1 > b2;
    }
  return false;
}
function v$3(a2, b2, c2, d2, e2, f2, g2) {
  this.acceptsBooleans = 2 === b2 || 3 === b2 || 4 === b2;
  this.attributeName = d2;
  this.attributeNamespace = e2;
  this.mustUseProperty = c2;
  this.propertyName = a2;
  this.type = b2;
  this.sanitizeURL = f2;
  this.removeEmptyString = g2;
}
var z$3 = {};
"children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function(a2) {
  z$3[a2] = new v$3(a2, 0, false, a2, null, false, false);
});
[["acceptCharset", "accept-charset"], ["className", "class"], ["htmlFor", "for"], ["httpEquiv", "http-equiv"]].forEach(function(a2) {
  var b2 = a2[0];
  z$3[b2] = new v$3(b2, 1, false, a2[1], null, false, false);
});
["contentEditable", "draggable", "spellCheck", "value"].forEach(function(a2) {
  z$3[a2] = new v$3(a2, 2, false, a2.toLowerCase(), null, false, false);
});
["autoReverse", "externalResourcesRequired", "focusable", "preserveAlpha"].forEach(function(a2) {
  z$3[a2] = new v$3(a2, 2, false, a2, null, false, false);
});
"allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function(a2) {
  z$3[a2] = new v$3(a2, 3, false, a2.toLowerCase(), null, false, false);
});
["checked", "multiple", "muted", "selected"].forEach(function(a2) {
  z$3[a2] = new v$3(a2, 3, true, a2, null, false, false);
});
["capture", "download"].forEach(function(a2) {
  z$3[a2] = new v$3(a2, 4, false, a2, null, false, false);
});
["cols", "rows", "size", "span"].forEach(function(a2) {
  z$3[a2] = new v$3(a2, 6, false, a2, null, false, false);
});
["rowSpan", "start"].forEach(function(a2) {
  z$3[a2] = new v$3(a2, 5, false, a2.toLowerCase(), null, false, false);
});
var ra = /[\-:]([a-z])/g;
function sa(a2) {
  return a2[1].toUpperCase();
}
"accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function(a2) {
  var b2 = a2.replace(
    ra,
    sa
  );
  z$3[b2] = new v$3(b2, 1, false, a2, null, false, false);
});
"xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function(a2) {
  var b2 = a2.replace(ra, sa);
  z$3[b2] = new v$3(b2, 1, false, a2, "http://www.w3.org/1999/xlink", false, false);
});
["xml:base", "xml:lang", "xml:space"].forEach(function(a2) {
  var b2 = a2.replace(ra, sa);
  z$3[b2] = new v$3(b2, 1, false, a2, "http://www.w3.org/XML/1998/namespace", false, false);
});
["tabIndex", "crossOrigin"].forEach(function(a2) {
  z$3[a2] = new v$3(a2, 1, false, a2.toLowerCase(), null, false, false);
});
z$3.xlinkHref = new v$3("xlinkHref", 1, false, "xlink:href", "http://www.w3.org/1999/xlink", true, false);
["src", "href", "action", "formAction"].forEach(function(a2) {
  z$3[a2] = new v$3(a2, 1, false, a2.toLowerCase(), null, true, true);
});
function ta(a2, b2, c2, d2) {
  var e2 = z$3.hasOwnProperty(b2) ? z$3[b2] : null;
  if (null !== e2 ? 0 !== e2.type : d2 || !(2 < b2.length) || "o" !== b2[0] && "O" !== b2[0] || "n" !== b2[1] && "N" !== b2[1])
    qa(b2, c2, e2, d2) && (c2 = null), d2 || null === e2 ? oa(b2) && (null === c2 ? a2.removeAttribute(b2) : a2.setAttribute(b2, "" + c2)) : e2.mustUseProperty ? a2[e2.propertyName] = null === c2 ? 3 === e2.type ? false : "" : c2 : (b2 = e2.attributeName, d2 = e2.attributeNamespace, null === c2 ? a2.removeAttribute(b2) : (e2 = e2.type, c2 = 3 === e2 || 4 === e2 && true === c2 ? "" : "" + c2, d2 ? a2.setAttributeNS(d2, b2, c2) : a2.setAttribute(b2, c2)));
}
var ua = aa.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED, va = Symbol.for("react.element"), wa = Symbol.for("react.portal"), ya = Symbol.for("react.fragment"), za = Symbol.for("react.strict_mode"), Aa = Symbol.for("react.profiler"), Ba = Symbol.for("react.provider"), Ca = Symbol.for("react.context"), Da = Symbol.for("react.forward_ref"), Ea = Symbol.for("react.suspense"), Fa = Symbol.for("react.suspense_list"), Ga = Symbol.for("react.memo"), Ha = Symbol.for("react.lazy");
var Ia = Symbol.for("react.offscreen");
var Ja = Symbol.iterator;
function Ka(a2) {
  if (null === a2 || "object" !== typeof a2)
    return null;
  a2 = Ja && a2[Ja] || a2["@@iterator"];
  return "function" === typeof a2 ? a2 : null;
}
var A$3 = Object.assign, La;
function Ma(a2) {
  if (void 0 === La)
    try {
      throw Error();
    } catch (c2) {
      var b2 = c2.stack.trim().match(/\n( *(at )?)/);
      La = b2 && b2[1] || "";
    }
  return "\n" + La + a2;
}
var Na = false;
function Oa(a2, b2) {
  if (!a2 || Na)
    return "";
  Na = true;
  var c2 = Error.prepareStackTrace;
  Error.prepareStackTrace = void 0;
  try {
    if (b2)
      if (b2 = function() {
        throw Error();
      }, Object.defineProperty(b2.prototype, "props", { set: function() {
        throw Error();
      } }), "object" === typeof Reflect && Reflect.construct) {
        try {
          Reflect.construct(b2, []);
        } catch (l2) {
          var d2 = l2;
        }
        Reflect.construct(a2, [], b2);
      } else {
        try {
          b2.call();
        } catch (l2) {
          d2 = l2;
        }
        a2.call(b2.prototype);
      }
    else {
      try {
        throw Error();
      } catch (l2) {
        d2 = l2;
      }
      a2();
    }
  } catch (l2) {
    if (l2 && d2 && "string" === typeof l2.stack) {
      for (var e2 = l2.stack.split("\n"), f2 = d2.stack.split("\n"), g2 = e2.length - 1, h2 = f2.length - 1; 1 <= g2 && 0 <= h2 && e2[g2] !== f2[h2]; )
        h2--;
      for (; 1 <= g2 && 0 <= h2; g2--, h2--)
        if (e2[g2] !== f2[h2]) {
          if (1 !== g2 || 1 !== h2) {
            do
              if (g2--, h2--, 0 > h2 || e2[g2] !== f2[h2]) {
                var k2 = "\n" + e2[g2].replace(" at new ", " at ");
                a2.displayName && k2.includes("<anonymous>") && (k2 = k2.replace("<anonymous>", a2.displayName));
                return k2;
              }
            while (1 <= g2 && 0 <= h2);
          }
          break;
        }
    }
  } finally {
    Na = false, Error.prepareStackTrace = c2;
  }
  return (a2 = a2 ? a2.displayName || a2.name : "") ? Ma(a2) : "";
}
function Pa(a2) {
  switch (a2.tag) {
    case 5:
      return Ma(a2.type);
    case 16:
      return Ma("Lazy");
    case 13:
      return Ma("Suspense");
    case 19:
      return Ma("SuspenseList");
    case 0:
    case 2:
    case 15:
      return a2 = Oa(a2.type, false), a2;
    case 11:
      return a2 = Oa(a2.type.render, false), a2;
    case 1:
      return a2 = Oa(a2.type, true), a2;
    default:
      return "";
  }
}
function Qa(a2) {
  if (null == a2)
    return null;
  if ("function" === typeof a2)
    return a2.displayName || a2.name || null;
  if ("string" === typeof a2)
    return a2;
  switch (a2) {
    case ya:
      return "Fragment";
    case wa:
      return "Portal";
    case Aa:
      return "Profiler";
    case za:
      return "StrictMode";
    case Ea:
      return "Suspense";
    case Fa:
      return "SuspenseList";
  }
  if ("object" === typeof a2)
    switch (a2.$$typeof) {
      case Ca:
        return (a2.displayName || "Context") + ".Consumer";
      case Ba:
        return (a2._context.displayName || "Context") + ".Provider";
      case Da:
        var b2 = a2.render;
        a2 = a2.displayName;
        a2 || (a2 = b2.displayName || b2.name || "", a2 = "" !== a2 ? "ForwardRef(" + a2 + ")" : "ForwardRef");
        return a2;
      case Ga:
        return b2 = a2.displayName || null, null !== b2 ? b2 : Qa(a2.type) || "Memo";
      case Ha:
        b2 = a2._payload;
        a2 = a2._init;
        try {
          return Qa(a2(b2));
        } catch (c2) {
        }
    }
  return null;
}
function Ra(a2) {
  var b2 = a2.type;
  switch (a2.tag) {
    case 24:
      return "Cache";
    case 9:
      return (b2.displayName || "Context") + ".Consumer";
    case 10:
      return (b2._context.displayName || "Context") + ".Provider";
    case 18:
      return "DehydratedFragment";
    case 11:
      return a2 = b2.render, a2 = a2.displayName || a2.name || "", b2.displayName || ("" !== a2 ? "ForwardRef(" + a2 + ")" : "ForwardRef");
    case 7:
      return "Fragment";
    case 5:
      return b2;
    case 4:
      return "Portal";
    case 3:
      return "Root";
    case 6:
      return "Text";
    case 16:
      return Qa(b2);
    case 8:
      return b2 === za ? "StrictMode" : "Mode";
    case 22:
      return "Offscreen";
    case 12:
      return "Profiler";
    case 21:
      return "Scope";
    case 13:
      return "Suspense";
    case 19:
      return "SuspenseList";
    case 25:
      return "TracingMarker";
    case 1:
    case 0:
    case 17:
    case 2:
    case 14:
    case 15:
      if ("function" === typeof b2)
        return b2.displayName || b2.name || null;
      if ("string" === typeof b2)
        return b2;
  }
  return null;
}
function Sa(a2) {
  switch (typeof a2) {
    case "boolean":
    case "number":
    case "string":
    case "undefined":
      return a2;
    case "object":
      return a2;
    default:
      return "";
  }
}
function Ta(a2) {
  var b2 = a2.type;
  return (a2 = a2.nodeName) && "input" === a2.toLowerCase() && ("checkbox" === b2 || "radio" === b2);
}
function Ua(a2) {
  var b2 = Ta(a2) ? "checked" : "value", c2 = Object.getOwnPropertyDescriptor(a2.constructor.prototype, b2), d2 = "" + a2[b2];
  if (!a2.hasOwnProperty(b2) && "undefined" !== typeof c2 && "function" === typeof c2.get && "function" === typeof c2.set) {
    var e2 = c2.get, f2 = c2.set;
    Object.defineProperty(a2, b2, { configurable: true, get: function() {
      return e2.call(this);
    }, set: function(a3) {
      d2 = "" + a3;
      f2.call(this, a3);
    } });
    Object.defineProperty(a2, b2, { enumerable: c2.enumerable });
    return { getValue: function() {
      return d2;
    }, setValue: function(a3) {
      d2 = "" + a3;
    }, stopTracking: function() {
      a2._valueTracker = null;
      delete a2[b2];
    } };
  }
}
function Va(a2) {
  a2._valueTracker || (a2._valueTracker = Ua(a2));
}
function Wa(a2) {
  if (!a2)
    return false;
  var b2 = a2._valueTracker;
  if (!b2)
    return true;
  var c2 = b2.getValue();
  var d2 = "";
  a2 && (d2 = Ta(a2) ? a2.checked ? "true" : "false" : a2.value);
  a2 = d2;
  return a2 !== c2 ? (b2.setValue(a2), true) : false;
}
function Xa(a2) {
  a2 = a2 || ("undefined" !== typeof document ? document : void 0);
  if ("undefined" === typeof a2)
    return null;
  try {
    return a2.activeElement || a2.body;
  } catch (b2) {
    return a2.body;
  }
}
function Ya(a2, b2) {
  var c2 = b2.checked;
  return A$3({}, b2, { defaultChecked: void 0, defaultValue: void 0, value: void 0, checked: null != c2 ? c2 : a2._wrapperState.initialChecked });
}
function Za(a2, b2) {
  var c2 = null == b2.defaultValue ? "" : b2.defaultValue, d2 = null != b2.checked ? b2.checked : b2.defaultChecked;
  c2 = Sa(null != b2.value ? b2.value : c2);
  a2._wrapperState = { initialChecked: d2, initialValue: c2, controlled: "checkbox" === b2.type || "radio" === b2.type ? null != b2.checked : null != b2.value };
}
function ab(a2, b2) {
  b2 = b2.checked;
  null != b2 && ta(a2, "checked", b2, false);
}
function bb(a2, b2) {
  ab(a2, b2);
  var c2 = Sa(b2.value), d2 = b2.type;
  if (null != c2)
    if ("number" === d2) {
      if (0 === c2 && "" === a2.value || a2.value != c2)
        a2.value = "" + c2;
    } else
      a2.value !== "" + c2 && (a2.value = "" + c2);
  else if ("submit" === d2 || "reset" === d2) {
    a2.removeAttribute("value");
    return;
  }
  b2.hasOwnProperty("value") ? cb(a2, b2.type, c2) : b2.hasOwnProperty("defaultValue") && cb(a2, b2.type, Sa(b2.defaultValue));
  null == b2.checked && null != b2.defaultChecked && (a2.defaultChecked = !!b2.defaultChecked);
}
function db(a2, b2, c2) {
  if (b2.hasOwnProperty("value") || b2.hasOwnProperty("defaultValue")) {
    var d2 = b2.type;
    if (!("submit" !== d2 && "reset" !== d2 || void 0 !== b2.value && null !== b2.value))
      return;
    b2 = "" + a2._wrapperState.initialValue;
    c2 || b2 === a2.value || (a2.value = b2);
    a2.defaultValue = b2;
  }
  c2 = a2.name;
  "" !== c2 && (a2.name = "");
  a2.defaultChecked = !!a2._wrapperState.initialChecked;
  "" !== c2 && (a2.name = c2);
}
function cb(a2, b2, c2) {
  if ("number" !== b2 || Xa(a2.ownerDocument) !== a2)
    null == c2 ? a2.defaultValue = "" + a2._wrapperState.initialValue : a2.defaultValue !== "" + c2 && (a2.defaultValue = "" + c2);
}
var eb = Array.isArray;
function fb(a2, b2, c2, d2) {
  a2 = a2.options;
  if (b2) {
    b2 = {};
    for (var e2 = 0; e2 < c2.length; e2++)
      b2["$" + c2[e2]] = true;
    for (c2 = 0; c2 < a2.length; c2++)
      e2 = b2.hasOwnProperty("$" + a2[c2].value), a2[c2].selected !== e2 && (a2[c2].selected = e2), e2 && d2 && (a2[c2].defaultSelected = true);
  } else {
    c2 = "" + Sa(c2);
    b2 = null;
    for (e2 = 0; e2 < a2.length; e2++) {
      if (a2[e2].value === c2) {
        a2[e2].selected = true;
        d2 && (a2[e2].defaultSelected = true);
        return;
      }
      null !== b2 || a2[e2].disabled || (b2 = a2[e2]);
    }
    null !== b2 && (b2.selected = true);
  }
}
function gb(a2, b2) {
  if (null != b2.dangerouslySetInnerHTML)
    throw Error(p$3(91));
  return A$3({}, b2, { value: void 0, defaultValue: void 0, children: "" + a2._wrapperState.initialValue });
}
function hb(a2, b2) {
  var c2 = b2.value;
  if (null == c2) {
    c2 = b2.children;
    b2 = b2.defaultValue;
    if (null != c2) {
      if (null != b2)
        throw Error(p$3(92));
      if (eb(c2)) {
        if (1 < c2.length)
          throw Error(p$3(93));
        c2 = c2[0];
      }
      b2 = c2;
    }
    null == b2 && (b2 = "");
    c2 = b2;
  }
  a2._wrapperState = { initialValue: Sa(c2) };
}
function ib(a2, b2) {
  var c2 = Sa(b2.value), d2 = Sa(b2.defaultValue);
  null != c2 && (c2 = "" + c2, c2 !== a2.value && (a2.value = c2), null == b2.defaultValue && a2.defaultValue !== c2 && (a2.defaultValue = c2));
  null != d2 && (a2.defaultValue = "" + d2);
}
function jb(a2) {
  var b2 = a2.textContent;
  b2 === a2._wrapperState.initialValue && "" !== b2 && null !== b2 && (a2.value = b2);
}
function kb(a2) {
  switch (a2) {
    case "svg":
      return "http://www.w3.org/2000/svg";
    case "math":
      return "http://www.w3.org/1998/Math/MathML";
    default:
      return "http://www.w3.org/1999/xhtml";
  }
}
function lb(a2, b2) {
  return null == a2 || "http://www.w3.org/1999/xhtml" === a2 ? kb(b2) : "http://www.w3.org/2000/svg" === a2 && "foreignObject" === b2 ? "http://www.w3.org/1999/xhtml" : a2;
}
var mb, nb = function(a2) {
  return "undefined" !== typeof MSApp && MSApp.execUnsafeLocalFunction ? function(b2, c2, d2, e2) {
    MSApp.execUnsafeLocalFunction(function() {
      return a2(b2, c2, d2, e2);
    });
  } : a2;
}(function(a2, b2) {
  if ("http://www.w3.org/2000/svg" !== a2.namespaceURI || "innerHTML" in a2)
    a2.innerHTML = b2;
  else {
    mb = mb || document.createElement("div");
    mb.innerHTML = "<svg>" + b2.valueOf().toString() + "</svg>";
    for (b2 = mb.firstChild; a2.firstChild; )
      a2.removeChild(a2.firstChild);
    for (; b2.firstChild; )
      a2.appendChild(b2.firstChild);
  }
});
function ob(a2, b2) {
  if (b2) {
    var c2 = a2.firstChild;
    if (c2 && c2 === a2.lastChild && 3 === c2.nodeType) {
      c2.nodeValue = b2;
      return;
    }
  }
  a2.textContent = b2;
}
var pb = {
  animationIterationCount: true,
  aspectRatio: true,
  borderImageOutset: true,
  borderImageSlice: true,
  borderImageWidth: true,
  boxFlex: true,
  boxFlexGroup: true,
  boxOrdinalGroup: true,
  columnCount: true,
  columns: true,
  flex: true,
  flexGrow: true,
  flexPositive: true,
  flexShrink: true,
  flexNegative: true,
  flexOrder: true,
  gridArea: true,
  gridRow: true,
  gridRowEnd: true,
  gridRowSpan: true,
  gridRowStart: true,
  gridColumn: true,
  gridColumnEnd: true,
  gridColumnSpan: true,
  gridColumnStart: true,
  fontWeight: true,
  lineClamp: true,
  lineHeight: true,
  opacity: true,
  order: true,
  orphans: true,
  tabSize: true,
  widows: true,
  zIndex: true,
  zoom: true,
  fillOpacity: true,
  floodOpacity: true,
  stopOpacity: true,
  strokeDasharray: true,
  strokeDashoffset: true,
  strokeMiterlimit: true,
  strokeOpacity: true,
  strokeWidth: true
}, qb = ["Webkit", "ms", "Moz", "O"];
Object.keys(pb).forEach(function(a2) {
  qb.forEach(function(b2) {
    b2 = b2 + a2.charAt(0).toUpperCase() + a2.substring(1);
    pb[b2] = pb[a2];
  });
});
function rb(a2, b2, c2) {
  return null == b2 || "boolean" === typeof b2 || "" === b2 ? "" : c2 || "number" !== typeof b2 || 0 === b2 || pb.hasOwnProperty(a2) && pb[a2] ? ("" + b2).trim() : b2 + "px";
}
function sb(a2, b2) {
  a2 = a2.style;
  for (var c2 in b2)
    if (b2.hasOwnProperty(c2)) {
      var d2 = 0 === c2.indexOf("--"), e2 = rb(c2, b2[c2], d2);
      "float" === c2 && (c2 = "cssFloat");
      d2 ? a2.setProperty(c2, e2) : a2[c2] = e2;
    }
}
var tb = A$3({ menuitem: true }, { area: true, base: true, br: true, col: true, embed: true, hr: true, img: true, input: true, keygen: true, link: true, meta: true, param: true, source: true, track: true, wbr: true });
function ub(a2, b2) {
  if (b2) {
    if (tb[a2] && (null != b2.children || null != b2.dangerouslySetInnerHTML))
      throw Error(p$3(137, a2));
    if (null != b2.dangerouslySetInnerHTML) {
      if (null != b2.children)
        throw Error(p$3(60));
      if ("object" !== typeof b2.dangerouslySetInnerHTML || !("__html" in b2.dangerouslySetInnerHTML))
        throw Error(p$3(61));
    }
    if (null != b2.style && "object" !== typeof b2.style)
      throw Error(p$3(62));
  }
}
function vb(a2, b2) {
  if (-1 === a2.indexOf("-"))
    return "string" === typeof b2.is;
  switch (a2) {
    case "annotation-xml":
    case "color-profile":
    case "font-face":
    case "font-face-src":
    case "font-face-uri":
    case "font-face-format":
    case "font-face-name":
    case "missing-glyph":
      return false;
    default:
      return true;
  }
}
var wb = null;
function xb(a2) {
  a2 = a2.target || a2.srcElement || window;
  a2.correspondingUseElement && (a2 = a2.correspondingUseElement);
  return 3 === a2.nodeType ? a2.parentNode : a2;
}
var yb = null, zb = null, Ab = null;
function Bb(a2) {
  if (a2 = Cb(a2)) {
    if ("function" !== typeof yb)
      throw Error(p$3(280));
    var b2 = a2.stateNode;
    b2 && (b2 = Db(b2), yb(a2.stateNode, a2.type, b2));
  }
}
function Eb(a2) {
  zb ? Ab ? Ab.push(a2) : Ab = [a2] : zb = a2;
}
function Fb() {
  if (zb) {
    var a2 = zb, b2 = Ab;
    Ab = zb = null;
    Bb(a2);
    if (b2)
      for (a2 = 0; a2 < b2.length; a2++)
        Bb(b2[a2]);
  }
}
function Gb(a2, b2) {
  return a2(b2);
}
function Hb() {
}
var Ib = false;
function Jb(a2, b2, c2) {
  if (Ib)
    return a2(b2, c2);
  Ib = true;
  try {
    return Gb(a2, b2, c2);
  } finally {
    if (Ib = false, null !== zb || null !== Ab)
      Hb(), Fb();
  }
}
function Kb(a2, b2) {
  var c2 = a2.stateNode;
  if (null === c2)
    return null;
  var d2 = Db(c2);
  if (null === d2)
    return null;
  c2 = d2[b2];
  a:
    switch (b2) {
      case "onClick":
      case "onClickCapture":
      case "onDoubleClick":
      case "onDoubleClickCapture":
      case "onMouseDown":
      case "onMouseDownCapture":
      case "onMouseMove":
      case "onMouseMoveCapture":
      case "onMouseUp":
      case "onMouseUpCapture":
      case "onMouseEnter":
        (d2 = !d2.disabled) || (a2 = a2.type, d2 = !("button" === a2 || "input" === a2 || "select" === a2 || "textarea" === a2));
        a2 = !d2;
        break a;
      default:
        a2 = false;
    }
  if (a2)
    return null;
  if (c2 && "function" !== typeof c2)
    throw Error(p$3(231, b2, typeof c2));
  return c2;
}
var Lb = false;
if (ia)
  try {
    var Mb = {};
    Object.defineProperty(Mb, "passive", { get: function() {
      Lb = true;
    } });
    window.addEventListener("test", Mb, Mb);
    window.removeEventListener("test", Mb, Mb);
  } catch (a2) {
    Lb = false;
  }
function Nb(a2, b2, c2, d2, e2, f2, g2, h2, k2) {
  var l2 = Array.prototype.slice.call(arguments, 3);
  try {
    b2.apply(c2, l2);
  } catch (m2) {
    this.onError(m2);
  }
}
var Ob = false, Pb = null, Qb = false, Rb = null, Sb = { onError: function(a2) {
  Ob = true;
  Pb = a2;
} };
function Tb(a2, b2, c2, d2, e2, f2, g2, h2, k2) {
  Ob = false;
  Pb = null;
  Nb.apply(Sb, arguments);
}
function Ub(a2, b2, c2, d2, e2, f2, g2, h2, k2) {
  Tb.apply(this, arguments);
  if (Ob) {
    if (Ob) {
      var l2 = Pb;
      Ob = false;
      Pb = null;
    } else
      throw Error(p$3(198));
    Qb || (Qb = true, Rb = l2);
  }
}
function Vb(a2) {
  var b2 = a2, c2 = a2;
  if (a2.alternate)
    for (; b2.return; )
      b2 = b2.return;
  else {
    a2 = b2;
    do
      b2 = a2, 0 !== (b2.flags & 4098) && (c2 = b2.return), a2 = b2.return;
    while (a2);
  }
  return 3 === b2.tag ? c2 : null;
}
function Wb(a2) {
  if (13 === a2.tag) {
    var b2 = a2.memoizedState;
    null === b2 && (a2 = a2.alternate, null !== a2 && (b2 = a2.memoizedState));
    if (null !== b2)
      return b2.dehydrated;
  }
  return null;
}
function Xb(a2) {
  if (Vb(a2) !== a2)
    throw Error(p$3(188));
}
function Yb(a2) {
  var b2 = a2.alternate;
  if (!b2) {
    b2 = Vb(a2);
    if (null === b2)
      throw Error(p$3(188));
    return b2 !== a2 ? null : a2;
  }
  for (var c2 = a2, d2 = b2; ; ) {
    var e2 = c2.return;
    if (null === e2)
      break;
    var f2 = e2.alternate;
    if (null === f2) {
      d2 = e2.return;
      if (null !== d2) {
        c2 = d2;
        continue;
      }
      break;
    }
    if (e2.child === f2.child) {
      for (f2 = e2.child; f2; ) {
        if (f2 === c2)
          return Xb(e2), a2;
        if (f2 === d2)
          return Xb(e2), b2;
        f2 = f2.sibling;
      }
      throw Error(p$3(188));
    }
    if (c2.return !== d2.return)
      c2 = e2, d2 = f2;
    else {
      for (var g2 = false, h2 = e2.child; h2; ) {
        if (h2 === c2) {
          g2 = true;
          c2 = e2;
          d2 = f2;
          break;
        }
        if (h2 === d2) {
          g2 = true;
          d2 = e2;
          c2 = f2;
          break;
        }
        h2 = h2.sibling;
      }
      if (!g2) {
        for (h2 = f2.child; h2; ) {
          if (h2 === c2) {
            g2 = true;
            c2 = f2;
            d2 = e2;
            break;
          }
          if (h2 === d2) {
            g2 = true;
            d2 = f2;
            c2 = e2;
            break;
          }
          h2 = h2.sibling;
        }
        if (!g2)
          throw Error(p$3(189));
      }
    }
    if (c2.alternate !== d2)
      throw Error(p$3(190));
  }
  if (3 !== c2.tag)
    throw Error(p$3(188));
  return c2.stateNode.current === c2 ? a2 : b2;
}
function Zb(a2) {
  a2 = Yb(a2);
  return null !== a2 ? $b(a2) : null;
}
function $b(a2) {
  if (5 === a2.tag || 6 === a2.tag)
    return a2;
  for (a2 = a2.child; null !== a2; ) {
    var b2 = $b(a2);
    if (null !== b2)
      return b2;
    a2 = a2.sibling;
  }
  return null;
}
var ac = ca.unstable_scheduleCallback, bc = ca.unstable_cancelCallback, cc = ca.unstable_shouldYield, dc = ca.unstable_requestPaint, B$2 = ca.unstable_now, ec = ca.unstable_getCurrentPriorityLevel, fc = ca.unstable_ImmediatePriority, gc = ca.unstable_UserBlockingPriority, hc = ca.unstable_NormalPriority, ic = ca.unstable_LowPriority, jc = ca.unstable_IdlePriority, kc = null, lc = null;
function mc(a2) {
  if (lc && "function" === typeof lc.onCommitFiberRoot)
    try {
      lc.onCommitFiberRoot(kc, a2, void 0, 128 === (a2.current.flags & 128));
    } catch (b2) {
    }
}
var oc = Math.clz32 ? Math.clz32 : nc, pc = Math.log, qc = Math.LN2;
function nc(a2) {
  a2 >>>= 0;
  return 0 === a2 ? 32 : 31 - (pc(a2) / qc | 0) | 0;
}
var rc = 64, sc = 4194304;
function tc(a2) {
  switch (a2 & -a2) {
    case 1:
      return 1;
    case 2:
      return 2;
    case 4:
      return 4;
    case 8:
      return 8;
    case 16:
      return 16;
    case 32:
      return 32;
    case 64:
    case 128:
    case 256:
    case 512:
    case 1024:
    case 2048:
    case 4096:
    case 8192:
    case 16384:
    case 32768:
    case 65536:
    case 131072:
    case 262144:
    case 524288:
    case 1048576:
    case 2097152:
      return a2 & 4194240;
    case 4194304:
    case 8388608:
    case 16777216:
    case 33554432:
    case 67108864:
      return a2 & 130023424;
    case 134217728:
      return 134217728;
    case 268435456:
      return 268435456;
    case 536870912:
      return 536870912;
    case 1073741824:
      return 1073741824;
    default:
      return a2;
  }
}
function uc(a2, b2) {
  var c2 = a2.pendingLanes;
  if (0 === c2)
    return 0;
  var d2 = 0, e2 = a2.suspendedLanes, f2 = a2.pingedLanes, g2 = c2 & 268435455;
  if (0 !== g2) {
    var h2 = g2 & ~e2;
    0 !== h2 ? d2 = tc(h2) : (f2 &= g2, 0 !== f2 && (d2 = tc(f2)));
  } else
    g2 = c2 & ~e2, 0 !== g2 ? d2 = tc(g2) : 0 !== f2 && (d2 = tc(f2));
  if (0 === d2)
    return 0;
  if (0 !== b2 && b2 !== d2 && 0 === (b2 & e2) && (e2 = d2 & -d2, f2 = b2 & -b2, e2 >= f2 || 16 === e2 && 0 !== (f2 & 4194240)))
    return b2;
  0 !== (d2 & 4) && (d2 |= c2 & 16);
  b2 = a2.entangledLanes;
  if (0 !== b2)
    for (a2 = a2.entanglements, b2 &= d2; 0 < b2; )
      c2 = 31 - oc(b2), e2 = 1 << c2, d2 |= a2[c2], b2 &= ~e2;
  return d2;
}
function vc(a2, b2) {
  switch (a2) {
    case 1:
    case 2:
    case 4:
      return b2 + 250;
    case 8:
    case 16:
    case 32:
    case 64:
    case 128:
    case 256:
    case 512:
    case 1024:
    case 2048:
    case 4096:
    case 8192:
    case 16384:
    case 32768:
    case 65536:
    case 131072:
    case 262144:
    case 524288:
    case 1048576:
    case 2097152:
      return b2 + 5e3;
    case 4194304:
    case 8388608:
    case 16777216:
    case 33554432:
    case 67108864:
      return -1;
    case 134217728:
    case 268435456:
    case 536870912:
    case 1073741824:
      return -1;
    default:
      return -1;
  }
}
function wc(a2, b2) {
  for (var c2 = a2.suspendedLanes, d2 = a2.pingedLanes, e2 = a2.expirationTimes, f2 = a2.pendingLanes; 0 < f2; ) {
    var g2 = 31 - oc(f2), h2 = 1 << g2, k2 = e2[g2];
    if (-1 === k2) {
      if (0 === (h2 & c2) || 0 !== (h2 & d2))
        e2[g2] = vc(h2, b2);
    } else
      k2 <= b2 && (a2.expiredLanes |= h2);
    f2 &= ~h2;
  }
}
function xc(a2) {
  a2 = a2.pendingLanes & -1073741825;
  return 0 !== a2 ? a2 : a2 & 1073741824 ? 1073741824 : 0;
}
function yc() {
  var a2 = rc;
  rc <<= 1;
  0 === (rc & 4194240) && (rc = 64);
  return a2;
}
function zc(a2) {
  for (var b2 = [], c2 = 0; 31 > c2; c2++)
    b2.push(a2);
  return b2;
}
function Ac(a2, b2, c2) {
  a2.pendingLanes |= b2;
  536870912 !== b2 && (a2.suspendedLanes = 0, a2.pingedLanes = 0);
  a2 = a2.eventTimes;
  b2 = 31 - oc(b2);
  a2[b2] = c2;
}
function Bc(a2, b2) {
  var c2 = a2.pendingLanes & ~b2;
  a2.pendingLanes = b2;
  a2.suspendedLanes = 0;
  a2.pingedLanes = 0;
  a2.expiredLanes &= b2;
  a2.mutableReadLanes &= b2;
  a2.entangledLanes &= b2;
  b2 = a2.entanglements;
  var d2 = a2.eventTimes;
  for (a2 = a2.expirationTimes; 0 < c2; ) {
    var e2 = 31 - oc(c2), f2 = 1 << e2;
    b2[e2] = 0;
    d2[e2] = -1;
    a2[e2] = -1;
    c2 &= ~f2;
  }
}
function Cc(a2, b2) {
  var c2 = a2.entangledLanes |= b2;
  for (a2 = a2.entanglements; c2; ) {
    var d2 = 31 - oc(c2), e2 = 1 << d2;
    e2 & b2 | a2[d2] & b2 && (a2[d2] |= b2);
    c2 &= ~e2;
  }
}
var C$2 = 0;
function Dc(a2) {
  a2 &= -a2;
  return 1 < a2 ? 4 < a2 ? 0 !== (a2 & 268435455) ? 16 : 536870912 : 4 : 1;
}
var Ec, Fc, Gc, Hc, Ic, Jc = false, Kc = [], Lc = null, Mc = null, Nc = null, Oc = /* @__PURE__ */ new Map(), Pc = /* @__PURE__ */ new Map(), Qc = [], Rc = "mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset submit".split(" ");
function Sc(a2, b2) {
  switch (a2) {
    case "focusin":
    case "focusout":
      Lc = null;
      break;
    case "dragenter":
    case "dragleave":
      Mc = null;
      break;
    case "mouseover":
    case "mouseout":
      Nc = null;
      break;
    case "pointerover":
    case "pointerout":
      Oc.delete(b2.pointerId);
      break;
    case "gotpointercapture":
    case "lostpointercapture":
      Pc.delete(b2.pointerId);
  }
}
function Tc(a2, b2, c2, d2, e2, f2) {
  if (null === a2 || a2.nativeEvent !== f2)
    return a2 = { blockedOn: b2, domEventName: c2, eventSystemFlags: d2, nativeEvent: f2, targetContainers: [e2] }, null !== b2 && (b2 = Cb(b2), null !== b2 && Fc(b2)), a2;
  a2.eventSystemFlags |= d2;
  b2 = a2.targetContainers;
  null !== e2 && -1 === b2.indexOf(e2) && b2.push(e2);
  return a2;
}
function Uc(a2, b2, c2, d2, e2) {
  switch (b2) {
    case "focusin":
      return Lc = Tc(Lc, a2, b2, c2, d2, e2), true;
    case "dragenter":
      return Mc = Tc(Mc, a2, b2, c2, d2, e2), true;
    case "mouseover":
      return Nc = Tc(Nc, a2, b2, c2, d2, e2), true;
    case "pointerover":
      var f2 = e2.pointerId;
      Oc.set(f2, Tc(Oc.get(f2) || null, a2, b2, c2, d2, e2));
      return true;
    case "gotpointercapture":
      return f2 = e2.pointerId, Pc.set(f2, Tc(Pc.get(f2) || null, a2, b2, c2, d2, e2)), true;
  }
  return false;
}
function Vc(a2) {
  var b2 = Wc(a2.target);
  if (null !== b2) {
    var c2 = Vb(b2);
    if (null !== c2) {
      if (b2 = c2.tag, 13 === b2) {
        if (b2 = Wb(c2), null !== b2) {
          a2.blockedOn = b2;
          Ic(a2.priority, function() {
            Gc(c2);
          });
          return;
        }
      } else if (3 === b2 && c2.stateNode.current.memoizedState.isDehydrated) {
        a2.blockedOn = 3 === c2.tag ? c2.stateNode.containerInfo : null;
        return;
      }
    }
  }
  a2.blockedOn = null;
}
function Xc(a2) {
  if (null !== a2.blockedOn)
    return false;
  for (var b2 = a2.targetContainers; 0 < b2.length; ) {
    var c2 = Yc(a2.domEventName, a2.eventSystemFlags, b2[0], a2.nativeEvent);
    if (null === c2) {
      c2 = a2.nativeEvent;
      var d2 = new c2.constructor(c2.type, c2);
      wb = d2;
      c2.target.dispatchEvent(d2);
      wb = null;
    } else
      return b2 = Cb(c2), null !== b2 && Fc(b2), a2.blockedOn = c2, false;
    b2.shift();
  }
  return true;
}
function Zc(a2, b2, c2) {
  Xc(a2) && c2.delete(b2);
}
function $c() {
  Jc = false;
  null !== Lc && Xc(Lc) && (Lc = null);
  null !== Mc && Xc(Mc) && (Mc = null);
  null !== Nc && Xc(Nc) && (Nc = null);
  Oc.forEach(Zc);
  Pc.forEach(Zc);
}
function ad(a2, b2) {
  a2.blockedOn === b2 && (a2.blockedOn = null, Jc || (Jc = true, ca.unstable_scheduleCallback(ca.unstable_NormalPriority, $c)));
}
function bd(a2) {
  function b2(b3) {
    return ad(b3, a2);
  }
  if (0 < Kc.length) {
    ad(Kc[0], a2);
    for (var c2 = 1; c2 < Kc.length; c2++) {
      var d2 = Kc[c2];
      d2.blockedOn === a2 && (d2.blockedOn = null);
    }
  }
  null !== Lc && ad(Lc, a2);
  null !== Mc && ad(Mc, a2);
  null !== Nc && ad(Nc, a2);
  Oc.forEach(b2);
  Pc.forEach(b2);
  for (c2 = 0; c2 < Qc.length; c2++)
    d2 = Qc[c2], d2.blockedOn === a2 && (d2.blockedOn = null);
  for (; 0 < Qc.length && (c2 = Qc[0], null === c2.blockedOn); )
    Vc(c2), null === c2.blockedOn && Qc.shift();
}
var cd = ua.ReactCurrentBatchConfig, dd = true;
function ed(a2, b2, c2, d2) {
  var e2 = C$2, f2 = cd.transition;
  cd.transition = null;
  try {
    C$2 = 1, fd(a2, b2, c2, d2);
  } finally {
    C$2 = e2, cd.transition = f2;
  }
}
function gd(a2, b2, c2, d2) {
  var e2 = C$2, f2 = cd.transition;
  cd.transition = null;
  try {
    C$2 = 4, fd(a2, b2, c2, d2);
  } finally {
    C$2 = e2, cd.transition = f2;
  }
}
function fd(a2, b2, c2, d2) {
  if (dd) {
    var e2 = Yc(a2, b2, c2, d2);
    if (null === e2)
      hd(a2, b2, d2, id, c2), Sc(a2, d2);
    else if (Uc(e2, a2, b2, c2, d2))
      d2.stopPropagation();
    else if (Sc(a2, d2), b2 & 4 && -1 < Rc.indexOf(a2)) {
      for (; null !== e2; ) {
        var f2 = Cb(e2);
        null !== f2 && Ec(f2);
        f2 = Yc(a2, b2, c2, d2);
        null === f2 && hd(a2, b2, d2, id, c2);
        if (f2 === e2)
          break;
        e2 = f2;
      }
      null !== e2 && d2.stopPropagation();
    } else
      hd(a2, b2, d2, null, c2);
  }
}
var id = null;
function Yc(a2, b2, c2, d2) {
  id = null;
  a2 = xb(d2);
  a2 = Wc(a2);
  if (null !== a2)
    if (b2 = Vb(a2), null === b2)
      a2 = null;
    else if (c2 = b2.tag, 13 === c2) {
      a2 = Wb(b2);
      if (null !== a2)
        return a2;
      a2 = null;
    } else if (3 === c2) {
      if (b2.stateNode.current.memoizedState.isDehydrated)
        return 3 === b2.tag ? b2.stateNode.containerInfo : null;
      a2 = null;
    } else
      b2 !== a2 && (a2 = null);
  id = a2;
  return null;
}
function jd(a2) {
  switch (a2) {
    case "cancel":
    case "click":
    case "close":
    case "contextmenu":
    case "copy":
    case "cut":
    case "auxclick":
    case "dblclick":
    case "dragend":
    case "dragstart":
    case "drop":
    case "focusin":
    case "focusout":
    case "input":
    case "invalid":
    case "keydown":
    case "keypress":
    case "keyup":
    case "mousedown":
    case "mouseup":
    case "paste":
    case "pause":
    case "play":
    case "pointercancel":
    case "pointerdown":
    case "pointerup":
    case "ratechange":
    case "reset":
    case "resize":
    case "seeked":
    case "submit":
    case "touchcancel":
    case "touchend":
    case "touchstart":
    case "volumechange":
    case "change":
    case "selectionchange":
    case "textInput":
    case "compositionstart":
    case "compositionend":
    case "compositionupdate":
    case "beforeblur":
    case "afterblur":
    case "beforeinput":
    case "blur":
    case "fullscreenchange":
    case "focus":
    case "hashchange":
    case "popstate":
    case "select":
    case "selectstart":
      return 1;
    case "drag":
    case "dragenter":
    case "dragexit":
    case "dragleave":
    case "dragover":
    case "mousemove":
    case "mouseout":
    case "mouseover":
    case "pointermove":
    case "pointerout":
    case "pointerover":
    case "scroll":
    case "toggle":
    case "touchmove":
    case "wheel":
    case "mouseenter":
    case "mouseleave":
    case "pointerenter":
    case "pointerleave":
      return 4;
    case "message":
      switch (ec()) {
        case fc:
          return 1;
        case gc:
          return 4;
        case hc:
        case ic:
          return 16;
        case jc:
          return 536870912;
        default:
          return 16;
      }
    default:
      return 16;
  }
}
var kd = null, ld = null, md = null;
function nd() {
  if (md)
    return md;
  var a2, b2 = ld, c2 = b2.length, d2, e2 = "value" in kd ? kd.value : kd.textContent, f2 = e2.length;
  for (a2 = 0; a2 < c2 && b2[a2] === e2[a2]; a2++)
    ;
  var g2 = c2 - a2;
  for (d2 = 1; d2 <= g2 && b2[c2 - d2] === e2[f2 - d2]; d2++)
    ;
  return md = e2.slice(a2, 1 < d2 ? 1 - d2 : void 0);
}
function od(a2) {
  var b2 = a2.keyCode;
  "charCode" in a2 ? (a2 = a2.charCode, 0 === a2 && 13 === b2 && (a2 = 13)) : a2 = b2;
  10 === a2 && (a2 = 13);
  return 32 <= a2 || 13 === a2 ? a2 : 0;
}
function pd() {
  return true;
}
function qd() {
  return false;
}
function rd(a2) {
  function b2(b3, d2, e2, f2, g2) {
    this._reactName = b3;
    this._targetInst = e2;
    this.type = d2;
    this.nativeEvent = f2;
    this.target = g2;
    this.currentTarget = null;
    for (var c2 in a2)
      a2.hasOwnProperty(c2) && (b3 = a2[c2], this[c2] = b3 ? b3(f2) : f2[c2]);
    this.isDefaultPrevented = (null != f2.defaultPrevented ? f2.defaultPrevented : false === f2.returnValue) ? pd : qd;
    this.isPropagationStopped = qd;
    return this;
  }
  A$3(b2.prototype, { preventDefault: function() {
    this.defaultPrevented = true;
    var a3 = this.nativeEvent;
    a3 && (a3.preventDefault ? a3.preventDefault() : "unknown" !== typeof a3.returnValue && (a3.returnValue = false), this.isDefaultPrevented = pd);
  }, stopPropagation: function() {
    var a3 = this.nativeEvent;
    a3 && (a3.stopPropagation ? a3.stopPropagation() : "unknown" !== typeof a3.cancelBubble && (a3.cancelBubble = true), this.isPropagationStopped = pd);
  }, persist: function() {
  }, isPersistent: pd });
  return b2;
}
var sd = { eventPhase: 0, bubbles: 0, cancelable: 0, timeStamp: function(a2) {
  return a2.timeStamp || Date.now();
}, defaultPrevented: 0, isTrusted: 0 }, td = rd(sd), ud = A$3({}, sd, { view: 0, detail: 0 }), vd = rd(ud), wd, xd, yd, Ad = A$3({}, ud, { screenX: 0, screenY: 0, clientX: 0, clientY: 0, pageX: 0, pageY: 0, ctrlKey: 0, shiftKey: 0, altKey: 0, metaKey: 0, getModifierState: zd, button: 0, buttons: 0, relatedTarget: function(a2) {
  return void 0 === a2.relatedTarget ? a2.fromElement === a2.srcElement ? a2.toElement : a2.fromElement : a2.relatedTarget;
}, movementX: function(a2) {
  if ("movementX" in a2)
    return a2.movementX;
  a2 !== yd && (yd && "mousemove" === a2.type ? (wd = a2.screenX - yd.screenX, xd = a2.screenY - yd.screenY) : xd = wd = 0, yd = a2);
  return wd;
}, movementY: function(a2) {
  return "movementY" in a2 ? a2.movementY : xd;
} }), Bd = rd(Ad), Cd = A$3({}, Ad, { dataTransfer: 0 }), Dd = rd(Cd), Ed = A$3({}, ud, { relatedTarget: 0 }), Fd = rd(Ed), Gd = A$3({}, sd, { animationName: 0, elapsedTime: 0, pseudoElement: 0 }), Hd = rd(Gd), Id = A$3({}, sd, { clipboardData: function(a2) {
  return "clipboardData" in a2 ? a2.clipboardData : window.clipboardData;
} }), Jd = rd(Id), Kd = A$3({}, sd, { data: 0 }), Ld = rd(Kd), Md = {
  Esc: "Escape",
  Spacebar: " ",
  Left: "ArrowLeft",
  Up: "ArrowUp",
  Right: "ArrowRight",
  Down: "ArrowDown",
  Del: "Delete",
  Win: "OS",
  Menu: "ContextMenu",
  Apps: "ContextMenu",
  Scroll: "ScrollLock",
  MozPrintableKey: "Unidentified"
}, Nd = {
  8: "Backspace",
  9: "Tab",
  12: "Clear",
  13: "Enter",
  16: "Shift",
  17: "Control",
  18: "Alt",
  19: "Pause",
  20: "CapsLock",
  27: "Escape",
  32: " ",
  33: "PageUp",
  34: "PageDown",
  35: "End",
  36: "Home",
  37: "ArrowLeft",
  38: "ArrowUp",
  39: "ArrowRight",
  40: "ArrowDown",
  45: "Insert",
  46: "Delete",
  112: "F1",
  113: "F2",
  114: "F3",
  115: "F4",
  116: "F5",
  117: "F6",
  118: "F7",
  119: "F8",
  120: "F9",
  121: "F10",
  122: "F11",
  123: "F12",
  144: "NumLock",
  145: "ScrollLock",
  224: "Meta"
}, Od = { Alt: "altKey", Control: "ctrlKey", Meta: "metaKey", Shift: "shiftKey" };
function Pd(a2) {
  var b2 = this.nativeEvent;
  return b2.getModifierState ? b2.getModifierState(a2) : (a2 = Od[a2]) ? !!b2[a2] : false;
}
function zd() {
  return Pd;
}
var Qd = A$3({}, ud, { key: function(a2) {
  if (a2.key) {
    var b2 = Md[a2.key] || a2.key;
    if ("Unidentified" !== b2)
      return b2;
  }
  return "keypress" === a2.type ? (a2 = od(a2), 13 === a2 ? "Enter" : String.fromCharCode(a2)) : "keydown" === a2.type || "keyup" === a2.type ? Nd[a2.keyCode] || "Unidentified" : "";
}, code: 0, location: 0, ctrlKey: 0, shiftKey: 0, altKey: 0, metaKey: 0, repeat: 0, locale: 0, getModifierState: zd, charCode: function(a2) {
  return "keypress" === a2.type ? od(a2) : 0;
}, keyCode: function(a2) {
  return "keydown" === a2.type || "keyup" === a2.type ? a2.keyCode : 0;
}, which: function(a2) {
  return "keypress" === a2.type ? od(a2) : "keydown" === a2.type || "keyup" === a2.type ? a2.keyCode : 0;
} }), Rd = rd(Qd), Sd = A$3({}, Ad, { pointerId: 0, width: 0, height: 0, pressure: 0, tangentialPressure: 0, tiltX: 0, tiltY: 0, twist: 0, pointerType: 0, isPrimary: 0 }), Td = rd(Sd), Ud = A$3({}, ud, { touches: 0, targetTouches: 0, changedTouches: 0, altKey: 0, metaKey: 0, ctrlKey: 0, shiftKey: 0, getModifierState: zd }), Vd = rd(Ud), Wd = A$3({}, sd, { propertyName: 0, elapsedTime: 0, pseudoElement: 0 }), Xd = rd(Wd), Yd = A$3({}, Ad, {
  deltaX: function(a2) {
    return "deltaX" in a2 ? a2.deltaX : "wheelDeltaX" in a2 ? -a2.wheelDeltaX : 0;
  },
  deltaY: function(a2) {
    return "deltaY" in a2 ? a2.deltaY : "wheelDeltaY" in a2 ? -a2.wheelDeltaY : "wheelDelta" in a2 ? -a2.wheelDelta : 0;
  },
  deltaZ: 0,
  deltaMode: 0
}), Zd = rd(Yd), $d = [9, 13, 27, 32], ae$1 = ia && "CompositionEvent" in window, be$1 = null;
ia && "documentMode" in document && (be$1 = document.documentMode);
var ce$1 = ia && "TextEvent" in window && !be$1, de$1 = ia && (!ae$1 || be$1 && 8 < be$1 && 11 >= be$1), ee$1 = String.fromCharCode(32), fe$1 = false;
function ge$1(a2, b2) {
  switch (a2) {
    case "keyup":
      return -1 !== $d.indexOf(b2.keyCode);
    case "keydown":
      return 229 !== b2.keyCode;
    case "keypress":
    case "mousedown":
    case "focusout":
      return true;
    default:
      return false;
  }
}
function he$1(a2) {
  a2 = a2.detail;
  return "object" === typeof a2 && "data" in a2 ? a2.data : null;
}
var ie$1 = false;
function je$1(a2, b2) {
  switch (a2) {
    case "compositionend":
      return he$1(b2);
    case "keypress":
      if (32 !== b2.which)
        return null;
      fe$1 = true;
      return ee$1;
    case "textInput":
      return a2 = b2.data, a2 === ee$1 && fe$1 ? null : a2;
    default:
      return null;
  }
}
function ke$1(a2, b2) {
  if (ie$1)
    return "compositionend" === a2 || !ae$1 && ge$1(a2, b2) ? (a2 = nd(), md = ld = kd = null, ie$1 = false, a2) : null;
  switch (a2) {
    case "paste":
      return null;
    case "keypress":
      if (!(b2.ctrlKey || b2.altKey || b2.metaKey) || b2.ctrlKey && b2.altKey) {
        if (b2.char && 1 < b2.char.length)
          return b2.char;
        if (b2.which)
          return String.fromCharCode(b2.which);
      }
      return null;
    case "compositionend":
      return de$1 && "ko" !== b2.locale ? null : b2.data;
    default:
      return null;
  }
}
var le$1 = { color: true, date: true, datetime: true, "datetime-local": true, email: true, month: true, number: true, password: true, range: true, search: true, tel: true, text: true, time: true, url: true, week: true };
function me$1(a2) {
  var b2 = a2 && a2.nodeName && a2.nodeName.toLowerCase();
  return "input" === b2 ? !!le$1[a2.type] : "textarea" === b2 ? true : false;
}
function ne$1(a2, b2, c2, d2) {
  Eb(d2);
  b2 = oe$1(b2, "onChange");
  0 < b2.length && (c2 = new td("onChange", "change", null, c2, d2), a2.push({ event: c2, listeners: b2 }));
}
var pe$1 = null, qe$1 = null;
function re$1(a2) {
  se$1(a2, 0);
}
function te$1(a2) {
  var b2 = ue$1(a2);
  if (Wa(b2))
    return a2;
}
function ve$1(a2, b2) {
  if ("change" === a2)
    return b2;
}
var we$1 = false;
if (ia) {
  var xe$1;
  if (ia) {
    var ye$1 = "oninput" in document;
    if (!ye$1) {
      var ze$1 = document.createElement("div");
      ze$1.setAttribute("oninput", "return;");
      ye$1 = "function" === typeof ze$1.oninput;
    }
    xe$1 = ye$1;
  } else
    xe$1 = false;
  we$1 = xe$1 && (!document.documentMode || 9 < document.documentMode);
}
function Ae$1() {
  pe$1 && (pe$1.detachEvent("onpropertychange", Be$1), qe$1 = pe$1 = null);
}
function Be$1(a2) {
  if ("value" === a2.propertyName && te$1(qe$1)) {
    var b2 = [];
    ne$1(b2, qe$1, a2, xb(a2));
    Jb(re$1, b2);
  }
}
function Ce$1(a2, b2, c2) {
  "focusin" === a2 ? (Ae$1(), pe$1 = b2, qe$1 = c2, pe$1.attachEvent("onpropertychange", Be$1)) : "focusout" === a2 && Ae$1();
}
function De$1(a2) {
  if ("selectionchange" === a2 || "keyup" === a2 || "keydown" === a2)
    return te$1(qe$1);
}
function Ee$1(a2, b2) {
  if ("click" === a2)
    return te$1(b2);
}
function Fe$1(a2, b2) {
  if ("input" === a2 || "change" === a2)
    return te$1(b2);
}
function Ge$1(a2, b2) {
  return a2 === b2 && (0 !== a2 || 1 / a2 === 1 / b2) || a2 !== a2 && b2 !== b2;
}
var He$1 = "function" === typeof Object.is ? Object.is : Ge$1;
function Ie$1(a2, b2) {
  if (He$1(a2, b2))
    return true;
  if ("object" !== typeof a2 || null === a2 || "object" !== typeof b2 || null === b2)
    return false;
  var c2 = Object.keys(a2), d2 = Object.keys(b2);
  if (c2.length !== d2.length)
    return false;
  for (d2 = 0; d2 < c2.length; d2++) {
    var e2 = c2[d2];
    if (!ja.call(b2, e2) || !He$1(a2[e2], b2[e2]))
      return false;
  }
  return true;
}
function Je$1(a2) {
  for (; a2 && a2.firstChild; )
    a2 = a2.firstChild;
  return a2;
}
function Ke$1(a2, b2) {
  var c2 = Je$1(a2);
  a2 = 0;
  for (var d2; c2; ) {
    if (3 === c2.nodeType) {
      d2 = a2 + c2.textContent.length;
      if (a2 <= b2 && d2 >= b2)
        return { node: c2, offset: b2 - a2 };
      a2 = d2;
    }
    a: {
      for (; c2; ) {
        if (c2.nextSibling) {
          c2 = c2.nextSibling;
          break a;
        }
        c2 = c2.parentNode;
      }
      c2 = void 0;
    }
    c2 = Je$1(c2);
  }
}
function Le$1(a2, b2) {
  return a2 && b2 ? a2 === b2 ? true : a2 && 3 === a2.nodeType ? false : b2 && 3 === b2.nodeType ? Le$1(a2, b2.parentNode) : "contains" in a2 ? a2.contains(b2) : a2.compareDocumentPosition ? !!(a2.compareDocumentPosition(b2) & 16) : false : false;
}
function Me$1() {
  for (var a2 = window, b2 = Xa(); b2 instanceof a2.HTMLIFrameElement; ) {
    try {
      var c2 = "string" === typeof b2.contentWindow.location.href;
    } catch (d2) {
      c2 = false;
    }
    if (c2)
      a2 = b2.contentWindow;
    else
      break;
    b2 = Xa(a2.document);
  }
  return b2;
}
function Ne$1(a2) {
  var b2 = a2 && a2.nodeName && a2.nodeName.toLowerCase();
  return b2 && ("input" === b2 && ("text" === a2.type || "search" === a2.type || "tel" === a2.type || "url" === a2.type || "password" === a2.type) || "textarea" === b2 || "true" === a2.contentEditable);
}
function Oe$1(a2) {
  var b2 = Me$1(), c2 = a2.focusedElem, d2 = a2.selectionRange;
  if (b2 !== c2 && c2 && c2.ownerDocument && Le$1(c2.ownerDocument.documentElement, c2)) {
    if (null !== d2 && Ne$1(c2)) {
      if (b2 = d2.start, a2 = d2.end, void 0 === a2 && (a2 = b2), "selectionStart" in c2)
        c2.selectionStart = b2, c2.selectionEnd = Math.min(a2, c2.value.length);
      else if (a2 = (b2 = c2.ownerDocument || document) && b2.defaultView || window, a2.getSelection) {
        a2 = a2.getSelection();
        var e2 = c2.textContent.length, f2 = Math.min(d2.start, e2);
        d2 = void 0 === d2.end ? f2 : Math.min(d2.end, e2);
        !a2.extend && f2 > d2 && (e2 = d2, d2 = f2, f2 = e2);
        e2 = Ke$1(c2, f2);
        var g2 = Ke$1(
          c2,
          d2
        );
        e2 && g2 && (1 !== a2.rangeCount || a2.anchorNode !== e2.node || a2.anchorOffset !== e2.offset || a2.focusNode !== g2.node || a2.focusOffset !== g2.offset) && (b2 = b2.createRange(), b2.setStart(e2.node, e2.offset), a2.removeAllRanges(), f2 > d2 ? (a2.addRange(b2), a2.extend(g2.node, g2.offset)) : (b2.setEnd(g2.node, g2.offset), a2.addRange(b2)));
      }
    }
    b2 = [];
    for (a2 = c2; a2 = a2.parentNode; )
      1 === a2.nodeType && b2.push({ element: a2, left: a2.scrollLeft, top: a2.scrollTop });
    "function" === typeof c2.focus && c2.focus();
    for (c2 = 0; c2 < b2.length; c2++)
      a2 = b2[c2], a2.element.scrollLeft = a2.left, a2.element.scrollTop = a2.top;
  }
}
var Pe$1 = ia && "documentMode" in document && 11 >= document.documentMode, Qe$1 = null, Re$1 = null, Se$1 = null, Te$1 = false;
function Ue$1(a2, b2, c2) {
  var d2 = c2.window === c2 ? c2.document : 9 === c2.nodeType ? c2 : c2.ownerDocument;
  Te$1 || null == Qe$1 || Qe$1 !== Xa(d2) || (d2 = Qe$1, "selectionStart" in d2 && Ne$1(d2) ? d2 = { start: d2.selectionStart, end: d2.selectionEnd } : (d2 = (d2.ownerDocument && d2.ownerDocument.defaultView || window).getSelection(), d2 = { anchorNode: d2.anchorNode, anchorOffset: d2.anchorOffset, focusNode: d2.focusNode, focusOffset: d2.focusOffset }), Se$1 && Ie$1(Se$1, d2) || (Se$1 = d2, d2 = oe$1(Re$1, "onSelect"), 0 < d2.length && (b2 = new td("onSelect", "select", null, b2, c2), a2.push({ event: b2, listeners: d2 }), b2.target = Qe$1)));
}
function Ve$1(a2, b2) {
  var c2 = {};
  c2[a2.toLowerCase()] = b2.toLowerCase();
  c2["Webkit" + a2] = "webkit" + b2;
  c2["Moz" + a2] = "moz" + b2;
  return c2;
}
var We$1 = { animationend: Ve$1("Animation", "AnimationEnd"), animationiteration: Ve$1("Animation", "AnimationIteration"), animationstart: Ve$1("Animation", "AnimationStart"), transitionend: Ve$1("Transition", "TransitionEnd") }, Xe$1 = {}, Ye$1 = {};
ia && (Ye$1 = document.createElement("div").style, "AnimationEvent" in window || (delete We$1.animationend.animation, delete We$1.animationiteration.animation, delete We$1.animationstart.animation), "TransitionEvent" in window || delete We$1.transitionend.transition);
function Ze$1(a2) {
  if (Xe$1[a2])
    return Xe$1[a2];
  if (!We$1[a2])
    return a2;
  var b2 = We$1[a2], c2;
  for (c2 in b2)
    if (b2.hasOwnProperty(c2) && c2 in Ye$1)
      return Xe$1[a2] = b2[c2];
  return a2;
}
var $e$1 = Ze$1("animationend"), af = Ze$1("animationiteration"), bf = Ze$1("animationstart"), cf = Ze$1("transitionend"), df = /* @__PURE__ */ new Map(), ef = "abort auxClick cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(" ");
function ff(a2, b2) {
  df.set(a2, b2);
  fa(b2, [a2]);
}
for (var gf = 0; gf < ef.length; gf++) {
  var hf = ef[gf], jf = hf.toLowerCase(), kf = hf[0].toUpperCase() + hf.slice(1);
  ff(jf, "on" + kf);
}
ff($e$1, "onAnimationEnd");
ff(af, "onAnimationIteration");
ff(bf, "onAnimationStart");
ff("dblclick", "onDoubleClick");
ff("focusin", "onFocus");
ff("focusout", "onBlur");
ff(cf, "onTransitionEnd");
ha("onMouseEnter", ["mouseout", "mouseover"]);
ha("onMouseLeave", ["mouseout", "mouseover"]);
ha("onPointerEnter", ["pointerout", "pointerover"]);
ha("onPointerLeave", ["pointerout", "pointerover"]);
fa("onChange", "change click focusin focusout input keydown keyup selectionchange".split(" "));
fa("onSelect", "focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(" "));
fa("onBeforeInput", ["compositionend", "keypress", "textInput", "paste"]);
fa("onCompositionEnd", "compositionend focusout keydown keypress keyup mousedown".split(" "));
fa("onCompositionStart", "compositionstart focusout keydown keypress keyup mousedown".split(" "));
fa("onCompositionUpdate", "compositionupdate focusout keydown keypress keyup mousedown".split(" "));
var lf = "abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(" "), mf = new Set("cancel close invalid load scroll toggle".split(" ").concat(lf));
function nf(a2, b2, c2) {
  var d2 = a2.type || "unknown-event";
  a2.currentTarget = c2;
  Ub(d2, b2, void 0, a2);
  a2.currentTarget = null;
}
function se$1(a2, b2) {
  b2 = 0 !== (b2 & 4);
  for (var c2 = 0; c2 < a2.length; c2++) {
    var d2 = a2[c2], e2 = d2.event;
    d2 = d2.listeners;
    a: {
      var f2 = void 0;
      if (b2)
        for (var g2 = d2.length - 1; 0 <= g2; g2--) {
          var h2 = d2[g2], k2 = h2.instance, l2 = h2.currentTarget;
          h2 = h2.listener;
          if (k2 !== f2 && e2.isPropagationStopped())
            break a;
          nf(e2, h2, l2);
          f2 = k2;
        }
      else
        for (g2 = 0; g2 < d2.length; g2++) {
          h2 = d2[g2];
          k2 = h2.instance;
          l2 = h2.currentTarget;
          h2 = h2.listener;
          if (k2 !== f2 && e2.isPropagationStopped())
            break a;
          nf(e2, h2, l2);
          f2 = k2;
        }
    }
  }
  if (Qb)
    throw a2 = Rb, Qb = false, Rb = null, a2;
}
function D$2(a2, b2) {
  var c2 = b2[of];
  void 0 === c2 && (c2 = b2[of] = /* @__PURE__ */ new Set());
  var d2 = a2 + "__bubble";
  c2.has(d2) || (pf(b2, a2, 2, false), c2.add(d2));
}
function qf(a2, b2, c2) {
  var d2 = 0;
  b2 && (d2 |= 4);
  pf(c2, a2, d2, b2);
}
var rf = "_reactListening" + Math.random().toString(36).slice(2);
function sf(a2) {
  if (!a2[rf]) {
    a2[rf] = true;
    da.forEach(function(b3) {
      "selectionchange" !== b3 && (mf.has(b3) || qf(b3, false, a2), qf(b3, true, a2));
    });
    var b2 = 9 === a2.nodeType ? a2 : a2.ownerDocument;
    null === b2 || b2[rf] || (b2[rf] = true, qf("selectionchange", false, b2));
  }
}
function pf(a2, b2, c2, d2) {
  switch (jd(b2)) {
    case 1:
      var e2 = ed;
      break;
    case 4:
      e2 = gd;
      break;
    default:
      e2 = fd;
  }
  c2 = e2.bind(null, b2, c2, a2);
  e2 = void 0;
  !Lb || "touchstart" !== b2 && "touchmove" !== b2 && "wheel" !== b2 || (e2 = true);
  d2 ? void 0 !== e2 ? a2.addEventListener(b2, c2, { capture: true, passive: e2 }) : a2.addEventListener(b2, c2, true) : void 0 !== e2 ? a2.addEventListener(b2, c2, { passive: e2 }) : a2.addEventListener(b2, c2, false);
}
function hd(a2, b2, c2, d2, e2) {
  var f2 = d2;
  if (0 === (b2 & 1) && 0 === (b2 & 2) && null !== d2)
    a:
      for (; ; ) {
        if (null === d2)
          return;
        var g2 = d2.tag;
        if (3 === g2 || 4 === g2) {
          var h2 = d2.stateNode.containerInfo;
          if (h2 === e2 || 8 === h2.nodeType && h2.parentNode === e2)
            break;
          if (4 === g2)
            for (g2 = d2.return; null !== g2; ) {
              var k2 = g2.tag;
              if (3 === k2 || 4 === k2) {
                if (k2 = g2.stateNode.containerInfo, k2 === e2 || 8 === k2.nodeType && k2.parentNode === e2)
                  return;
              }
              g2 = g2.return;
            }
          for (; null !== h2; ) {
            g2 = Wc(h2);
            if (null === g2)
              return;
            k2 = g2.tag;
            if (5 === k2 || 6 === k2) {
              d2 = f2 = g2;
              continue a;
            }
            h2 = h2.parentNode;
          }
        }
        d2 = d2.return;
      }
  Jb(function() {
    var d3 = f2, e3 = xb(c2), g3 = [];
    a: {
      var h3 = df.get(a2);
      if (void 0 !== h3) {
        var k3 = td, n2 = a2;
        switch (a2) {
          case "keypress":
            if (0 === od(c2))
              break a;
          case "keydown":
          case "keyup":
            k3 = Rd;
            break;
          case "focusin":
            n2 = "focus";
            k3 = Fd;
            break;
          case "focusout":
            n2 = "blur";
            k3 = Fd;
            break;
          case "beforeblur":
          case "afterblur":
            k3 = Fd;
            break;
          case "click":
            if (2 === c2.button)
              break a;
          case "auxclick":
          case "dblclick":
          case "mousedown":
          case "mousemove":
          case "mouseup":
          case "mouseout":
          case "mouseover":
          case "contextmenu":
            k3 = Bd;
            break;
          case "drag":
          case "dragend":
          case "dragenter":
          case "dragexit":
          case "dragleave":
          case "dragover":
          case "dragstart":
          case "drop":
            k3 = Dd;
            break;
          case "touchcancel":
          case "touchend":
          case "touchmove":
          case "touchstart":
            k3 = Vd;
            break;
          case $e$1:
          case af:
          case bf:
            k3 = Hd;
            break;
          case cf:
            k3 = Xd;
            break;
          case "scroll":
            k3 = vd;
            break;
          case "wheel":
            k3 = Zd;
            break;
          case "copy":
          case "cut":
          case "paste":
            k3 = Jd;
            break;
          case "gotpointercapture":
          case "lostpointercapture":
          case "pointercancel":
          case "pointerdown":
          case "pointermove":
          case "pointerout":
          case "pointerover":
          case "pointerup":
            k3 = Td;
        }
        var t2 = 0 !== (b2 & 4), J2 = !t2 && "scroll" === a2, x = t2 ? null !== h3 ? h3 + "Capture" : null : h3;
        t2 = [];
        for (var w2 = d3, u2; null !== w2; ) {
          u2 = w2;
          var F2 = u2.stateNode;
          5 === u2.tag && null !== F2 && (u2 = F2, null !== x && (F2 = Kb(w2, x), null != F2 && t2.push(tf(w2, F2, u2))));
          if (J2)
            break;
          w2 = w2.return;
        }
        0 < t2.length && (h3 = new k3(h3, n2, null, c2, e3), g3.push({ event: h3, listeners: t2 }));
      }
    }
    if (0 === (b2 & 7)) {
      a: {
        h3 = "mouseover" === a2 || "pointerover" === a2;
        k3 = "mouseout" === a2 || "pointerout" === a2;
        if (h3 && c2 !== wb && (n2 = c2.relatedTarget || c2.fromElement) && (Wc(n2) || n2[uf]))
          break a;
        if (k3 || h3) {
          h3 = e3.window === e3 ? e3 : (h3 = e3.ownerDocument) ? h3.defaultView || h3.parentWindow : window;
          if (k3) {
            if (n2 = c2.relatedTarget || c2.toElement, k3 = d3, n2 = n2 ? Wc(n2) : null, null !== n2 && (J2 = Vb(n2), n2 !== J2 || 5 !== n2.tag && 6 !== n2.tag))
              n2 = null;
          } else
            k3 = null, n2 = d3;
          if (k3 !== n2) {
            t2 = Bd;
            F2 = "onMouseLeave";
            x = "onMouseEnter";
            w2 = "mouse";
            if ("pointerout" === a2 || "pointerover" === a2)
              t2 = Td, F2 = "onPointerLeave", x = "onPointerEnter", w2 = "pointer";
            J2 = null == k3 ? h3 : ue$1(k3);
            u2 = null == n2 ? h3 : ue$1(n2);
            h3 = new t2(F2, w2 + "leave", k3, c2, e3);
            h3.target = J2;
            h3.relatedTarget = u2;
            F2 = null;
            Wc(e3) === d3 && (t2 = new t2(x, w2 + "enter", n2, c2, e3), t2.target = u2, t2.relatedTarget = J2, F2 = t2);
            J2 = F2;
            if (k3 && n2)
              b: {
                t2 = k3;
                x = n2;
                w2 = 0;
                for (u2 = t2; u2; u2 = vf(u2))
                  w2++;
                u2 = 0;
                for (F2 = x; F2; F2 = vf(F2))
                  u2++;
                for (; 0 < w2 - u2; )
                  t2 = vf(t2), w2--;
                for (; 0 < u2 - w2; )
                  x = vf(x), u2--;
                for (; w2--; ) {
                  if (t2 === x || null !== x && t2 === x.alternate)
                    break b;
                  t2 = vf(t2);
                  x = vf(x);
                }
                t2 = null;
              }
            else
              t2 = null;
            null !== k3 && wf(g3, h3, k3, t2, false);
            null !== n2 && null !== J2 && wf(g3, J2, n2, t2, true);
          }
        }
      }
      a: {
        h3 = d3 ? ue$1(d3) : window;
        k3 = h3.nodeName && h3.nodeName.toLowerCase();
        if ("select" === k3 || "input" === k3 && "file" === h3.type)
          var na = ve$1;
        else if (me$1(h3))
          if (we$1)
            na = Fe$1;
          else {
            na = De$1;
            var xa = Ce$1;
          }
        else
          (k3 = h3.nodeName) && "input" === k3.toLowerCase() && ("checkbox" === h3.type || "radio" === h3.type) && (na = Ee$1);
        if (na && (na = na(a2, d3))) {
          ne$1(g3, na, c2, e3);
          break a;
        }
        xa && xa(a2, h3, d3);
        "focusout" === a2 && (xa = h3._wrapperState) && xa.controlled && "number" === h3.type && cb(h3, "number", h3.value);
      }
      xa = d3 ? ue$1(d3) : window;
      switch (a2) {
        case "focusin":
          if (me$1(xa) || "true" === xa.contentEditable)
            Qe$1 = xa, Re$1 = d3, Se$1 = null;
          break;
        case "focusout":
          Se$1 = Re$1 = Qe$1 = null;
          break;
        case "mousedown":
          Te$1 = true;
          break;
        case "contextmenu":
        case "mouseup":
        case "dragend":
          Te$1 = false;
          Ue$1(g3, c2, e3);
          break;
        case "selectionchange":
          if (Pe$1)
            break;
        case "keydown":
        case "keyup":
          Ue$1(g3, c2, e3);
      }
      var $a;
      if (ae$1)
        b: {
          switch (a2) {
            case "compositionstart":
              var ba = "onCompositionStart";
              break b;
            case "compositionend":
              ba = "onCompositionEnd";
              break b;
            case "compositionupdate":
              ba = "onCompositionUpdate";
              break b;
          }
          ba = void 0;
        }
      else
        ie$1 ? ge$1(a2, c2) && (ba = "onCompositionEnd") : "keydown" === a2 && 229 === c2.keyCode && (ba = "onCompositionStart");
      ba && (de$1 && "ko" !== c2.locale && (ie$1 || "onCompositionStart" !== ba ? "onCompositionEnd" === ba && ie$1 && ($a = nd()) : (kd = e3, ld = "value" in kd ? kd.value : kd.textContent, ie$1 = true)), xa = oe$1(d3, ba), 0 < xa.length && (ba = new Ld(ba, a2, null, c2, e3), g3.push({ event: ba, listeners: xa }), $a ? ba.data = $a : ($a = he$1(c2), null !== $a && (ba.data = $a))));
      if ($a = ce$1 ? je$1(a2, c2) : ke$1(a2, c2))
        d3 = oe$1(d3, "onBeforeInput"), 0 < d3.length && (e3 = new Ld("onBeforeInput", "beforeinput", null, c2, e3), g3.push({ event: e3, listeners: d3 }), e3.data = $a);
    }
    se$1(g3, b2);
  });
}
function tf(a2, b2, c2) {
  return { instance: a2, listener: b2, currentTarget: c2 };
}
function oe$1(a2, b2) {
  for (var c2 = b2 + "Capture", d2 = []; null !== a2; ) {
    var e2 = a2, f2 = e2.stateNode;
    5 === e2.tag && null !== f2 && (e2 = f2, f2 = Kb(a2, c2), null != f2 && d2.unshift(tf(a2, f2, e2)), f2 = Kb(a2, b2), null != f2 && d2.push(tf(a2, f2, e2)));
    a2 = a2.return;
  }
  return d2;
}
function vf(a2) {
  if (null === a2)
    return null;
  do
    a2 = a2.return;
  while (a2 && 5 !== a2.tag);
  return a2 ? a2 : null;
}
function wf(a2, b2, c2, d2, e2) {
  for (var f2 = b2._reactName, g2 = []; null !== c2 && c2 !== d2; ) {
    var h2 = c2, k2 = h2.alternate, l2 = h2.stateNode;
    if (null !== k2 && k2 === d2)
      break;
    5 === h2.tag && null !== l2 && (h2 = l2, e2 ? (k2 = Kb(c2, f2), null != k2 && g2.unshift(tf(c2, k2, h2))) : e2 || (k2 = Kb(c2, f2), null != k2 && g2.push(tf(c2, k2, h2))));
    c2 = c2.return;
  }
  0 !== g2.length && a2.push({ event: b2, listeners: g2 });
}
var xf = /\r\n?/g, yf = /\u0000|\uFFFD/g;
function zf(a2) {
  return ("string" === typeof a2 ? a2 : "" + a2).replace(xf, "\n").replace(yf, "");
}
function Af(a2, b2, c2) {
  b2 = zf(b2);
  if (zf(a2) !== b2 && c2)
    throw Error(p$3(425));
}
function Bf() {
}
var Cf = null, Df = null;
function Ef(a2, b2) {
  return "textarea" === a2 || "noscript" === a2 || "string" === typeof b2.children || "number" === typeof b2.children || "object" === typeof b2.dangerouslySetInnerHTML && null !== b2.dangerouslySetInnerHTML && null != b2.dangerouslySetInnerHTML.__html;
}
var Ff = "function" === typeof setTimeout ? setTimeout : void 0, Gf = "function" === typeof clearTimeout ? clearTimeout : void 0, Hf = "function" === typeof Promise ? Promise : void 0, Jf = "function" === typeof queueMicrotask ? queueMicrotask : "undefined" !== typeof Hf ? function(a2) {
  return Hf.resolve(null).then(a2).catch(If);
} : Ff;
function If(a2) {
  setTimeout(function() {
    throw a2;
  });
}
function Kf(a2, b2) {
  var c2 = b2, d2 = 0;
  do {
    var e2 = c2.nextSibling;
    a2.removeChild(c2);
    if (e2 && 8 === e2.nodeType)
      if (c2 = e2.data, "/$" === c2) {
        if (0 === d2) {
          a2.removeChild(e2);
          bd(b2);
          return;
        }
        d2--;
      } else
        "$" !== c2 && "$?" !== c2 && "$!" !== c2 || d2++;
    c2 = e2;
  } while (c2);
  bd(b2);
}
function Lf(a2) {
  for (; null != a2; a2 = a2.nextSibling) {
    var b2 = a2.nodeType;
    if (1 === b2 || 3 === b2)
      break;
    if (8 === b2) {
      b2 = a2.data;
      if ("$" === b2 || "$!" === b2 || "$?" === b2)
        break;
      if ("/$" === b2)
        return null;
    }
  }
  return a2;
}
function Mf(a2) {
  a2 = a2.previousSibling;
  for (var b2 = 0; a2; ) {
    if (8 === a2.nodeType) {
      var c2 = a2.data;
      if ("$" === c2 || "$!" === c2 || "$?" === c2) {
        if (0 === b2)
          return a2;
        b2--;
      } else
        "/$" === c2 && b2++;
    }
    a2 = a2.previousSibling;
  }
  return null;
}
var Nf = Math.random().toString(36).slice(2), Of = "__reactFiber$" + Nf, Pf = "__reactProps$" + Nf, uf = "__reactContainer$" + Nf, of = "__reactEvents$" + Nf, Qf = "__reactListeners$" + Nf, Rf = "__reactHandles$" + Nf;
function Wc(a2) {
  var b2 = a2[Of];
  if (b2)
    return b2;
  for (var c2 = a2.parentNode; c2; ) {
    if (b2 = c2[uf] || c2[Of]) {
      c2 = b2.alternate;
      if (null !== b2.child || null !== c2 && null !== c2.child)
        for (a2 = Mf(a2); null !== a2; ) {
          if (c2 = a2[Of])
            return c2;
          a2 = Mf(a2);
        }
      return b2;
    }
    a2 = c2;
    c2 = a2.parentNode;
  }
  return null;
}
function Cb(a2) {
  a2 = a2[Of] || a2[uf];
  return !a2 || 5 !== a2.tag && 6 !== a2.tag && 13 !== a2.tag && 3 !== a2.tag ? null : a2;
}
function ue$1(a2) {
  if (5 === a2.tag || 6 === a2.tag)
    return a2.stateNode;
  throw Error(p$3(33));
}
function Db(a2) {
  return a2[Pf] || null;
}
var Sf = [], Tf = -1;
function Uf(a2) {
  return { current: a2 };
}
function E$2(a2) {
  0 > Tf || (a2.current = Sf[Tf], Sf[Tf] = null, Tf--);
}
function G$2(a2, b2) {
  Tf++;
  Sf[Tf] = a2.current;
  a2.current = b2;
}
var Vf = {}, H$2 = Uf(Vf), Wf = Uf(false), Xf = Vf;
function Yf(a2, b2) {
  var c2 = a2.type.contextTypes;
  if (!c2)
    return Vf;
  var d2 = a2.stateNode;
  if (d2 && d2.__reactInternalMemoizedUnmaskedChildContext === b2)
    return d2.__reactInternalMemoizedMaskedChildContext;
  var e2 = {}, f2;
  for (f2 in c2)
    e2[f2] = b2[f2];
  d2 && (a2 = a2.stateNode, a2.__reactInternalMemoizedUnmaskedChildContext = b2, a2.__reactInternalMemoizedMaskedChildContext = e2);
  return e2;
}
function Zf(a2) {
  a2 = a2.childContextTypes;
  return null !== a2 && void 0 !== a2;
}
function $f() {
  E$2(Wf);
  E$2(H$2);
}
function ag(a2, b2, c2) {
  if (H$2.current !== Vf)
    throw Error(p$3(168));
  G$2(H$2, b2);
  G$2(Wf, c2);
}
function bg(a2, b2, c2) {
  var d2 = a2.stateNode;
  b2 = b2.childContextTypes;
  if ("function" !== typeof d2.getChildContext)
    return c2;
  d2 = d2.getChildContext();
  for (var e2 in d2)
    if (!(e2 in b2))
      throw Error(p$3(108, Ra(a2) || "Unknown", e2));
  return A$3({}, c2, d2);
}
function cg(a2) {
  a2 = (a2 = a2.stateNode) && a2.__reactInternalMemoizedMergedChildContext || Vf;
  Xf = H$2.current;
  G$2(H$2, a2);
  G$2(Wf, Wf.current);
  return true;
}
function dg(a2, b2, c2) {
  var d2 = a2.stateNode;
  if (!d2)
    throw Error(p$3(169));
  c2 ? (a2 = bg(a2, b2, Xf), d2.__reactInternalMemoizedMergedChildContext = a2, E$2(Wf), E$2(H$2), G$2(H$2, a2)) : E$2(Wf);
  G$2(Wf, c2);
}
var eg = null, fg = false, gg = false;
function hg(a2) {
  null === eg ? eg = [a2] : eg.push(a2);
}
function ig(a2) {
  fg = true;
  hg(a2);
}
function jg() {
  if (!gg && null !== eg) {
    gg = true;
    var a2 = 0, b2 = C$2;
    try {
      var c2 = eg;
      for (C$2 = 1; a2 < c2.length; a2++) {
        var d2 = c2[a2];
        do
          d2 = d2(true);
        while (null !== d2);
      }
      eg = null;
      fg = false;
    } catch (e2) {
      throw null !== eg && (eg = eg.slice(a2 + 1)), ac(fc, jg), e2;
    } finally {
      C$2 = b2, gg = false;
    }
  }
  return null;
}
var kg = [], lg = 0, mg = null, ng = 0, og = [], pg = 0, qg = null, rg = 1, sg = "";
function tg(a2, b2) {
  kg[lg++] = ng;
  kg[lg++] = mg;
  mg = a2;
  ng = b2;
}
function ug(a2, b2, c2) {
  og[pg++] = rg;
  og[pg++] = sg;
  og[pg++] = qg;
  qg = a2;
  var d2 = rg;
  a2 = sg;
  var e2 = 32 - oc(d2) - 1;
  d2 &= ~(1 << e2);
  c2 += 1;
  var f2 = 32 - oc(b2) + e2;
  if (30 < f2) {
    var g2 = e2 - e2 % 5;
    f2 = (d2 & (1 << g2) - 1).toString(32);
    d2 >>= g2;
    e2 -= g2;
    rg = 1 << 32 - oc(b2) + e2 | c2 << e2 | d2;
    sg = f2 + a2;
  } else
    rg = 1 << f2 | c2 << e2 | d2, sg = a2;
}
function vg(a2) {
  null !== a2.return && (tg(a2, 1), ug(a2, 1, 0));
}
function wg(a2) {
  for (; a2 === mg; )
    mg = kg[--lg], kg[lg] = null, ng = kg[--lg], kg[lg] = null;
  for (; a2 === qg; )
    qg = og[--pg], og[pg] = null, sg = og[--pg], og[pg] = null, rg = og[--pg], og[pg] = null;
}
var xg = null, yg = null, I$2 = false, zg = null;
function Ag(a2, b2) {
  var c2 = Bg(5, null, null, 0);
  c2.elementType = "DELETED";
  c2.stateNode = b2;
  c2.return = a2;
  b2 = a2.deletions;
  null === b2 ? (a2.deletions = [c2], a2.flags |= 16) : b2.push(c2);
}
function Cg(a2, b2) {
  switch (a2.tag) {
    case 5:
      var c2 = a2.type;
      b2 = 1 !== b2.nodeType || c2.toLowerCase() !== b2.nodeName.toLowerCase() ? null : b2;
      return null !== b2 ? (a2.stateNode = b2, xg = a2, yg = Lf(b2.firstChild), true) : false;
    case 6:
      return b2 = "" === a2.pendingProps || 3 !== b2.nodeType ? null : b2, null !== b2 ? (a2.stateNode = b2, xg = a2, yg = null, true) : false;
    case 13:
      return b2 = 8 !== b2.nodeType ? null : b2, null !== b2 ? (c2 = null !== qg ? { id: rg, overflow: sg } : null, a2.memoizedState = { dehydrated: b2, treeContext: c2, retryLane: 1073741824 }, c2 = Bg(18, null, null, 0), c2.stateNode = b2, c2.return = a2, a2.child = c2, xg = a2, yg = null, true) : false;
    default:
      return false;
  }
}
function Dg(a2) {
  return 0 !== (a2.mode & 1) && 0 === (a2.flags & 128);
}
function Eg(a2) {
  if (I$2) {
    var b2 = yg;
    if (b2) {
      var c2 = b2;
      if (!Cg(a2, b2)) {
        if (Dg(a2))
          throw Error(p$3(418));
        b2 = Lf(c2.nextSibling);
        var d2 = xg;
        b2 && Cg(a2, b2) ? Ag(d2, c2) : (a2.flags = a2.flags & -4097 | 2, I$2 = false, xg = a2);
      }
    } else {
      if (Dg(a2))
        throw Error(p$3(418));
      a2.flags = a2.flags & -4097 | 2;
      I$2 = false;
      xg = a2;
    }
  }
}
function Fg(a2) {
  for (a2 = a2.return; null !== a2 && 5 !== a2.tag && 3 !== a2.tag && 13 !== a2.tag; )
    a2 = a2.return;
  xg = a2;
}
function Gg(a2) {
  if (a2 !== xg)
    return false;
  if (!I$2)
    return Fg(a2), I$2 = true, false;
  var b2;
  (b2 = 3 !== a2.tag) && !(b2 = 5 !== a2.tag) && (b2 = a2.type, b2 = "head" !== b2 && "body" !== b2 && !Ef(a2.type, a2.memoizedProps));
  if (b2 && (b2 = yg)) {
    if (Dg(a2))
      throw Hg(), Error(p$3(418));
    for (; b2; )
      Ag(a2, b2), b2 = Lf(b2.nextSibling);
  }
  Fg(a2);
  if (13 === a2.tag) {
    a2 = a2.memoizedState;
    a2 = null !== a2 ? a2.dehydrated : null;
    if (!a2)
      throw Error(p$3(317));
    a: {
      a2 = a2.nextSibling;
      for (b2 = 0; a2; ) {
        if (8 === a2.nodeType) {
          var c2 = a2.data;
          if ("/$" === c2) {
            if (0 === b2) {
              yg = Lf(a2.nextSibling);
              break a;
            }
            b2--;
          } else
            "$" !== c2 && "$!" !== c2 && "$?" !== c2 || b2++;
        }
        a2 = a2.nextSibling;
      }
      yg = null;
    }
  } else
    yg = xg ? Lf(a2.stateNode.nextSibling) : null;
  return true;
}
function Hg() {
  for (var a2 = yg; a2; )
    a2 = Lf(a2.nextSibling);
}
function Ig() {
  yg = xg = null;
  I$2 = false;
}
function Jg(a2) {
  null === zg ? zg = [a2] : zg.push(a2);
}
var Kg = ua.ReactCurrentBatchConfig;
function Lg(a2, b2) {
  if (a2 && a2.defaultProps) {
    b2 = A$3({}, b2);
    a2 = a2.defaultProps;
    for (var c2 in a2)
      void 0 === b2[c2] && (b2[c2] = a2[c2]);
    return b2;
  }
  return b2;
}
var Mg = Uf(null), Ng = null, Og = null, Pg = null;
function Qg() {
  Pg = Og = Ng = null;
}
function Rg(a2) {
  var b2 = Mg.current;
  E$2(Mg);
  a2._currentValue = b2;
}
function Sg(a2, b2, c2) {
  for (; null !== a2; ) {
    var d2 = a2.alternate;
    (a2.childLanes & b2) !== b2 ? (a2.childLanes |= b2, null !== d2 && (d2.childLanes |= b2)) : null !== d2 && (d2.childLanes & b2) !== b2 && (d2.childLanes |= b2);
    if (a2 === c2)
      break;
    a2 = a2.return;
  }
}
function Tg(a2, b2) {
  Ng = a2;
  Pg = Og = null;
  a2 = a2.dependencies;
  null !== a2 && null !== a2.firstContext && (0 !== (a2.lanes & b2) && (Ug = true), a2.firstContext = null);
}
function Vg(a2) {
  var b2 = a2._currentValue;
  if (Pg !== a2)
    if (a2 = { context: a2, memoizedValue: b2, next: null }, null === Og) {
      if (null === Ng)
        throw Error(p$3(308));
      Og = a2;
      Ng.dependencies = { lanes: 0, firstContext: a2 };
    } else
      Og = Og.next = a2;
  return b2;
}
var Wg = null;
function Xg(a2) {
  null === Wg ? Wg = [a2] : Wg.push(a2);
}
function Yg(a2, b2, c2, d2) {
  var e2 = b2.interleaved;
  null === e2 ? (c2.next = c2, Xg(b2)) : (c2.next = e2.next, e2.next = c2);
  b2.interleaved = c2;
  return Zg(a2, d2);
}
function Zg(a2, b2) {
  a2.lanes |= b2;
  var c2 = a2.alternate;
  null !== c2 && (c2.lanes |= b2);
  c2 = a2;
  for (a2 = a2.return; null !== a2; )
    a2.childLanes |= b2, c2 = a2.alternate, null !== c2 && (c2.childLanes |= b2), c2 = a2, a2 = a2.return;
  return 3 === c2.tag ? c2.stateNode : null;
}
var $g = false;
function ah(a2) {
  a2.updateQueue = { baseState: a2.memoizedState, firstBaseUpdate: null, lastBaseUpdate: null, shared: { pending: null, interleaved: null, lanes: 0 }, effects: null };
}
function bh(a2, b2) {
  a2 = a2.updateQueue;
  b2.updateQueue === a2 && (b2.updateQueue = { baseState: a2.baseState, firstBaseUpdate: a2.firstBaseUpdate, lastBaseUpdate: a2.lastBaseUpdate, shared: a2.shared, effects: a2.effects });
}
function ch(a2, b2) {
  return { eventTime: a2, lane: b2, tag: 0, payload: null, callback: null, next: null };
}
function dh(a2, b2, c2) {
  var d2 = a2.updateQueue;
  if (null === d2)
    return null;
  d2 = d2.shared;
  if (0 !== (K$1 & 2)) {
    var e2 = d2.pending;
    null === e2 ? b2.next = b2 : (b2.next = e2.next, e2.next = b2);
    d2.pending = b2;
    return Zg(a2, c2);
  }
  e2 = d2.interleaved;
  null === e2 ? (b2.next = b2, Xg(d2)) : (b2.next = e2.next, e2.next = b2);
  d2.interleaved = b2;
  return Zg(a2, c2);
}
function eh(a2, b2, c2) {
  b2 = b2.updateQueue;
  if (null !== b2 && (b2 = b2.shared, 0 !== (c2 & 4194240))) {
    var d2 = b2.lanes;
    d2 &= a2.pendingLanes;
    c2 |= d2;
    b2.lanes = c2;
    Cc(a2, c2);
  }
}
function fh(a2, b2) {
  var c2 = a2.updateQueue, d2 = a2.alternate;
  if (null !== d2 && (d2 = d2.updateQueue, c2 === d2)) {
    var e2 = null, f2 = null;
    c2 = c2.firstBaseUpdate;
    if (null !== c2) {
      do {
        var g2 = { eventTime: c2.eventTime, lane: c2.lane, tag: c2.tag, payload: c2.payload, callback: c2.callback, next: null };
        null === f2 ? e2 = f2 = g2 : f2 = f2.next = g2;
        c2 = c2.next;
      } while (null !== c2);
      null === f2 ? e2 = f2 = b2 : f2 = f2.next = b2;
    } else
      e2 = f2 = b2;
    c2 = { baseState: d2.baseState, firstBaseUpdate: e2, lastBaseUpdate: f2, shared: d2.shared, effects: d2.effects };
    a2.updateQueue = c2;
    return;
  }
  a2 = c2.lastBaseUpdate;
  null === a2 ? c2.firstBaseUpdate = b2 : a2.next = b2;
  c2.lastBaseUpdate = b2;
}
function gh(a2, b2, c2, d2) {
  var e2 = a2.updateQueue;
  $g = false;
  var f2 = e2.firstBaseUpdate, g2 = e2.lastBaseUpdate, h2 = e2.shared.pending;
  if (null !== h2) {
    e2.shared.pending = null;
    var k2 = h2, l2 = k2.next;
    k2.next = null;
    null === g2 ? f2 = l2 : g2.next = l2;
    g2 = k2;
    var m2 = a2.alternate;
    null !== m2 && (m2 = m2.updateQueue, h2 = m2.lastBaseUpdate, h2 !== g2 && (null === h2 ? m2.firstBaseUpdate = l2 : h2.next = l2, m2.lastBaseUpdate = k2));
  }
  if (null !== f2) {
    var q2 = e2.baseState;
    g2 = 0;
    m2 = l2 = k2 = null;
    h2 = f2;
    do {
      var r2 = h2.lane, y2 = h2.eventTime;
      if ((d2 & r2) === r2) {
        null !== m2 && (m2 = m2.next = {
          eventTime: y2,
          lane: 0,
          tag: h2.tag,
          payload: h2.payload,
          callback: h2.callback,
          next: null
        });
        a: {
          var n2 = a2, t2 = h2;
          r2 = b2;
          y2 = c2;
          switch (t2.tag) {
            case 1:
              n2 = t2.payload;
              if ("function" === typeof n2) {
                q2 = n2.call(y2, q2, r2);
                break a;
              }
              q2 = n2;
              break a;
            case 3:
              n2.flags = n2.flags & -65537 | 128;
            case 0:
              n2 = t2.payload;
              r2 = "function" === typeof n2 ? n2.call(y2, q2, r2) : n2;
              if (null === r2 || void 0 === r2)
                break a;
              q2 = A$3({}, q2, r2);
              break a;
            case 2:
              $g = true;
          }
        }
        null !== h2.callback && 0 !== h2.lane && (a2.flags |= 64, r2 = e2.effects, null === r2 ? e2.effects = [h2] : r2.push(h2));
      } else
        y2 = { eventTime: y2, lane: r2, tag: h2.tag, payload: h2.payload, callback: h2.callback, next: null }, null === m2 ? (l2 = m2 = y2, k2 = q2) : m2 = m2.next = y2, g2 |= r2;
      h2 = h2.next;
      if (null === h2)
        if (h2 = e2.shared.pending, null === h2)
          break;
        else
          r2 = h2, h2 = r2.next, r2.next = null, e2.lastBaseUpdate = r2, e2.shared.pending = null;
    } while (1);
    null === m2 && (k2 = q2);
    e2.baseState = k2;
    e2.firstBaseUpdate = l2;
    e2.lastBaseUpdate = m2;
    b2 = e2.shared.interleaved;
    if (null !== b2) {
      e2 = b2;
      do
        g2 |= e2.lane, e2 = e2.next;
      while (e2 !== b2);
    } else
      null === f2 && (e2.shared.lanes = 0);
    hh |= g2;
    a2.lanes = g2;
    a2.memoizedState = q2;
  }
}
function ih(a2, b2, c2) {
  a2 = b2.effects;
  b2.effects = null;
  if (null !== a2)
    for (b2 = 0; b2 < a2.length; b2++) {
      var d2 = a2[b2], e2 = d2.callback;
      if (null !== e2) {
        d2.callback = null;
        d2 = c2;
        if ("function" !== typeof e2)
          throw Error(p$3(191, e2));
        e2.call(d2);
      }
    }
}
var jh = new aa.Component().refs;
function kh(a2, b2, c2, d2) {
  b2 = a2.memoizedState;
  c2 = c2(d2, b2);
  c2 = null === c2 || void 0 === c2 ? b2 : A$3({}, b2, c2);
  a2.memoizedState = c2;
  0 === a2.lanes && (a2.updateQueue.baseState = c2);
}
var nh = { isMounted: function(a2) {
  return (a2 = a2._reactInternals) ? Vb(a2) === a2 : false;
}, enqueueSetState: function(a2, b2, c2) {
  a2 = a2._reactInternals;
  var d2 = L$1(), e2 = lh(a2), f2 = ch(d2, e2);
  f2.payload = b2;
  void 0 !== c2 && null !== c2 && (f2.callback = c2);
  b2 = dh(a2, f2, e2);
  null !== b2 && (mh(b2, a2, e2, d2), eh(b2, a2, e2));
}, enqueueReplaceState: function(a2, b2, c2) {
  a2 = a2._reactInternals;
  var d2 = L$1(), e2 = lh(a2), f2 = ch(d2, e2);
  f2.tag = 1;
  f2.payload = b2;
  void 0 !== c2 && null !== c2 && (f2.callback = c2);
  b2 = dh(a2, f2, e2);
  null !== b2 && (mh(b2, a2, e2, d2), eh(b2, a2, e2));
}, enqueueForceUpdate: function(a2, b2) {
  a2 = a2._reactInternals;
  var c2 = L$1(), d2 = lh(a2), e2 = ch(c2, d2);
  e2.tag = 2;
  void 0 !== b2 && null !== b2 && (e2.callback = b2);
  b2 = dh(a2, e2, d2);
  null !== b2 && (mh(b2, a2, d2, c2), eh(b2, a2, d2));
} };
function oh(a2, b2, c2, d2, e2, f2, g2) {
  a2 = a2.stateNode;
  return "function" === typeof a2.shouldComponentUpdate ? a2.shouldComponentUpdate(d2, f2, g2) : b2.prototype && b2.prototype.isPureReactComponent ? !Ie$1(c2, d2) || !Ie$1(e2, f2) : true;
}
function ph(a2, b2, c2) {
  var d2 = false, e2 = Vf;
  var f2 = b2.contextType;
  "object" === typeof f2 && null !== f2 ? f2 = Vg(f2) : (e2 = Zf(b2) ? Xf : H$2.current, d2 = b2.contextTypes, f2 = (d2 = null !== d2 && void 0 !== d2) ? Yf(a2, e2) : Vf);
  b2 = new b2(c2, f2);
  a2.memoizedState = null !== b2.state && void 0 !== b2.state ? b2.state : null;
  b2.updater = nh;
  a2.stateNode = b2;
  b2._reactInternals = a2;
  d2 && (a2 = a2.stateNode, a2.__reactInternalMemoizedUnmaskedChildContext = e2, a2.__reactInternalMemoizedMaskedChildContext = f2);
  return b2;
}
function qh(a2, b2, c2, d2) {
  a2 = b2.state;
  "function" === typeof b2.componentWillReceiveProps && b2.componentWillReceiveProps(c2, d2);
  "function" === typeof b2.UNSAFE_componentWillReceiveProps && b2.UNSAFE_componentWillReceiveProps(c2, d2);
  b2.state !== a2 && nh.enqueueReplaceState(b2, b2.state, null);
}
function rh(a2, b2, c2, d2) {
  var e2 = a2.stateNode;
  e2.props = c2;
  e2.state = a2.memoizedState;
  e2.refs = jh;
  ah(a2);
  var f2 = b2.contextType;
  "object" === typeof f2 && null !== f2 ? e2.context = Vg(f2) : (f2 = Zf(b2) ? Xf : H$2.current, e2.context = Yf(a2, f2));
  e2.state = a2.memoizedState;
  f2 = b2.getDerivedStateFromProps;
  "function" === typeof f2 && (kh(a2, b2, f2, c2), e2.state = a2.memoizedState);
  "function" === typeof b2.getDerivedStateFromProps || "function" === typeof e2.getSnapshotBeforeUpdate || "function" !== typeof e2.UNSAFE_componentWillMount && "function" !== typeof e2.componentWillMount || (b2 = e2.state, "function" === typeof e2.componentWillMount && e2.componentWillMount(), "function" === typeof e2.UNSAFE_componentWillMount && e2.UNSAFE_componentWillMount(), b2 !== e2.state && nh.enqueueReplaceState(e2, e2.state, null), gh(a2, c2, e2, d2), e2.state = a2.memoizedState);
  "function" === typeof e2.componentDidMount && (a2.flags |= 4194308);
}
function sh(a2, b2, c2) {
  a2 = c2.ref;
  if (null !== a2 && "function" !== typeof a2 && "object" !== typeof a2) {
    if (c2._owner) {
      c2 = c2._owner;
      if (c2) {
        if (1 !== c2.tag)
          throw Error(p$3(309));
        var d2 = c2.stateNode;
      }
      if (!d2)
        throw Error(p$3(147, a2));
      var e2 = d2, f2 = "" + a2;
      if (null !== b2 && null !== b2.ref && "function" === typeof b2.ref && b2.ref._stringRef === f2)
        return b2.ref;
      b2 = function(a3) {
        var b3 = e2.refs;
        b3 === jh && (b3 = e2.refs = {});
        null === a3 ? delete b3[f2] : b3[f2] = a3;
      };
      b2._stringRef = f2;
      return b2;
    }
    if ("string" !== typeof a2)
      throw Error(p$3(284));
    if (!c2._owner)
      throw Error(p$3(290, a2));
  }
  return a2;
}
function th(a2, b2) {
  a2 = Object.prototype.toString.call(b2);
  throw Error(p$3(31, "[object Object]" === a2 ? "object with keys {" + Object.keys(b2).join(", ") + "}" : a2));
}
function uh(a2) {
  var b2 = a2._init;
  return b2(a2._payload);
}
function vh(a2) {
  function b2(b3, c3) {
    if (a2) {
      var d3 = b3.deletions;
      null === d3 ? (b3.deletions = [c3], b3.flags |= 16) : d3.push(c3);
    }
  }
  function c2(c3, d3) {
    if (!a2)
      return null;
    for (; null !== d3; )
      b2(c3, d3), d3 = d3.sibling;
    return null;
  }
  function d2(a3, b3) {
    for (a3 = /* @__PURE__ */ new Map(); null !== b3; )
      null !== b3.key ? a3.set(b3.key, b3) : a3.set(b3.index, b3), b3 = b3.sibling;
    return a3;
  }
  function e2(a3, b3) {
    a3 = wh(a3, b3);
    a3.index = 0;
    a3.sibling = null;
    return a3;
  }
  function f2(b3, c3, d3) {
    b3.index = d3;
    if (!a2)
      return b3.flags |= 1048576, c3;
    d3 = b3.alternate;
    if (null !== d3)
      return d3 = d3.index, d3 < c3 ? (b3.flags |= 2, c3) : d3;
    b3.flags |= 2;
    return c3;
  }
  function g2(b3) {
    a2 && null === b3.alternate && (b3.flags |= 2);
    return b3;
  }
  function h2(a3, b3, c3, d3) {
    if (null === b3 || 6 !== b3.tag)
      return b3 = xh(c3, a3.mode, d3), b3.return = a3, b3;
    b3 = e2(b3, c3);
    b3.return = a3;
    return b3;
  }
  function k2(a3, b3, c3, d3) {
    var f3 = c3.type;
    if (f3 === ya)
      return m2(a3, b3, c3.props.children, d3, c3.key);
    if (null !== b3 && (b3.elementType === f3 || "object" === typeof f3 && null !== f3 && f3.$$typeof === Ha && uh(f3) === b3.type))
      return d3 = e2(b3, c3.props), d3.ref = sh(a3, b3, c3), d3.return = a3, d3;
    d3 = yh(c3.type, c3.key, c3.props, null, a3.mode, d3);
    d3.ref = sh(a3, b3, c3);
    d3.return = a3;
    return d3;
  }
  function l2(a3, b3, c3, d3) {
    if (null === b3 || 4 !== b3.tag || b3.stateNode.containerInfo !== c3.containerInfo || b3.stateNode.implementation !== c3.implementation)
      return b3 = zh(c3, a3.mode, d3), b3.return = a3, b3;
    b3 = e2(b3, c3.children || []);
    b3.return = a3;
    return b3;
  }
  function m2(a3, b3, c3, d3, f3) {
    if (null === b3 || 7 !== b3.tag)
      return b3 = Ah(c3, a3.mode, d3, f3), b3.return = a3, b3;
    b3 = e2(b3, c3);
    b3.return = a3;
    return b3;
  }
  function q2(a3, b3, c3) {
    if ("string" === typeof b3 && "" !== b3 || "number" === typeof b3)
      return b3 = xh("" + b3, a3.mode, c3), b3.return = a3, b3;
    if ("object" === typeof b3 && null !== b3) {
      switch (b3.$$typeof) {
        case va:
          return c3 = yh(b3.type, b3.key, b3.props, null, a3.mode, c3), c3.ref = sh(a3, null, b3), c3.return = a3, c3;
        case wa:
          return b3 = zh(b3, a3.mode, c3), b3.return = a3, b3;
        case Ha:
          var d3 = b3._init;
          return q2(a3, d3(b3._payload), c3);
      }
      if (eb(b3) || Ka(b3))
        return b3 = Ah(b3, a3.mode, c3, null), b3.return = a3, b3;
      th(a3, b3);
    }
    return null;
  }
  function r2(a3, b3, c3, d3) {
    var e3 = null !== b3 ? b3.key : null;
    if ("string" === typeof c3 && "" !== c3 || "number" === typeof c3)
      return null !== e3 ? null : h2(a3, b3, "" + c3, d3);
    if ("object" === typeof c3 && null !== c3) {
      switch (c3.$$typeof) {
        case va:
          return c3.key === e3 ? k2(a3, b3, c3, d3) : null;
        case wa:
          return c3.key === e3 ? l2(a3, b3, c3, d3) : null;
        case Ha:
          return e3 = c3._init, r2(
            a3,
            b3,
            e3(c3._payload),
            d3
          );
      }
      if (eb(c3) || Ka(c3))
        return null !== e3 ? null : m2(a3, b3, c3, d3, null);
      th(a3, c3);
    }
    return null;
  }
  function y2(a3, b3, c3, d3, e3) {
    if ("string" === typeof d3 && "" !== d3 || "number" === typeof d3)
      return a3 = a3.get(c3) || null, h2(b3, a3, "" + d3, e3);
    if ("object" === typeof d3 && null !== d3) {
      switch (d3.$$typeof) {
        case va:
          return a3 = a3.get(null === d3.key ? c3 : d3.key) || null, k2(b3, a3, d3, e3);
        case wa:
          return a3 = a3.get(null === d3.key ? c3 : d3.key) || null, l2(b3, a3, d3, e3);
        case Ha:
          var f3 = d3._init;
          return y2(a3, b3, c3, f3(d3._payload), e3);
      }
      if (eb(d3) || Ka(d3))
        return a3 = a3.get(c3) || null, m2(b3, a3, d3, e3, null);
      th(b3, d3);
    }
    return null;
  }
  function n2(e3, g3, h3, k3) {
    for (var l3 = null, m3 = null, u2 = g3, w2 = g3 = 0, x = null; null !== u2 && w2 < h3.length; w2++) {
      u2.index > w2 ? (x = u2, u2 = null) : x = u2.sibling;
      var n3 = r2(e3, u2, h3[w2], k3);
      if (null === n3) {
        null === u2 && (u2 = x);
        break;
      }
      a2 && u2 && null === n3.alternate && b2(e3, u2);
      g3 = f2(n3, g3, w2);
      null === m3 ? l3 = n3 : m3.sibling = n3;
      m3 = n3;
      u2 = x;
    }
    if (w2 === h3.length)
      return c2(e3, u2), I$2 && tg(e3, w2), l3;
    if (null === u2) {
      for (; w2 < h3.length; w2++)
        u2 = q2(e3, h3[w2], k3), null !== u2 && (g3 = f2(u2, g3, w2), null === m3 ? l3 = u2 : m3.sibling = u2, m3 = u2);
      I$2 && tg(e3, w2);
      return l3;
    }
    for (u2 = d2(e3, u2); w2 < h3.length; w2++)
      x = y2(u2, e3, w2, h3[w2], k3), null !== x && (a2 && null !== x.alternate && u2.delete(null === x.key ? w2 : x.key), g3 = f2(x, g3, w2), null === m3 ? l3 = x : m3.sibling = x, m3 = x);
    a2 && u2.forEach(function(a3) {
      return b2(e3, a3);
    });
    I$2 && tg(e3, w2);
    return l3;
  }
  function t2(e3, g3, h3, k3) {
    var l3 = Ka(h3);
    if ("function" !== typeof l3)
      throw Error(p$3(150));
    h3 = l3.call(h3);
    if (null == h3)
      throw Error(p$3(151));
    for (var u2 = l3 = null, m3 = g3, w2 = g3 = 0, x = null, n3 = h3.next(); null !== m3 && !n3.done; w2++, n3 = h3.next()) {
      m3.index > w2 ? (x = m3, m3 = null) : x = m3.sibling;
      var t3 = r2(e3, m3, n3.value, k3);
      if (null === t3) {
        null === m3 && (m3 = x);
        break;
      }
      a2 && m3 && null === t3.alternate && b2(e3, m3);
      g3 = f2(t3, g3, w2);
      null === u2 ? l3 = t3 : u2.sibling = t3;
      u2 = t3;
      m3 = x;
    }
    if (n3.done)
      return c2(
        e3,
        m3
      ), I$2 && tg(e3, w2), l3;
    if (null === m3) {
      for (; !n3.done; w2++, n3 = h3.next())
        n3 = q2(e3, n3.value, k3), null !== n3 && (g3 = f2(n3, g3, w2), null === u2 ? l3 = n3 : u2.sibling = n3, u2 = n3);
      I$2 && tg(e3, w2);
      return l3;
    }
    for (m3 = d2(e3, m3); !n3.done; w2++, n3 = h3.next())
      n3 = y2(m3, e3, w2, n3.value, k3), null !== n3 && (a2 && null !== n3.alternate && m3.delete(null === n3.key ? w2 : n3.key), g3 = f2(n3, g3, w2), null === u2 ? l3 = n3 : u2.sibling = n3, u2 = n3);
    a2 && m3.forEach(function(a3) {
      return b2(e3, a3);
    });
    I$2 && tg(e3, w2);
    return l3;
  }
  function J2(a3, d3, f3, h3) {
    "object" === typeof f3 && null !== f3 && f3.type === ya && null === f3.key && (f3 = f3.props.children);
    if ("object" === typeof f3 && null !== f3) {
      switch (f3.$$typeof) {
        case va:
          a: {
            for (var k3 = f3.key, l3 = d3; null !== l3; ) {
              if (l3.key === k3) {
                k3 = f3.type;
                if (k3 === ya) {
                  if (7 === l3.tag) {
                    c2(a3, l3.sibling);
                    d3 = e2(l3, f3.props.children);
                    d3.return = a3;
                    a3 = d3;
                    break a;
                  }
                } else if (l3.elementType === k3 || "object" === typeof k3 && null !== k3 && k3.$$typeof === Ha && uh(k3) === l3.type) {
                  c2(a3, l3.sibling);
                  d3 = e2(l3, f3.props);
                  d3.ref = sh(a3, l3, f3);
                  d3.return = a3;
                  a3 = d3;
                  break a;
                }
                c2(a3, l3);
                break;
              } else
                b2(a3, l3);
              l3 = l3.sibling;
            }
            f3.type === ya ? (d3 = Ah(f3.props.children, a3.mode, h3, f3.key), d3.return = a3, a3 = d3) : (h3 = yh(f3.type, f3.key, f3.props, null, a3.mode, h3), h3.ref = sh(a3, d3, f3), h3.return = a3, a3 = h3);
          }
          return g2(a3);
        case wa:
          a: {
            for (l3 = f3.key; null !== d3; ) {
              if (d3.key === l3)
                if (4 === d3.tag && d3.stateNode.containerInfo === f3.containerInfo && d3.stateNode.implementation === f3.implementation) {
                  c2(a3, d3.sibling);
                  d3 = e2(d3, f3.children || []);
                  d3.return = a3;
                  a3 = d3;
                  break a;
                } else {
                  c2(a3, d3);
                  break;
                }
              else
                b2(a3, d3);
              d3 = d3.sibling;
            }
            d3 = zh(f3, a3.mode, h3);
            d3.return = a3;
            a3 = d3;
          }
          return g2(a3);
        case Ha:
          return l3 = f3._init, J2(a3, d3, l3(f3._payload), h3);
      }
      if (eb(f3))
        return n2(a3, d3, f3, h3);
      if (Ka(f3))
        return t2(a3, d3, f3, h3);
      th(a3, f3);
    }
    return "string" === typeof f3 && "" !== f3 || "number" === typeof f3 ? (f3 = "" + f3, null !== d3 && 6 === d3.tag ? (c2(a3, d3.sibling), d3 = e2(d3, f3), d3.return = a3, a3 = d3) : (c2(a3, d3), d3 = xh(f3, a3.mode, h3), d3.return = a3, a3 = d3), g2(a3)) : c2(a3, d3);
  }
  return J2;
}
var Bh = vh(true), Ch = vh(false), Dh = {}, Eh = Uf(Dh), Fh = Uf(Dh), Gh = Uf(Dh);
function Hh(a2) {
  if (a2 === Dh)
    throw Error(p$3(174));
  return a2;
}
function Ih(a2, b2) {
  G$2(Gh, b2);
  G$2(Fh, a2);
  G$2(Eh, Dh);
  a2 = b2.nodeType;
  switch (a2) {
    case 9:
    case 11:
      b2 = (b2 = b2.documentElement) ? b2.namespaceURI : lb(null, "");
      break;
    default:
      a2 = 8 === a2 ? b2.parentNode : b2, b2 = a2.namespaceURI || null, a2 = a2.tagName, b2 = lb(b2, a2);
  }
  E$2(Eh);
  G$2(Eh, b2);
}
function Jh() {
  E$2(Eh);
  E$2(Fh);
  E$2(Gh);
}
function Kh(a2) {
  Hh(Gh.current);
  var b2 = Hh(Eh.current);
  var c2 = lb(b2, a2.type);
  b2 !== c2 && (G$2(Fh, a2), G$2(Eh, c2));
}
function Lh(a2) {
  Fh.current === a2 && (E$2(Eh), E$2(Fh));
}
var M$1 = Uf(0);
function Mh(a2) {
  for (var b2 = a2; null !== b2; ) {
    if (13 === b2.tag) {
      var c2 = b2.memoizedState;
      if (null !== c2 && (c2 = c2.dehydrated, null === c2 || "$?" === c2.data || "$!" === c2.data))
        return b2;
    } else if (19 === b2.tag && void 0 !== b2.memoizedProps.revealOrder) {
      if (0 !== (b2.flags & 128))
        return b2;
    } else if (null !== b2.child) {
      b2.child.return = b2;
      b2 = b2.child;
      continue;
    }
    if (b2 === a2)
      break;
    for (; null === b2.sibling; ) {
      if (null === b2.return || b2.return === a2)
        return null;
      b2 = b2.return;
    }
    b2.sibling.return = b2.return;
    b2 = b2.sibling;
  }
  return null;
}
var Nh = [];
function Oh() {
  for (var a2 = 0; a2 < Nh.length; a2++)
    Nh[a2]._workInProgressVersionPrimary = null;
  Nh.length = 0;
}
var Ph = ua.ReactCurrentDispatcher, Qh = ua.ReactCurrentBatchConfig, Rh = 0, N$1 = null, O$1 = null, P$1 = null, Sh = false, Th = false, Uh = 0, Vh = 0;
function Q$1() {
  throw Error(p$3(321));
}
function Wh(a2, b2) {
  if (null === b2)
    return false;
  for (var c2 = 0; c2 < b2.length && c2 < a2.length; c2++)
    if (!He$1(a2[c2], b2[c2]))
      return false;
  return true;
}
function Xh(a2, b2, c2, d2, e2, f2) {
  Rh = f2;
  N$1 = b2;
  b2.memoizedState = null;
  b2.updateQueue = null;
  b2.lanes = 0;
  Ph.current = null === a2 || null === a2.memoizedState ? Yh : Zh;
  a2 = c2(d2, e2);
  if (Th) {
    f2 = 0;
    do {
      Th = false;
      Uh = 0;
      if (25 <= f2)
        throw Error(p$3(301));
      f2 += 1;
      P$1 = O$1 = null;
      b2.updateQueue = null;
      Ph.current = $h;
      a2 = c2(d2, e2);
    } while (Th);
  }
  Ph.current = ai$1;
  b2 = null !== O$1 && null !== O$1.next;
  Rh = 0;
  P$1 = O$1 = N$1 = null;
  Sh = false;
  if (b2)
    throw Error(p$3(300));
  return a2;
}
function bi$1() {
  var a2 = 0 !== Uh;
  Uh = 0;
  return a2;
}
function ci$1() {
  var a2 = { memoizedState: null, baseState: null, baseQueue: null, queue: null, next: null };
  null === P$1 ? N$1.memoizedState = P$1 = a2 : P$1 = P$1.next = a2;
  return P$1;
}
function di$1() {
  if (null === O$1) {
    var a2 = N$1.alternate;
    a2 = null !== a2 ? a2.memoizedState : null;
  } else
    a2 = O$1.next;
  var b2 = null === P$1 ? N$1.memoizedState : P$1.next;
  if (null !== b2)
    P$1 = b2, O$1 = a2;
  else {
    if (null === a2)
      throw Error(p$3(310));
    O$1 = a2;
    a2 = { memoizedState: O$1.memoizedState, baseState: O$1.baseState, baseQueue: O$1.baseQueue, queue: O$1.queue, next: null };
    null === P$1 ? N$1.memoizedState = P$1 = a2 : P$1 = P$1.next = a2;
  }
  return P$1;
}
function ei$1(a2, b2) {
  return "function" === typeof b2 ? b2(a2) : b2;
}
function fi$1(a2) {
  var b2 = di$1(), c2 = b2.queue;
  if (null === c2)
    throw Error(p$3(311));
  c2.lastRenderedReducer = a2;
  var d2 = O$1, e2 = d2.baseQueue, f2 = c2.pending;
  if (null !== f2) {
    if (null !== e2) {
      var g2 = e2.next;
      e2.next = f2.next;
      f2.next = g2;
    }
    d2.baseQueue = e2 = f2;
    c2.pending = null;
  }
  if (null !== e2) {
    f2 = e2.next;
    d2 = d2.baseState;
    var h2 = g2 = null, k2 = null, l2 = f2;
    do {
      var m2 = l2.lane;
      if ((Rh & m2) === m2)
        null !== k2 && (k2 = k2.next = { lane: 0, action: l2.action, hasEagerState: l2.hasEagerState, eagerState: l2.eagerState, next: null }), d2 = l2.hasEagerState ? l2.eagerState : a2(d2, l2.action);
      else {
        var q2 = {
          lane: m2,
          action: l2.action,
          hasEagerState: l2.hasEagerState,
          eagerState: l2.eagerState,
          next: null
        };
        null === k2 ? (h2 = k2 = q2, g2 = d2) : k2 = k2.next = q2;
        N$1.lanes |= m2;
        hh |= m2;
      }
      l2 = l2.next;
    } while (null !== l2 && l2 !== f2);
    null === k2 ? g2 = d2 : k2.next = h2;
    He$1(d2, b2.memoizedState) || (Ug = true);
    b2.memoizedState = d2;
    b2.baseState = g2;
    b2.baseQueue = k2;
    c2.lastRenderedState = d2;
  }
  a2 = c2.interleaved;
  if (null !== a2) {
    e2 = a2;
    do
      f2 = e2.lane, N$1.lanes |= f2, hh |= f2, e2 = e2.next;
    while (e2 !== a2);
  } else
    null === e2 && (c2.lanes = 0);
  return [b2.memoizedState, c2.dispatch];
}
function gi$1(a2) {
  var b2 = di$1(), c2 = b2.queue;
  if (null === c2)
    throw Error(p$3(311));
  c2.lastRenderedReducer = a2;
  var d2 = c2.dispatch, e2 = c2.pending, f2 = b2.memoizedState;
  if (null !== e2) {
    c2.pending = null;
    var g2 = e2 = e2.next;
    do
      f2 = a2(f2, g2.action), g2 = g2.next;
    while (g2 !== e2);
    He$1(f2, b2.memoizedState) || (Ug = true);
    b2.memoizedState = f2;
    null === b2.baseQueue && (b2.baseState = f2);
    c2.lastRenderedState = f2;
  }
  return [f2, d2];
}
function hi$1() {
}
function ii$1(a2, b2) {
  var c2 = N$1, d2 = di$1(), e2 = b2(), f2 = !He$1(d2.memoizedState, e2);
  f2 && (d2.memoizedState = e2, Ug = true);
  d2 = d2.queue;
  ji$1(ki$1.bind(null, c2, d2, a2), [a2]);
  if (d2.getSnapshot !== b2 || f2 || null !== P$1 && P$1.memoizedState.tag & 1) {
    c2.flags |= 2048;
    li$1(9, mi$1.bind(null, c2, d2, e2, b2), void 0, null);
    if (null === R$1)
      throw Error(p$3(349));
    0 !== (Rh & 30) || ni$1(c2, b2, e2);
  }
  return e2;
}
function ni$1(a2, b2, c2) {
  a2.flags |= 16384;
  a2 = { getSnapshot: b2, value: c2 };
  b2 = N$1.updateQueue;
  null === b2 ? (b2 = { lastEffect: null, stores: null }, N$1.updateQueue = b2, b2.stores = [a2]) : (c2 = b2.stores, null === c2 ? b2.stores = [a2] : c2.push(a2));
}
function mi$1(a2, b2, c2, d2) {
  b2.value = c2;
  b2.getSnapshot = d2;
  oi$1(b2) && pi$1(a2);
}
function ki$1(a2, b2, c2) {
  return c2(function() {
    oi$1(b2) && pi$1(a2);
  });
}
function oi$1(a2) {
  var b2 = a2.getSnapshot;
  a2 = a2.value;
  try {
    var c2 = b2();
    return !He$1(a2, c2);
  } catch (d2) {
    return true;
  }
}
function pi$1(a2) {
  var b2 = Zg(a2, 1);
  null !== b2 && mh(b2, a2, 1, -1);
}
function qi$1(a2) {
  var b2 = ci$1();
  "function" === typeof a2 && (a2 = a2());
  b2.memoizedState = b2.baseState = a2;
  a2 = { pending: null, interleaved: null, lanes: 0, dispatch: null, lastRenderedReducer: ei$1, lastRenderedState: a2 };
  b2.queue = a2;
  a2 = a2.dispatch = ri$1.bind(null, N$1, a2);
  return [b2.memoizedState, a2];
}
function li$1(a2, b2, c2, d2) {
  a2 = { tag: a2, create: b2, destroy: c2, deps: d2, next: null };
  b2 = N$1.updateQueue;
  null === b2 ? (b2 = { lastEffect: null, stores: null }, N$1.updateQueue = b2, b2.lastEffect = a2.next = a2) : (c2 = b2.lastEffect, null === c2 ? b2.lastEffect = a2.next = a2 : (d2 = c2.next, c2.next = a2, a2.next = d2, b2.lastEffect = a2));
  return a2;
}
function si$1() {
  return di$1().memoizedState;
}
function ti$1(a2, b2, c2, d2) {
  var e2 = ci$1();
  N$1.flags |= a2;
  e2.memoizedState = li$1(1 | b2, c2, void 0, void 0 === d2 ? null : d2);
}
function ui$1(a2, b2, c2, d2) {
  var e2 = di$1();
  d2 = void 0 === d2 ? null : d2;
  var f2 = void 0;
  if (null !== O$1) {
    var g2 = O$1.memoizedState;
    f2 = g2.destroy;
    if (null !== d2 && Wh(d2, g2.deps)) {
      e2.memoizedState = li$1(b2, c2, f2, d2);
      return;
    }
  }
  N$1.flags |= a2;
  e2.memoizedState = li$1(1 | b2, c2, f2, d2);
}
function vi$1(a2, b2) {
  return ti$1(8390656, 8, a2, b2);
}
function ji$1(a2, b2) {
  return ui$1(2048, 8, a2, b2);
}
function wi$1(a2, b2) {
  return ui$1(4, 2, a2, b2);
}
function xi$1(a2, b2) {
  return ui$1(4, 4, a2, b2);
}
function yi$1(a2, b2) {
  if ("function" === typeof b2)
    return a2 = a2(), b2(a2), function() {
      b2(null);
    };
  if (null !== b2 && void 0 !== b2)
    return a2 = a2(), b2.current = a2, function() {
      b2.current = null;
    };
}
function zi$1(a2, b2, c2) {
  c2 = null !== c2 && void 0 !== c2 ? c2.concat([a2]) : null;
  return ui$1(4, 4, yi$1.bind(null, b2, a2), c2);
}
function Ai$1() {
}
function Bi$1(a2, b2) {
  var c2 = di$1();
  b2 = void 0 === b2 ? null : b2;
  var d2 = c2.memoizedState;
  if (null !== d2 && null !== b2 && Wh(b2, d2[1]))
    return d2[0];
  c2.memoizedState = [a2, b2];
  return a2;
}
function Ci$1(a2, b2) {
  var c2 = di$1();
  b2 = void 0 === b2 ? null : b2;
  var d2 = c2.memoizedState;
  if (null !== d2 && null !== b2 && Wh(b2, d2[1]))
    return d2[0];
  a2 = a2();
  c2.memoizedState = [a2, b2];
  return a2;
}
function Di$1(a2, b2, c2) {
  if (0 === (Rh & 21))
    return a2.baseState && (a2.baseState = false, Ug = true), a2.memoizedState = c2;
  He$1(c2, b2) || (c2 = yc(), N$1.lanes |= c2, hh |= c2, a2.baseState = true);
  return b2;
}
function Ei$1(a2, b2) {
  var c2 = C$2;
  C$2 = 0 !== c2 && 4 > c2 ? c2 : 4;
  a2(true);
  var d2 = Qh.transition;
  Qh.transition = {};
  try {
    a2(false), b2();
  } finally {
    C$2 = c2, Qh.transition = d2;
  }
}
function Fi$1() {
  return di$1().memoizedState;
}
function Gi$1(a2, b2, c2) {
  var d2 = lh(a2);
  c2 = { lane: d2, action: c2, hasEagerState: false, eagerState: null, next: null };
  if (Hi$1(a2))
    Ii$1(b2, c2);
  else if (c2 = Yg(a2, b2, c2, d2), null !== c2) {
    var e2 = L$1();
    mh(c2, a2, d2, e2);
    Ji$1(c2, b2, d2);
  }
}
function ri$1(a2, b2, c2) {
  var d2 = lh(a2), e2 = { lane: d2, action: c2, hasEagerState: false, eagerState: null, next: null };
  if (Hi$1(a2))
    Ii$1(b2, e2);
  else {
    var f2 = a2.alternate;
    if (0 === a2.lanes && (null === f2 || 0 === f2.lanes) && (f2 = b2.lastRenderedReducer, null !== f2))
      try {
        var g2 = b2.lastRenderedState, h2 = f2(g2, c2);
        e2.hasEagerState = true;
        e2.eagerState = h2;
        if (He$1(h2, g2)) {
          var k2 = b2.interleaved;
          null === k2 ? (e2.next = e2, Xg(b2)) : (e2.next = k2.next, k2.next = e2);
          b2.interleaved = e2;
          return;
        }
      } catch (l2) {
      } finally {
      }
    c2 = Yg(a2, b2, e2, d2);
    null !== c2 && (e2 = L$1(), mh(c2, a2, d2, e2), Ji$1(c2, b2, d2));
  }
}
function Hi$1(a2) {
  var b2 = a2.alternate;
  return a2 === N$1 || null !== b2 && b2 === N$1;
}
function Ii$1(a2, b2) {
  Th = Sh = true;
  var c2 = a2.pending;
  null === c2 ? b2.next = b2 : (b2.next = c2.next, c2.next = b2);
  a2.pending = b2;
}
function Ji$1(a2, b2, c2) {
  if (0 !== (c2 & 4194240)) {
    var d2 = b2.lanes;
    d2 &= a2.pendingLanes;
    c2 |= d2;
    b2.lanes = c2;
    Cc(a2, c2);
  }
}
var ai$1 = { readContext: Vg, useCallback: Q$1, useContext: Q$1, useEffect: Q$1, useImperativeHandle: Q$1, useInsertionEffect: Q$1, useLayoutEffect: Q$1, useMemo: Q$1, useReducer: Q$1, useRef: Q$1, useState: Q$1, useDebugValue: Q$1, useDeferredValue: Q$1, useTransition: Q$1, useMutableSource: Q$1, useSyncExternalStore: Q$1, useId: Q$1, unstable_isNewReconciler: false }, Yh = { readContext: Vg, useCallback: function(a2, b2) {
  ci$1().memoizedState = [a2, void 0 === b2 ? null : b2];
  return a2;
}, useContext: Vg, useEffect: vi$1, useImperativeHandle: function(a2, b2, c2) {
  c2 = null !== c2 && void 0 !== c2 ? c2.concat([a2]) : null;
  return ti$1(
    4194308,
    4,
    yi$1.bind(null, b2, a2),
    c2
  );
}, useLayoutEffect: function(a2, b2) {
  return ti$1(4194308, 4, a2, b2);
}, useInsertionEffect: function(a2, b2) {
  return ti$1(4, 2, a2, b2);
}, useMemo: function(a2, b2) {
  var c2 = ci$1();
  b2 = void 0 === b2 ? null : b2;
  a2 = a2();
  c2.memoizedState = [a2, b2];
  return a2;
}, useReducer: function(a2, b2, c2) {
  var d2 = ci$1();
  b2 = void 0 !== c2 ? c2(b2) : b2;
  d2.memoizedState = d2.baseState = b2;
  a2 = { pending: null, interleaved: null, lanes: 0, dispatch: null, lastRenderedReducer: a2, lastRenderedState: b2 };
  d2.queue = a2;
  a2 = a2.dispatch = Gi$1.bind(null, N$1, a2);
  return [d2.memoizedState, a2];
}, useRef: function(a2) {
  var b2 = ci$1();
  a2 = { current: a2 };
  return b2.memoizedState = a2;
}, useState: qi$1, useDebugValue: Ai$1, useDeferredValue: function(a2) {
  return ci$1().memoizedState = a2;
}, useTransition: function() {
  var a2 = qi$1(false), b2 = a2[0];
  a2 = Ei$1.bind(null, a2[1]);
  ci$1().memoizedState = a2;
  return [b2, a2];
}, useMutableSource: function() {
}, useSyncExternalStore: function(a2, b2, c2) {
  var d2 = N$1, e2 = ci$1();
  if (I$2) {
    if (void 0 === c2)
      throw Error(p$3(407));
    c2 = c2();
  } else {
    c2 = b2();
    if (null === R$1)
      throw Error(p$3(349));
    0 !== (Rh & 30) || ni$1(d2, b2, c2);
  }
  e2.memoizedState = c2;
  var f2 = { value: c2, getSnapshot: b2 };
  e2.queue = f2;
  vi$1(ki$1.bind(
    null,
    d2,
    f2,
    a2
  ), [a2]);
  d2.flags |= 2048;
  li$1(9, mi$1.bind(null, d2, f2, c2, b2), void 0, null);
  return c2;
}, useId: function() {
  var a2 = ci$1(), b2 = R$1.identifierPrefix;
  if (I$2) {
    var c2 = sg;
    var d2 = rg;
    c2 = (d2 & ~(1 << 32 - oc(d2) - 1)).toString(32) + c2;
    b2 = ":" + b2 + "R" + c2;
    c2 = Uh++;
    0 < c2 && (b2 += "H" + c2.toString(32));
    b2 += ":";
  } else
    c2 = Vh++, b2 = ":" + b2 + "r" + c2.toString(32) + ":";
  return a2.memoizedState = b2;
}, unstable_isNewReconciler: false }, Zh = {
  readContext: Vg,
  useCallback: Bi$1,
  useContext: Vg,
  useEffect: ji$1,
  useImperativeHandle: zi$1,
  useInsertionEffect: wi$1,
  useLayoutEffect: xi$1,
  useMemo: Ci$1,
  useReducer: fi$1,
  useRef: si$1,
  useState: function() {
    return fi$1(ei$1);
  },
  useDebugValue: Ai$1,
  useDeferredValue: function(a2) {
    var b2 = di$1();
    return Di$1(b2, O$1.memoizedState, a2);
  },
  useTransition: function() {
    var a2 = fi$1(ei$1)[0], b2 = di$1().memoizedState;
    return [a2, b2];
  },
  useMutableSource: hi$1,
  useSyncExternalStore: ii$1,
  useId: Fi$1,
  unstable_isNewReconciler: false
}, $h = { readContext: Vg, useCallback: Bi$1, useContext: Vg, useEffect: ji$1, useImperativeHandle: zi$1, useInsertionEffect: wi$1, useLayoutEffect: xi$1, useMemo: Ci$1, useReducer: gi$1, useRef: si$1, useState: function() {
  return gi$1(ei$1);
}, useDebugValue: Ai$1, useDeferredValue: function(a2) {
  var b2 = di$1();
  return null === O$1 ? b2.memoizedState = a2 : Di$1(b2, O$1.memoizedState, a2);
}, useTransition: function() {
  var a2 = gi$1(ei$1)[0], b2 = di$1().memoizedState;
  return [a2, b2];
}, useMutableSource: hi$1, useSyncExternalStore: ii$1, useId: Fi$1, unstable_isNewReconciler: false };
function Ki$1(a2, b2) {
  try {
    var c2 = "", d2 = b2;
    do
      c2 += Pa(d2), d2 = d2.return;
    while (d2);
    var e2 = c2;
  } catch (f2) {
    e2 = "\nError generating stack: " + f2.message + "\n" + f2.stack;
  }
  return { value: a2, source: b2, stack: e2, digest: null };
}
function Li$1(a2, b2, c2) {
  return { value: a2, source: null, stack: null != c2 ? c2 : null, digest: null != b2 ? b2 : null };
}
function Mi$1(a2, b2) {
  try {
    console.error(b2.value);
  } catch (c2) {
    setTimeout(function() {
      throw c2;
    });
  }
}
var Ni$1 = "function" === typeof WeakMap ? WeakMap : Map;
function Oi$1(a2, b2, c2) {
  c2 = ch(-1, c2);
  c2.tag = 3;
  c2.payload = { element: null };
  var d2 = b2.value;
  c2.callback = function() {
    Pi$1 || (Pi$1 = true, Qi$1 = d2);
    Mi$1(a2, b2);
  };
  return c2;
}
function Ri$1(a2, b2, c2) {
  c2 = ch(-1, c2);
  c2.tag = 3;
  var d2 = a2.type.getDerivedStateFromError;
  if ("function" === typeof d2) {
    var e2 = b2.value;
    c2.payload = function() {
      return d2(e2);
    };
    c2.callback = function() {
      Mi$1(a2, b2);
    };
  }
  var f2 = a2.stateNode;
  null !== f2 && "function" === typeof f2.componentDidCatch && (c2.callback = function() {
    Mi$1(a2, b2);
    "function" !== typeof d2 && (null === Si$1 ? Si$1 = /* @__PURE__ */ new Set([this]) : Si$1.add(this));
    var c3 = b2.stack;
    this.componentDidCatch(b2.value, { componentStack: null !== c3 ? c3 : "" });
  });
  return c2;
}
function Ti$1(a2, b2, c2) {
  var d2 = a2.pingCache;
  if (null === d2) {
    d2 = a2.pingCache = new Ni$1();
    var e2 = /* @__PURE__ */ new Set();
    d2.set(b2, e2);
  } else
    e2 = d2.get(b2), void 0 === e2 && (e2 = /* @__PURE__ */ new Set(), d2.set(b2, e2));
  e2.has(c2) || (e2.add(c2), a2 = Ui$1.bind(null, a2, b2, c2), b2.then(a2, a2));
}
function Vi$1(a2) {
  do {
    var b2;
    if (b2 = 13 === a2.tag)
      b2 = a2.memoizedState, b2 = null !== b2 ? null !== b2.dehydrated ? true : false : true;
    if (b2)
      return a2;
    a2 = a2.return;
  } while (null !== a2);
  return null;
}
function Wi$1(a2, b2, c2, d2, e2) {
  if (0 === (a2.mode & 1))
    return a2 === b2 ? a2.flags |= 65536 : (a2.flags |= 128, c2.flags |= 131072, c2.flags &= -52805, 1 === c2.tag && (null === c2.alternate ? c2.tag = 17 : (b2 = ch(-1, 1), b2.tag = 2, dh(c2, b2, 1))), c2.lanes |= 1), a2;
  a2.flags |= 65536;
  a2.lanes = e2;
  return a2;
}
var Xi$1 = ua.ReactCurrentOwner, Ug = false;
function Yi$1(a2, b2, c2, d2) {
  b2.child = null === a2 ? Ch(b2, null, c2, d2) : Bh(b2, a2.child, c2, d2);
}
function Zi$1(a2, b2, c2, d2, e2) {
  c2 = c2.render;
  var f2 = b2.ref;
  Tg(b2, e2);
  d2 = Xh(a2, b2, c2, d2, f2, e2);
  c2 = bi$1();
  if (null !== a2 && !Ug)
    return b2.updateQueue = a2.updateQueue, b2.flags &= -2053, a2.lanes &= ~e2, $i$1(a2, b2, e2);
  I$2 && c2 && vg(b2);
  b2.flags |= 1;
  Yi$1(a2, b2, d2, e2);
  return b2.child;
}
function aj(a2, b2, c2, d2, e2) {
  if (null === a2) {
    var f2 = c2.type;
    if ("function" === typeof f2 && !bj(f2) && void 0 === f2.defaultProps && null === c2.compare && void 0 === c2.defaultProps)
      return b2.tag = 15, b2.type = f2, cj(a2, b2, f2, d2, e2);
    a2 = yh(c2.type, null, d2, b2, b2.mode, e2);
    a2.ref = b2.ref;
    a2.return = b2;
    return b2.child = a2;
  }
  f2 = a2.child;
  if (0 === (a2.lanes & e2)) {
    var g2 = f2.memoizedProps;
    c2 = c2.compare;
    c2 = null !== c2 ? c2 : Ie$1;
    if (c2(g2, d2) && a2.ref === b2.ref)
      return $i$1(a2, b2, e2);
  }
  b2.flags |= 1;
  a2 = wh(f2, d2);
  a2.ref = b2.ref;
  a2.return = b2;
  return b2.child = a2;
}
function cj(a2, b2, c2, d2, e2) {
  if (null !== a2) {
    var f2 = a2.memoizedProps;
    if (Ie$1(f2, d2) && a2.ref === b2.ref)
      if (Ug = false, b2.pendingProps = d2 = f2, 0 !== (a2.lanes & e2))
        0 !== (a2.flags & 131072) && (Ug = true);
      else
        return b2.lanes = a2.lanes, $i$1(a2, b2, e2);
  }
  return dj(a2, b2, c2, d2, e2);
}
function ej(a2, b2, c2) {
  var d2 = b2.pendingProps, e2 = d2.children, f2 = null !== a2 ? a2.memoizedState : null;
  if ("hidden" === d2.mode)
    if (0 === (b2.mode & 1))
      b2.memoizedState = { baseLanes: 0, cachePool: null, transitions: null }, G$2(fj, gj), gj |= c2;
    else {
      if (0 === (c2 & 1073741824))
        return a2 = null !== f2 ? f2.baseLanes | c2 : c2, b2.lanes = b2.childLanes = 1073741824, b2.memoizedState = { baseLanes: a2, cachePool: null, transitions: null }, b2.updateQueue = null, G$2(fj, gj), gj |= a2, null;
      b2.memoizedState = { baseLanes: 0, cachePool: null, transitions: null };
      d2 = null !== f2 ? f2.baseLanes : c2;
      G$2(fj, gj);
      gj |= d2;
    }
  else
    null !== f2 ? (d2 = f2.baseLanes | c2, b2.memoizedState = null) : d2 = c2, G$2(fj, gj), gj |= d2;
  Yi$1(a2, b2, e2, c2);
  return b2.child;
}
function hj(a2, b2) {
  var c2 = b2.ref;
  if (null === a2 && null !== c2 || null !== a2 && a2.ref !== c2)
    b2.flags |= 512, b2.flags |= 2097152;
}
function dj(a2, b2, c2, d2, e2) {
  var f2 = Zf(c2) ? Xf : H$2.current;
  f2 = Yf(b2, f2);
  Tg(b2, e2);
  c2 = Xh(a2, b2, c2, d2, f2, e2);
  d2 = bi$1();
  if (null !== a2 && !Ug)
    return b2.updateQueue = a2.updateQueue, b2.flags &= -2053, a2.lanes &= ~e2, $i$1(a2, b2, e2);
  I$2 && d2 && vg(b2);
  b2.flags |= 1;
  Yi$1(a2, b2, c2, e2);
  return b2.child;
}
function ij(a2, b2, c2, d2, e2) {
  if (Zf(c2)) {
    var f2 = true;
    cg(b2);
  } else
    f2 = false;
  Tg(b2, e2);
  if (null === b2.stateNode)
    jj(a2, b2), ph(b2, c2, d2), rh(b2, c2, d2, e2), d2 = true;
  else if (null === a2) {
    var g2 = b2.stateNode, h2 = b2.memoizedProps;
    g2.props = h2;
    var k2 = g2.context, l2 = c2.contextType;
    "object" === typeof l2 && null !== l2 ? l2 = Vg(l2) : (l2 = Zf(c2) ? Xf : H$2.current, l2 = Yf(b2, l2));
    var m2 = c2.getDerivedStateFromProps, q2 = "function" === typeof m2 || "function" === typeof g2.getSnapshotBeforeUpdate;
    q2 || "function" !== typeof g2.UNSAFE_componentWillReceiveProps && "function" !== typeof g2.componentWillReceiveProps || (h2 !== d2 || k2 !== l2) && qh(b2, g2, d2, l2);
    $g = false;
    var r2 = b2.memoizedState;
    g2.state = r2;
    gh(b2, d2, g2, e2);
    k2 = b2.memoizedState;
    h2 !== d2 || r2 !== k2 || Wf.current || $g ? ("function" === typeof m2 && (kh(b2, c2, m2, d2), k2 = b2.memoizedState), (h2 = $g || oh(b2, c2, h2, d2, r2, k2, l2)) ? (q2 || "function" !== typeof g2.UNSAFE_componentWillMount && "function" !== typeof g2.componentWillMount || ("function" === typeof g2.componentWillMount && g2.componentWillMount(), "function" === typeof g2.UNSAFE_componentWillMount && g2.UNSAFE_componentWillMount()), "function" === typeof g2.componentDidMount && (b2.flags |= 4194308)) : ("function" === typeof g2.componentDidMount && (b2.flags |= 4194308), b2.memoizedProps = d2, b2.memoizedState = k2), g2.props = d2, g2.state = k2, g2.context = l2, d2 = h2) : ("function" === typeof g2.componentDidMount && (b2.flags |= 4194308), d2 = false);
  } else {
    g2 = b2.stateNode;
    bh(a2, b2);
    h2 = b2.memoizedProps;
    l2 = b2.type === b2.elementType ? h2 : Lg(b2.type, h2);
    g2.props = l2;
    q2 = b2.pendingProps;
    r2 = g2.context;
    k2 = c2.contextType;
    "object" === typeof k2 && null !== k2 ? k2 = Vg(k2) : (k2 = Zf(c2) ? Xf : H$2.current, k2 = Yf(b2, k2));
    var y2 = c2.getDerivedStateFromProps;
    (m2 = "function" === typeof y2 || "function" === typeof g2.getSnapshotBeforeUpdate) || "function" !== typeof g2.UNSAFE_componentWillReceiveProps && "function" !== typeof g2.componentWillReceiveProps || (h2 !== q2 || r2 !== k2) && qh(b2, g2, d2, k2);
    $g = false;
    r2 = b2.memoizedState;
    g2.state = r2;
    gh(b2, d2, g2, e2);
    var n2 = b2.memoizedState;
    h2 !== q2 || r2 !== n2 || Wf.current || $g ? ("function" === typeof y2 && (kh(b2, c2, y2, d2), n2 = b2.memoizedState), (l2 = $g || oh(b2, c2, l2, d2, r2, n2, k2) || false) ? (m2 || "function" !== typeof g2.UNSAFE_componentWillUpdate && "function" !== typeof g2.componentWillUpdate || ("function" === typeof g2.componentWillUpdate && g2.componentWillUpdate(d2, n2, k2), "function" === typeof g2.UNSAFE_componentWillUpdate && g2.UNSAFE_componentWillUpdate(d2, n2, k2)), "function" === typeof g2.componentDidUpdate && (b2.flags |= 4), "function" === typeof g2.getSnapshotBeforeUpdate && (b2.flags |= 1024)) : ("function" !== typeof g2.componentDidUpdate || h2 === a2.memoizedProps && r2 === a2.memoizedState || (b2.flags |= 4), "function" !== typeof g2.getSnapshotBeforeUpdate || h2 === a2.memoizedProps && r2 === a2.memoizedState || (b2.flags |= 1024), b2.memoizedProps = d2, b2.memoizedState = n2), g2.props = d2, g2.state = n2, g2.context = k2, d2 = l2) : ("function" !== typeof g2.componentDidUpdate || h2 === a2.memoizedProps && r2 === a2.memoizedState || (b2.flags |= 4), "function" !== typeof g2.getSnapshotBeforeUpdate || h2 === a2.memoizedProps && r2 === a2.memoizedState || (b2.flags |= 1024), d2 = false);
  }
  return kj(a2, b2, c2, d2, f2, e2);
}
function kj(a2, b2, c2, d2, e2, f2) {
  hj(a2, b2);
  var g2 = 0 !== (b2.flags & 128);
  if (!d2 && !g2)
    return e2 && dg(b2, c2, false), $i$1(a2, b2, f2);
  d2 = b2.stateNode;
  Xi$1.current = b2;
  var h2 = g2 && "function" !== typeof c2.getDerivedStateFromError ? null : d2.render();
  b2.flags |= 1;
  null !== a2 && g2 ? (b2.child = Bh(b2, a2.child, null, f2), b2.child = Bh(b2, null, h2, f2)) : Yi$1(a2, b2, h2, f2);
  b2.memoizedState = d2.state;
  e2 && dg(b2, c2, true);
  return b2.child;
}
function lj(a2) {
  var b2 = a2.stateNode;
  b2.pendingContext ? ag(a2, b2.pendingContext, b2.pendingContext !== b2.context) : b2.context && ag(a2, b2.context, false);
  Ih(a2, b2.containerInfo);
}
function mj(a2, b2, c2, d2, e2) {
  Ig();
  Jg(e2);
  b2.flags |= 256;
  Yi$1(a2, b2, c2, d2);
  return b2.child;
}
var nj = { dehydrated: null, treeContext: null, retryLane: 0 };
function oj(a2) {
  return { baseLanes: a2, cachePool: null, transitions: null };
}
function pj(a2, b2, c2) {
  var d2 = b2.pendingProps, e2 = M$1.current, f2 = false, g2 = 0 !== (b2.flags & 128), h2;
  (h2 = g2) || (h2 = null !== a2 && null === a2.memoizedState ? false : 0 !== (e2 & 2));
  if (h2)
    f2 = true, b2.flags &= -129;
  else if (null === a2 || null !== a2.memoizedState)
    e2 |= 1;
  G$2(M$1, e2 & 1);
  if (null === a2) {
    Eg(b2);
    a2 = b2.memoizedState;
    if (null !== a2 && (a2 = a2.dehydrated, null !== a2))
      return 0 === (b2.mode & 1) ? b2.lanes = 1 : "$!" === a2.data ? b2.lanes = 8 : b2.lanes = 1073741824, null;
    g2 = d2.children;
    a2 = d2.fallback;
    return f2 ? (d2 = b2.mode, f2 = b2.child, g2 = { mode: "hidden", children: g2 }, 0 === (d2 & 1) && null !== f2 ? (f2.childLanes = 0, f2.pendingProps = g2) : f2 = qj(g2, d2, 0, null), a2 = Ah(a2, d2, c2, null), f2.return = b2, a2.return = b2, f2.sibling = a2, b2.child = f2, b2.child.memoizedState = oj(c2), b2.memoizedState = nj, a2) : rj(b2, g2);
  }
  e2 = a2.memoizedState;
  if (null !== e2 && (h2 = e2.dehydrated, null !== h2))
    return sj(a2, b2, g2, d2, h2, e2, c2);
  if (f2) {
    f2 = d2.fallback;
    g2 = b2.mode;
    e2 = a2.child;
    h2 = e2.sibling;
    var k2 = { mode: "hidden", children: d2.children };
    0 === (g2 & 1) && b2.child !== e2 ? (d2 = b2.child, d2.childLanes = 0, d2.pendingProps = k2, b2.deletions = null) : (d2 = wh(e2, k2), d2.subtreeFlags = e2.subtreeFlags & 14680064);
    null !== h2 ? f2 = wh(h2, f2) : (f2 = Ah(f2, g2, c2, null), f2.flags |= 2);
    f2.return = b2;
    d2.return = b2;
    d2.sibling = f2;
    b2.child = d2;
    d2 = f2;
    f2 = b2.child;
    g2 = a2.child.memoizedState;
    g2 = null === g2 ? oj(c2) : { baseLanes: g2.baseLanes | c2, cachePool: null, transitions: g2.transitions };
    f2.memoizedState = g2;
    f2.childLanes = a2.childLanes & ~c2;
    b2.memoizedState = nj;
    return d2;
  }
  f2 = a2.child;
  a2 = f2.sibling;
  d2 = wh(f2, { mode: "visible", children: d2.children });
  0 === (b2.mode & 1) && (d2.lanes = c2);
  d2.return = b2;
  d2.sibling = null;
  null !== a2 && (c2 = b2.deletions, null === c2 ? (b2.deletions = [a2], b2.flags |= 16) : c2.push(a2));
  b2.child = d2;
  b2.memoizedState = null;
  return d2;
}
function rj(a2, b2) {
  b2 = qj({ mode: "visible", children: b2 }, a2.mode, 0, null);
  b2.return = a2;
  return a2.child = b2;
}
function tj(a2, b2, c2, d2) {
  null !== d2 && Jg(d2);
  Bh(b2, a2.child, null, c2);
  a2 = rj(b2, b2.pendingProps.children);
  a2.flags |= 2;
  b2.memoizedState = null;
  return a2;
}
function sj(a2, b2, c2, d2, e2, f2, g2) {
  if (c2) {
    if (b2.flags & 256)
      return b2.flags &= -257, d2 = Li$1(Error(p$3(422))), tj(a2, b2, g2, d2);
    if (null !== b2.memoizedState)
      return b2.child = a2.child, b2.flags |= 128, null;
    f2 = d2.fallback;
    e2 = b2.mode;
    d2 = qj({ mode: "visible", children: d2.children }, e2, 0, null);
    f2 = Ah(f2, e2, g2, null);
    f2.flags |= 2;
    d2.return = b2;
    f2.return = b2;
    d2.sibling = f2;
    b2.child = d2;
    0 !== (b2.mode & 1) && Bh(b2, a2.child, null, g2);
    b2.child.memoizedState = oj(g2);
    b2.memoizedState = nj;
    return f2;
  }
  if (0 === (b2.mode & 1))
    return tj(a2, b2, g2, null);
  if ("$!" === e2.data) {
    d2 = e2.nextSibling && e2.nextSibling.dataset;
    if (d2)
      var h2 = d2.dgst;
    d2 = h2;
    f2 = Error(p$3(419));
    d2 = Li$1(f2, d2, void 0);
    return tj(a2, b2, g2, d2);
  }
  h2 = 0 !== (g2 & a2.childLanes);
  if (Ug || h2) {
    d2 = R$1;
    if (null !== d2) {
      switch (g2 & -g2) {
        case 4:
          e2 = 2;
          break;
        case 16:
          e2 = 8;
          break;
        case 64:
        case 128:
        case 256:
        case 512:
        case 1024:
        case 2048:
        case 4096:
        case 8192:
        case 16384:
        case 32768:
        case 65536:
        case 131072:
        case 262144:
        case 524288:
        case 1048576:
        case 2097152:
        case 4194304:
        case 8388608:
        case 16777216:
        case 33554432:
        case 67108864:
          e2 = 32;
          break;
        case 536870912:
          e2 = 268435456;
          break;
        default:
          e2 = 0;
      }
      e2 = 0 !== (e2 & (d2.suspendedLanes | g2)) ? 0 : e2;
      0 !== e2 && e2 !== f2.retryLane && (f2.retryLane = e2, Zg(a2, e2), mh(d2, a2, e2, -1));
    }
    uj();
    d2 = Li$1(Error(p$3(421)));
    return tj(a2, b2, g2, d2);
  }
  if ("$?" === e2.data)
    return b2.flags |= 128, b2.child = a2.child, b2 = vj.bind(null, a2), e2._reactRetry = b2, null;
  a2 = f2.treeContext;
  yg = Lf(e2.nextSibling);
  xg = b2;
  I$2 = true;
  zg = null;
  null !== a2 && (og[pg++] = rg, og[pg++] = sg, og[pg++] = qg, rg = a2.id, sg = a2.overflow, qg = b2);
  b2 = rj(b2, d2.children);
  b2.flags |= 4096;
  return b2;
}
function wj(a2, b2, c2) {
  a2.lanes |= b2;
  var d2 = a2.alternate;
  null !== d2 && (d2.lanes |= b2);
  Sg(a2.return, b2, c2);
}
function xj(a2, b2, c2, d2, e2) {
  var f2 = a2.memoizedState;
  null === f2 ? a2.memoizedState = { isBackwards: b2, rendering: null, renderingStartTime: 0, last: d2, tail: c2, tailMode: e2 } : (f2.isBackwards = b2, f2.rendering = null, f2.renderingStartTime = 0, f2.last = d2, f2.tail = c2, f2.tailMode = e2);
}
function yj(a2, b2, c2) {
  var d2 = b2.pendingProps, e2 = d2.revealOrder, f2 = d2.tail;
  Yi$1(a2, b2, d2.children, c2);
  d2 = M$1.current;
  if (0 !== (d2 & 2))
    d2 = d2 & 1 | 2, b2.flags |= 128;
  else {
    if (null !== a2 && 0 !== (a2.flags & 128))
      a:
        for (a2 = b2.child; null !== a2; ) {
          if (13 === a2.tag)
            null !== a2.memoizedState && wj(a2, c2, b2);
          else if (19 === a2.tag)
            wj(a2, c2, b2);
          else if (null !== a2.child) {
            a2.child.return = a2;
            a2 = a2.child;
            continue;
          }
          if (a2 === b2)
            break a;
          for (; null === a2.sibling; ) {
            if (null === a2.return || a2.return === b2)
              break a;
            a2 = a2.return;
          }
          a2.sibling.return = a2.return;
          a2 = a2.sibling;
        }
    d2 &= 1;
  }
  G$2(M$1, d2);
  if (0 === (b2.mode & 1))
    b2.memoizedState = null;
  else
    switch (e2) {
      case "forwards":
        c2 = b2.child;
        for (e2 = null; null !== c2; )
          a2 = c2.alternate, null !== a2 && null === Mh(a2) && (e2 = c2), c2 = c2.sibling;
        c2 = e2;
        null === c2 ? (e2 = b2.child, b2.child = null) : (e2 = c2.sibling, c2.sibling = null);
        xj(b2, false, e2, c2, f2);
        break;
      case "backwards":
        c2 = null;
        e2 = b2.child;
        for (b2.child = null; null !== e2; ) {
          a2 = e2.alternate;
          if (null !== a2 && null === Mh(a2)) {
            b2.child = e2;
            break;
          }
          a2 = e2.sibling;
          e2.sibling = c2;
          c2 = e2;
          e2 = a2;
        }
        xj(b2, true, c2, null, f2);
        break;
      case "together":
        xj(b2, false, null, null, void 0);
        break;
      default:
        b2.memoizedState = null;
    }
  return b2.child;
}
function jj(a2, b2) {
  0 === (b2.mode & 1) && null !== a2 && (a2.alternate = null, b2.alternate = null, b2.flags |= 2);
}
function $i$1(a2, b2, c2) {
  null !== a2 && (b2.dependencies = a2.dependencies);
  hh |= b2.lanes;
  if (0 === (c2 & b2.childLanes))
    return null;
  if (null !== a2 && b2.child !== a2.child)
    throw Error(p$3(153));
  if (null !== b2.child) {
    a2 = b2.child;
    c2 = wh(a2, a2.pendingProps);
    b2.child = c2;
    for (c2.return = b2; null !== a2.sibling; )
      a2 = a2.sibling, c2 = c2.sibling = wh(a2, a2.pendingProps), c2.return = b2;
    c2.sibling = null;
  }
  return b2.child;
}
function zj(a2, b2, c2) {
  switch (b2.tag) {
    case 3:
      lj(b2);
      Ig();
      break;
    case 5:
      Kh(b2);
      break;
    case 1:
      Zf(b2.type) && cg(b2);
      break;
    case 4:
      Ih(b2, b2.stateNode.containerInfo);
      break;
    case 10:
      var d2 = b2.type._context, e2 = b2.memoizedProps.value;
      G$2(Mg, d2._currentValue);
      d2._currentValue = e2;
      break;
    case 13:
      d2 = b2.memoizedState;
      if (null !== d2) {
        if (null !== d2.dehydrated)
          return G$2(M$1, M$1.current & 1), b2.flags |= 128, null;
        if (0 !== (c2 & b2.child.childLanes))
          return pj(a2, b2, c2);
        G$2(M$1, M$1.current & 1);
        a2 = $i$1(a2, b2, c2);
        return null !== a2 ? a2.sibling : null;
      }
      G$2(M$1, M$1.current & 1);
      break;
    case 19:
      d2 = 0 !== (c2 & b2.childLanes);
      if (0 !== (a2.flags & 128)) {
        if (d2)
          return yj(a2, b2, c2);
        b2.flags |= 128;
      }
      e2 = b2.memoizedState;
      null !== e2 && (e2.rendering = null, e2.tail = null, e2.lastEffect = null);
      G$2(M$1, M$1.current);
      if (d2)
        break;
      else
        return null;
    case 22:
    case 23:
      return b2.lanes = 0, ej(a2, b2, c2);
  }
  return $i$1(a2, b2, c2);
}
var Aj, Bj, Cj, Dj;
Aj = function(a2, b2) {
  for (var c2 = b2.child; null !== c2; ) {
    if (5 === c2.tag || 6 === c2.tag)
      a2.appendChild(c2.stateNode);
    else if (4 !== c2.tag && null !== c2.child) {
      c2.child.return = c2;
      c2 = c2.child;
      continue;
    }
    if (c2 === b2)
      break;
    for (; null === c2.sibling; ) {
      if (null === c2.return || c2.return === b2)
        return;
      c2 = c2.return;
    }
    c2.sibling.return = c2.return;
    c2 = c2.sibling;
  }
};
Bj = function() {
};
Cj = function(a2, b2, c2, d2) {
  var e2 = a2.memoizedProps;
  if (e2 !== d2) {
    a2 = b2.stateNode;
    Hh(Eh.current);
    var f2 = null;
    switch (c2) {
      case "input":
        e2 = Ya(a2, e2);
        d2 = Ya(a2, d2);
        f2 = [];
        break;
      case "select":
        e2 = A$3({}, e2, { value: void 0 });
        d2 = A$3({}, d2, { value: void 0 });
        f2 = [];
        break;
      case "textarea":
        e2 = gb(a2, e2);
        d2 = gb(a2, d2);
        f2 = [];
        break;
      default:
        "function" !== typeof e2.onClick && "function" === typeof d2.onClick && (a2.onclick = Bf);
    }
    ub(c2, d2);
    var g2;
    c2 = null;
    for (l2 in e2)
      if (!d2.hasOwnProperty(l2) && e2.hasOwnProperty(l2) && null != e2[l2])
        if ("style" === l2) {
          var h2 = e2[l2];
          for (g2 in h2)
            h2.hasOwnProperty(g2) && (c2 || (c2 = {}), c2[g2] = "");
        } else
          "dangerouslySetInnerHTML" !== l2 && "children" !== l2 && "suppressContentEditableWarning" !== l2 && "suppressHydrationWarning" !== l2 && "autoFocus" !== l2 && (ea.hasOwnProperty(l2) ? f2 || (f2 = []) : (f2 = f2 || []).push(l2, null));
    for (l2 in d2) {
      var k2 = d2[l2];
      h2 = null != e2 ? e2[l2] : void 0;
      if (d2.hasOwnProperty(l2) && k2 !== h2 && (null != k2 || null != h2))
        if ("style" === l2)
          if (h2) {
            for (g2 in h2)
              !h2.hasOwnProperty(g2) || k2 && k2.hasOwnProperty(g2) || (c2 || (c2 = {}), c2[g2] = "");
            for (g2 in k2)
              k2.hasOwnProperty(g2) && h2[g2] !== k2[g2] && (c2 || (c2 = {}), c2[g2] = k2[g2]);
          } else
            c2 || (f2 || (f2 = []), f2.push(
              l2,
              c2
            )), c2 = k2;
        else
          "dangerouslySetInnerHTML" === l2 ? (k2 = k2 ? k2.__html : void 0, h2 = h2 ? h2.__html : void 0, null != k2 && h2 !== k2 && (f2 = f2 || []).push(l2, k2)) : "children" === l2 ? "string" !== typeof k2 && "number" !== typeof k2 || (f2 = f2 || []).push(l2, "" + k2) : "suppressContentEditableWarning" !== l2 && "suppressHydrationWarning" !== l2 && (ea.hasOwnProperty(l2) ? (null != k2 && "onScroll" === l2 && D$2("scroll", a2), f2 || h2 === k2 || (f2 = [])) : (f2 = f2 || []).push(l2, k2));
    }
    c2 && (f2 = f2 || []).push("style", c2);
    var l2 = f2;
    if (b2.updateQueue = l2)
      b2.flags |= 4;
  }
};
Dj = function(a2, b2, c2, d2) {
  c2 !== d2 && (b2.flags |= 4);
};
function Ej(a2, b2) {
  if (!I$2)
    switch (a2.tailMode) {
      case "hidden":
        b2 = a2.tail;
        for (var c2 = null; null !== b2; )
          null !== b2.alternate && (c2 = b2), b2 = b2.sibling;
        null === c2 ? a2.tail = null : c2.sibling = null;
        break;
      case "collapsed":
        c2 = a2.tail;
        for (var d2 = null; null !== c2; )
          null !== c2.alternate && (d2 = c2), c2 = c2.sibling;
        null === d2 ? b2 || null === a2.tail ? a2.tail = null : a2.tail.sibling = null : d2.sibling = null;
    }
}
function S$1(a2) {
  var b2 = null !== a2.alternate && a2.alternate.child === a2.child, c2 = 0, d2 = 0;
  if (b2)
    for (var e2 = a2.child; null !== e2; )
      c2 |= e2.lanes | e2.childLanes, d2 |= e2.subtreeFlags & 14680064, d2 |= e2.flags & 14680064, e2.return = a2, e2 = e2.sibling;
  else
    for (e2 = a2.child; null !== e2; )
      c2 |= e2.lanes | e2.childLanes, d2 |= e2.subtreeFlags, d2 |= e2.flags, e2.return = a2, e2 = e2.sibling;
  a2.subtreeFlags |= d2;
  a2.childLanes = c2;
  return b2;
}
function Fj(a2, b2, c2) {
  var d2 = b2.pendingProps;
  wg(b2);
  switch (b2.tag) {
    case 2:
    case 16:
    case 15:
    case 0:
    case 11:
    case 7:
    case 8:
    case 12:
    case 9:
    case 14:
      return S$1(b2), null;
    case 1:
      return Zf(b2.type) && $f(), S$1(b2), null;
    case 3:
      d2 = b2.stateNode;
      Jh();
      E$2(Wf);
      E$2(H$2);
      Oh();
      d2.pendingContext && (d2.context = d2.pendingContext, d2.pendingContext = null);
      if (null === a2 || null === a2.child)
        Gg(b2) ? b2.flags |= 4 : null === a2 || a2.memoizedState.isDehydrated && 0 === (b2.flags & 256) || (b2.flags |= 1024, null !== zg && (Gj(zg), zg = null));
      Bj(a2, b2);
      S$1(b2);
      return null;
    case 5:
      Lh(b2);
      var e2 = Hh(Gh.current);
      c2 = b2.type;
      if (null !== a2 && null != b2.stateNode)
        Cj(a2, b2, c2, d2, e2), a2.ref !== b2.ref && (b2.flags |= 512, b2.flags |= 2097152);
      else {
        if (!d2) {
          if (null === b2.stateNode)
            throw Error(p$3(166));
          S$1(b2);
          return null;
        }
        a2 = Hh(Eh.current);
        if (Gg(b2)) {
          d2 = b2.stateNode;
          c2 = b2.type;
          var f2 = b2.memoizedProps;
          d2[Of] = b2;
          d2[Pf] = f2;
          a2 = 0 !== (b2.mode & 1);
          switch (c2) {
            case "dialog":
              D$2("cancel", d2);
              D$2("close", d2);
              break;
            case "iframe":
            case "object":
            case "embed":
              D$2("load", d2);
              break;
            case "video":
            case "audio":
              for (e2 = 0; e2 < lf.length; e2++)
                D$2(lf[e2], d2);
              break;
            case "source":
              D$2("error", d2);
              break;
            case "img":
            case "image":
            case "link":
              D$2(
                "error",
                d2
              );
              D$2("load", d2);
              break;
            case "details":
              D$2("toggle", d2);
              break;
            case "input":
              Za(d2, f2);
              D$2("invalid", d2);
              break;
            case "select":
              d2._wrapperState = { wasMultiple: !!f2.multiple };
              D$2("invalid", d2);
              break;
            case "textarea":
              hb(d2, f2), D$2("invalid", d2);
          }
          ub(c2, f2);
          e2 = null;
          for (var g2 in f2)
            if (f2.hasOwnProperty(g2)) {
              var h2 = f2[g2];
              "children" === g2 ? "string" === typeof h2 ? d2.textContent !== h2 && (true !== f2.suppressHydrationWarning && Af(d2.textContent, h2, a2), e2 = ["children", h2]) : "number" === typeof h2 && d2.textContent !== "" + h2 && (true !== f2.suppressHydrationWarning && Af(
                d2.textContent,
                h2,
                a2
              ), e2 = ["children", "" + h2]) : ea.hasOwnProperty(g2) && null != h2 && "onScroll" === g2 && D$2("scroll", d2);
            }
          switch (c2) {
            case "input":
              Va(d2);
              db(d2, f2, true);
              break;
            case "textarea":
              Va(d2);
              jb(d2);
              break;
            case "select":
            case "option":
              break;
            default:
              "function" === typeof f2.onClick && (d2.onclick = Bf);
          }
          d2 = e2;
          b2.updateQueue = d2;
          null !== d2 && (b2.flags |= 4);
        } else {
          g2 = 9 === e2.nodeType ? e2 : e2.ownerDocument;
          "http://www.w3.org/1999/xhtml" === a2 && (a2 = kb(c2));
          "http://www.w3.org/1999/xhtml" === a2 ? "script" === c2 ? (a2 = g2.createElement("div"), a2.innerHTML = "<script><\/script>", a2 = a2.removeChild(a2.firstChild)) : "string" === typeof d2.is ? a2 = g2.createElement(c2, { is: d2.is }) : (a2 = g2.createElement(c2), "select" === c2 && (g2 = a2, d2.multiple ? g2.multiple = true : d2.size && (g2.size = d2.size))) : a2 = g2.createElementNS(a2, c2);
          a2[Of] = b2;
          a2[Pf] = d2;
          Aj(a2, b2, false, false);
          b2.stateNode = a2;
          a: {
            g2 = vb(c2, d2);
            switch (c2) {
              case "dialog":
                D$2("cancel", a2);
                D$2("close", a2);
                e2 = d2;
                break;
              case "iframe":
              case "object":
              case "embed":
                D$2("load", a2);
                e2 = d2;
                break;
              case "video":
              case "audio":
                for (e2 = 0; e2 < lf.length; e2++)
                  D$2(lf[e2], a2);
                e2 = d2;
                break;
              case "source":
                D$2("error", a2);
                e2 = d2;
                break;
              case "img":
              case "image":
              case "link":
                D$2(
                  "error",
                  a2
                );
                D$2("load", a2);
                e2 = d2;
                break;
              case "details":
                D$2("toggle", a2);
                e2 = d2;
                break;
              case "input":
                Za(a2, d2);
                e2 = Ya(a2, d2);
                D$2("invalid", a2);
                break;
              case "option":
                e2 = d2;
                break;
              case "select":
                a2._wrapperState = { wasMultiple: !!d2.multiple };
                e2 = A$3({}, d2, { value: void 0 });
                D$2("invalid", a2);
                break;
              case "textarea":
                hb(a2, d2);
                e2 = gb(a2, d2);
                D$2("invalid", a2);
                break;
              default:
                e2 = d2;
            }
            ub(c2, e2);
            h2 = e2;
            for (f2 in h2)
              if (h2.hasOwnProperty(f2)) {
                var k2 = h2[f2];
                "style" === f2 ? sb(a2, k2) : "dangerouslySetInnerHTML" === f2 ? (k2 = k2 ? k2.__html : void 0, null != k2 && nb(a2, k2)) : "children" === f2 ? "string" === typeof k2 ? ("textarea" !== c2 || "" !== k2) && ob(a2, k2) : "number" === typeof k2 && ob(a2, "" + k2) : "suppressContentEditableWarning" !== f2 && "suppressHydrationWarning" !== f2 && "autoFocus" !== f2 && (ea.hasOwnProperty(f2) ? null != k2 && "onScroll" === f2 && D$2("scroll", a2) : null != k2 && ta(a2, f2, k2, g2));
              }
            switch (c2) {
              case "input":
                Va(a2);
                db(a2, d2, false);
                break;
              case "textarea":
                Va(a2);
                jb(a2);
                break;
              case "option":
                null != d2.value && a2.setAttribute("value", "" + Sa(d2.value));
                break;
              case "select":
                a2.multiple = !!d2.multiple;
                f2 = d2.value;
                null != f2 ? fb(a2, !!d2.multiple, f2, false) : null != d2.defaultValue && fb(
                  a2,
                  !!d2.multiple,
                  d2.defaultValue,
                  true
                );
                break;
              default:
                "function" === typeof e2.onClick && (a2.onclick = Bf);
            }
            switch (c2) {
              case "button":
              case "input":
              case "select":
              case "textarea":
                d2 = !!d2.autoFocus;
                break a;
              case "img":
                d2 = true;
                break a;
              default:
                d2 = false;
            }
          }
          d2 && (b2.flags |= 4);
        }
        null !== b2.ref && (b2.flags |= 512, b2.flags |= 2097152);
      }
      S$1(b2);
      return null;
    case 6:
      if (a2 && null != b2.stateNode)
        Dj(a2, b2, a2.memoizedProps, d2);
      else {
        if ("string" !== typeof d2 && null === b2.stateNode)
          throw Error(p$3(166));
        c2 = Hh(Gh.current);
        Hh(Eh.current);
        if (Gg(b2)) {
          d2 = b2.stateNode;
          c2 = b2.memoizedProps;
          d2[Of] = b2;
          if (f2 = d2.nodeValue !== c2) {
            if (a2 = xg, null !== a2)
              switch (a2.tag) {
                case 3:
                  Af(d2.nodeValue, c2, 0 !== (a2.mode & 1));
                  break;
                case 5:
                  true !== a2.memoizedProps.suppressHydrationWarning && Af(d2.nodeValue, c2, 0 !== (a2.mode & 1));
              }
          }
          f2 && (b2.flags |= 4);
        } else
          d2 = (9 === c2.nodeType ? c2 : c2.ownerDocument).createTextNode(d2), d2[Of] = b2, b2.stateNode = d2;
      }
      S$1(b2);
      return null;
    case 13:
      E$2(M$1);
      d2 = b2.memoizedState;
      if (null === a2 || null !== a2.memoizedState && null !== a2.memoizedState.dehydrated) {
        if (I$2 && null !== yg && 0 !== (b2.mode & 1) && 0 === (b2.flags & 128))
          Hg(), Ig(), b2.flags |= 98560, f2 = false;
        else if (f2 = Gg(b2), null !== d2 && null !== d2.dehydrated) {
          if (null === a2) {
            if (!f2)
              throw Error(p$3(318));
            f2 = b2.memoizedState;
            f2 = null !== f2 ? f2.dehydrated : null;
            if (!f2)
              throw Error(p$3(317));
            f2[Of] = b2;
          } else
            Ig(), 0 === (b2.flags & 128) && (b2.memoizedState = null), b2.flags |= 4;
          S$1(b2);
          f2 = false;
        } else
          null !== zg && (Gj(zg), zg = null), f2 = true;
        if (!f2)
          return b2.flags & 65536 ? b2 : null;
      }
      if (0 !== (b2.flags & 128))
        return b2.lanes = c2, b2;
      d2 = null !== d2;
      d2 !== (null !== a2 && null !== a2.memoizedState) && d2 && (b2.child.flags |= 8192, 0 !== (b2.mode & 1) && (null === a2 || 0 !== (M$1.current & 1) ? 0 === T$1 && (T$1 = 3) : uj()));
      null !== b2.updateQueue && (b2.flags |= 4);
      S$1(b2);
      return null;
    case 4:
      return Jh(), Bj(a2, b2), null === a2 && sf(b2.stateNode.containerInfo), S$1(b2), null;
    case 10:
      return Rg(b2.type._context), S$1(b2), null;
    case 17:
      return Zf(b2.type) && $f(), S$1(b2), null;
    case 19:
      E$2(M$1);
      f2 = b2.memoizedState;
      if (null === f2)
        return S$1(b2), null;
      d2 = 0 !== (b2.flags & 128);
      g2 = f2.rendering;
      if (null === g2)
        if (d2)
          Ej(f2, false);
        else {
          if (0 !== T$1 || null !== a2 && 0 !== (a2.flags & 128))
            for (a2 = b2.child; null !== a2; ) {
              g2 = Mh(a2);
              if (null !== g2) {
                b2.flags |= 128;
                Ej(f2, false);
                d2 = g2.updateQueue;
                null !== d2 && (b2.updateQueue = d2, b2.flags |= 4);
                b2.subtreeFlags = 0;
                d2 = c2;
                for (c2 = b2.child; null !== c2; )
                  f2 = c2, a2 = d2, f2.flags &= 14680066, g2 = f2.alternate, null === g2 ? (f2.childLanes = 0, f2.lanes = a2, f2.child = null, f2.subtreeFlags = 0, f2.memoizedProps = null, f2.memoizedState = null, f2.updateQueue = null, f2.dependencies = null, f2.stateNode = null) : (f2.childLanes = g2.childLanes, f2.lanes = g2.lanes, f2.child = g2.child, f2.subtreeFlags = 0, f2.deletions = null, f2.memoizedProps = g2.memoizedProps, f2.memoizedState = g2.memoizedState, f2.updateQueue = g2.updateQueue, f2.type = g2.type, a2 = g2.dependencies, f2.dependencies = null === a2 ? null : { lanes: a2.lanes, firstContext: a2.firstContext }), c2 = c2.sibling;
                G$2(M$1, M$1.current & 1 | 2);
                return b2.child;
              }
              a2 = a2.sibling;
            }
          null !== f2.tail && B$2() > Hj && (b2.flags |= 128, d2 = true, Ej(f2, false), b2.lanes = 4194304);
        }
      else {
        if (!d2)
          if (a2 = Mh(g2), null !== a2) {
            if (b2.flags |= 128, d2 = true, c2 = a2.updateQueue, null !== c2 && (b2.updateQueue = c2, b2.flags |= 4), Ej(f2, true), null === f2.tail && "hidden" === f2.tailMode && !g2.alternate && !I$2)
              return S$1(b2), null;
          } else
            2 * B$2() - f2.renderingStartTime > Hj && 1073741824 !== c2 && (b2.flags |= 128, d2 = true, Ej(f2, false), b2.lanes = 4194304);
        f2.isBackwards ? (g2.sibling = b2.child, b2.child = g2) : (c2 = f2.last, null !== c2 ? c2.sibling = g2 : b2.child = g2, f2.last = g2);
      }
      if (null !== f2.tail)
        return b2 = f2.tail, f2.rendering = b2, f2.tail = b2.sibling, f2.renderingStartTime = B$2(), b2.sibling = null, c2 = M$1.current, G$2(M$1, d2 ? c2 & 1 | 2 : c2 & 1), b2;
      S$1(b2);
      return null;
    case 22:
    case 23:
      return Ij(), d2 = null !== b2.memoizedState, null !== a2 && null !== a2.memoizedState !== d2 && (b2.flags |= 8192), d2 && 0 !== (b2.mode & 1) ? 0 !== (gj & 1073741824) && (S$1(b2), b2.subtreeFlags & 6 && (b2.flags |= 8192)) : S$1(b2), null;
    case 24:
      return null;
    case 25:
      return null;
  }
  throw Error(p$3(156, b2.tag));
}
function Jj(a2, b2) {
  wg(b2);
  switch (b2.tag) {
    case 1:
      return Zf(b2.type) && $f(), a2 = b2.flags, a2 & 65536 ? (b2.flags = a2 & -65537 | 128, b2) : null;
    case 3:
      return Jh(), E$2(Wf), E$2(H$2), Oh(), a2 = b2.flags, 0 !== (a2 & 65536) && 0 === (a2 & 128) ? (b2.flags = a2 & -65537 | 128, b2) : null;
    case 5:
      return Lh(b2), null;
    case 13:
      E$2(M$1);
      a2 = b2.memoizedState;
      if (null !== a2 && null !== a2.dehydrated) {
        if (null === b2.alternate)
          throw Error(p$3(340));
        Ig();
      }
      a2 = b2.flags;
      return a2 & 65536 ? (b2.flags = a2 & -65537 | 128, b2) : null;
    case 19:
      return E$2(M$1), null;
    case 4:
      return Jh(), null;
    case 10:
      return Rg(b2.type._context), null;
    case 22:
    case 23:
      return Ij(), null;
    case 24:
      return null;
    default:
      return null;
  }
}
var Kj = false, U$1 = false, Lj = "function" === typeof WeakSet ? WeakSet : Set, V$1 = null;
function Mj(a2, b2) {
  var c2 = a2.ref;
  if (null !== c2)
    if ("function" === typeof c2)
      try {
        c2(null);
      } catch (d2) {
        W$1(a2, b2, d2);
      }
    else
      c2.current = null;
}
function Nj(a2, b2, c2) {
  try {
    c2();
  } catch (d2) {
    W$1(a2, b2, d2);
  }
}
var Oj = false;
function Pj(a2, b2) {
  Cf = dd;
  a2 = Me$1();
  if (Ne$1(a2)) {
    if ("selectionStart" in a2)
      var c2 = { start: a2.selectionStart, end: a2.selectionEnd };
    else
      a: {
        c2 = (c2 = a2.ownerDocument) && c2.defaultView || window;
        var d2 = c2.getSelection && c2.getSelection();
        if (d2 && 0 !== d2.rangeCount) {
          c2 = d2.anchorNode;
          var e2 = d2.anchorOffset, f2 = d2.focusNode;
          d2 = d2.focusOffset;
          try {
            c2.nodeType, f2.nodeType;
          } catch (F2) {
            c2 = null;
            break a;
          }
          var g2 = 0, h2 = -1, k2 = -1, l2 = 0, m2 = 0, q2 = a2, r2 = null;
          b:
            for (; ; ) {
              for (var y2; ; ) {
                q2 !== c2 || 0 !== e2 && 3 !== q2.nodeType || (h2 = g2 + e2);
                q2 !== f2 || 0 !== d2 && 3 !== q2.nodeType || (k2 = g2 + d2);
                3 === q2.nodeType && (g2 += q2.nodeValue.length);
                if (null === (y2 = q2.firstChild))
                  break;
                r2 = q2;
                q2 = y2;
              }
              for (; ; ) {
                if (q2 === a2)
                  break b;
                r2 === c2 && ++l2 === e2 && (h2 = g2);
                r2 === f2 && ++m2 === d2 && (k2 = g2);
                if (null !== (y2 = q2.nextSibling))
                  break;
                q2 = r2;
                r2 = q2.parentNode;
              }
              q2 = y2;
            }
          c2 = -1 === h2 || -1 === k2 ? null : { start: h2, end: k2 };
        } else
          c2 = null;
      }
    c2 = c2 || { start: 0, end: 0 };
  } else
    c2 = null;
  Df = { focusedElem: a2, selectionRange: c2 };
  dd = false;
  for (V$1 = b2; null !== V$1; )
    if (b2 = V$1, a2 = b2.child, 0 !== (b2.subtreeFlags & 1028) && null !== a2)
      a2.return = b2, V$1 = a2;
    else
      for (; null !== V$1; ) {
        b2 = V$1;
        try {
          var n2 = b2.alternate;
          if (0 !== (b2.flags & 1024))
            switch (b2.tag) {
              case 0:
              case 11:
              case 15:
                break;
              case 1:
                if (null !== n2) {
                  var t2 = n2.memoizedProps, J2 = n2.memoizedState, x = b2.stateNode, w2 = x.getSnapshotBeforeUpdate(b2.elementType === b2.type ? t2 : Lg(b2.type, t2), J2);
                  x.__reactInternalSnapshotBeforeUpdate = w2;
                }
                break;
              case 3:
                var u2 = b2.stateNode.containerInfo;
                1 === u2.nodeType ? u2.textContent = "" : 9 === u2.nodeType && u2.documentElement && u2.removeChild(u2.documentElement);
                break;
              case 5:
              case 6:
              case 4:
              case 17:
                break;
              default:
                throw Error(p$3(163));
            }
        } catch (F2) {
          W$1(b2, b2.return, F2);
        }
        a2 = b2.sibling;
        if (null !== a2) {
          a2.return = b2.return;
          V$1 = a2;
          break;
        }
        V$1 = b2.return;
      }
  n2 = Oj;
  Oj = false;
  return n2;
}
function Qj(a2, b2, c2) {
  var d2 = b2.updateQueue;
  d2 = null !== d2 ? d2.lastEffect : null;
  if (null !== d2) {
    var e2 = d2 = d2.next;
    do {
      if ((e2.tag & a2) === a2) {
        var f2 = e2.destroy;
        e2.destroy = void 0;
        void 0 !== f2 && Nj(b2, c2, f2);
      }
      e2 = e2.next;
    } while (e2 !== d2);
  }
}
function Rj(a2, b2) {
  b2 = b2.updateQueue;
  b2 = null !== b2 ? b2.lastEffect : null;
  if (null !== b2) {
    var c2 = b2 = b2.next;
    do {
      if ((c2.tag & a2) === a2) {
        var d2 = c2.create;
        c2.destroy = d2();
      }
      c2 = c2.next;
    } while (c2 !== b2);
  }
}
function Sj(a2) {
  var b2 = a2.ref;
  if (null !== b2) {
    var c2 = a2.stateNode;
    switch (a2.tag) {
      case 5:
        a2 = c2;
        break;
      default:
        a2 = c2;
    }
    "function" === typeof b2 ? b2(a2) : b2.current = a2;
  }
}
function Tj(a2) {
  var b2 = a2.alternate;
  null !== b2 && (a2.alternate = null, Tj(b2));
  a2.child = null;
  a2.deletions = null;
  a2.sibling = null;
  5 === a2.tag && (b2 = a2.stateNode, null !== b2 && (delete b2[Of], delete b2[Pf], delete b2[of], delete b2[Qf], delete b2[Rf]));
  a2.stateNode = null;
  a2.return = null;
  a2.dependencies = null;
  a2.memoizedProps = null;
  a2.memoizedState = null;
  a2.pendingProps = null;
  a2.stateNode = null;
  a2.updateQueue = null;
}
function Uj(a2) {
  return 5 === a2.tag || 3 === a2.tag || 4 === a2.tag;
}
function Vj(a2) {
  a:
    for (; ; ) {
      for (; null === a2.sibling; ) {
        if (null === a2.return || Uj(a2.return))
          return null;
        a2 = a2.return;
      }
      a2.sibling.return = a2.return;
      for (a2 = a2.sibling; 5 !== a2.tag && 6 !== a2.tag && 18 !== a2.tag; ) {
        if (a2.flags & 2)
          continue a;
        if (null === a2.child || 4 === a2.tag)
          continue a;
        else
          a2.child.return = a2, a2 = a2.child;
      }
      if (!(a2.flags & 2))
        return a2.stateNode;
    }
}
function Wj(a2, b2, c2) {
  var d2 = a2.tag;
  if (5 === d2 || 6 === d2)
    a2 = a2.stateNode, b2 ? 8 === c2.nodeType ? c2.parentNode.insertBefore(a2, b2) : c2.insertBefore(a2, b2) : (8 === c2.nodeType ? (b2 = c2.parentNode, b2.insertBefore(a2, c2)) : (b2 = c2, b2.appendChild(a2)), c2 = c2._reactRootContainer, null !== c2 && void 0 !== c2 || null !== b2.onclick || (b2.onclick = Bf));
  else if (4 !== d2 && (a2 = a2.child, null !== a2))
    for (Wj(a2, b2, c2), a2 = a2.sibling; null !== a2; )
      Wj(a2, b2, c2), a2 = a2.sibling;
}
function Xj(a2, b2, c2) {
  var d2 = a2.tag;
  if (5 === d2 || 6 === d2)
    a2 = a2.stateNode, b2 ? c2.insertBefore(a2, b2) : c2.appendChild(a2);
  else if (4 !== d2 && (a2 = a2.child, null !== a2))
    for (Xj(a2, b2, c2), a2 = a2.sibling; null !== a2; )
      Xj(a2, b2, c2), a2 = a2.sibling;
}
var X$1 = null, Yj = false;
function Zj(a2, b2, c2) {
  for (c2 = c2.child; null !== c2; )
    ak(a2, b2, c2), c2 = c2.sibling;
}
function ak(a2, b2, c2) {
  if (lc && "function" === typeof lc.onCommitFiberUnmount)
    try {
      lc.onCommitFiberUnmount(kc, c2);
    } catch (h2) {
    }
  switch (c2.tag) {
    case 5:
      U$1 || Mj(c2, b2);
    case 6:
      var d2 = X$1, e2 = Yj;
      X$1 = null;
      Zj(a2, b2, c2);
      X$1 = d2;
      Yj = e2;
      null !== X$1 && (Yj ? (a2 = X$1, c2 = c2.stateNode, 8 === a2.nodeType ? a2.parentNode.removeChild(c2) : a2.removeChild(c2)) : X$1.removeChild(c2.stateNode));
      break;
    case 18:
      null !== X$1 && (Yj ? (a2 = X$1, c2 = c2.stateNode, 8 === a2.nodeType ? Kf(a2.parentNode, c2) : 1 === a2.nodeType && Kf(a2, c2), bd(a2)) : Kf(X$1, c2.stateNode));
      break;
    case 4:
      d2 = X$1;
      e2 = Yj;
      X$1 = c2.stateNode.containerInfo;
      Yj = true;
      Zj(a2, b2, c2);
      X$1 = d2;
      Yj = e2;
      break;
    case 0:
    case 11:
    case 14:
    case 15:
      if (!U$1 && (d2 = c2.updateQueue, null !== d2 && (d2 = d2.lastEffect, null !== d2))) {
        e2 = d2 = d2.next;
        do {
          var f2 = e2, g2 = f2.destroy;
          f2 = f2.tag;
          void 0 !== g2 && (0 !== (f2 & 2) ? Nj(c2, b2, g2) : 0 !== (f2 & 4) && Nj(c2, b2, g2));
          e2 = e2.next;
        } while (e2 !== d2);
      }
      Zj(a2, b2, c2);
      break;
    case 1:
      if (!U$1 && (Mj(c2, b2), d2 = c2.stateNode, "function" === typeof d2.componentWillUnmount))
        try {
          d2.props = c2.memoizedProps, d2.state = c2.memoizedState, d2.componentWillUnmount();
        } catch (h2) {
          W$1(c2, b2, h2);
        }
      Zj(a2, b2, c2);
      break;
    case 21:
      Zj(a2, b2, c2);
      break;
    case 22:
      c2.mode & 1 ? (U$1 = (d2 = U$1) || null !== c2.memoizedState, Zj(a2, b2, c2), U$1 = d2) : Zj(a2, b2, c2);
      break;
    default:
      Zj(a2, b2, c2);
  }
}
function bk(a2) {
  var b2 = a2.updateQueue;
  if (null !== b2) {
    a2.updateQueue = null;
    var c2 = a2.stateNode;
    null === c2 && (c2 = a2.stateNode = new Lj());
    b2.forEach(function(b3) {
      var d2 = ck.bind(null, a2, b3);
      c2.has(b3) || (c2.add(b3), b3.then(d2, d2));
    });
  }
}
function dk(a2, b2) {
  var c2 = b2.deletions;
  if (null !== c2)
    for (var d2 = 0; d2 < c2.length; d2++) {
      var e2 = c2[d2];
      try {
        var f2 = a2, g2 = b2, h2 = g2;
        a:
          for (; null !== h2; ) {
            switch (h2.tag) {
              case 5:
                X$1 = h2.stateNode;
                Yj = false;
                break a;
              case 3:
                X$1 = h2.stateNode.containerInfo;
                Yj = true;
                break a;
              case 4:
                X$1 = h2.stateNode.containerInfo;
                Yj = true;
                break a;
            }
            h2 = h2.return;
          }
        if (null === X$1)
          throw Error(p$3(160));
        ak(f2, g2, e2);
        X$1 = null;
        Yj = false;
        var k2 = e2.alternate;
        null !== k2 && (k2.return = null);
        e2.return = null;
      } catch (l2) {
        W$1(e2, b2, l2);
      }
    }
  if (b2.subtreeFlags & 12854)
    for (b2 = b2.child; null !== b2; )
      ek(b2, a2), b2 = b2.sibling;
}
function ek(a2, b2) {
  var c2 = a2.alternate, d2 = a2.flags;
  switch (a2.tag) {
    case 0:
    case 11:
    case 14:
    case 15:
      dk(b2, a2);
      fk(a2);
      if (d2 & 4) {
        try {
          Qj(3, a2, a2.return), Rj(3, a2);
        } catch (t2) {
          W$1(a2, a2.return, t2);
        }
        try {
          Qj(5, a2, a2.return);
        } catch (t2) {
          W$1(a2, a2.return, t2);
        }
      }
      break;
    case 1:
      dk(b2, a2);
      fk(a2);
      d2 & 512 && null !== c2 && Mj(c2, c2.return);
      break;
    case 5:
      dk(b2, a2);
      fk(a2);
      d2 & 512 && null !== c2 && Mj(c2, c2.return);
      if (a2.flags & 32) {
        var e2 = a2.stateNode;
        try {
          ob(e2, "");
        } catch (t2) {
          W$1(a2, a2.return, t2);
        }
      }
      if (d2 & 4 && (e2 = a2.stateNode, null != e2)) {
        var f2 = a2.memoizedProps, g2 = null !== c2 ? c2.memoizedProps : f2, h2 = a2.type, k2 = a2.updateQueue;
        a2.updateQueue = null;
        if (null !== k2)
          try {
            "input" === h2 && "radio" === f2.type && null != f2.name && ab(e2, f2);
            vb(h2, g2);
            var l2 = vb(h2, f2);
            for (g2 = 0; g2 < k2.length; g2 += 2) {
              var m2 = k2[g2], q2 = k2[g2 + 1];
              "style" === m2 ? sb(e2, q2) : "dangerouslySetInnerHTML" === m2 ? nb(e2, q2) : "children" === m2 ? ob(e2, q2) : ta(e2, m2, q2, l2);
            }
            switch (h2) {
              case "input":
                bb(e2, f2);
                break;
              case "textarea":
                ib(e2, f2);
                break;
              case "select":
                var r2 = e2._wrapperState.wasMultiple;
                e2._wrapperState.wasMultiple = !!f2.multiple;
                var y2 = f2.value;
                null != y2 ? fb(e2, !!f2.multiple, y2, false) : r2 !== !!f2.multiple && (null != f2.defaultValue ? fb(
                  e2,
                  !!f2.multiple,
                  f2.defaultValue,
                  true
                ) : fb(e2, !!f2.multiple, f2.multiple ? [] : "", false));
            }
            e2[Pf] = f2;
          } catch (t2) {
            W$1(a2, a2.return, t2);
          }
      }
      break;
    case 6:
      dk(b2, a2);
      fk(a2);
      if (d2 & 4) {
        if (null === a2.stateNode)
          throw Error(p$3(162));
        e2 = a2.stateNode;
        f2 = a2.memoizedProps;
        try {
          e2.nodeValue = f2;
        } catch (t2) {
          W$1(a2, a2.return, t2);
        }
      }
      break;
    case 3:
      dk(b2, a2);
      fk(a2);
      if (d2 & 4 && null !== c2 && c2.memoizedState.isDehydrated)
        try {
          bd(b2.containerInfo);
        } catch (t2) {
          W$1(a2, a2.return, t2);
        }
      break;
    case 4:
      dk(b2, a2);
      fk(a2);
      break;
    case 13:
      dk(b2, a2);
      fk(a2);
      e2 = a2.child;
      e2.flags & 8192 && (f2 = null !== e2.memoizedState, e2.stateNode.isHidden = f2, !f2 || null !== e2.alternate && null !== e2.alternate.memoizedState || (gk = B$2()));
      d2 & 4 && bk(a2);
      break;
    case 22:
      m2 = null !== c2 && null !== c2.memoizedState;
      a2.mode & 1 ? (U$1 = (l2 = U$1) || m2, dk(b2, a2), U$1 = l2) : dk(b2, a2);
      fk(a2);
      if (d2 & 8192) {
        l2 = null !== a2.memoizedState;
        if ((a2.stateNode.isHidden = l2) && !m2 && 0 !== (a2.mode & 1))
          for (V$1 = a2, m2 = a2.child; null !== m2; ) {
            for (q2 = V$1 = m2; null !== V$1; ) {
              r2 = V$1;
              y2 = r2.child;
              switch (r2.tag) {
                case 0:
                case 11:
                case 14:
                case 15:
                  Qj(4, r2, r2.return);
                  break;
                case 1:
                  Mj(r2, r2.return);
                  var n2 = r2.stateNode;
                  if ("function" === typeof n2.componentWillUnmount) {
                    d2 = r2;
                    c2 = r2.return;
                    try {
                      b2 = d2, n2.props = b2.memoizedProps, n2.state = b2.memoizedState, n2.componentWillUnmount();
                    } catch (t2) {
                      W$1(d2, c2, t2);
                    }
                  }
                  break;
                case 5:
                  Mj(r2, r2.return);
                  break;
                case 22:
                  if (null !== r2.memoizedState) {
                    hk(q2);
                    continue;
                  }
              }
              null !== y2 ? (y2.return = r2, V$1 = y2) : hk(q2);
            }
            m2 = m2.sibling;
          }
        a:
          for (m2 = null, q2 = a2; ; ) {
            if (5 === q2.tag) {
              if (null === m2) {
                m2 = q2;
                try {
                  e2 = q2.stateNode, l2 ? (f2 = e2.style, "function" === typeof f2.setProperty ? f2.setProperty("display", "none", "important") : f2.display = "none") : (h2 = q2.stateNode, k2 = q2.memoizedProps.style, g2 = void 0 !== k2 && null !== k2 && k2.hasOwnProperty("display") ? k2.display : null, h2.style.display = rb("display", g2));
                } catch (t2) {
                  W$1(a2, a2.return, t2);
                }
              }
            } else if (6 === q2.tag) {
              if (null === m2)
                try {
                  q2.stateNode.nodeValue = l2 ? "" : q2.memoizedProps;
                } catch (t2) {
                  W$1(a2, a2.return, t2);
                }
            } else if ((22 !== q2.tag && 23 !== q2.tag || null === q2.memoizedState || q2 === a2) && null !== q2.child) {
              q2.child.return = q2;
              q2 = q2.child;
              continue;
            }
            if (q2 === a2)
              break a;
            for (; null === q2.sibling; ) {
              if (null === q2.return || q2.return === a2)
                break a;
              m2 === q2 && (m2 = null);
              q2 = q2.return;
            }
            m2 === q2 && (m2 = null);
            q2.sibling.return = q2.return;
            q2 = q2.sibling;
          }
      }
      break;
    case 19:
      dk(b2, a2);
      fk(a2);
      d2 & 4 && bk(a2);
      break;
    case 21:
      break;
    default:
      dk(
        b2,
        a2
      ), fk(a2);
  }
}
function fk(a2) {
  var b2 = a2.flags;
  if (b2 & 2) {
    try {
      a: {
        for (var c2 = a2.return; null !== c2; ) {
          if (Uj(c2)) {
            var d2 = c2;
            break a;
          }
          c2 = c2.return;
        }
        throw Error(p$3(160));
      }
      switch (d2.tag) {
        case 5:
          var e2 = d2.stateNode;
          d2.flags & 32 && (ob(e2, ""), d2.flags &= -33);
          var f2 = Vj(a2);
          Xj(a2, f2, e2);
          break;
        case 3:
        case 4:
          var g2 = d2.stateNode.containerInfo, h2 = Vj(a2);
          Wj(a2, h2, g2);
          break;
        default:
          throw Error(p$3(161));
      }
    } catch (k2) {
      W$1(a2, a2.return, k2);
    }
    a2.flags &= -3;
  }
  b2 & 4096 && (a2.flags &= -4097);
}
function ik(a2, b2, c2) {
  V$1 = a2;
  jk(a2);
}
function jk(a2, b2, c2) {
  for (var d2 = 0 !== (a2.mode & 1); null !== V$1; ) {
    var e2 = V$1, f2 = e2.child;
    if (22 === e2.tag && d2) {
      var g2 = null !== e2.memoizedState || Kj;
      if (!g2) {
        var h2 = e2.alternate, k2 = null !== h2 && null !== h2.memoizedState || U$1;
        h2 = Kj;
        var l2 = U$1;
        Kj = g2;
        if ((U$1 = k2) && !l2)
          for (V$1 = e2; null !== V$1; )
            g2 = V$1, k2 = g2.child, 22 === g2.tag && null !== g2.memoizedState ? kk(e2) : null !== k2 ? (k2.return = g2, V$1 = k2) : kk(e2);
        for (; null !== f2; )
          V$1 = f2, jk(f2), f2 = f2.sibling;
        V$1 = e2;
        Kj = h2;
        U$1 = l2;
      }
      lk(a2);
    } else
      0 !== (e2.subtreeFlags & 8772) && null !== f2 ? (f2.return = e2, V$1 = f2) : lk(a2);
  }
}
function lk(a2) {
  for (; null !== V$1; ) {
    var b2 = V$1;
    if (0 !== (b2.flags & 8772)) {
      var c2 = b2.alternate;
      try {
        if (0 !== (b2.flags & 8772))
          switch (b2.tag) {
            case 0:
            case 11:
            case 15:
              U$1 || Rj(5, b2);
              break;
            case 1:
              var d2 = b2.stateNode;
              if (b2.flags & 4 && !U$1)
                if (null === c2)
                  d2.componentDidMount();
                else {
                  var e2 = b2.elementType === b2.type ? c2.memoizedProps : Lg(b2.type, c2.memoizedProps);
                  d2.componentDidUpdate(e2, c2.memoizedState, d2.__reactInternalSnapshotBeforeUpdate);
                }
              var f2 = b2.updateQueue;
              null !== f2 && ih(b2, f2, d2);
              break;
            case 3:
              var g2 = b2.updateQueue;
              if (null !== g2) {
                c2 = null;
                if (null !== b2.child)
                  switch (b2.child.tag) {
                    case 5:
                      c2 = b2.child.stateNode;
                      break;
                    case 1:
                      c2 = b2.child.stateNode;
                  }
                ih(b2, g2, c2);
              }
              break;
            case 5:
              var h2 = b2.stateNode;
              if (null === c2 && b2.flags & 4) {
                c2 = h2;
                var k2 = b2.memoizedProps;
                switch (b2.type) {
                  case "button":
                  case "input":
                  case "select":
                  case "textarea":
                    k2.autoFocus && c2.focus();
                    break;
                  case "img":
                    k2.src && (c2.src = k2.src);
                }
              }
              break;
            case 6:
              break;
            case 4:
              break;
            case 12:
              break;
            case 13:
              if (null === b2.memoizedState) {
                var l2 = b2.alternate;
                if (null !== l2) {
                  var m2 = l2.memoizedState;
                  if (null !== m2) {
                    var q2 = m2.dehydrated;
                    null !== q2 && bd(q2);
                  }
                }
              }
              break;
            case 19:
            case 17:
            case 21:
            case 22:
            case 23:
            case 25:
              break;
            default:
              throw Error(p$3(163));
          }
        U$1 || b2.flags & 512 && Sj(b2);
      } catch (r2) {
        W$1(b2, b2.return, r2);
      }
    }
    if (b2 === a2) {
      V$1 = null;
      break;
    }
    c2 = b2.sibling;
    if (null !== c2) {
      c2.return = b2.return;
      V$1 = c2;
      break;
    }
    V$1 = b2.return;
  }
}
function hk(a2) {
  for (; null !== V$1; ) {
    var b2 = V$1;
    if (b2 === a2) {
      V$1 = null;
      break;
    }
    var c2 = b2.sibling;
    if (null !== c2) {
      c2.return = b2.return;
      V$1 = c2;
      break;
    }
    V$1 = b2.return;
  }
}
function kk(a2) {
  for (; null !== V$1; ) {
    var b2 = V$1;
    try {
      switch (b2.tag) {
        case 0:
        case 11:
        case 15:
          var c2 = b2.return;
          try {
            Rj(4, b2);
          } catch (k2) {
            W$1(b2, c2, k2);
          }
          break;
        case 1:
          var d2 = b2.stateNode;
          if ("function" === typeof d2.componentDidMount) {
            var e2 = b2.return;
            try {
              d2.componentDidMount();
            } catch (k2) {
              W$1(b2, e2, k2);
            }
          }
          var f2 = b2.return;
          try {
            Sj(b2);
          } catch (k2) {
            W$1(b2, f2, k2);
          }
          break;
        case 5:
          var g2 = b2.return;
          try {
            Sj(b2);
          } catch (k2) {
            W$1(b2, g2, k2);
          }
      }
    } catch (k2) {
      W$1(b2, b2.return, k2);
    }
    if (b2 === a2) {
      V$1 = null;
      break;
    }
    var h2 = b2.sibling;
    if (null !== h2) {
      h2.return = b2.return;
      V$1 = h2;
      break;
    }
    V$1 = b2.return;
  }
}
var mk = Math.ceil, nk = ua.ReactCurrentDispatcher, ok = ua.ReactCurrentOwner, pk = ua.ReactCurrentBatchConfig, K$1 = 0, R$1 = null, Y$1 = null, Z$1 = 0, gj = 0, fj = Uf(0), T$1 = 0, qk = null, hh = 0, rk = 0, sk = 0, tk = null, uk = null, gk = 0, Hj = Infinity, vk = null, Pi$1 = false, Qi$1 = null, Si$1 = null, wk = false, xk = null, yk = 0, zk = 0, Ak = null, Bk = -1, Ck = 0;
function L$1() {
  return 0 !== (K$1 & 6) ? B$2() : -1 !== Bk ? Bk : Bk = B$2();
}
function lh(a2) {
  if (0 === (a2.mode & 1))
    return 1;
  if (0 !== (K$1 & 2) && 0 !== Z$1)
    return Z$1 & -Z$1;
  if (null !== Kg.transition)
    return 0 === Ck && (Ck = yc()), Ck;
  a2 = C$2;
  if (0 !== a2)
    return a2;
  a2 = window.event;
  a2 = void 0 === a2 ? 16 : jd(a2.type);
  return a2;
}
function mh(a2, b2, c2, d2) {
  if (50 < zk)
    throw zk = 0, Ak = null, Error(p$3(185));
  Ac(a2, c2, d2);
  if (0 === (K$1 & 2) || a2 !== R$1)
    a2 === R$1 && (0 === (K$1 & 2) && (rk |= c2), 4 === T$1 && Dk(a2, Z$1)), Ek(a2, d2), 1 === c2 && 0 === K$1 && 0 === (b2.mode & 1) && (Hj = B$2() + 500, fg && jg());
}
function Ek(a2, b2) {
  var c2 = a2.callbackNode;
  wc(a2, b2);
  var d2 = uc(a2, a2 === R$1 ? Z$1 : 0);
  if (0 === d2)
    null !== c2 && bc(c2), a2.callbackNode = null, a2.callbackPriority = 0;
  else if (b2 = d2 & -d2, a2.callbackPriority !== b2) {
    null != c2 && bc(c2);
    if (1 === b2)
      0 === a2.tag ? ig(Fk.bind(null, a2)) : hg(Fk.bind(null, a2)), Jf(function() {
        0 === (K$1 & 6) && jg();
      }), c2 = null;
    else {
      switch (Dc(d2)) {
        case 1:
          c2 = fc;
          break;
        case 4:
          c2 = gc;
          break;
        case 16:
          c2 = hc;
          break;
        case 536870912:
          c2 = jc;
          break;
        default:
          c2 = hc;
      }
      c2 = Gk(c2, Hk.bind(null, a2));
    }
    a2.callbackPriority = b2;
    a2.callbackNode = c2;
  }
}
function Hk(a2, b2) {
  Bk = -1;
  Ck = 0;
  if (0 !== (K$1 & 6))
    throw Error(p$3(327));
  var c2 = a2.callbackNode;
  if (Ik() && a2.callbackNode !== c2)
    return null;
  var d2 = uc(a2, a2 === R$1 ? Z$1 : 0);
  if (0 === d2)
    return null;
  if (0 !== (d2 & 30) || 0 !== (d2 & a2.expiredLanes) || b2)
    b2 = Jk(a2, d2);
  else {
    b2 = d2;
    var e2 = K$1;
    K$1 |= 2;
    var f2 = Kk();
    if (R$1 !== a2 || Z$1 !== b2)
      vk = null, Hj = B$2() + 500, Lk(a2, b2);
    do
      try {
        Mk();
        break;
      } catch (h2) {
        Nk(a2, h2);
      }
    while (1);
    Qg();
    nk.current = f2;
    K$1 = e2;
    null !== Y$1 ? b2 = 0 : (R$1 = null, Z$1 = 0, b2 = T$1);
  }
  if (0 !== b2) {
    2 === b2 && (e2 = xc(a2), 0 !== e2 && (d2 = e2, b2 = Ok(a2, e2)));
    if (1 === b2)
      throw c2 = qk, Lk(a2, 0), Dk(a2, d2), Ek(a2, B$2()), c2;
    if (6 === b2)
      Dk(a2, d2);
    else {
      e2 = a2.current.alternate;
      if (0 === (d2 & 30) && !Pk(e2) && (b2 = Jk(a2, d2), 2 === b2 && (f2 = xc(a2), 0 !== f2 && (d2 = f2, b2 = Ok(a2, f2))), 1 === b2))
        throw c2 = qk, Lk(a2, 0), Dk(a2, d2), Ek(a2, B$2()), c2;
      a2.finishedWork = e2;
      a2.finishedLanes = d2;
      switch (b2) {
        case 0:
        case 1:
          throw Error(p$3(345));
        case 2:
          Qk(a2, uk, vk);
          break;
        case 3:
          Dk(a2, d2);
          if ((d2 & 130023424) === d2 && (b2 = gk + 500 - B$2(), 10 < b2)) {
            if (0 !== uc(a2, 0))
              break;
            e2 = a2.suspendedLanes;
            if ((e2 & d2) !== d2) {
              L$1();
              a2.pingedLanes |= a2.suspendedLanes & e2;
              break;
            }
            a2.timeoutHandle = Ff(Qk.bind(null, a2, uk, vk), b2);
            break;
          }
          Qk(a2, uk, vk);
          break;
        case 4:
          Dk(a2, d2);
          if ((d2 & 4194240) === d2)
            break;
          b2 = a2.eventTimes;
          for (e2 = -1; 0 < d2; ) {
            var g2 = 31 - oc(d2);
            f2 = 1 << g2;
            g2 = b2[g2];
            g2 > e2 && (e2 = g2);
            d2 &= ~f2;
          }
          d2 = e2;
          d2 = B$2() - d2;
          d2 = (120 > d2 ? 120 : 480 > d2 ? 480 : 1080 > d2 ? 1080 : 1920 > d2 ? 1920 : 3e3 > d2 ? 3e3 : 4320 > d2 ? 4320 : 1960 * mk(d2 / 1960)) - d2;
          if (10 < d2) {
            a2.timeoutHandle = Ff(Qk.bind(null, a2, uk, vk), d2);
            break;
          }
          Qk(a2, uk, vk);
          break;
        case 5:
          Qk(a2, uk, vk);
          break;
        default:
          throw Error(p$3(329));
      }
    }
  }
  Ek(a2, B$2());
  return a2.callbackNode === c2 ? Hk.bind(null, a2) : null;
}
function Ok(a2, b2) {
  var c2 = tk;
  a2.current.memoizedState.isDehydrated && (Lk(a2, b2).flags |= 256);
  a2 = Jk(a2, b2);
  2 !== a2 && (b2 = uk, uk = c2, null !== b2 && Gj(b2));
  return a2;
}
function Gj(a2) {
  null === uk ? uk = a2 : uk.push.apply(uk, a2);
}
function Pk(a2) {
  for (var b2 = a2; ; ) {
    if (b2.flags & 16384) {
      var c2 = b2.updateQueue;
      if (null !== c2 && (c2 = c2.stores, null !== c2))
        for (var d2 = 0; d2 < c2.length; d2++) {
          var e2 = c2[d2], f2 = e2.getSnapshot;
          e2 = e2.value;
          try {
            if (!He$1(f2(), e2))
              return false;
          } catch (g2) {
            return false;
          }
        }
    }
    c2 = b2.child;
    if (b2.subtreeFlags & 16384 && null !== c2)
      c2.return = b2, b2 = c2;
    else {
      if (b2 === a2)
        break;
      for (; null === b2.sibling; ) {
        if (null === b2.return || b2.return === a2)
          return true;
        b2 = b2.return;
      }
      b2.sibling.return = b2.return;
      b2 = b2.sibling;
    }
  }
  return true;
}
function Dk(a2, b2) {
  b2 &= ~sk;
  b2 &= ~rk;
  a2.suspendedLanes |= b2;
  a2.pingedLanes &= ~b2;
  for (a2 = a2.expirationTimes; 0 < b2; ) {
    var c2 = 31 - oc(b2), d2 = 1 << c2;
    a2[c2] = -1;
    b2 &= ~d2;
  }
}
function Fk(a2) {
  if (0 !== (K$1 & 6))
    throw Error(p$3(327));
  Ik();
  var b2 = uc(a2, 0);
  if (0 === (b2 & 1))
    return Ek(a2, B$2()), null;
  var c2 = Jk(a2, b2);
  if (0 !== a2.tag && 2 === c2) {
    var d2 = xc(a2);
    0 !== d2 && (b2 = d2, c2 = Ok(a2, d2));
  }
  if (1 === c2)
    throw c2 = qk, Lk(a2, 0), Dk(a2, b2), Ek(a2, B$2()), c2;
  if (6 === c2)
    throw Error(p$3(345));
  a2.finishedWork = a2.current.alternate;
  a2.finishedLanes = b2;
  Qk(a2, uk, vk);
  Ek(a2, B$2());
  return null;
}
function Rk(a2, b2) {
  var c2 = K$1;
  K$1 |= 1;
  try {
    return a2(b2);
  } finally {
    K$1 = c2, 0 === K$1 && (Hj = B$2() + 500, fg && jg());
  }
}
function Sk(a2) {
  null !== xk && 0 === xk.tag && 0 === (K$1 & 6) && Ik();
  var b2 = K$1;
  K$1 |= 1;
  var c2 = pk.transition, d2 = C$2;
  try {
    if (pk.transition = null, C$2 = 1, a2)
      return a2();
  } finally {
    C$2 = d2, pk.transition = c2, K$1 = b2, 0 === (K$1 & 6) && jg();
  }
}
function Ij() {
  gj = fj.current;
  E$2(fj);
}
function Lk(a2, b2) {
  a2.finishedWork = null;
  a2.finishedLanes = 0;
  var c2 = a2.timeoutHandle;
  -1 !== c2 && (a2.timeoutHandle = -1, Gf(c2));
  if (null !== Y$1)
    for (c2 = Y$1.return; null !== c2; ) {
      var d2 = c2;
      wg(d2);
      switch (d2.tag) {
        case 1:
          d2 = d2.type.childContextTypes;
          null !== d2 && void 0 !== d2 && $f();
          break;
        case 3:
          Jh();
          E$2(Wf);
          E$2(H$2);
          Oh();
          break;
        case 5:
          Lh(d2);
          break;
        case 4:
          Jh();
          break;
        case 13:
          E$2(M$1);
          break;
        case 19:
          E$2(M$1);
          break;
        case 10:
          Rg(d2.type._context);
          break;
        case 22:
        case 23:
          Ij();
      }
      c2 = c2.return;
    }
  R$1 = a2;
  Y$1 = a2 = wh(a2.current, null);
  Z$1 = gj = b2;
  T$1 = 0;
  qk = null;
  sk = rk = hh = 0;
  uk = tk = null;
  if (null !== Wg) {
    for (b2 = 0; b2 < Wg.length; b2++)
      if (c2 = Wg[b2], d2 = c2.interleaved, null !== d2) {
        c2.interleaved = null;
        var e2 = d2.next, f2 = c2.pending;
        if (null !== f2) {
          var g2 = f2.next;
          f2.next = e2;
          d2.next = g2;
        }
        c2.pending = d2;
      }
    Wg = null;
  }
  return a2;
}
function Nk(a2, b2) {
  do {
    var c2 = Y$1;
    try {
      Qg();
      Ph.current = ai$1;
      if (Sh) {
        for (var d2 = N$1.memoizedState; null !== d2; ) {
          var e2 = d2.queue;
          null !== e2 && (e2.pending = null);
          d2 = d2.next;
        }
        Sh = false;
      }
      Rh = 0;
      P$1 = O$1 = N$1 = null;
      Th = false;
      Uh = 0;
      ok.current = null;
      if (null === c2 || null === c2.return) {
        T$1 = 1;
        qk = b2;
        Y$1 = null;
        break;
      }
      a: {
        var f2 = a2, g2 = c2.return, h2 = c2, k2 = b2;
        b2 = Z$1;
        h2.flags |= 32768;
        if (null !== k2 && "object" === typeof k2 && "function" === typeof k2.then) {
          var l2 = k2, m2 = h2, q2 = m2.tag;
          if (0 === (m2.mode & 1) && (0 === q2 || 11 === q2 || 15 === q2)) {
            var r2 = m2.alternate;
            r2 ? (m2.updateQueue = r2.updateQueue, m2.memoizedState = r2.memoizedState, m2.lanes = r2.lanes) : (m2.updateQueue = null, m2.memoizedState = null);
          }
          var y2 = Vi$1(g2);
          if (null !== y2) {
            y2.flags &= -257;
            Wi$1(y2, g2, h2, f2, b2);
            y2.mode & 1 && Ti$1(f2, l2, b2);
            b2 = y2;
            k2 = l2;
            var n2 = b2.updateQueue;
            if (null === n2) {
              var t2 = /* @__PURE__ */ new Set();
              t2.add(k2);
              b2.updateQueue = t2;
            } else
              n2.add(k2);
            break a;
          } else {
            if (0 === (b2 & 1)) {
              Ti$1(f2, l2, b2);
              uj();
              break a;
            }
            k2 = Error(p$3(426));
          }
        } else if (I$2 && h2.mode & 1) {
          var J2 = Vi$1(g2);
          if (null !== J2) {
            0 === (J2.flags & 65536) && (J2.flags |= 256);
            Wi$1(J2, g2, h2, f2, b2);
            Jg(Ki$1(k2, h2));
            break a;
          }
        }
        f2 = k2 = Ki$1(k2, h2);
        4 !== T$1 && (T$1 = 2);
        null === tk ? tk = [f2] : tk.push(f2);
        f2 = g2;
        do {
          switch (f2.tag) {
            case 3:
              f2.flags |= 65536;
              b2 &= -b2;
              f2.lanes |= b2;
              var x = Oi$1(f2, k2, b2);
              fh(f2, x);
              break a;
            case 1:
              h2 = k2;
              var w2 = f2.type, u2 = f2.stateNode;
              if (0 === (f2.flags & 128) && ("function" === typeof w2.getDerivedStateFromError || null !== u2 && "function" === typeof u2.componentDidCatch && (null === Si$1 || !Si$1.has(u2)))) {
                f2.flags |= 65536;
                b2 &= -b2;
                f2.lanes |= b2;
                var F2 = Ri$1(f2, h2, b2);
                fh(f2, F2);
                break a;
              }
          }
          f2 = f2.return;
        } while (null !== f2);
      }
      Tk(c2);
    } catch (na) {
      b2 = na;
      Y$1 === c2 && null !== c2 && (Y$1 = c2 = c2.return);
      continue;
    }
    break;
  } while (1);
}
function Kk() {
  var a2 = nk.current;
  nk.current = ai$1;
  return null === a2 ? ai$1 : a2;
}
function uj() {
  if (0 === T$1 || 3 === T$1 || 2 === T$1)
    T$1 = 4;
  null === R$1 || 0 === (hh & 268435455) && 0 === (rk & 268435455) || Dk(R$1, Z$1);
}
function Jk(a2, b2) {
  var c2 = K$1;
  K$1 |= 2;
  var d2 = Kk();
  if (R$1 !== a2 || Z$1 !== b2)
    vk = null, Lk(a2, b2);
  do
    try {
      Uk();
      break;
    } catch (e2) {
      Nk(a2, e2);
    }
  while (1);
  Qg();
  K$1 = c2;
  nk.current = d2;
  if (null !== Y$1)
    throw Error(p$3(261));
  R$1 = null;
  Z$1 = 0;
  return T$1;
}
function Uk() {
  for (; null !== Y$1; )
    Vk(Y$1);
}
function Mk() {
  for (; null !== Y$1 && !cc(); )
    Vk(Y$1);
}
function Vk(a2) {
  var b2 = Wk(a2.alternate, a2, gj);
  a2.memoizedProps = a2.pendingProps;
  null === b2 ? Tk(a2) : Y$1 = b2;
  ok.current = null;
}
function Tk(a2) {
  var b2 = a2;
  do {
    var c2 = b2.alternate;
    a2 = b2.return;
    if (0 === (b2.flags & 32768)) {
      if (c2 = Fj(c2, b2, gj), null !== c2) {
        Y$1 = c2;
        return;
      }
    } else {
      c2 = Jj(c2, b2);
      if (null !== c2) {
        c2.flags &= 32767;
        Y$1 = c2;
        return;
      }
      if (null !== a2)
        a2.flags |= 32768, a2.subtreeFlags = 0, a2.deletions = null;
      else {
        T$1 = 6;
        Y$1 = null;
        return;
      }
    }
    b2 = b2.sibling;
    if (null !== b2) {
      Y$1 = b2;
      return;
    }
    Y$1 = b2 = a2;
  } while (null !== b2);
  0 === T$1 && (T$1 = 5);
}
function Qk(a2, b2, c2) {
  var d2 = C$2, e2 = pk.transition;
  try {
    pk.transition = null, C$2 = 1, Xk(a2, b2, c2, d2);
  } finally {
    pk.transition = e2, C$2 = d2;
  }
  return null;
}
function Xk(a2, b2, c2, d2) {
  do
    Ik();
  while (null !== xk);
  if (0 !== (K$1 & 6))
    throw Error(p$3(327));
  c2 = a2.finishedWork;
  var e2 = a2.finishedLanes;
  if (null === c2)
    return null;
  a2.finishedWork = null;
  a2.finishedLanes = 0;
  if (c2 === a2.current)
    throw Error(p$3(177));
  a2.callbackNode = null;
  a2.callbackPriority = 0;
  var f2 = c2.lanes | c2.childLanes;
  Bc(a2, f2);
  a2 === R$1 && (Y$1 = R$1 = null, Z$1 = 0);
  0 === (c2.subtreeFlags & 2064) && 0 === (c2.flags & 2064) || wk || (wk = true, Gk(hc, function() {
    Ik();
    return null;
  }));
  f2 = 0 !== (c2.flags & 15990);
  if (0 !== (c2.subtreeFlags & 15990) || f2) {
    f2 = pk.transition;
    pk.transition = null;
    var g2 = C$2;
    C$2 = 1;
    var h2 = K$1;
    K$1 |= 4;
    ok.current = null;
    Pj(a2, c2);
    ek(c2, a2);
    Oe$1(Df);
    dd = !!Cf;
    Df = Cf = null;
    a2.current = c2;
    ik(c2);
    dc();
    K$1 = h2;
    C$2 = g2;
    pk.transition = f2;
  } else
    a2.current = c2;
  wk && (wk = false, xk = a2, yk = e2);
  f2 = a2.pendingLanes;
  0 === f2 && (Si$1 = null);
  mc(c2.stateNode);
  Ek(a2, B$2());
  if (null !== b2)
    for (d2 = a2.onRecoverableError, c2 = 0; c2 < b2.length; c2++)
      e2 = b2[c2], d2(e2.value, { componentStack: e2.stack, digest: e2.digest });
  if (Pi$1)
    throw Pi$1 = false, a2 = Qi$1, Qi$1 = null, a2;
  0 !== (yk & 1) && 0 !== a2.tag && Ik();
  f2 = a2.pendingLanes;
  0 !== (f2 & 1) ? a2 === Ak ? zk++ : (zk = 0, Ak = a2) : zk = 0;
  jg();
  return null;
}
function Ik() {
  if (null !== xk) {
    var a2 = Dc(yk), b2 = pk.transition, c2 = C$2;
    try {
      pk.transition = null;
      C$2 = 16 > a2 ? 16 : a2;
      if (null === xk)
        var d2 = false;
      else {
        a2 = xk;
        xk = null;
        yk = 0;
        if (0 !== (K$1 & 6))
          throw Error(p$3(331));
        var e2 = K$1;
        K$1 |= 4;
        for (V$1 = a2.current; null !== V$1; ) {
          var f2 = V$1, g2 = f2.child;
          if (0 !== (V$1.flags & 16)) {
            var h2 = f2.deletions;
            if (null !== h2) {
              for (var k2 = 0; k2 < h2.length; k2++) {
                var l2 = h2[k2];
                for (V$1 = l2; null !== V$1; ) {
                  var m2 = V$1;
                  switch (m2.tag) {
                    case 0:
                    case 11:
                    case 15:
                      Qj(8, m2, f2);
                  }
                  var q2 = m2.child;
                  if (null !== q2)
                    q2.return = m2, V$1 = q2;
                  else
                    for (; null !== V$1; ) {
                      m2 = V$1;
                      var r2 = m2.sibling, y2 = m2.return;
                      Tj(m2);
                      if (m2 === l2) {
                        V$1 = null;
                        break;
                      }
                      if (null !== r2) {
                        r2.return = y2;
                        V$1 = r2;
                        break;
                      }
                      V$1 = y2;
                    }
                }
              }
              var n2 = f2.alternate;
              if (null !== n2) {
                var t2 = n2.child;
                if (null !== t2) {
                  n2.child = null;
                  do {
                    var J2 = t2.sibling;
                    t2.sibling = null;
                    t2 = J2;
                  } while (null !== t2);
                }
              }
              V$1 = f2;
            }
          }
          if (0 !== (f2.subtreeFlags & 2064) && null !== g2)
            g2.return = f2, V$1 = g2;
          else
            b:
              for (; null !== V$1; ) {
                f2 = V$1;
                if (0 !== (f2.flags & 2048))
                  switch (f2.tag) {
                    case 0:
                    case 11:
                    case 15:
                      Qj(9, f2, f2.return);
                  }
                var x = f2.sibling;
                if (null !== x) {
                  x.return = f2.return;
                  V$1 = x;
                  break b;
                }
                V$1 = f2.return;
              }
        }
        var w2 = a2.current;
        for (V$1 = w2; null !== V$1; ) {
          g2 = V$1;
          var u2 = g2.child;
          if (0 !== (g2.subtreeFlags & 2064) && null !== u2)
            u2.return = g2, V$1 = u2;
          else
            b:
              for (g2 = w2; null !== V$1; ) {
                h2 = V$1;
                if (0 !== (h2.flags & 2048))
                  try {
                    switch (h2.tag) {
                      case 0:
                      case 11:
                      case 15:
                        Rj(9, h2);
                    }
                  } catch (na) {
                    W$1(h2, h2.return, na);
                  }
                if (h2 === g2) {
                  V$1 = null;
                  break b;
                }
                var F2 = h2.sibling;
                if (null !== F2) {
                  F2.return = h2.return;
                  V$1 = F2;
                  break b;
                }
                V$1 = h2.return;
              }
        }
        K$1 = e2;
        jg();
        if (lc && "function" === typeof lc.onPostCommitFiberRoot)
          try {
            lc.onPostCommitFiberRoot(kc, a2);
          } catch (na) {
          }
        d2 = true;
      }
      return d2;
    } finally {
      C$2 = c2, pk.transition = b2;
    }
  }
  return false;
}
function Yk(a2, b2, c2) {
  b2 = Ki$1(c2, b2);
  b2 = Oi$1(a2, b2, 1);
  a2 = dh(a2, b2, 1);
  b2 = L$1();
  null !== a2 && (Ac(a2, 1, b2), Ek(a2, b2));
}
function W$1(a2, b2, c2) {
  if (3 === a2.tag)
    Yk(a2, a2, c2);
  else
    for (; null !== b2; ) {
      if (3 === b2.tag) {
        Yk(b2, a2, c2);
        break;
      } else if (1 === b2.tag) {
        var d2 = b2.stateNode;
        if ("function" === typeof b2.type.getDerivedStateFromError || "function" === typeof d2.componentDidCatch && (null === Si$1 || !Si$1.has(d2))) {
          a2 = Ki$1(c2, a2);
          a2 = Ri$1(b2, a2, 1);
          b2 = dh(b2, a2, 1);
          a2 = L$1();
          null !== b2 && (Ac(b2, 1, a2), Ek(b2, a2));
          break;
        }
      }
      b2 = b2.return;
    }
}
function Ui$1(a2, b2, c2) {
  var d2 = a2.pingCache;
  null !== d2 && d2.delete(b2);
  b2 = L$1();
  a2.pingedLanes |= a2.suspendedLanes & c2;
  R$1 === a2 && (Z$1 & c2) === c2 && (4 === T$1 || 3 === T$1 && (Z$1 & 130023424) === Z$1 && 500 > B$2() - gk ? Lk(a2, 0) : sk |= c2);
  Ek(a2, b2);
}
function Zk(a2, b2) {
  0 === b2 && (0 === (a2.mode & 1) ? b2 = 1 : (b2 = sc, sc <<= 1, 0 === (sc & 130023424) && (sc = 4194304)));
  var c2 = L$1();
  a2 = Zg(a2, b2);
  null !== a2 && (Ac(a2, b2, c2), Ek(a2, c2));
}
function vj(a2) {
  var b2 = a2.memoizedState, c2 = 0;
  null !== b2 && (c2 = b2.retryLane);
  Zk(a2, c2);
}
function ck(a2, b2) {
  var c2 = 0;
  switch (a2.tag) {
    case 13:
      var d2 = a2.stateNode;
      var e2 = a2.memoizedState;
      null !== e2 && (c2 = e2.retryLane);
      break;
    case 19:
      d2 = a2.stateNode;
      break;
    default:
      throw Error(p$3(314));
  }
  null !== d2 && d2.delete(b2);
  Zk(a2, c2);
}
var Wk;
Wk = function(a2, b2, c2) {
  if (null !== a2)
    if (a2.memoizedProps !== b2.pendingProps || Wf.current)
      Ug = true;
    else {
      if (0 === (a2.lanes & c2) && 0 === (b2.flags & 128))
        return Ug = false, zj(a2, b2, c2);
      Ug = 0 !== (a2.flags & 131072) ? true : false;
    }
  else
    Ug = false, I$2 && 0 !== (b2.flags & 1048576) && ug(b2, ng, b2.index);
  b2.lanes = 0;
  switch (b2.tag) {
    case 2:
      var d2 = b2.type;
      jj(a2, b2);
      a2 = b2.pendingProps;
      var e2 = Yf(b2, H$2.current);
      Tg(b2, c2);
      e2 = Xh(null, b2, d2, a2, e2, c2);
      var f2 = bi$1();
      b2.flags |= 1;
      "object" === typeof e2 && null !== e2 && "function" === typeof e2.render && void 0 === e2.$$typeof ? (b2.tag = 1, b2.memoizedState = null, b2.updateQueue = null, Zf(d2) ? (f2 = true, cg(b2)) : f2 = false, b2.memoizedState = null !== e2.state && void 0 !== e2.state ? e2.state : null, ah(b2), e2.updater = nh, b2.stateNode = e2, e2._reactInternals = b2, rh(b2, d2, a2, c2), b2 = kj(null, b2, d2, true, f2, c2)) : (b2.tag = 0, I$2 && f2 && vg(b2), Yi$1(null, b2, e2, c2), b2 = b2.child);
      return b2;
    case 16:
      d2 = b2.elementType;
      a: {
        jj(a2, b2);
        a2 = b2.pendingProps;
        e2 = d2._init;
        d2 = e2(d2._payload);
        b2.type = d2;
        e2 = b2.tag = $k(d2);
        a2 = Lg(d2, a2);
        switch (e2) {
          case 0:
            b2 = dj(null, b2, d2, a2, c2);
            break a;
          case 1:
            b2 = ij(null, b2, d2, a2, c2);
            break a;
          case 11:
            b2 = Zi$1(null, b2, d2, a2, c2);
            break a;
          case 14:
            b2 = aj(null, b2, d2, Lg(d2.type, a2), c2);
            break a;
        }
        throw Error(p$3(
          306,
          d2,
          ""
        ));
      }
      return b2;
    case 0:
      return d2 = b2.type, e2 = b2.pendingProps, e2 = b2.elementType === d2 ? e2 : Lg(d2, e2), dj(a2, b2, d2, e2, c2);
    case 1:
      return d2 = b2.type, e2 = b2.pendingProps, e2 = b2.elementType === d2 ? e2 : Lg(d2, e2), ij(a2, b2, d2, e2, c2);
    case 3:
      a: {
        lj(b2);
        if (null === a2)
          throw Error(p$3(387));
        d2 = b2.pendingProps;
        f2 = b2.memoizedState;
        e2 = f2.element;
        bh(a2, b2);
        gh(b2, d2, null, c2);
        var g2 = b2.memoizedState;
        d2 = g2.element;
        if (f2.isDehydrated)
          if (f2 = { element: d2, isDehydrated: false, cache: g2.cache, pendingSuspenseBoundaries: g2.pendingSuspenseBoundaries, transitions: g2.transitions }, b2.updateQueue.baseState = f2, b2.memoizedState = f2, b2.flags & 256) {
            e2 = Ki$1(Error(p$3(423)), b2);
            b2 = mj(a2, b2, d2, c2, e2);
            break a;
          } else if (d2 !== e2) {
            e2 = Ki$1(Error(p$3(424)), b2);
            b2 = mj(a2, b2, d2, c2, e2);
            break a;
          } else
            for (yg = Lf(b2.stateNode.containerInfo.firstChild), xg = b2, I$2 = true, zg = null, c2 = Ch(b2, null, d2, c2), b2.child = c2; c2; )
              c2.flags = c2.flags & -3 | 4096, c2 = c2.sibling;
        else {
          Ig();
          if (d2 === e2) {
            b2 = $i$1(a2, b2, c2);
            break a;
          }
          Yi$1(a2, b2, d2, c2);
        }
        b2 = b2.child;
      }
      return b2;
    case 5:
      return Kh(b2), null === a2 && Eg(b2), d2 = b2.type, e2 = b2.pendingProps, f2 = null !== a2 ? a2.memoizedProps : null, g2 = e2.children, Ef(d2, e2) ? g2 = null : null !== f2 && Ef(d2, f2) && (b2.flags |= 32), hj(a2, b2), Yi$1(a2, b2, g2, c2), b2.child;
    case 6:
      return null === a2 && Eg(b2), null;
    case 13:
      return pj(a2, b2, c2);
    case 4:
      return Ih(b2, b2.stateNode.containerInfo), d2 = b2.pendingProps, null === a2 ? b2.child = Bh(b2, null, d2, c2) : Yi$1(a2, b2, d2, c2), b2.child;
    case 11:
      return d2 = b2.type, e2 = b2.pendingProps, e2 = b2.elementType === d2 ? e2 : Lg(d2, e2), Zi$1(a2, b2, d2, e2, c2);
    case 7:
      return Yi$1(a2, b2, b2.pendingProps, c2), b2.child;
    case 8:
      return Yi$1(a2, b2, b2.pendingProps.children, c2), b2.child;
    case 12:
      return Yi$1(a2, b2, b2.pendingProps.children, c2), b2.child;
    case 10:
      a: {
        d2 = b2.type._context;
        e2 = b2.pendingProps;
        f2 = b2.memoizedProps;
        g2 = e2.value;
        G$2(Mg, d2._currentValue);
        d2._currentValue = g2;
        if (null !== f2)
          if (He$1(f2.value, g2)) {
            if (f2.children === e2.children && !Wf.current) {
              b2 = $i$1(a2, b2, c2);
              break a;
            }
          } else
            for (f2 = b2.child, null !== f2 && (f2.return = b2); null !== f2; ) {
              var h2 = f2.dependencies;
              if (null !== h2) {
                g2 = f2.child;
                for (var k2 = h2.firstContext; null !== k2; ) {
                  if (k2.context === d2) {
                    if (1 === f2.tag) {
                      k2 = ch(-1, c2 & -c2);
                      k2.tag = 2;
                      var l2 = f2.updateQueue;
                      if (null !== l2) {
                        l2 = l2.shared;
                        var m2 = l2.pending;
                        null === m2 ? k2.next = k2 : (k2.next = m2.next, m2.next = k2);
                        l2.pending = k2;
                      }
                    }
                    f2.lanes |= c2;
                    k2 = f2.alternate;
                    null !== k2 && (k2.lanes |= c2);
                    Sg(
                      f2.return,
                      c2,
                      b2
                    );
                    h2.lanes |= c2;
                    break;
                  }
                  k2 = k2.next;
                }
              } else if (10 === f2.tag)
                g2 = f2.type === b2.type ? null : f2.child;
              else if (18 === f2.tag) {
                g2 = f2.return;
                if (null === g2)
                  throw Error(p$3(341));
                g2.lanes |= c2;
                h2 = g2.alternate;
                null !== h2 && (h2.lanes |= c2);
                Sg(g2, c2, b2);
                g2 = f2.sibling;
              } else
                g2 = f2.child;
              if (null !== g2)
                g2.return = f2;
              else
                for (g2 = f2; null !== g2; ) {
                  if (g2 === b2) {
                    g2 = null;
                    break;
                  }
                  f2 = g2.sibling;
                  if (null !== f2) {
                    f2.return = g2.return;
                    g2 = f2;
                    break;
                  }
                  g2 = g2.return;
                }
              f2 = g2;
            }
        Yi$1(a2, b2, e2.children, c2);
        b2 = b2.child;
      }
      return b2;
    case 9:
      return e2 = b2.type, d2 = b2.pendingProps.children, Tg(b2, c2), e2 = Vg(e2), d2 = d2(e2), b2.flags |= 1, Yi$1(a2, b2, d2, c2), b2.child;
    case 14:
      return d2 = b2.type, e2 = Lg(d2, b2.pendingProps), e2 = Lg(d2.type, e2), aj(a2, b2, d2, e2, c2);
    case 15:
      return cj(a2, b2, b2.type, b2.pendingProps, c2);
    case 17:
      return d2 = b2.type, e2 = b2.pendingProps, e2 = b2.elementType === d2 ? e2 : Lg(d2, e2), jj(a2, b2), b2.tag = 1, Zf(d2) ? (a2 = true, cg(b2)) : a2 = false, Tg(b2, c2), ph(b2, d2, e2), rh(b2, d2, e2, c2), kj(null, b2, d2, true, a2, c2);
    case 19:
      return yj(a2, b2, c2);
    case 22:
      return ej(a2, b2, c2);
  }
  throw Error(p$3(156, b2.tag));
};
function Gk(a2, b2) {
  return ac(a2, b2);
}
function al(a2, b2, c2, d2) {
  this.tag = a2;
  this.key = c2;
  this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null;
  this.index = 0;
  this.ref = null;
  this.pendingProps = b2;
  this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null;
  this.mode = d2;
  this.subtreeFlags = this.flags = 0;
  this.deletions = null;
  this.childLanes = this.lanes = 0;
  this.alternate = null;
}
function Bg(a2, b2, c2, d2) {
  return new al(a2, b2, c2, d2);
}
function bj(a2) {
  a2 = a2.prototype;
  return !(!a2 || !a2.isReactComponent);
}
function $k(a2) {
  if ("function" === typeof a2)
    return bj(a2) ? 1 : 0;
  if (void 0 !== a2 && null !== a2) {
    a2 = a2.$$typeof;
    if (a2 === Da)
      return 11;
    if (a2 === Ga)
      return 14;
  }
  return 2;
}
function wh(a2, b2) {
  var c2 = a2.alternate;
  null === c2 ? (c2 = Bg(a2.tag, b2, a2.key, a2.mode), c2.elementType = a2.elementType, c2.type = a2.type, c2.stateNode = a2.stateNode, c2.alternate = a2, a2.alternate = c2) : (c2.pendingProps = b2, c2.type = a2.type, c2.flags = 0, c2.subtreeFlags = 0, c2.deletions = null);
  c2.flags = a2.flags & 14680064;
  c2.childLanes = a2.childLanes;
  c2.lanes = a2.lanes;
  c2.child = a2.child;
  c2.memoizedProps = a2.memoizedProps;
  c2.memoizedState = a2.memoizedState;
  c2.updateQueue = a2.updateQueue;
  b2 = a2.dependencies;
  c2.dependencies = null === b2 ? null : { lanes: b2.lanes, firstContext: b2.firstContext };
  c2.sibling = a2.sibling;
  c2.index = a2.index;
  c2.ref = a2.ref;
  return c2;
}
function yh(a2, b2, c2, d2, e2, f2) {
  var g2 = 2;
  d2 = a2;
  if ("function" === typeof a2)
    bj(a2) && (g2 = 1);
  else if ("string" === typeof a2)
    g2 = 5;
  else
    a:
      switch (a2) {
        case ya:
          return Ah(c2.children, e2, f2, b2);
        case za:
          g2 = 8;
          e2 |= 8;
          break;
        case Aa:
          return a2 = Bg(12, c2, b2, e2 | 2), a2.elementType = Aa, a2.lanes = f2, a2;
        case Ea:
          return a2 = Bg(13, c2, b2, e2), a2.elementType = Ea, a2.lanes = f2, a2;
        case Fa:
          return a2 = Bg(19, c2, b2, e2), a2.elementType = Fa, a2.lanes = f2, a2;
        case Ia:
          return qj(c2, e2, f2, b2);
        default:
          if ("object" === typeof a2 && null !== a2)
            switch (a2.$$typeof) {
              case Ba:
                g2 = 10;
                break a;
              case Ca:
                g2 = 9;
                break a;
              case Da:
                g2 = 11;
                break a;
              case Ga:
                g2 = 14;
                break a;
              case Ha:
                g2 = 16;
                d2 = null;
                break a;
            }
          throw Error(p$3(130, null == a2 ? a2 : typeof a2, ""));
      }
  b2 = Bg(g2, c2, b2, e2);
  b2.elementType = a2;
  b2.type = d2;
  b2.lanes = f2;
  return b2;
}
function Ah(a2, b2, c2, d2) {
  a2 = Bg(7, a2, d2, b2);
  a2.lanes = c2;
  return a2;
}
function qj(a2, b2, c2, d2) {
  a2 = Bg(22, a2, d2, b2);
  a2.elementType = Ia;
  a2.lanes = c2;
  a2.stateNode = { isHidden: false };
  return a2;
}
function xh(a2, b2, c2) {
  a2 = Bg(6, a2, null, b2);
  a2.lanes = c2;
  return a2;
}
function zh(a2, b2, c2) {
  b2 = Bg(4, null !== a2.children ? a2.children : [], a2.key, b2);
  b2.lanes = c2;
  b2.stateNode = { containerInfo: a2.containerInfo, pendingChildren: null, implementation: a2.implementation };
  return b2;
}
function bl(a2, b2, c2, d2, e2) {
  this.tag = b2;
  this.containerInfo = a2;
  this.finishedWork = this.pingCache = this.current = this.pendingChildren = null;
  this.timeoutHandle = -1;
  this.callbackNode = this.pendingContext = this.context = null;
  this.callbackPriority = 0;
  this.eventTimes = zc(0);
  this.expirationTimes = zc(-1);
  this.entangledLanes = this.finishedLanes = this.mutableReadLanes = this.expiredLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0;
  this.entanglements = zc(0);
  this.identifierPrefix = d2;
  this.onRecoverableError = e2;
  this.mutableSourceEagerHydrationData = null;
}
function cl(a2, b2, c2, d2, e2, f2, g2, h2, k2) {
  a2 = new bl(a2, b2, c2, h2, k2);
  1 === b2 ? (b2 = 1, true === f2 && (b2 |= 8)) : b2 = 0;
  f2 = Bg(3, null, null, b2);
  a2.current = f2;
  f2.stateNode = a2;
  f2.memoizedState = { element: d2, isDehydrated: c2, cache: null, transitions: null, pendingSuspenseBoundaries: null };
  ah(f2);
  return a2;
}
function dl(a2, b2, c2) {
  var d2 = 3 < arguments.length && void 0 !== arguments[3] ? arguments[3] : null;
  return { $$typeof: wa, key: null == d2 ? null : "" + d2, children: a2, containerInfo: b2, implementation: c2 };
}
function el(a2) {
  if (!a2)
    return Vf;
  a2 = a2._reactInternals;
  a: {
    if (Vb(a2) !== a2 || 1 !== a2.tag)
      throw Error(p$3(170));
    var b2 = a2;
    do {
      switch (b2.tag) {
        case 3:
          b2 = b2.stateNode.context;
          break a;
        case 1:
          if (Zf(b2.type)) {
            b2 = b2.stateNode.__reactInternalMemoizedMergedChildContext;
            break a;
          }
      }
      b2 = b2.return;
    } while (null !== b2);
    throw Error(p$3(171));
  }
  if (1 === a2.tag) {
    var c2 = a2.type;
    if (Zf(c2))
      return bg(a2, c2, b2);
  }
  return b2;
}
function fl(a2, b2, c2, d2, e2, f2, g2, h2, k2) {
  a2 = cl(c2, d2, true, a2, e2, f2, g2, h2, k2);
  a2.context = el(null);
  c2 = a2.current;
  d2 = L$1();
  e2 = lh(c2);
  f2 = ch(d2, e2);
  f2.callback = void 0 !== b2 && null !== b2 ? b2 : null;
  dh(c2, f2, e2);
  a2.current.lanes = e2;
  Ac(a2, e2, d2);
  Ek(a2, d2);
  return a2;
}
function gl(a2, b2, c2, d2) {
  var e2 = b2.current, f2 = L$1(), g2 = lh(e2);
  c2 = el(c2);
  null === b2.context ? b2.context = c2 : b2.pendingContext = c2;
  b2 = ch(f2, g2);
  b2.payload = { element: a2 };
  d2 = void 0 === d2 ? null : d2;
  null !== d2 && (b2.callback = d2);
  a2 = dh(e2, b2, g2);
  null !== a2 && (mh(a2, e2, g2, f2), eh(a2, e2, g2));
  return g2;
}
function hl(a2) {
  a2 = a2.current;
  if (!a2.child)
    return null;
  switch (a2.child.tag) {
    case 5:
      return a2.child.stateNode;
    default:
      return a2.child.stateNode;
  }
}
function il(a2, b2) {
  a2 = a2.memoizedState;
  if (null !== a2 && null !== a2.dehydrated) {
    var c2 = a2.retryLane;
    a2.retryLane = 0 !== c2 && c2 < b2 ? c2 : b2;
  }
}
function jl(a2, b2) {
  il(a2, b2);
  (a2 = a2.alternate) && il(a2, b2);
}
function kl() {
  return null;
}
var ll = "function" === typeof reportError ? reportError : function(a2) {
  console.error(a2);
};
function ml(a2) {
  this._internalRoot = a2;
}
nl.prototype.render = ml.prototype.render = function(a2) {
  var b2 = this._internalRoot;
  if (null === b2)
    throw Error(p$3(409));
  gl(a2, b2, null, null);
};
nl.prototype.unmount = ml.prototype.unmount = function() {
  var a2 = this._internalRoot;
  if (null !== a2) {
    this._internalRoot = null;
    var b2 = a2.containerInfo;
    Sk(function() {
      gl(null, a2, null, null);
    });
    b2[uf] = null;
  }
};
function nl(a2) {
  this._internalRoot = a2;
}
nl.prototype.unstable_scheduleHydration = function(a2) {
  if (a2) {
    var b2 = Hc();
    a2 = { blockedOn: null, target: a2, priority: b2 };
    for (var c2 = 0; c2 < Qc.length && 0 !== b2 && b2 < Qc[c2].priority; c2++)
      ;
    Qc.splice(c2, 0, a2);
    0 === c2 && Vc(a2);
  }
};
function ol(a2) {
  return !(!a2 || 1 !== a2.nodeType && 9 !== a2.nodeType && 11 !== a2.nodeType);
}
function pl(a2) {
  return !(!a2 || 1 !== a2.nodeType && 9 !== a2.nodeType && 11 !== a2.nodeType && (8 !== a2.nodeType || " react-mount-point-unstable " !== a2.nodeValue));
}
function ql() {
}
function rl(a2, b2, c2, d2, e2) {
  if (e2) {
    if ("function" === typeof d2) {
      var f2 = d2;
      d2 = function() {
        var a3 = hl(g2);
        f2.call(a3);
      };
    }
    var g2 = fl(b2, d2, a2, 0, null, false, false, "", ql);
    a2._reactRootContainer = g2;
    a2[uf] = g2.current;
    sf(8 === a2.nodeType ? a2.parentNode : a2);
    Sk();
    return g2;
  }
  for (; e2 = a2.lastChild; )
    a2.removeChild(e2);
  if ("function" === typeof d2) {
    var h2 = d2;
    d2 = function() {
      var a3 = hl(k2);
      h2.call(a3);
    };
  }
  var k2 = cl(a2, 0, false, null, null, false, false, "", ql);
  a2._reactRootContainer = k2;
  a2[uf] = k2.current;
  sf(8 === a2.nodeType ? a2.parentNode : a2);
  Sk(function() {
    gl(b2, k2, c2, d2);
  });
  return k2;
}
function sl(a2, b2, c2, d2, e2) {
  var f2 = c2._reactRootContainer;
  if (f2) {
    var g2 = f2;
    if ("function" === typeof e2) {
      var h2 = e2;
      e2 = function() {
        var a3 = hl(g2);
        h2.call(a3);
      };
    }
    gl(b2, g2, a2, e2);
  } else
    g2 = rl(c2, b2, a2, e2, d2);
  return hl(g2);
}
Ec = function(a2) {
  switch (a2.tag) {
    case 3:
      var b2 = a2.stateNode;
      if (b2.current.memoizedState.isDehydrated) {
        var c2 = tc(b2.pendingLanes);
        0 !== c2 && (Cc(b2, c2 | 1), Ek(b2, B$2()), 0 === (K$1 & 6) && (Hj = B$2() + 500, jg()));
      }
      break;
    case 13:
      Sk(function() {
        var b3 = Zg(a2, 1);
        if (null !== b3) {
          var c3 = L$1();
          mh(b3, a2, 1, c3);
        }
      }), jl(a2, 1);
  }
};
Fc = function(a2) {
  if (13 === a2.tag) {
    var b2 = Zg(a2, 134217728);
    if (null !== b2) {
      var c2 = L$1();
      mh(b2, a2, 134217728, c2);
    }
    jl(a2, 134217728);
  }
};
Gc = function(a2) {
  if (13 === a2.tag) {
    var b2 = lh(a2), c2 = Zg(a2, b2);
    if (null !== c2) {
      var d2 = L$1();
      mh(c2, a2, b2, d2);
    }
    jl(a2, b2);
  }
};
Hc = function() {
  return C$2;
};
Ic = function(a2, b2) {
  var c2 = C$2;
  try {
    return C$2 = a2, b2();
  } finally {
    C$2 = c2;
  }
};
yb = function(a2, b2, c2) {
  switch (b2) {
    case "input":
      bb(a2, c2);
      b2 = c2.name;
      if ("radio" === c2.type && null != b2) {
        for (c2 = a2; c2.parentNode; )
          c2 = c2.parentNode;
        c2 = c2.querySelectorAll("input[name=" + JSON.stringify("" + b2) + '][type="radio"]');
        for (b2 = 0; b2 < c2.length; b2++) {
          var d2 = c2[b2];
          if (d2 !== a2 && d2.form === a2.form) {
            var e2 = Db(d2);
            if (!e2)
              throw Error(p$3(90));
            Wa(d2);
            bb(d2, e2);
          }
        }
      }
      break;
    case "textarea":
      ib(a2, c2);
      break;
    case "select":
      b2 = c2.value, null != b2 && fb(a2, !!c2.multiple, b2, false);
  }
};
Gb = Rk;
Hb = Sk;
var tl = { usingClientEntryPoint: false, Events: [Cb, ue$1, Db, Eb, Fb, Rk] }, ul = { findFiberByHostInstance: Wc, bundleType: 0, version: "18.2.0", rendererPackageName: "react-dom" };
var vl = { bundleType: ul.bundleType, version: ul.version, rendererPackageName: ul.rendererPackageName, rendererConfig: ul.rendererConfig, overrideHookState: null, overrideHookStateDeletePath: null, overrideHookStateRenamePath: null, overrideProps: null, overridePropsDeletePath: null, overridePropsRenamePath: null, setErrorHandler: null, setSuspenseHandler: null, scheduleUpdate: null, currentDispatcherRef: ua.ReactCurrentDispatcher, findHostInstanceByFiber: function(a2) {
  a2 = Zb(a2);
  return null === a2 ? null : a2.stateNode;
}, findFiberByHostInstance: ul.findFiberByHostInstance || kl, findHostInstancesForRefresh: null, scheduleRefresh: null, scheduleRoot: null, setRefreshHandler: null, getCurrentFiber: null, reconcilerVersion: "18.2.0-next-9e3b772b8-20220608" };
if ("undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__) {
  var wl = __REACT_DEVTOOLS_GLOBAL_HOOK__;
  if (!wl.isDisabled && wl.supportsFiber)
    try {
      kc = wl.inject(vl), lc = wl;
    } catch (a2) {
    }
}
reactDom_production_min.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = tl;
reactDom_production_min.createPortal = function(a2, b2) {
  var c2 = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : null;
  if (!ol(b2))
    throw Error(p$3(200));
  return dl(a2, b2, null, c2);
};
reactDom_production_min.createRoot = function(a2, b2) {
  if (!ol(a2))
    throw Error(p$3(299));
  var c2 = false, d2 = "", e2 = ll;
  null !== b2 && void 0 !== b2 && (true === b2.unstable_strictMode && (c2 = true), void 0 !== b2.identifierPrefix && (d2 = b2.identifierPrefix), void 0 !== b2.onRecoverableError && (e2 = b2.onRecoverableError));
  b2 = cl(a2, 1, false, null, null, c2, false, d2, e2);
  a2[uf] = b2.current;
  sf(8 === a2.nodeType ? a2.parentNode : a2);
  return new ml(b2);
};
reactDom_production_min.findDOMNode = function(a2) {
  if (null == a2)
    return null;
  if (1 === a2.nodeType)
    return a2;
  var b2 = a2._reactInternals;
  if (void 0 === b2) {
    if ("function" === typeof a2.render)
      throw Error(p$3(188));
    a2 = Object.keys(a2).join(",");
    throw Error(p$3(268, a2));
  }
  a2 = Zb(b2);
  a2 = null === a2 ? null : a2.stateNode;
  return a2;
};
reactDom_production_min.flushSync = function(a2) {
  return Sk(a2);
};
reactDom_production_min.hydrate = function(a2, b2, c2) {
  if (!pl(b2))
    throw Error(p$3(200));
  return sl(null, a2, b2, true, c2);
};
reactDom_production_min.hydrateRoot = function(a2, b2, c2) {
  if (!ol(a2))
    throw Error(p$3(405));
  var d2 = null != c2 && c2.hydratedSources || null, e2 = false, f2 = "", g2 = ll;
  null !== c2 && void 0 !== c2 && (true === c2.unstable_strictMode && (e2 = true), void 0 !== c2.identifierPrefix && (f2 = c2.identifierPrefix), void 0 !== c2.onRecoverableError && (g2 = c2.onRecoverableError));
  b2 = fl(b2, null, a2, 1, null != c2 ? c2 : null, e2, false, f2, g2);
  a2[uf] = b2.current;
  sf(a2);
  if (d2)
    for (a2 = 0; a2 < d2.length; a2++)
      c2 = d2[a2], e2 = c2._getVersion, e2 = e2(c2._source), null == b2.mutableSourceEagerHydrationData ? b2.mutableSourceEagerHydrationData = [c2, e2] : b2.mutableSourceEagerHydrationData.push(
        c2,
        e2
      );
  return new nl(b2);
};
reactDom_production_min.render = function(a2, b2, c2) {
  if (!pl(b2))
    throw Error(p$3(200));
  return sl(null, a2, b2, false, c2);
};
reactDom_production_min.unmountComponentAtNode = function(a2) {
  if (!pl(a2))
    throw Error(p$3(40));
  return a2._reactRootContainer ? (Sk(function() {
    sl(null, null, a2, false, function() {
      a2._reactRootContainer = null;
      a2[uf] = null;
    });
  }), true) : false;
};
reactDom_production_min.unstable_batchedUpdates = Rk;
reactDom_production_min.unstable_renderSubtreeIntoContainer = function(a2, b2, c2, d2) {
  if (!pl(c2))
    throw Error(p$3(200));
  if (null == a2 || void 0 === a2._reactInternals)
    throw Error(p$3(38));
  return sl(a2, b2, c2, false, d2);
};
reactDom_production_min.version = "18.2.0-next-9e3b772b8-20220608";
function checkDCE() {
  if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === "undefined" || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE !== "function") {
    return;
  }
  try {
    __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(checkDCE);
  } catch (err2) {
    console.error(err2);
  }
}
{
  checkDCE();
  reactDom.exports = reactDom_production_min;
}
var reactDomExports = reactDom.exports;
const ReactDOM = /* @__PURE__ */ getDefaultExportFromCjs(reactDomExports);
var m$3 = reactDomExports;
{
  client.createRoot = m$3.createRoot;
  client.hydrateRoot = m$3.hydrateRoot;
}
function err(message) {
  const error = new Error(message);
  if (error.stack === void 0) {
    try {
      throw error;
    } catch (_2) {
    }
  }
  return error;
}
var err_1 = err;
var Recoil_err = err_1;
function isPromise(p2) {
  return !!p2 && typeof p2.then === "function";
}
var Recoil_isPromise = isPromise;
function nullthrows(x, message) {
  if (x != null) {
    return x;
  }
  throw Recoil_err(message !== null && message !== void 0 ? message : "Got unexpected null or undefined");
}
var Recoil_nullthrows = nullthrows;
function _defineProperty$1(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}
class BaseLoadable {
  getValue() {
    throw Recoil_err("BaseLoadable");
  }
  toPromise() {
    throw Recoil_err("BaseLoadable");
  }
  valueMaybe() {
    throw Recoil_err("BaseLoadable");
  }
  valueOrThrow() {
    throw Recoil_err(`Loadable expected value, but in "${this.state}" state`);
  }
  promiseMaybe() {
    throw Recoil_err("BaseLoadable");
  }
  promiseOrThrow() {
    throw Recoil_err(`Loadable expected promise, but in "${this.state}" state`);
  }
  errorMaybe() {
    throw Recoil_err("BaseLoadable");
  }
  errorOrThrow() {
    throw Recoil_err(`Loadable expected error, but in "${this.state}" state`);
  }
  is(other) {
    return other.state === this.state && other.contents === this.contents;
  }
  map(_map) {
    throw Recoil_err("BaseLoadable");
  }
}
class ValueLoadable extends BaseLoadable {
  constructor(value) {
    super();
    _defineProperty$1(this, "state", "hasValue");
    _defineProperty$1(this, "contents", void 0);
    this.contents = value;
  }
  getValue() {
    return this.contents;
  }
  toPromise() {
    return Promise.resolve(this.contents);
  }
  valueMaybe() {
    return this.contents;
  }
  valueOrThrow() {
    return this.contents;
  }
  promiseMaybe() {
    return void 0;
  }
  errorMaybe() {
    return void 0;
  }
  map(map) {
    try {
      const next = map(this.contents);
      return Recoil_isPromise(next) ? loadableWithPromise(next) : isLoadable(next) ? next : loadableWithValue(next);
    } catch (e2) {
      return Recoil_isPromise(e2) ? (
        // If we "suspended", then try again.
        // errors and subsequent retries will be handled in 'loading' case
        // $FlowFixMe[prop-missing]
        loadableWithPromise(e2.next(() => this.map(map)))
      ) : loadableWithError(e2);
    }
  }
}
class ErrorLoadable extends BaseLoadable {
  constructor(error) {
    super();
    _defineProperty$1(this, "state", "hasError");
    _defineProperty$1(this, "contents", void 0);
    this.contents = error;
  }
  getValue() {
    throw this.contents;
  }
  toPromise() {
    return Promise.reject(this.contents);
  }
  valueMaybe() {
    return void 0;
  }
  promiseMaybe() {
    return void 0;
  }
  errorMaybe() {
    return this.contents;
  }
  errorOrThrow() {
    return this.contents;
  }
  map(_map) {
    return this;
  }
}
class LoadingLoadable extends BaseLoadable {
  constructor(promise) {
    super();
    _defineProperty$1(this, "state", "loading");
    _defineProperty$1(this, "contents", void 0);
    this.contents = promise;
  }
  getValue() {
    throw this.contents;
  }
  toPromise() {
    return this.contents;
  }
  valueMaybe() {
    return void 0;
  }
  promiseMaybe() {
    return this.contents;
  }
  promiseOrThrow() {
    return this.contents;
  }
  errorMaybe() {
    return void 0;
  }
  map(map) {
    return loadableWithPromise(this.contents.then((value) => {
      const next = map(value);
      if (isLoadable(next)) {
        const nextLoadable = next;
        switch (nextLoadable.state) {
          case "hasValue":
            return nextLoadable.contents;
          case "hasError":
            throw nextLoadable.contents;
          case "loading":
            return nextLoadable.contents;
        }
      }
      return next;
    }).catch((e2) => {
      if (Recoil_isPromise(e2)) {
        return e2.then(() => this.map(map).contents);
      }
      throw e2;
    }));
  }
}
function loadableWithValue(value) {
  return Object.freeze(new ValueLoadable(value));
}
function loadableWithError(error) {
  return Object.freeze(new ErrorLoadable(error));
}
function loadableWithPromise(promise) {
  return Object.freeze(new LoadingLoadable(promise));
}
function loadableLoading() {
  return Object.freeze(new LoadingLoadable(new Promise(() => {
  })));
}
function loadableAllArray(inputs) {
  return inputs.every((i2) => i2.state === "hasValue") ? loadableWithValue(inputs.map((i2) => i2.contents)) : inputs.some((i2) => i2.state === "hasError") ? loadableWithError(Recoil_nullthrows(inputs.find((i2) => i2.state === "hasError"), "Invalid loadable passed to loadableAll").contents) : loadableWithPromise(Promise.all(inputs.map((i2) => i2.contents)));
}
function loadableAll(inputs) {
  const unwrapedInputs = Array.isArray(inputs) ? inputs : Object.getOwnPropertyNames(inputs).map((key) => inputs[key]);
  const normalizedInputs = unwrapedInputs.map((x) => isLoadable(x) ? x : Recoil_isPromise(x) ? loadableWithPromise(x) : loadableWithValue(x));
  const output = loadableAllArray(normalizedInputs);
  return Array.isArray(inputs) ? (
    // $FlowIssue[incompatible-return]
    output
  ) : (
    // Object.getOwnPropertyNames() has consistent key ordering with ES6
    // $FlowIssue[incompatible-call]
    output.map((outputs) => Object.getOwnPropertyNames(inputs).reduce(
      // $FlowFixMe[invalid-computed-prop]
      (out, key, idx) => ({
        ...out,
        [key]: outputs[idx]
      }),
      {}
    ))
  );
}
function isLoadable(x) {
  return x instanceof BaseLoadable;
}
const LoadableStaticInterface = {
  of: (value) => Recoil_isPromise(value) ? loadableWithPromise(value) : isLoadable(value) ? value : loadableWithValue(value),
  error: (error) => loadableWithError(error),
  // $FlowIssue[incompatible-return]
  loading: () => loadableLoading(),
  // $FlowIssue[unclear-type]
  all: loadableAll,
  isLoadable
};
var Recoil_Loadable = {
  loadableWithValue,
  loadableWithError,
  loadableWithPromise,
  loadableLoading,
  loadableAll,
  isLoadable,
  RecoilLoadable: LoadableStaticInterface
};
var Recoil_Loadable_1 = Recoil_Loadable.loadableWithValue;
var Recoil_Loadable_2 = Recoil_Loadable.loadableWithError;
var Recoil_Loadable_3 = Recoil_Loadable.loadableWithPromise;
var Recoil_Loadable_4 = Recoil_Loadable.loadableLoading;
var Recoil_Loadable_5 = Recoil_Loadable.loadableAll;
var Recoil_Loadable_6 = Recoil_Loadable.isLoadable;
var Recoil_Loadable_7 = Recoil_Loadable.RecoilLoadable;
var Recoil_Loadable$1 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  loadableWithValue: Recoil_Loadable_1,
  loadableWithError: Recoil_Loadable_2,
  loadableWithPromise: Recoil_Loadable_3,
  loadableLoading: Recoil_Loadable_4,
  loadableAll: Recoil_Loadable_5,
  isLoadable: Recoil_Loadable_6,
  RecoilLoadable: Recoil_Loadable_7
});
const env = {
  RECOIL_DUPLICATE_ATOM_KEY_CHECKING_ENABLED: true,
  // Note: RECOIL_GKS_ENABLED settings will only be honored in OSS builds of Recoil
  RECOIL_GKS_ENABLED: /* @__PURE__ */ new Set(["recoil_hamt_2020", "recoil_sync_external_store", "recoil_suppress_rerender_in_callback", "recoil_memory_managament_2020"])
};
function readProcessEnvBooleanFlag(name, set) {
  var _process$env$name, _process$env$name$toL;
  const sanitizedValue = (_process$env$name = process.env[name]) === null || _process$env$name === void 0 ? void 0 : (_process$env$name$toL = _process$env$name.toLowerCase()) === null || _process$env$name$toL === void 0 ? void 0 : _process$env$name$toL.trim();
  if (sanitizedValue == null || sanitizedValue === "") {
    return;
  }
  const allowedValues = ["true", "false"];
  if (!allowedValues.includes(sanitizedValue)) {
    throw Recoil_err(`({}).${name} value must be 'true', 'false', or empty: ${sanitizedValue}`);
  }
  set(sanitizedValue === "true");
}
function readProcessEnvStringArrayFlag(name, set) {
  var _process$env$name2;
  const sanitizedValue = (_process$env$name2 = process.env[name]) === null || _process$env$name2 === void 0 ? void 0 : _process$env$name2.trim();
  if (sanitizedValue == null || sanitizedValue === "") {
    return;
  }
  set(sanitizedValue.split(/\s*,\s*|\s+/));
}
function applyProcessEnvFlagOverrides() {
  var _process;
  if (typeof process === "undefined") {
    return;
  }
  if (((_process = process) === null || _process === void 0 ? void 0 : _process.env) == null) {
    return;
  }
  readProcessEnvBooleanFlag("RECOIL_DUPLICATE_ATOM_KEY_CHECKING_ENABLED", (value) => {
    env.RECOIL_DUPLICATE_ATOM_KEY_CHECKING_ENABLED = value;
  });
  readProcessEnvStringArrayFlag("RECOIL_GKS_ENABLED", (value) => {
    value.forEach((gk2) => {
      env.RECOIL_GKS_ENABLED.add(gk2);
    });
  });
}
applyProcessEnvFlagOverrides();
var Recoil_RecoilEnv = env;
function Recoil_gkx_OSS(gk2) {
  return Recoil_RecoilEnv.RECOIL_GKS_ENABLED.has(gk2);
}
Recoil_gkx_OSS.setPass = (gk2) => {
  Recoil_RecoilEnv.RECOIL_GKS_ENABLED.add(gk2);
};
Recoil_gkx_OSS.setFail = (gk2) => {
  Recoil_RecoilEnv.RECOIL_GKS_ENABLED.delete(gk2);
};
Recoil_gkx_OSS.clear = () => {
  Recoil_RecoilEnv.RECOIL_GKS_ENABLED.clear();
};
var Recoil_gkx = Recoil_gkx_OSS;
function recoverableViolation(message, _projectName, {
  error
} = {}) {
  return null;
}
var recoverableViolation_1 = recoverableViolation;
var Recoil_recoverableViolation = recoverableViolation_1;
var _createMutableSource, _useMutableSource, _useSyncExternalStore;
const createMutableSource = (
  // flowlint-next-line unclear-type:off
  (_createMutableSource = React.createMutableSource) !== null && _createMutableSource !== void 0 ? _createMutableSource : React.unstable_createMutableSource
);
const useMutableSource = (
  // flowlint-next-line unclear-type:off
  (_useMutableSource = React.useMutableSource) !== null && _useMutableSource !== void 0 ? _useMutableSource : React.unstable_useMutableSource
);
const useSyncExternalStore = (
  // flowlint-next-line unclear-type:off
  (_useSyncExternalStore = React.useSyncExternalStore) !== null && _useSyncExternalStore !== void 0 ? _useSyncExternalStore : (
    // flowlint-next-line unclear-type:off
    React.unstable_useSyncExternalStore
  )
);
function currentRendererSupportsUseSyncExternalStore() {
  var _ReactCurrentDispatch;
  const {
    ReactCurrentDispatcher,
    ReactCurrentOwner
  } = (
    /* $FlowFixMe[prop-missing] This workaround was approved as a safer mechanism
     * to detect if the current renderer supports useSyncExternalStore()
     * https://fb.workplace.com/groups/reactjs/posts/9558682330846963/ */
    React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED
  );
  const dispatcher = (_ReactCurrentDispatch = ReactCurrentDispatcher === null || ReactCurrentDispatcher === void 0 ? void 0 : ReactCurrentDispatcher.current) !== null && _ReactCurrentDispatch !== void 0 ? _ReactCurrentDispatch : ReactCurrentOwner.currentDispatcher;
  const isUseSyncExternalStoreSupported = dispatcher.useSyncExternalStore != null;
  return isUseSyncExternalStoreSupported;
}
function reactMode() {
  if (Recoil_gkx("recoil_transition_support")) {
    return {
      mode: "TRANSITION_SUPPORT",
      early: true,
      concurrent: true
    };
  }
  if (Recoil_gkx("recoil_sync_external_store") && useSyncExternalStore != null) {
    return {
      mode: "SYNC_EXTERNAL_STORE",
      early: true,
      concurrent: false
    };
  }
  if (Recoil_gkx("recoil_mutable_source") && useMutableSource != null && typeof window !== "undefined" && !window.$disableRecoilValueMutableSource_TEMP_HACK_DO_NOT_USE) {
    return Recoil_gkx("recoil_suppress_rerender_in_callback") ? {
      mode: "MUTABLE_SOURCE",
      early: true,
      concurrent: true
    } : {
      mode: "MUTABLE_SOURCE",
      early: false,
      concurrent: false
    };
  }
  return Recoil_gkx("recoil_suppress_rerender_in_callback") ? {
    mode: "LEGACY",
    early: true,
    concurrent: false
  } : {
    mode: "LEGACY",
    early: false,
    concurrent: false
  };
}
function isFastRefreshEnabled() {
  return false;
}
var Recoil_ReactMode = {
  createMutableSource,
  useMutableSource,
  useSyncExternalStore,
  currentRendererSupportsUseSyncExternalStore,
  reactMode,
  isFastRefreshEnabled
};
class AbstractRecoilValue {
  constructor(newKey) {
    _defineProperty$1(this, "key", void 0);
    this.key = newKey;
  }
  toJSON() {
    return {
      key: this.key
    };
  }
}
class RecoilState extends AbstractRecoilValue {
}
class RecoilValueReadOnly extends AbstractRecoilValue {
}
function isRecoilValue(x) {
  return x instanceof RecoilState || x instanceof RecoilValueReadOnly;
}
var Recoil_RecoilValue = {
  AbstractRecoilValue,
  RecoilState,
  RecoilValueReadOnly,
  isRecoilValue
};
var Recoil_RecoilValue_1 = Recoil_RecoilValue.AbstractRecoilValue;
var Recoil_RecoilValue_2 = Recoil_RecoilValue.RecoilState;
var Recoil_RecoilValue_3 = Recoil_RecoilValue.RecoilValueReadOnly;
var Recoil_RecoilValue_4 = Recoil_RecoilValue.isRecoilValue;
var Recoil_RecoilValue$1 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  AbstractRecoilValue: Recoil_RecoilValue_1,
  RecoilState: Recoil_RecoilValue_2,
  RecoilValueReadOnly: Recoil_RecoilValue_3,
  isRecoilValue: Recoil_RecoilValue_4
});
function mapIterable(iterable, callback) {
  return function* () {
    let index2 = 0;
    for (const value of iterable) {
      yield callback(value, index2++);
    }
  }();
}
var Recoil_mapIterable = mapIterable;
class DefaultValue {
}
const DEFAULT_VALUE = new DefaultValue();
const nodes = /* @__PURE__ */ new Map();
const recoilValues = /* @__PURE__ */ new Map();
function recoilValuesForKeys(keys) {
  return Recoil_mapIterable(keys, (key) => Recoil_nullthrows(recoilValues.get(key)));
}
function checkForDuplicateAtomKey(key) {
  if (nodes.has(key)) {
    const message = `Duplicate atom key "${key}". This is a FATAL ERROR in
      production. But it is safe to ignore this warning if it occurred because of
      hot module replacement.`;
    {
      console.warn(message);
    }
  }
}
function registerNode(node) {
  if (Recoil_RecoilEnv.RECOIL_DUPLICATE_ATOM_KEY_CHECKING_ENABLED) {
    checkForDuplicateAtomKey(node.key);
  }
  nodes.set(node.key, node);
  const recoilValue = node.set == null ? new Recoil_RecoilValue$1.RecoilValueReadOnly(node.key) : new Recoil_RecoilValue$1.RecoilState(node.key);
  recoilValues.set(node.key, recoilValue);
  return recoilValue;
}
class NodeMissingError extends Error {
}
function getNode(key) {
  const node = nodes.get(key);
  if (node == null) {
    throw new NodeMissingError(`Missing definition for RecoilValue: "${key}""`);
  }
  return node;
}
function getNodeMaybe(key) {
  return nodes.get(key);
}
const configDeletionHandlers = /* @__PURE__ */ new Map();
function deleteNodeConfigIfPossible(key) {
  var _node$shouldDeleteCon;
  if (!Recoil_gkx("recoil_memory_managament_2020")) {
    return;
  }
  const node = nodes.get(key);
  if (node !== null && node !== void 0 && (_node$shouldDeleteCon = node.shouldDeleteConfigOnRelease) !== null && _node$shouldDeleteCon !== void 0 && _node$shouldDeleteCon.call(node)) {
    var _getConfigDeletionHan;
    nodes.delete(key);
    (_getConfigDeletionHan = getConfigDeletionHandler(key)) === null || _getConfigDeletionHan === void 0 ? void 0 : _getConfigDeletionHan();
    configDeletionHandlers.delete(key);
  }
}
function setConfigDeletionHandler(key, fn2) {
  if (!Recoil_gkx("recoil_memory_managament_2020")) {
    return;
  }
  if (fn2 === void 0) {
    configDeletionHandlers.delete(key);
  } else {
    configDeletionHandlers.set(key, fn2);
  }
}
function getConfigDeletionHandler(key) {
  return configDeletionHandlers.get(key);
}
var Recoil_Node = {
  nodes,
  recoilValues,
  registerNode,
  getNode,
  getNodeMaybe,
  deleteNodeConfigIfPossible,
  setConfigDeletionHandler,
  getConfigDeletionHandler,
  recoilValuesForKeys,
  NodeMissingError,
  DefaultValue,
  DEFAULT_VALUE
};
function enqueueExecution(s2, f2) {
  f2();
}
var Recoil_Queue = {
  enqueueExecution
};
function createCommonjsModule(fn2, module) {
  return module = { exports: {} }, fn2(module, module.exports), module.exports;
}
var hamt_1 = createCommonjsModule(function(module) {
  var _typeof2 = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function(obj) {
    return typeof obj;
  } : function(obj) {
    return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
  };
  var hamt = {};
  var SIZE = 5;
  var BUCKET_SIZE = Math.pow(2, SIZE);
  var MASK = BUCKET_SIZE - 1;
  var MAX_INDEX_NODE = BUCKET_SIZE / 2;
  var MIN_ARRAY_NODE = BUCKET_SIZE / 4;
  var nothing = {};
  var constant = function constant2(x) {
    return function() {
      return x;
    };
  };
  var hash = hamt.hash = function(str) {
    var type = typeof str === "undefined" ? "undefined" : _typeof2(str);
    if (type === "number")
      return str;
    if (type !== "string")
      str += "";
    var hash2 = 0;
    for (var i2 = 0, len = str.length; i2 < len; ++i2) {
      var c2 = str.charCodeAt(i2);
      hash2 = (hash2 << 5) - hash2 + c2 | 0;
    }
    return hash2;
  };
  var popcount = function popcount2(x) {
    x -= x >> 1 & 1431655765;
    x = (x & 858993459) + (x >> 2 & 858993459);
    x = x + (x >> 4) & 252645135;
    x += x >> 8;
    x += x >> 16;
    return x & 127;
  };
  var hashFragment = function hashFragment2(shift3, h2) {
    return h2 >>> shift3 & MASK;
  };
  var toBitmap = function toBitmap2(x) {
    return 1 << x;
  };
  var fromBitmap = function fromBitmap2(bitmap, bit) {
    return popcount(bitmap & bit - 1);
  };
  var arrayUpdate = function arrayUpdate2(mutate2, at2, v2, arr) {
    var out = arr;
    if (!mutate2) {
      var len = arr.length;
      out = new Array(len);
      for (var i2 = 0; i2 < len; ++i2) {
        out[i2] = arr[i2];
      }
    }
    out[at2] = v2;
    return out;
  };
  var arraySpliceOut = function arraySpliceOut2(mutate2, at2, arr) {
    var newLen = arr.length - 1;
    var i2 = 0;
    var g2 = 0;
    var out = arr;
    if (mutate2) {
      i2 = g2 = at2;
    } else {
      out = new Array(newLen);
      while (i2 < at2) {
        out[g2++] = arr[i2++];
      }
    }
    ++i2;
    while (i2 <= newLen) {
      out[g2++] = arr[i2++];
    }
    if (mutate2) {
      out.length = newLen;
    }
    return out;
  };
  var arraySpliceIn = function arraySpliceIn2(mutate2, at2, v2, arr) {
    var len = arr.length;
    if (mutate2) {
      var _i2 = len;
      while (_i2 >= at2) {
        arr[_i2--] = arr[_i2];
      }
      arr[at2] = v2;
      return arr;
    }
    var i2 = 0, g2 = 0;
    var out = new Array(len + 1);
    while (i2 < at2) {
      out[g2++] = arr[i2++];
    }
    out[at2] = v2;
    while (i2 < len) {
      out[++g2] = arr[i2++];
    }
    return out;
  };
  var LEAF = 1;
  var COLLISION = 2;
  var INDEX = 3;
  var ARRAY = 4;
  var empty2 = {
    __hamt_isEmpty: true
  };
  var isEmptyNode = function isEmptyNode2(x) {
    return x === empty2 || x && x.__hamt_isEmpty;
  };
  var Leaf = function Leaf2(edit, hash2, key, value) {
    return {
      type: LEAF,
      edit,
      hash: hash2,
      key,
      value,
      _modify: Leaf__modify
    };
  };
  var Collision = function Collision2(edit, hash2, children) {
    return {
      type: COLLISION,
      edit,
      hash: hash2,
      children,
      _modify: Collision__modify
    };
  };
  var IndexedNode = function IndexedNode2(edit, mask, children) {
    return {
      type: INDEX,
      edit,
      mask,
      children,
      _modify: IndexedNode__modify
    };
  };
  var ArrayNode = function ArrayNode2(edit, size, children) {
    return {
      type: ARRAY,
      edit,
      size,
      children,
      _modify: ArrayNode__modify
    };
  };
  var isLeaf = function isLeaf2(node) {
    return node === empty2 || node.type === LEAF || node.type === COLLISION;
  };
  var expand3 = function expand4(edit, frag, child, bitmap, subNodes) {
    var arr = [];
    var bit = bitmap;
    var count3 = 0;
    for (var i2 = 0; bit; ++i2) {
      if (bit & 1)
        arr[i2] = subNodes[count3++];
      bit >>>= 1;
    }
    arr[frag] = child;
    return ArrayNode(edit, count3 + 1, arr);
  };
  var pack = function pack2(edit, count3, removed, elements) {
    var children = new Array(count3 - 1);
    var g2 = 0;
    var bitmap = 0;
    for (var i2 = 0, len = elements.length; i2 < len; ++i2) {
      if (i2 !== removed) {
        var elem = elements[i2];
        if (elem && !isEmptyNode(elem)) {
          children[g2++] = elem;
          bitmap |= 1 << i2;
        }
      }
    }
    return IndexedNode(edit, bitmap, children);
  };
  var mergeLeaves = function mergeLeaves2(edit, shift3, h1, n1, h2, n2) {
    if (h1 === h2)
      return Collision(edit, h1, [n2, n1]);
    var subH1 = hashFragment(shift3, h1);
    var subH2 = hashFragment(shift3, h2);
    return IndexedNode(edit, toBitmap(subH1) | toBitmap(subH2), subH1 === subH2 ? [mergeLeaves2(edit, shift3 + SIZE, h1, n1, h2, n2)] : subH1 < subH2 ? [n1, n2] : [n2, n1]);
  };
  var updateCollisionList = function updateCollisionList2(mutate2, edit, keyEq, h2, list, f2, k2, size) {
    var len = list.length;
    for (var i2 = 0; i2 < len; ++i2) {
      var child = list[i2];
      if (keyEq(k2, child.key)) {
        var value = child.value;
        var _newValue = f2(value);
        if (_newValue === value)
          return list;
        if (_newValue === nothing) {
          --size.value;
          return arraySpliceOut(mutate2, i2, list);
        }
        return arrayUpdate(mutate2, i2, Leaf(edit, h2, k2, _newValue), list);
      }
    }
    var newValue = f2();
    if (newValue === nothing)
      return list;
    ++size.value;
    return arrayUpdate(mutate2, len, Leaf(edit, h2, k2, newValue), list);
  };
  var canEditNode = function canEditNode2(edit, node) {
    return edit === node.edit;
  };
  var Leaf__modify = function Leaf__modify2(edit, keyEq, shift3, f2, h2, k2, size) {
    if (keyEq(k2, this.key)) {
      var _v = f2(this.value);
      if (_v === this.value)
        return this;
      else if (_v === nothing) {
        --size.value;
        return empty2;
      }
      if (canEditNode(edit, this)) {
        this.value = _v;
        return this;
      }
      return Leaf(edit, h2, k2, _v);
    }
    var v2 = f2();
    if (v2 === nothing)
      return this;
    ++size.value;
    return mergeLeaves(edit, shift3, this.hash, this, h2, Leaf(edit, h2, k2, v2));
  };
  var Collision__modify = function Collision__modify2(edit, keyEq, shift3, f2, h2, k2, size) {
    if (h2 === this.hash) {
      var canEdit = canEditNode(edit, this);
      var list = updateCollisionList(canEdit, edit, keyEq, this.hash, this.children, f2, k2, size);
      if (list === this.children)
        return this;
      return list.length > 1 ? Collision(edit, this.hash, list) : list[0];
    }
    var v2 = f2();
    if (v2 === nothing)
      return this;
    ++size.value;
    return mergeLeaves(edit, shift3, this.hash, this, h2, Leaf(edit, h2, k2, v2));
  };
  var IndexedNode__modify = function IndexedNode__modify2(edit, keyEq, shift3, f2, h2, k2, size) {
    var mask = this.mask;
    var children = this.children;
    var frag = hashFragment(shift3, h2);
    var bit = toBitmap(frag);
    var indx = fromBitmap(mask, bit);
    var exists = mask & bit;
    var current = exists ? children[indx] : empty2;
    var child = current._modify(edit, keyEq, shift3 + SIZE, f2, h2, k2, size);
    if (current === child)
      return this;
    var canEdit = canEditNode(edit, this);
    var bitmap = mask;
    var newChildren = void 0;
    if (exists && isEmptyNode(child)) {
      bitmap &= ~bit;
      if (!bitmap)
        return empty2;
      if (children.length <= 2 && isLeaf(children[indx ^ 1]))
        return children[indx ^ 1];
      newChildren = arraySpliceOut(canEdit, indx, children);
    } else if (!exists && !isEmptyNode(child)) {
      if (children.length >= MAX_INDEX_NODE)
        return expand3(edit, frag, child, mask, children);
      bitmap |= bit;
      newChildren = arraySpliceIn(canEdit, indx, child, children);
    } else {
      newChildren = arrayUpdate(canEdit, indx, child, children);
    }
    if (canEdit) {
      this.mask = bitmap;
      this.children = newChildren;
      return this;
    }
    return IndexedNode(edit, bitmap, newChildren);
  };
  var ArrayNode__modify = function ArrayNode__modify2(edit, keyEq, shift3, f2, h2, k2, size) {
    var count3 = this.size;
    var children = this.children;
    var frag = hashFragment(shift3, h2);
    var child = children[frag];
    var newChild = (child || empty2)._modify(edit, keyEq, shift3 + SIZE, f2, h2, k2, size);
    if (child === newChild)
      return this;
    var canEdit = canEditNode(edit, this);
    var newChildren = void 0;
    if (isEmptyNode(child) && !isEmptyNode(newChild)) {
      ++count3;
      newChildren = arrayUpdate(canEdit, frag, newChild, children);
    } else if (!isEmptyNode(child) && isEmptyNode(newChild)) {
      --count3;
      if (count3 <= MIN_ARRAY_NODE)
        return pack(edit, count3, frag, children);
      newChildren = arrayUpdate(canEdit, frag, empty2, children);
    } else {
      newChildren = arrayUpdate(canEdit, frag, newChild, children);
    }
    if (canEdit) {
      this.size = count3;
      this.children = newChildren;
      return this;
    }
    return ArrayNode(edit, count3, newChildren);
  };
  empty2._modify = function(edit, keyEq, shift3, f2, h2, k2, size) {
    var v2 = f2();
    if (v2 === nothing)
      return empty2;
    ++size.value;
    return Leaf(edit, h2, k2, v2);
  };
  function Map2(editable, edit, config2, root, size) {
    this._editable = editable;
    this._edit = edit;
    this._config = config2;
    this._root = root;
    this._size = size;
  }
  Map2.prototype.setTree = function(newRoot, newSize) {
    if (this._editable) {
      this._root = newRoot;
      this._size = newSize;
      return this;
    }
    return newRoot === this._root ? this : new Map2(this._editable, this._edit, this._config, newRoot, newSize);
  };
  var tryGetHash = hamt.tryGetHash = function(alt, hash2, key, map) {
    var node = map._root;
    var shift3 = 0;
    var keyEq = map._config.keyEq;
    while (true) {
      switch (node.type) {
        case LEAF: {
          return keyEq(key, node.key) ? node.value : alt;
        }
        case COLLISION: {
          if (hash2 === node.hash) {
            var children = node.children;
            for (var i2 = 0, len = children.length; i2 < len; ++i2) {
              var child = children[i2];
              if (keyEq(key, child.key))
                return child.value;
            }
          }
          return alt;
        }
        case INDEX: {
          var frag = hashFragment(shift3, hash2);
          var bit = toBitmap(frag);
          if (node.mask & bit) {
            node = node.children[fromBitmap(node.mask, bit)];
            shift3 += SIZE;
            break;
          }
          return alt;
        }
        case ARRAY: {
          node = node.children[hashFragment(shift3, hash2)];
          if (node) {
            shift3 += SIZE;
            break;
          }
          return alt;
        }
        default:
          return alt;
      }
    }
  };
  Map2.prototype.tryGetHash = function(alt, hash2, key) {
    return tryGetHash(alt, hash2, key, this);
  };
  var tryGet = hamt.tryGet = function(alt, key, map) {
    return tryGetHash(alt, map._config.hash(key), key, map);
  };
  Map2.prototype.tryGet = function(alt, key) {
    return tryGet(alt, key, this);
  };
  var getHash = hamt.getHash = function(hash2, key, map) {
    return tryGetHash(void 0, hash2, key, map);
  };
  Map2.prototype.getHash = function(hash2, key) {
    return getHash(hash2, key, this);
  };
  hamt.get = function(key, map) {
    return tryGetHash(void 0, map._config.hash(key), key, map);
  };
  Map2.prototype.get = function(key, alt) {
    return tryGet(alt, key, this);
  };
  var hasHash = hamt.has = function(hash2, key, map) {
    return tryGetHash(nothing, hash2, key, map) !== nothing;
  };
  Map2.prototype.hasHash = function(hash2, key) {
    return hasHash(hash2, key, this);
  };
  var has = hamt.has = function(key, map) {
    return hasHash(map._config.hash(key), key, map);
  };
  Map2.prototype.has = function(key) {
    return has(key, this);
  };
  var defKeyCompare = function defKeyCompare2(x, y2) {
    return x === y2;
  };
  hamt.make = function(config2) {
    return new Map2(0, 0, {
      keyEq: config2 && config2.keyEq || defKeyCompare,
      hash: config2 && config2.hash || hash
    }, empty2, 0);
  };
  hamt.empty = hamt.make();
  var isEmpty = hamt.isEmpty = function(map) {
    return map && !!isEmptyNode(map._root);
  };
  Map2.prototype.isEmpty = function() {
    return isEmpty(this);
  };
  var modifyHash = hamt.modifyHash = function(f2, hash2, key, map) {
    var size = {
      value: map._size
    };
    var newRoot = map._root._modify(map._editable ? map._edit : NaN, map._config.keyEq, 0, f2, hash2, key, size);
    return map.setTree(newRoot, size.value);
  };
  Map2.prototype.modifyHash = function(hash2, key, f2) {
    return modifyHash(f2, hash2, key, this);
  };
  var modify = hamt.modify = function(f2, key, map) {
    return modifyHash(f2, map._config.hash(key), key, map);
  };
  Map2.prototype.modify = function(key, f2) {
    return modify(f2, key, this);
  };
  var setHash = hamt.setHash = function(hash2, key, value, map) {
    return modifyHash(constant(value), hash2, key, map);
  };
  Map2.prototype.setHash = function(hash2, key, value) {
    return setHash(hash2, key, value, this);
  };
  var set = hamt.set = function(key, value, map) {
    return setHash(map._config.hash(key), key, value, map);
  };
  Map2.prototype.set = function(key, value) {
    return set(key, value, this);
  };
  var del = constant(nothing);
  var removeHash = hamt.removeHash = function(hash2, key, map) {
    return modifyHash(del, hash2, key, map);
  };
  Map2.prototype.removeHash = Map2.prototype.deleteHash = function(hash2, key) {
    return removeHash(hash2, key, this);
  };
  var remove = hamt.remove = function(key, map) {
    return removeHash(map._config.hash(key), key, map);
  };
  Map2.prototype.remove = Map2.prototype.delete = function(key) {
    return remove(key, this);
  };
  var beginMutation = hamt.beginMutation = function(map) {
    return new Map2(map._editable + 1, map._edit + 1, map._config, map._root, map._size);
  };
  Map2.prototype.beginMutation = function() {
    return beginMutation(this);
  };
  var endMutation = hamt.endMutation = function(map) {
    map._editable = map._editable && map._editable - 1;
    return map;
  };
  Map2.prototype.endMutation = function() {
    return endMutation(this);
  };
  var mutate = hamt.mutate = function(f2, map) {
    var transient = beginMutation(map);
    f2(transient);
    return endMutation(transient);
  };
  Map2.prototype.mutate = function(f2) {
    return mutate(f2, this);
  };
  var appk = function appk2(k2) {
    return k2 && lazyVisitChildren(k2[0], k2[1], k2[2], k2[3], k2[4]);
  };
  var lazyVisitChildren = function lazyVisitChildren2(len, children, i2, f2, k2) {
    while (i2 < len) {
      var child = children[i2++];
      if (child && !isEmptyNode(child))
        return lazyVisit(child, f2, [len, children, i2, f2, k2]);
    }
    return appk(k2);
  };
  var lazyVisit = function lazyVisit2(node, f2, k2) {
    switch (node.type) {
      case LEAF:
        return {
          value: f2(node),
          rest: k2
        };
      case COLLISION:
      case ARRAY:
      case INDEX:
        var children = node.children;
        return lazyVisitChildren(children.length, children, 0, f2, k2);
      default:
        return appk(k2);
    }
  };
  var DONE = {
    done: true
  };
  function MapIterator(v2) {
    this.v = v2;
  }
  MapIterator.prototype.next = function() {
    if (!this.v)
      return DONE;
    var v0 = this.v;
    this.v = appk(v0.rest);
    return v0;
  };
  MapIterator.prototype[Symbol.iterator] = function() {
    return this;
  };
  var visit = function visit2(map, f2) {
    return new MapIterator(lazyVisit(map._root, f2));
  };
  var buildPairs = function buildPairs2(x) {
    return [x.key, x.value];
  };
  var entries = hamt.entries = function(map) {
    return visit(map, buildPairs);
  };
  Map2.prototype.entries = Map2.prototype[Symbol.iterator] = function() {
    return entries(this);
  };
  var buildKeys = function buildKeys2(x) {
    return x.key;
  };
  var keys = hamt.keys = function(map) {
    return visit(map, buildKeys);
  };
  Map2.prototype.keys = function() {
    return keys(this);
  };
  var buildValues = function buildValues2(x) {
    return x.value;
  };
  var values2 = hamt.values = Map2.prototype.values = function(map) {
    return visit(map, buildValues);
  };
  Map2.prototype.values = function() {
    return values2(this);
  };
  var fold = hamt.fold = function(f2, z2, m2) {
    var root = m2._root;
    if (root.type === LEAF)
      return f2(z2, root.value, root.key);
    var toVisit = [root.children];
    var children = void 0;
    while (children = toVisit.pop()) {
      for (var i2 = 0, len = children.length; i2 < len; ) {
        var child = children[i2++];
        if (child && child.type) {
          if (child.type === LEAF)
            z2 = f2(z2, child.value, child.key);
          else
            toVisit.push(child.children);
        }
      }
    }
    return z2;
  };
  Map2.prototype.fold = function(f2, z2) {
    return fold(f2, z2, this);
  };
  var forEach = hamt.forEach = function(f2, map) {
    return fold(function(_2, value, key) {
      return f2(value, key, map);
    }, null, map);
  };
  Map2.prototype.forEach = function(f2) {
    return forEach(f2, this);
  };
  var count2 = hamt.count = function(map) {
    return map._size;
  };
  Map2.prototype.count = function() {
    return count2(this);
  };
  Object.defineProperty(Map2.prototype, "size", {
    get: Map2.prototype.count
  });
  if (module.exports) {
    module.exports = hamt;
  } else {
    (void 0).hamt = hamt;
  }
});
class BuiltInMap {
  constructor(existing) {
    _defineProperty$1(this, "_map", void 0);
    this._map = new Map(existing === null || existing === void 0 ? void 0 : existing.entries());
  }
  keys() {
    return this._map.keys();
  }
  entries() {
    return this._map.entries();
  }
  get(k2) {
    return this._map.get(k2);
  }
  has(k2) {
    return this._map.has(k2);
  }
  set(k2, v2) {
    this._map.set(k2, v2);
    return this;
  }
  delete(k2) {
    this._map.delete(k2);
    return this;
  }
  clone() {
    return persistentMap(this);
  }
  toMap() {
    return new Map(this._map);
  }
}
class HashArrayMappedTrieMap {
  // Because hamt.empty is not a function there is no way to introduce type
  // parameters on it, so empty is typed as HAMTPlusMap<string, mixed>.
  // $FlowIssue
  constructor(existing) {
    _defineProperty$1(this, "_hamt", hamt_1.empty.beginMutation());
    if (existing instanceof HashArrayMappedTrieMap) {
      const h2 = existing._hamt.endMutation();
      existing._hamt = h2.beginMutation();
      this._hamt = h2.beginMutation();
    } else if (existing) {
      for (const [k2, v2] of existing.entries()) {
        this._hamt.set(k2, v2);
      }
    }
  }
  keys() {
    return this._hamt.keys();
  }
  entries() {
    return this._hamt.entries();
  }
  get(k2) {
    return this._hamt.get(k2);
  }
  has(k2) {
    return this._hamt.has(k2);
  }
  set(k2, v2) {
    this._hamt.set(k2, v2);
    return this;
  }
  delete(k2) {
    this._hamt.delete(k2);
    return this;
  }
  clone() {
    return persistentMap(this);
  }
  toMap() {
    return new Map(this._hamt);
  }
}
function persistentMap(existing) {
  if (Recoil_gkx("recoil_hamt_2020")) {
    return new HashArrayMappedTrieMap(existing);
  } else {
    return new BuiltInMap(existing);
  }
}
var Recoil_PersistentMap = {
  persistentMap
};
var Recoil_PersistentMap_1 = Recoil_PersistentMap.persistentMap;
var Recoil_PersistentMap$1 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  persistentMap: Recoil_PersistentMap_1
});
function differenceSets(set, ...setsWithValuesToRemove) {
  const ret = /* @__PURE__ */ new Set();
  FIRST:
    for (const value of set) {
      for (const otherSet of setsWithValuesToRemove) {
        if (otherSet.has(value)) {
          continue FIRST;
        }
      }
      ret.add(value);
    }
  return ret;
}
var Recoil_differenceSets = differenceSets;
function mapMap(map, callback) {
  const result = /* @__PURE__ */ new Map();
  map.forEach((value, key) => {
    result.set(key, callback(value, key));
  });
  return result;
}
var Recoil_mapMap = mapMap;
function makeGraph() {
  return {
    nodeDeps: /* @__PURE__ */ new Map(),
    nodeToNodeSubscriptions: /* @__PURE__ */ new Map()
  };
}
function cloneGraph(graph2) {
  return {
    nodeDeps: Recoil_mapMap(graph2.nodeDeps, (s2) => new Set(s2)),
    nodeToNodeSubscriptions: Recoil_mapMap(graph2.nodeToNodeSubscriptions, (s2) => new Set(s2))
  };
}
function mergeDepsIntoGraph(key, newDeps, graph2, olderGraph) {
  const {
    nodeDeps,
    nodeToNodeSubscriptions
  } = graph2;
  const oldDeps = nodeDeps.get(key);
  if (oldDeps && olderGraph && oldDeps !== olderGraph.nodeDeps.get(key)) {
    return;
  }
  nodeDeps.set(key, newDeps);
  const addedDeps = oldDeps == null ? newDeps : Recoil_differenceSets(newDeps, oldDeps);
  for (const dep of addedDeps) {
    if (!nodeToNodeSubscriptions.has(dep)) {
      nodeToNodeSubscriptions.set(dep, /* @__PURE__ */ new Set());
    }
    const existing = Recoil_nullthrows(nodeToNodeSubscriptions.get(dep));
    existing.add(key);
  }
  if (oldDeps) {
    const removedDeps = Recoil_differenceSets(oldDeps, newDeps);
    for (const dep of removedDeps) {
      if (!nodeToNodeSubscriptions.has(dep)) {
        return;
      }
      const existing = Recoil_nullthrows(nodeToNodeSubscriptions.get(dep));
      existing.delete(key);
      if (existing.size === 0) {
        nodeToNodeSubscriptions.delete(dep);
      }
    }
  }
}
function saveDepsToStore(key, deps, store, version) {
  var _storeState$nextTree, _storeState$previousT, _storeState$previousT2, _storeState$previousT3;
  const storeState = store.getState();
  if (!(version === storeState.currentTree.version || version === ((_storeState$nextTree = storeState.nextTree) === null || _storeState$nextTree === void 0 ? void 0 : _storeState$nextTree.version) || version === ((_storeState$previousT = storeState.previousTree) === null || _storeState$previousT === void 0 ? void 0 : _storeState$previousT.version)))
    ;
  const graph2 = store.getGraph(version);
  mergeDepsIntoGraph(key, deps, graph2);
  if (version === ((_storeState$previousT2 = storeState.previousTree) === null || _storeState$previousT2 === void 0 ? void 0 : _storeState$previousT2.version)) {
    const currentGraph = store.getGraph(storeState.currentTree.version);
    mergeDepsIntoGraph(key, deps, currentGraph, graph2);
  }
  if (version === ((_storeState$previousT3 = storeState.previousTree) === null || _storeState$previousT3 === void 0 ? void 0 : _storeState$previousT3.version) || version === storeState.currentTree.version) {
    var _storeState$nextTree2;
    const nextVersion = (_storeState$nextTree2 = storeState.nextTree) === null || _storeState$nextTree2 === void 0 ? void 0 : _storeState$nextTree2.version;
    if (nextVersion !== void 0) {
      const nextGraph = store.getGraph(nextVersion);
      mergeDepsIntoGraph(key, deps, nextGraph, graph2);
    }
  }
}
var Recoil_Graph = {
  cloneGraph,
  graph: makeGraph,
  saveDepsToStore
};
let nextTreeStateVersion = 0;
const getNextTreeStateVersion = () => nextTreeStateVersion++;
let nextStoreID = 0;
const getNextStoreID = () => nextStoreID++;
let nextComponentID = 0;
const getNextComponentID = () => nextComponentID++;
var Recoil_Keys = {
  getNextTreeStateVersion,
  getNextStoreID,
  getNextComponentID
};
const {
  persistentMap: persistentMap$1
} = Recoil_PersistentMap$1;
const {
  graph
} = Recoil_Graph;
const {
  getNextTreeStateVersion: getNextTreeStateVersion$1
} = Recoil_Keys;
function makeEmptyTreeState() {
  const version = getNextTreeStateVersion$1();
  return {
    version,
    stateID: version,
    transactionMetadata: {},
    dirtyAtoms: /* @__PURE__ */ new Set(),
    atomValues: persistentMap$1(),
    nonvalidatedAtoms: persistentMap$1()
  };
}
function makeEmptyStoreState() {
  const currentTree = makeEmptyTreeState();
  return {
    currentTree,
    nextTree: null,
    previousTree: null,
    commitDepth: 0,
    knownAtoms: /* @__PURE__ */ new Set(),
    knownSelectors: /* @__PURE__ */ new Set(),
    transactionSubscriptions: /* @__PURE__ */ new Map(),
    nodeTransactionSubscriptions: /* @__PURE__ */ new Map(),
    nodeToComponentSubscriptions: /* @__PURE__ */ new Map(),
    queuedComponentCallbacks_DEPRECATED: [],
    suspendedComponentResolvers: /* @__PURE__ */ new Set(),
    graphsByVersion: (/* @__PURE__ */ new Map()).set(currentTree.version, graph()),
    retention: {
      referenceCounts: /* @__PURE__ */ new Map(),
      nodesRetainedByZone: /* @__PURE__ */ new Map(),
      retainablesToCheckForRelease: /* @__PURE__ */ new Set()
    },
    nodeCleanupFunctions: /* @__PURE__ */ new Map()
  };
}
var Recoil_State = {
  makeEmptyTreeState,
  makeEmptyStoreState,
  getNextTreeStateVersion: getNextTreeStateVersion$1
};
class RetentionZone {
}
function retentionZone() {
  return new RetentionZone();
}
var Recoil_RetentionZone = {
  RetentionZone,
  retentionZone
};
function setByAddingToSet(set, v2) {
  const next = new Set(set);
  next.add(v2);
  return next;
}
function setByDeletingFromSet(set, v2) {
  const next = new Set(set);
  next.delete(v2);
  return next;
}
function mapBySettingInMap(map, k2, v2) {
  const next = new Map(map);
  next.set(k2, v2);
  return next;
}
function mapByUpdatingInMap(map, k2, updater) {
  const next = new Map(map);
  next.set(k2, updater(next.get(k2)));
  return next;
}
function mapByDeletingFromMap(map, k2) {
  const next = new Map(map);
  next.delete(k2);
  return next;
}
function mapByDeletingMultipleFromMap(map, ks2) {
  const next = new Map(map);
  ks2.forEach((k2) => next.delete(k2));
  return next;
}
var Recoil_CopyOnWrite = {
  setByAddingToSet,
  setByDeletingFromSet,
  mapBySettingInMap,
  mapByUpdatingInMap,
  mapByDeletingFromMap,
  mapByDeletingMultipleFromMap
};
function* filterIterable(iterable, predicate) {
  let index2 = 0;
  for (const value of iterable) {
    if (predicate(value, index2++)) {
      yield value;
    }
  }
}
var Recoil_filterIterable = filterIterable;
function lazyProxy(base, factories) {
  const proxy = new Proxy(base, {
    // Compute and cache lazy property if not already done.
    get: (target, prop) => {
      if (!(prop in target) && prop in factories) {
        target[prop] = factories[prop]();
      }
      return target[prop];
    },
    // This method allows user to iterate keys as normal
    ownKeys: (target) => {
      return Object.keys(target);
    }
  });
  return proxy;
}
var Recoil_lazyProxy = lazyProxy;
const {
  getNode: getNode$1,
  getNodeMaybe: getNodeMaybe$1,
  recoilValuesForKeys: recoilValuesForKeys$1
} = Recoil_Node;
const {
  RetentionZone: RetentionZone$1
} = Recoil_RetentionZone;
const {
  setByAddingToSet: setByAddingToSet$1
} = Recoil_CopyOnWrite;
const emptySet = Object.freeze(/* @__PURE__ */ new Set());
class ReadOnlyRecoilValueError extends Error {
}
function initializeRetentionForNode(store, nodeKey, retainedBy) {
  if (!Recoil_gkx("recoil_memory_managament_2020")) {
    return () => void 0;
  }
  const {
    nodesRetainedByZone: nodesRetainedByZone2
  } = store.getState().retention;
  function addToZone(zone) {
    let set = nodesRetainedByZone2.get(zone);
    if (!set) {
      nodesRetainedByZone2.set(zone, set = /* @__PURE__ */ new Set());
    }
    set.add(nodeKey);
  }
  if (retainedBy instanceof RetentionZone$1) {
    addToZone(retainedBy);
  } else if (Array.isArray(retainedBy)) {
    for (const zone of retainedBy) {
      addToZone(zone);
    }
  }
  return () => {
    if (!Recoil_gkx("recoil_memory_managament_2020")) {
      return;
    }
    const {
      retention
    } = store.getState();
    function deleteFromZone(zone) {
      const set = retention.nodesRetainedByZone.get(zone);
      set === null || set === void 0 ? void 0 : set.delete(nodeKey);
      if (set && set.size === 0) {
        retention.nodesRetainedByZone.delete(zone);
      }
    }
    if (retainedBy instanceof RetentionZone$1) {
      deleteFromZone(retainedBy);
    } else if (Array.isArray(retainedBy)) {
      for (const zone of retainedBy) {
        deleteFromZone(zone);
      }
    }
  };
}
function initializeNodeIfNewToStore(store, treeState, key, trigger) {
  const storeState = store.getState();
  if (storeState.nodeCleanupFunctions.has(key)) {
    return;
  }
  const node = getNode$1(key);
  const retentionCleanup = initializeRetentionForNode(store, key, node.retainedBy);
  const nodeCleanup = node.init(store, treeState, trigger);
  storeState.nodeCleanupFunctions.set(key, () => {
    nodeCleanup();
    retentionCleanup();
  });
}
function initializeNode(store, key, trigger) {
  initializeNodeIfNewToStore(store, store.getState().currentTree, key, trigger);
}
function cleanUpNode(store, key) {
  var _state$nodeCleanupFun;
  const state = store.getState();
  (_state$nodeCleanupFun = state.nodeCleanupFunctions.get(key)) === null || _state$nodeCleanupFun === void 0 ? void 0 : _state$nodeCleanupFun();
  state.nodeCleanupFunctions.delete(key);
}
function getNodeLoadable(store, state, key) {
  initializeNodeIfNewToStore(store, state, key, "get");
  return getNode$1(key).get(store, state);
}
function peekNodeLoadable(store, state, key) {
  return getNode$1(key).peek(store, state);
}
function setUnvalidatedAtomValue_DEPRECATED(state, key, newValue) {
  var _node$invalidate;
  const node = getNodeMaybe$1(key);
  node === null || node === void 0 ? void 0 : (_node$invalidate = node.invalidate) === null || _node$invalidate === void 0 ? void 0 : _node$invalidate.call(node, state);
  return {
    ...state,
    atomValues: state.atomValues.clone().delete(key),
    nonvalidatedAtoms: state.nonvalidatedAtoms.clone().set(key, newValue),
    dirtyAtoms: setByAddingToSet$1(state.dirtyAtoms, key)
  };
}
function setNodeValue(store, state, key, newValue) {
  const node = getNode$1(key);
  if (node.set == null) {
    throw new ReadOnlyRecoilValueError(`Attempt to set read-only RecoilValue: ${key}`);
  }
  const set = node.set;
  initializeNodeIfNewToStore(store, state, key, "set");
  return set(store, state, newValue);
}
function peekNodeInfo(store, state, key) {
  const storeState = store.getState();
  const graph2 = store.getGraph(state.version);
  const type = getNode$1(key).nodeType;
  return Recoil_lazyProxy({
    type
  }, {
    // $FlowFixMe[underconstrained-implicit-instantiation]
    loadable: () => peekNodeLoadable(store, state, key),
    isActive: () => storeState.knownAtoms.has(key) || storeState.knownSelectors.has(key),
    isSet: () => type === "selector" ? false : state.atomValues.has(key),
    isModified: () => state.dirtyAtoms.has(key),
    // Report current dependencies.  If the node hasn't been evaluated, then
    // dependencies may be missing based on the current state.
    deps: () => {
      var _graph$nodeDeps$get;
      return recoilValuesForKeys$1((_graph$nodeDeps$get = graph2.nodeDeps.get(key)) !== null && _graph$nodeDeps$get !== void 0 ? _graph$nodeDeps$get : []);
    },
    // Reports all "current" subscribers.  Evaluating other nodes or
    // previous in-progress async evaluations may introduce new subscribers.
    subscribers: () => {
      var _storeState$nodeToCom, _storeState$nodeToCom2;
      return {
        nodes: recoilValuesForKeys$1(Recoil_filterIterable(getDownstreamNodes(store, state, /* @__PURE__ */ new Set([key])), (nodeKey) => nodeKey !== key)),
        components: Recoil_mapIterable((_storeState$nodeToCom = (_storeState$nodeToCom2 = storeState.nodeToComponentSubscriptions.get(key)) === null || _storeState$nodeToCom2 === void 0 ? void 0 : _storeState$nodeToCom2.values()) !== null && _storeState$nodeToCom !== void 0 ? _storeState$nodeToCom : [], ([name]) => ({
          name
        }))
      };
    }
  });
}
function getDownstreamNodes(store, state, keys) {
  const visitedNodes = /* @__PURE__ */ new Set();
  const visitingNodes = Array.from(keys);
  const graph2 = store.getGraph(state.version);
  for (let key = visitingNodes.pop(); key; key = visitingNodes.pop()) {
    var _graph$nodeToNodeSubs;
    visitedNodes.add(key);
    const subscribedNodes = (_graph$nodeToNodeSubs = graph2.nodeToNodeSubscriptions.get(key)) !== null && _graph$nodeToNodeSubs !== void 0 ? _graph$nodeToNodeSubs : emptySet;
    for (const downstreamNode of subscribedNodes) {
      if (!visitedNodes.has(downstreamNode)) {
        visitingNodes.push(downstreamNode);
      }
    }
  }
  return visitedNodes;
}
var Recoil_FunctionalCore = {
  getNodeLoadable,
  peekNodeLoadable,
  setNodeValue,
  initializeNode,
  cleanUpNode,
  setUnvalidatedAtomValue_DEPRECATED,
  peekNodeInfo,
  getDownstreamNodes
};
let _invalidateMemoizedSnapshot = null;
function setInvalidateMemoizedSnapshot(invalidate) {
  _invalidateMemoizedSnapshot = invalidate;
}
function invalidateMemoizedSnapshot() {
  var _invalidateMemoizedSn;
  (_invalidateMemoizedSn = _invalidateMemoizedSnapshot) === null || _invalidateMemoizedSn === void 0 ? void 0 : _invalidateMemoizedSn();
}
var Recoil_SnapshotCache = {
  setInvalidateMemoizedSnapshot,
  invalidateMemoizedSnapshot
};
const {
  getDownstreamNodes: getDownstreamNodes$1,
  getNodeLoadable: getNodeLoadable$1,
  setNodeValue: setNodeValue$1
} = Recoil_FunctionalCore;
const {
  getNextComponentID: getNextComponentID$1
} = Recoil_Keys;
const {
  getNode: getNode$2,
  getNodeMaybe: getNodeMaybe$2
} = Recoil_Node;
const {
  DefaultValue: DefaultValue$1
} = Recoil_Node;
const {
  reactMode: reactMode$1
} = Recoil_ReactMode;
const {
  AbstractRecoilValue: AbstractRecoilValue$1,
  RecoilState: RecoilState$1,
  RecoilValueReadOnly: RecoilValueReadOnly$1,
  isRecoilValue: isRecoilValue$1
} = Recoil_RecoilValue$1;
const {
  invalidateMemoizedSnapshot: invalidateMemoizedSnapshot$1
} = Recoil_SnapshotCache;
function getRecoilValueAsLoadable(store, {
  key
}, treeState = store.getState().currentTree) {
  var _storeState$nextTree, _storeState$previousT;
  const storeState = store.getState();
  if (!(treeState.version === storeState.currentTree.version || treeState.version === ((_storeState$nextTree = storeState.nextTree) === null || _storeState$nextTree === void 0 ? void 0 : _storeState$nextTree.version) || treeState.version === ((_storeState$previousT = storeState.previousTree) === null || _storeState$previousT === void 0 ? void 0 : _storeState$previousT.version)))
    ;
  const loadable = getNodeLoadable$1(store, treeState, key);
  if (loadable.state === "loading") {
    loadable.contents.catch(() => {
      return;
    });
  }
  return loadable;
}
function applyAtomValueWrites(atomValues, writes) {
  const result = atomValues.clone();
  writes.forEach((v2, k2) => {
    if (v2.state === "hasValue" && v2.contents instanceof DefaultValue$1) {
      result.delete(k2);
    } else {
      result.set(k2, v2);
    }
  });
  return result;
}
function valueFromValueOrUpdater(store, state, {
  key
}, valueOrUpdater) {
  if (typeof valueOrUpdater === "function") {
    const current = getNodeLoadable$1(store, state, key);
    if (current.state === "loading") {
      const msg = `Tried to set atom or selector "${key}" using an updater function while the current state is pending, this is not currently supported.`;
      throw Recoil_err(msg);
    } else if (current.state === "hasError") {
      throw current.contents;
    }
    return valueOrUpdater(current.contents);
  } else {
    return valueOrUpdater;
  }
}
function applyAction(store, state, action) {
  if (action.type === "set") {
    const {
      recoilValue,
      valueOrUpdater
    } = action;
    const newValue = valueFromValueOrUpdater(store, state, recoilValue, valueOrUpdater);
    const writes = setNodeValue$1(store, state, recoilValue.key, newValue);
    for (const [key, loadable] of writes.entries()) {
      writeLoadableToTreeState(state, key, loadable);
    }
  } else if (action.type === "setLoadable") {
    const {
      recoilValue: {
        key
      },
      loadable
    } = action;
    writeLoadableToTreeState(state, key, loadable);
  } else if (action.type === "markModified") {
    const {
      recoilValue: {
        key
      }
    } = action;
    state.dirtyAtoms.add(key);
  } else if (action.type === "setUnvalidated") {
    var _node$invalidate;
    const {
      recoilValue: {
        key
      },
      unvalidatedValue
    } = action;
    const node = getNodeMaybe$2(key);
    node === null || node === void 0 ? void 0 : (_node$invalidate = node.invalidate) === null || _node$invalidate === void 0 ? void 0 : _node$invalidate.call(node, state);
    state.atomValues.delete(key);
    state.nonvalidatedAtoms.set(key, unvalidatedValue);
    state.dirtyAtoms.add(key);
  } else {
    Recoil_recoverableViolation(`Unknown action ${action.type}`);
  }
}
function writeLoadableToTreeState(state, key, loadable) {
  if (loadable.state === "hasValue" && loadable.contents instanceof DefaultValue$1) {
    state.atomValues.delete(key);
  } else {
    state.atomValues.set(key, loadable);
  }
  state.dirtyAtoms.add(key);
  state.nonvalidatedAtoms.delete(key);
}
function applyActionsToStore(store, actions) {
  store.replaceState((state) => {
    const newState = copyTreeState(state);
    for (const action of actions) {
      applyAction(store, newState, action);
    }
    invalidateDownstreams(store, newState);
    invalidateMemoizedSnapshot$1();
    return newState;
  });
}
function queueOrPerformStateUpdate(store, action) {
  if (batchStack.length) {
    const actionsByStore = batchStack[batchStack.length - 1];
    let actions = actionsByStore.get(store);
    if (!actions) {
      actionsByStore.set(store, actions = []);
    }
    actions.push(action);
  } else {
    applyActionsToStore(store, [action]);
  }
}
const batchStack = [];
function batchStart() {
  const actionsByStore = /* @__PURE__ */ new Map();
  batchStack.push(actionsByStore);
  return () => {
    for (const [store, actions] of actionsByStore) {
      applyActionsToStore(store, actions);
    }
    batchStack.pop();
  };
}
function copyTreeState(state) {
  return {
    ...state,
    atomValues: state.atomValues.clone(),
    nonvalidatedAtoms: state.nonvalidatedAtoms.clone(),
    dirtyAtoms: new Set(state.dirtyAtoms)
  };
}
function invalidateDownstreams(store, state) {
  const downstreams = getDownstreamNodes$1(store, state, state.dirtyAtoms);
  for (const key of downstreams) {
    var _getNodeMaybe, _getNodeMaybe$invalid;
    (_getNodeMaybe = getNodeMaybe$2(key)) === null || _getNodeMaybe === void 0 ? void 0 : (_getNodeMaybe$invalid = _getNodeMaybe.invalidate) === null || _getNodeMaybe$invalid === void 0 ? void 0 : _getNodeMaybe$invalid.call(_getNodeMaybe, state);
  }
}
function setRecoilValue(store, recoilValue, valueOrUpdater) {
  queueOrPerformStateUpdate(store, {
    type: "set",
    recoilValue,
    valueOrUpdater
  });
}
function setRecoilValueLoadable(store, recoilValue, loadable) {
  if (loadable instanceof DefaultValue$1) {
    return setRecoilValue(store, recoilValue, loadable);
  }
  queueOrPerformStateUpdate(store, {
    type: "setLoadable",
    recoilValue,
    loadable
  });
}
function markRecoilValueModified(store, recoilValue) {
  queueOrPerformStateUpdate(store, {
    type: "markModified",
    recoilValue
  });
}
function setUnvalidatedRecoilValue(store, recoilValue, unvalidatedValue) {
  queueOrPerformStateUpdate(store, {
    type: "setUnvalidated",
    recoilValue,
    unvalidatedValue
  });
}
function subscribeToRecoilValue(store, {
  key
}, callback, componentDebugName = null) {
  const subID = getNextComponentID$1();
  const storeState = store.getState();
  if (!storeState.nodeToComponentSubscriptions.has(key)) {
    storeState.nodeToComponentSubscriptions.set(key, /* @__PURE__ */ new Map());
  }
  Recoil_nullthrows(storeState.nodeToComponentSubscriptions.get(key)).set(subID, [componentDebugName !== null && componentDebugName !== void 0 ? componentDebugName : "<not captured>", callback]);
  const mode = reactMode$1();
  if (mode.early && (mode.mode === "LEGACY" || mode.mode === "MUTABLE_SOURCE")) {
    const nextTree = store.getState().nextTree;
    if (nextTree && nextTree.dirtyAtoms.has(key)) {
      callback(nextTree);
    }
  }
  return {
    release: () => {
      const releaseStoreState = store.getState();
      const subs = releaseStoreState.nodeToComponentSubscriptions.get(key);
      if (subs === void 0 || !subs.has(subID)) {
        return;
      }
      subs.delete(subID);
      if (subs.size === 0) {
        releaseStoreState.nodeToComponentSubscriptions.delete(key);
      }
    }
  };
}
function refreshRecoilValue(store, recoilValue) {
  var _node$clearCache;
  const {
    currentTree
  } = store.getState();
  const node = getNode$2(recoilValue.key);
  (_node$clearCache = node.clearCache) === null || _node$clearCache === void 0 ? void 0 : _node$clearCache.call(node, store, currentTree);
}
var Recoil_RecoilValueInterface = {
  RecoilValueReadOnly: RecoilValueReadOnly$1,
  AbstractRecoilValue: AbstractRecoilValue$1,
  RecoilState: RecoilState$1,
  getRecoilValueAsLoadable,
  setRecoilValue,
  setRecoilValueLoadable,
  markRecoilValueModified,
  setUnvalidatedRecoilValue,
  subscribeToRecoilValue,
  isRecoilValue: isRecoilValue$1,
  applyAtomValueWrites,
  // TODO Remove export when deprecating initialStoreState_DEPRECATED in RecoilRoot
  batchStart,
  writeLoadableToTreeState,
  invalidateDownstreams,
  copyTreeState,
  refreshRecoilValue
};
function someSet(set, callback, context) {
  const iterator = set.entries();
  let current = iterator.next();
  while (!current.done) {
    const entry = current.value;
    if (callback.call(context, entry[1], entry[0], set)) {
      return true;
    }
    current = iterator.next();
  }
  return false;
}
var Recoil_someSet = someSet;
const {
  cleanUpNode: cleanUpNode$1
} = Recoil_FunctionalCore;
const {
  deleteNodeConfigIfPossible: deleteNodeConfigIfPossible$1,
  getNode: getNode$3
} = Recoil_Node;
const {
  RetentionZone: RetentionZone$2
} = Recoil_RetentionZone;
const SUSPENSE_TIMEOUT_MS = 12e4;
const emptySet$1 = /* @__PURE__ */ new Set();
function releaseRetainablesNowOnCurrentTree(store, retainables) {
  const storeState = store.getState();
  const treeState = storeState.currentTree;
  if (storeState.nextTree) {
    return;
  }
  const nodes2 = /* @__PURE__ */ new Set();
  for (const r2 of retainables) {
    if (r2 instanceof RetentionZone$2) {
      for (const n2 of nodesRetainedByZone(storeState, r2)) {
        nodes2.add(n2);
      }
    } else {
      nodes2.add(r2);
    }
  }
  const releasableNodes = findReleasableNodes(store, nodes2);
  for (const node of releasableNodes) {
    releaseNode(store, treeState, node);
  }
}
function findReleasableNodes(store, searchFromNodes) {
  const storeState = store.getState();
  const treeState = storeState.currentTree;
  const graph2 = store.getGraph(treeState.version);
  const releasableNodes = /* @__PURE__ */ new Set();
  const nonReleasableNodes = /* @__PURE__ */ new Set();
  findReleasableNodesInner(searchFromNodes);
  return releasableNodes;
  function findReleasableNodesInner(searchFromNodes2) {
    const releasableNodesFoundThisIteration = /* @__PURE__ */ new Set();
    const downstreams = getDownstreamNodesInTopologicalOrder(
      store,
      treeState,
      searchFromNodes2,
      releasableNodes,
      // don't descend into these
      nonReleasableNodes
      // don't descend into these
    );
    for (const node of downstreams) {
      var _storeState$retention;
      if (getNode$3(node).retainedBy === "recoilRoot") {
        nonReleasableNodes.add(node);
        continue;
      }
      if (((_storeState$retention = storeState.retention.referenceCounts.get(node)) !== null && _storeState$retention !== void 0 ? _storeState$retention : 0) > 0) {
        nonReleasableNodes.add(node);
        continue;
      }
      if (zonesThatCouldRetainNode(node).some((z2) => storeState.retention.referenceCounts.get(z2))) {
        nonReleasableNodes.add(node);
        continue;
      }
      const nodeChildren = graph2.nodeToNodeSubscriptions.get(node);
      if (nodeChildren && Recoil_someSet(nodeChildren, (child) => nonReleasableNodes.has(child))) {
        nonReleasableNodes.add(node);
        continue;
      }
      releasableNodes.add(node);
      releasableNodesFoundThisIteration.add(node);
    }
    const parents = /* @__PURE__ */ new Set();
    for (const node of releasableNodesFoundThisIteration) {
      for (const parent of (_graph$nodeDeps$get = graph2.nodeDeps.get(node)) !== null && _graph$nodeDeps$get !== void 0 ? _graph$nodeDeps$get : emptySet$1) {
        var _graph$nodeDeps$get;
        if (!releasableNodes.has(parent)) {
          parents.add(parent);
        }
      }
    }
    if (parents.size) {
      findReleasableNodesInner(parents);
    }
  }
}
function getDownstreamNodesInTopologicalOrder(store, treeState, nodes2, doNotDescendInto1, doNotDescendInto2) {
  const graph2 = store.getGraph(treeState.version);
  const answer = [];
  const visited = /* @__PURE__ */ new Set();
  while (nodes2.size > 0) {
    visit(Recoil_nullthrows(nodes2.values().next().value));
  }
  return answer;
  function visit(node) {
    if (doNotDescendInto1.has(node) || doNotDescendInto2.has(node)) {
      nodes2.delete(node);
      return;
    }
    if (visited.has(node)) {
      return;
    }
    const children = graph2.nodeToNodeSubscriptions.get(node);
    if (children) {
      for (const child of children) {
        visit(child);
      }
    }
    visited.add(node);
    nodes2.delete(node);
    answer.push(node);
  }
}
function releaseNode(store, treeState, node) {
  if (!Recoil_gkx("recoil_memory_managament_2020")) {
    return;
  }
  cleanUpNode$1(store, node);
  const storeState = store.getState();
  storeState.knownAtoms.delete(node);
  storeState.knownSelectors.delete(node);
  storeState.nodeTransactionSubscriptions.delete(node);
  storeState.retention.referenceCounts.delete(node);
  const zones = zonesThatCouldRetainNode(node);
  for (const zone of zones) {
    var _storeState$retention2;
    (_storeState$retention2 = storeState.retention.nodesRetainedByZone.get(zone)) === null || _storeState$retention2 === void 0 ? void 0 : _storeState$retention2.delete(node);
  }
  treeState.atomValues.delete(node);
  treeState.dirtyAtoms.delete(node);
  treeState.nonvalidatedAtoms.delete(node);
  const graph2 = storeState.graphsByVersion.get(treeState.version);
  if (graph2) {
    const deps = graph2.nodeDeps.get(node);
    if (deps !== void 0) {
      graph2.nodeDeps.delete(node);
      for (const dep of deps) {
        var _graph$nodeToNodeSubs;
        (_graph$nodeToNodeSubs = graph2.nodeToNodeSubscriptions.get(dep)) === null || _graph$nodeToNodeSubs === void 0 ? void 0 : _graph$nodeToNodeSubs.delete(node);
      }
    }
    graph2.nodeToNodeSubscriptions.delete(node);
  }
  deleteNodeConfigIfPossible$1(node);
}
function nodesRetainedByZone(storeState, zone) {
  var _storeState$retention3;
  return (_storeState$retention3 = storeState.retention.nodesRetainedByZone.get(zone)) !== null && _storeState$retention3 !== void 0 ? _storeState$retention3 : emptySet$1;
}
function zonesThatCouldRetainNode(node) {
  const retainedBy = getNode$3(node).retainedBy;
  if (retainedBy === void 0 || retainedBy === "components" || retainedBy === "recoilRoot") {
    return [];
  } else if (retainedBy instanceof RetentionZone$2) {
    return [retainedBy];
  } else {
    return retainedBy;
  }
}
function scheduleOrPerformPossibleReleaseOfRetainable(store, retainable) {
  const state = store.getState();
  if (state.nextTree) {
    state.retention.retainablesToCheckForRelease.add(retainable);
  } else {
    releaseRetainablesNowOnCurrentTree(store, /* @__PURE__ */ new Set([retainable]));
  }
}
function updateRetainCount(store, retainable, delta) {
  var _map$get;
  if (!Recoil_gkx("recoil_memory_managament_2020")) {
    return;
  }
  const map = store.getState().retention.referenceCounts;
  const newCount = ((_map$get = map.get(retainable)) !== null && _map$get !== void 0 ? _map$get : 0) + delta;
  if (newCount === 0) {
    updateRetainCountToZero(store, retainable);
  } else {
    map.set(retainable, newCount);
  }
}
function updateRetainCountToZero(store, retainable) {
  if (!Recoil_gkx("recoil_memory_managament_2020")) {
    return;
  }
  const map = store.getState().retention.referenceCounts;
  map.delete(retainable);
  scheduleOrPerformPossibleReleaseOfRetainable(store, retainable);
}
function releaseScheduledRetainablesNow(store) {
  if (!Recoil_gkx("recoil_memory_managament_2020")) {
    return;
  }
  const state = store.getState();
  releaseRetainablesNowOnCurrentTree(store, state.retention.retainablesToCheckForRelease);
  state.retention.retainablesToCheckForRelease.clear();
}
function retainedByOptionWithDefault(r2) {
  return r2 === void 0 ? "recoilRoot" : r2;
}
var Recoil_Retention = {
  SUSPENSE_TIMEOUT_MS,
  updateRetainCount,
  updateRetainCountToZero,
  releaseScheduledRetainablesNow,
  retainedByOptionWithDefault
};
const {
  unstable_batchedUpdates
} = ReactDOM;
var ReactBatchedUpdates = {
  unstable_batchedUpdates
};
const {
  unstable_batchedUpdates: unstable_batchedUpdates$1
} = ReactBatchedUpdates;
var Recoil_ReactBatchedUpdates = {
  unstable_batchedUpdates: unstable_batchedUpdates$1
};
const {
  batchStart: batchStart$1
} = Recoil_RecoilValueInterface;
const {
  unstable_batchedUpdates: unstable_batchedUpdates$2
} = Recoil_ReactBatchedUpdates;
let batcher = unstable_batchedUpdates$2 || ((batchFn) => batchFn());
const setBatcher = (newBatcher) => {
  batcher = newBatcher;
};
const getBatcher = () => batcher;
const batchUpdates = (callback) => {
  batcher(() => {
    let batchEnd = () => void 0;
    try {
      batchEnd = batchStart$1();
      callback();
    } finally {
      batchEnd();
    }
  });
};
var Recoil_Batching = {
  getBatcher,
  setBatcher,
  batchUpdates
};
function* concatIterables(iters) {
  for (const iter of iters) {
    for (const val of iter) {
      yield val;
    }
  }
}
var Recoil_concatIterables = concatIterables;
const isSSR = (
  // $FlowFixMe(site=recoil) Window does not have a FlowType definition https://github.com/facebook/flow/issues/6709
  typeof Window === "undefined" || typeof window === "undefined"
);
const isWindow = (value) => !isSSR && // $FlowFixMe(site=recoil) Window does not have a FlowType definition https://github.com/facebook/flow/issues/6709
(value === window || value instanceof Window);
const isReactNative = typeof navigator !== "undefined" && navigator.product === "ReactNative";
var Recoil_Environment = {
  isSSR,
  isReactNative,
  isWindow
};
function memoizeWithArgsHash(fn2, hashFunction) {
  let cache;
  return (...args) => {
    if (!cache) {
      cache = {};
    }
    const key = hashFunction(...args);
    if (!Object.hasOwnProperty.call(cache, key)) {
      cache[key] = fn2(...args);
    }
    return cache[key];
  };
}
function memoizeOneWithArgsHash(fn2, hashFunction) {
  let lastKey;
  let lastResult;
  return (...args) => {
    const key = hashFunction(...args);
    if (lastKey === key) {
      return lastResult;
    }
    lastKey = key;
    lastResult = fn2(...args);
    return lastResult;
  };
}
function memoizeOneWithArgsHashAndInvalidation(fn2, hashFunction) {
  let lastKey;
  let lastResult;
  const memoizedFn = (...args) => {
    const key = hashFunction(...args);
    if (lastKey === key) {
      return lastResult;
    }
    lastKey = key;
    lastResult = fn2(...args);
    return lastResult;
  };
  const invalidate = () => {
    lastKey = null;
  };
  return [memoizedFn, invalidate];
}
var Recoil_Memoize = {
  memoizeWithArgsHash,
  memoizeOneWithArgsHash,
  memoizeOneWithArgsHashAndInvalidation
};
const {
  batchUpdates: batchUpdates$1
} = Recoil_Batching;
const {
  initializeNode: initializeNode$1,
  peekNodeInfo: peekNodeInfo$1
} = Recoil_FunctionalCore;
const {
  graph: graph$1
} = Recoil_Graph;
const {
  getNextStoreID: getNextStoreID$1
} = Recoil_Keys;
const {
  DEFAULT_VALUE: DEFAULT_VALUE$1,
  recoilValues: recoilValues$1,
  recoilValuesForKeys: recoilValuesForKeys$2
} = Recoil_Node;
const {
  AbstractRecoilValue: AbstractRecoilValue$2,
  getRecoilValueAsLoadable: getRecoilValueAsLoadable$1,
  setRecoilValue: setRecoilValue$1,
  setUnvalidatedRecoilValue: setUnvalidatedRecoilValue$1
} = Recoil_RecoilValueInterface;
const {
  updateRetainCount: updateRetainCount$1
} = Recoil_Retention;
const {
  setInvalidateMemoizedSnapshot: setInvalidateMemoizedSnapshot$1
} = Recoil_SnapshotCache;
const {
  getNextTreeStateVersion: getNextTreeStateVersion$2,
  makeEmptyStoreState: makeEmptyStoreState$1
} = Recoil_State;
const {
  isSSR: isSSR$1
} = Recoil_Environment;
const {
  memoizeOneWithArgsHashAndInvalidation: memoizeOneWithArgsHashAndInvalidation$1
} = Recoil_Memoize;
class Snapshot {
  // eslint-disable-next-line fb-www/no-uninitialized-properties
  constructor(storeState, parentStoreID) {
    _defineProperty$1(this, "_store", void 0);
    _defineProperty$1(this, "_refCount", 1);
    _defineProperty$1(this, "getLoadable", (recoilValue) => {
      this.checkRefCount_INTERNAL();
      return getRecoilValueAsLoadable$1(this._store, recoilValue);
    });
    _defineProperty$1(this, "getPromise", (recoilValue) => {
      this.checkRefCount_INTERNAL();
      return this.getLoadable(recoilValue).toPromise();
    });
    _defineProperty$1(this, "getNodes_UNSTABLE", (opt) => {
      this.checkRefCount_INTERNAL();
      if ((opt === null || opt === void 0 ? void 0 : opt.isModified) === true) {
        if ((opt === null || opt === void 0 ? void 0 : opt.isInitialized) === false) {
          return [];
        }
        const state = this._store.getState().currentTree;
        return recoilValuesForKeys$2(state.dirtyAtoms);
      }
      const knownAtoms = this._store.getState().knownAtoms;
      const knownSelectors = this._store.getState().knownSelectors;
      return (opt === null || opt === void 0 ? void 0 : opt.isInitialized) == null ? recoilValues$1.values() : opt.isInitialized === true ? recoilValuesForKeys$2(Recoil_concatIterables([knownAtoms, knownSelectors])) : Recoil_filterIterable(recoilValues$1.values(), ({
        key
      }) => !knownAtoms.has(key) && !knownSelectors.has(key));
    });
    _defineProperty$1(this, "getInfo_UNSTABLE", ({
      key
    }) => {
      this.checkRefCount_INTERNAL();
      return peekNodeInfo$1(this._store, this._store.getState().currentTree, key);
    });
    _defineProperty$1(this, "map", (mapper) => {
      this.checkRefCount_INTERNAL();
      const mutableSnapshot = new MutableSnapshot(this, batchUpdates$1);
      mapper(mutableSnapshot);
      return mutableSnapshot;
    });
    _defineProperty$1(this, "asyncMap", async (mapper) => {
      this.checkRefCount_INTERNAL();
      const mutableSnapshot = new MutableSnapshot(this, batchUpdates$1);
      mutableSnapshot.retain();
      await mapper(mutableSnapshot);
      mutableSnapshot.autoRelease_INTERNAL();
      return mutableSnapshot;
    });
    this._store = {
      storeID: getNextStoreID$1(),
      parentStoreID,
      getState: () => storeState,
      replaceState: (replacer) => {
        storeState.currentTree = replacer(storeState.currentTree);
      },
      getGraph: (version) => {
        const graphs = storeState.graphsByVersion;
        if (graphs.has(version)) {
          return Recoil_nullthrows(graphs.get(version));
        }
        const newGraph = graph$1();
        graphs.set(version, newGraph);
        return newGraph;
      },
      subscribeToTransactions: () => ({
        release: () => {
        }
      }),
      addTransactionMetadata: () => {
        throw Recoil_err("Cannot subscribe to Snapshots");
      }
    };
    for (const nodeKey of this._store.getState().knownAtoms) {
      initializeNode$1(this._store, nodeKey, "get");
      updateRetainCount$1(this._store, nodeKey, 1);
    }
    this.autoRelease_INTERNAL();
  }
  retain() {
    if (this._refCount <= 0)
      ;
    this._refCount++;
    let released = false;
    return () => {
      if (!released) {
        released = true;
        this._release();
      }
    };
  }
  /**
   * Release the snapshot on the next tick.  This means the snapshot is retained
   * during the execution of the current function using it.
   */
  autoRelease_INTERNAL() {
    if (!isSSR$1) {
      window.setTimeout(() => this._release(), 10);
    }
  }
  _release() {
    this._refCount--;
    if (this._refCount === 0) {
      this._store.getState().nodeCleanupFunctions.forEach((cleanup) => cleanup());
      this._store.getState().nodeCleanupFunctions.clear();
      if (!Recoil_gkx("recoil_memory_managament_2020")) {
        return;
      }
    } else if (this._refCount < 0)
      ;
  }
  isRetained() {
    return this._refCount > 0;
  }
  checkRefCount_INTERNAL() {
    if (Recoil_gkx("recoil_memory_managament_2020") && this._refCount <= 0)
      ;
  }
  getStore_INTERNAL() {
    this.checkRefCount_INTERNAL();
    return this._store;
  }
  getID() {
    this.checkRefCount_INTERNAL();
    return this._store.getState().currentTree.stateID;
  }
  getStoreID() {
    this.checkRefCount_INTERNAL();
    return this._store.storeID;
  }
  // We want to allow the methods to be destructured and used as accessors
  /* eslint-disable fb-www/extra-arrow-initializer */
  /* eslint-enable fb-www/extra-arrow-initializer */
}
function cloneStoreState(store, treeState, bumpVersion = false) {
  const storeState = store.getState();
  const version = bumpVersion ? getNextTreeStateVersion$2() : treeState.version;
  return {
    // Always clone the TreeState to isolate stores from accidental mutations.
    // For example, reading a selector from a cloned snapshot shouldn't cache
    // in the original treestate which may cause the original to skip
    // initialization of upstream atoms.
    currentTree: {
      // TODO snapshots shouldn't really have versions because a new version number
      // is always assigned when the snapshot is gone to.
      version: bumpVersion ? version : treeState.version,
      stateID: bumpVersion ? version : treeState.stateID,
      transactionMetadata: {
        ...treeState.transactionMetadata
      },
      dirtyAtoms: new Set(treeState.dirtyAtoms),
      atomValues: treeState.atomValues.clone(),
      nonvalidatedAtoms: treeState.nonvalidatedAtoms.clone()
    },
    commitDepth: 0,
    nextTree: null,
    previousTree: null,
    knownAtoms: new Set(storeState.knownAtoms),
    // FIXME here's a copy
    knownSelectors: new Set(storeState.knownSelectors),
    // FIXME here's a copy
    transactionSubscriptions: /* @__PURE__ */ new Map(),
    nodeTransactionSubscriptions: /* @__PURE__ */ new Map(),
    nodeToComponentSubscriptions: /* @__PURE__ */ new Map(),
    queuedComponentCallbacks_DEPRECATED: [],
    suspendedComponentResolvers: /* @__PURE__ */ new Set(),
    graphsByVersion: (/* @__PURE__ */ new Map()).set(version, store.getGraph(treeState.version)),
    retention: {
      referenceCounts: /* @__PURE__ */ new Map(),
      nodesRetainedByZone: /* @__PURE__ */ new Map(),
      retainablesToCheckForRelease: /* @__PURE__ */ new Set()
    },
    // FIXME here's a copy
    // Create blank cleanup handlers for atoms so snapshots don't re-run
    // atom effects.
    nodeCleanupFunctions: new Map(Recoil_mapIterable(storeState.nodeCleanupFunctions.entries(), ([key]) => [key, () => {
    }]))
  };
}
function freshSnapshot(initializeState) {
  const snapshot = new Snapshot(makeEmptyStoreState$1());
  return initializeState != null ? snapshot.map(initializeState) : snapshot;
}
const [memoizedCloneSnapshot, invalidateMemoizedSnapshot$2] = memoizeOneWithArgsHashAndInvalidation$1(
  // $FlowFixMe[missing-local-annot]
  (store, version) => {
    var _storeState$nextTree;
    const storeState = store.getState();
    const treeState = version === "latest" ? (_storeState$nextTree = storeState.nextTree) !== null && _storeState$nextTree !== void 0 ? _storeState$nextTree : storeState.currentTree : Recoil_nullthrows(storeState.previousTree);
    return new Snapshot(cloneStoreState(store, treeState), store.storeID);
  },
  (store, version) => {
    var _store$getState$nextT, _store$getState$previ;
    return String(version) + String(store.storeID) + String((_store$getState$nextT = store.getState().nextTree) === null || _store$getState$nextT === void 0 ? void 0 : _store$getState$nextT.version) + String(store.getState().currentTree.version) + String((_store$getState$previ = store.getState().previousTree) === null || _store$getState$previ === void 0 ? void 0 : _store$getState$previ.version);
  }
);
setInvalidateMemoizedSnapshot$1(invalidateMemoizedSnapshot$2);
function cloneSnapshot(store, version = "latest") {
  const snapshot = memoizedCloneSnapshot(store, version);
  if (!snapshot.isRetained()) {
    invalidateMemoizedSnapshot$2();
    return memoizedCloneSnapshot(store, version);
  }
  return snapshot;
}
class MutableSnapshot extends Snapshot {
  constructor(snapshot, batch2) {
    super(cloneStoreState(snapshot.getStore_INTERNAL(), snapshot.getStore_INTERNAL().getState().currentTree, true), snapshot.getStoreID());
    _defineProperty$1(this, "_batch", void 0);
    _defineProperty$1(this, "set", (recoilState, newValueOrUpdater) => {
      this.checkRefCount_INTERNAL();
      const store = this.getStore_INTERNAL();
      this._batch(() => {
        updateRetainCount$1(store, recoilState.key, 1);
        setRecoilValue$1(this.getStore_INTERNAL(), recoilState, newValueOrUpdater);
      });
    });
    _defineProperty$1(this, "reset", (recoilState) => {
      this.checkRefCount_INTERNAL();
      const store = this.getStore_INTERNAL();
      this._batch(() => {
        updateRetainCount$1(store, recoilState.key, 1);
        setRecoilValue$1(this.getStore_INTERNAL(), recoilState, DEFAULT_VALUE$1);
      });
    });
    _defineProperty$1(this, "setUnvalidatedAtomValues_DEPRECATED", (values2) => {
      this.checkRefCount_INTERNAL();
      const store = this.getStore_INTERNAL();
      batchUpdates$1(() => {
        for (const [k2, v2] of values2.entries()) {
          updateRetainCount$1(store, k2, 1);
          setUnvalidatedRecoilValue$1(store, new AbstractRecoilValue$2(k2), v2);
        }
      });
    });
    this._batch = batch2;
  }
}
var Recoil_Snapshot = {
  Snapshot,
  MutableSnapshot,
  freshSnapshot,
  cloneSnapshot
};
var Recoil_Snapshot_1 = Recoil_Snapshot.Snapshot;
var Recoil_Snapshot_2 = Recoil_Snapshot.MutableSnapshot;
var Recoil_Snapshot_3 = Recoil_Snapshot.freshSnapshot;
var Recoil_Snapshot_4 = Recoil_Snapshot.cloneSnapshot;
var Recoil_Snapshot$1 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  Snapshot: Recoil_Snapshot_1,
  MutableSnapshot: Recoil_Snapshot_2,
  freshSnapshot: Recoil_Snapshot_3,
  cloneSnapshot: Recoil_Snapshot_4
});
function unionSets(...sets) {
  const result = /* @__PURE__ */ new Set();
  for (const set of sets) {
    for (const value of set) {
      result.add(value);
    }
  }
  return result;
}
var Recoil_unionSets = unionSets;
const {
  useRef
} = React;
function useRefInitOnce(initialValue) {
  const ref = useRef(initialValue);
  if (ref.current === initialValue && typeof initialValue === "function") {
    ref.current = initialValue();
  }
  return ref;
}
var Recoil_useRefInitOnce = useRefInitOnce;
const {
  getNextTreeStateVersion: getNextTreeStateVersion$3,
  makeEmptyStoreState: makeEmptyStoreState$2
} = Recoil_State;
const {
  cleanUpNode: cleanUpNode$2,
  getDownstreamNodes: getDownstreamNodes$2,
  initializeNode: initializeNode$2,
  setNodeValue: setNodeValue$2,
  setUnvalidatedAtomValue_DEPRECATED: setUnvalidatedAtomValue_DEPRECATED$1
} = Recoil_FunctionalCore;
const {
  graph: graph$2
} = Recoil_Graph;
const {
  cloneGraph: cloneGraph$1
} = Recoil_Graph;
const {
  getNextStoreID: getNextStoreID$2
} = Recoil_Keys;
const {
  createMutableSource: createMutableSource$1,
  reactMode: reactMode$2
} = Recoil_ReactMode;
const {
  applyAtomValueWrites: applyAtomValueWrites$1
} = Recoil_RecoilValueInterface;
const {
  releaseScheduledRetainablesNow: releaseScheduledRetainablesNow$1
} = Recoil_Retention;
const {
  freshSnapshot: freshSnapshot$1
} = Recoil_Snapshot$1;
const {
  useCallback: useCallback$1,
  useContext,
  useEffect,
  useMemo: useMemo$1,
  useRef: useRef$1,
  useState
} = React;
function notInAContext() {
  throw Recoil_err("This component must be used inside a <RecoilRoot> component.");
}
const defaultStore = Object.freeze({
  storeID: getNextStoreID$2(),
  getState: notInAContext,
  replaceState: notInAContext,
  getGraph: notInAContext,
  subscribeToTransactions: notInAContext,
  addTransactionMetadata: notInAContext
});
let stateReplacerIsBeingExecuted = false;
function startNextTreeIfNeeded(store) {
  if (stateReplacerIsBeingExecuted) {
    throw Recoil_err("An atom update was triggered within the execution of a state updater function. State updater functions provided to Recoil must be pure functions.");
  }
  const storeState = store.getState();
  if (storeState.nextTree === null) {
    if (Recoil_gkx("recoil_memory_managament_2020") && Recoil_gkx("recoil_release_on_cascading_update_killswitch_2021")) {
      if (storeState.commitDepth > 0) {
        releaseScheduledRetainablesNow$1(store);
      }
    }
    const version = storeState.currentTree.version;
    const nextVersion = getNextTreeStateVersion$3();
    storeState.nextTree = {
      ...storeState.currentTree,
      version: nextVersion,
      stateID: nextVersion,
      dirtyAtoms: /* @__PURE__ */ new Set(),
      transactionMetadata: {}
    };
    storeState.graphsByVersion.set(nextVersion, cloneGraph$1(Recoil_nullthrows(storeState.graphsByVersion.get(version))));
  }
}
const AppContext$1 = React.createContext({
  current: defaultStore
});
const useStoreRef = () => useContext(AppContext$1);
const MutableSourceContext = React.createContext(null);
function useRecoilMutableSource() {
  const mutableSource = useContext(MutableSourceContext);
  return mutableSource;
}
function notifyComponents(store, storeState, treeState) {
  const dependentNodes = getDownstreamNodes$2(store, treeState, treeState.dirtyAtoms);
  for (const key of dependentNodes) {
    const comps = storeState.nodeToComponentSubscriptions.get(key);
    if (comps) {
      for (const [_subID, [_debugName, callback]] of comps) {
        callback(treeState);
      }
    }
  }
}
function sendEndOfBatchNotifications(store) {
  const storeState = store.getState();
  const treeState = storeState.currentTree;
  const dirtyAtoms = treeState.dirtyAtoms;
  if (dirtyAtoms.size) {
    for (const [key, subscriptions] of storeState.nodeTransactionSubscriptions) {
      if (dirtyAtoms.has(key)) {
        for (const [_2, subscription] of subscriptions) {
          subscription(store);
        }
      }
    }
    for (const [_2, subscription] of storeState.transactionSubscriptions) {
      subscription(store);
    }
    if (!reactMode$2().early || storeState.suspendedComponentResolvers.size > 0) {
      notifyComponents(store, storeState, treeState);
      storeState.suspendedComponentResolvers.forEach((cb2) => cb2());
      storeState.suspendedComponentResolvers.clear();
    }
  }
  storeState.queuedComponentCallbacks_DEPRECATED.forEach((cb2) => cb2(treeState));
  storeState.queuedComponentCallbacks_DEPRECATED.splice(0, storeState.queuedComponentCallbacks_DEPRECATED.length);
}
function endBatch(store) {
  const storeState = store.getState();
  storeState.commitDepth++;
  try {
    const {
      nextTree
    } = storeState;
    if (nextTree == null) {
      return;
    }
    storeState.previousTree = storeState.currentTree;
    storeState.currentTree = nextTree;
    storeState.nextTree = null;
    sendEndOfBatchNotifications(store);
    if (storeState.previousTree != null) {
      storeState.graphsByVersion.delete(storeState.previousTree.version);
    } else {
      Recoil_recoverableViolation("Ended batch with no previous state, which is unexpected", "recoil");
    }
    storeState.previousTree = null;
    if (Recoil_gkx("recoil_memory_managament_2020")) {
      if (nextTree == null) {
        releaseScheduledRetainablesNow$1(store);
      }
    }
  } finally {
    storeState.commitDepth--;
  }
}
function Batcher({
  setNotifyBatcherOfChange
}) {
  const storeRef = useStoreRef();
  const [, setState] = useState([]);
  setNotifyBatcherOfChange(() => setState({}));
  useEffect(() => {
    setNotifyBatcherOfChange(() => setState({}));
    return () => {
      setNotifyBatcherOfChange(() => {
      });
    };
  }, [setNotifyBatcherOfChange]);
  useEffect(() => {
    Recoil_Queue.enqueueExecution("Batcher", () => {
      endBatch(storeRef.current);
    });
  });
  return null;
}
function initialStoreState_DEPRECATED(store, initializeState) {
  const initial = makeEmptyStoreState$2();
  initializeState({
    set: (atom2, value) => {
      const state = initial.currentTree;
      const writes = setNodeValue$2(store, state, atom2.key, value);
      const writtenNodes = new Set(writes.keys());
      const nonvalidatedAtoms = state.nonvalidatedAtoms.clone();
      for (const n2 of writtenNodes) {
        nonvalidatedAtoms.delete(n2);
      }
      initial.currentTree = {
        ...state,
        dirtyAtoms: Recoil_unionSets(state.dirtyAtoms, writtenNodes),
        atomValues: applyAtomValueWrites$1(state.atomValues, writes),
        // NB: PLEASE un-export applyAtomValueWrites when deleting this code
        nonvalidatedAtoms
      };
    },
    setUnvalidatedAtomValues: (atomValues) => {
      atomValues.forEach((v2, k2) => {
        initial.currentTree = setUnvalidatedAtomValue_DEPRECATED$1(initial.currentTree, k2, v2);
      });
    }
  });
  return initial;
}
function initialStoreState(initializeState) {
  const snapshot = freshSnapshot$1(initializeState);
  const storeState = snapshot.getStore_INTERNAL().getState();
  snapshot.retain();
  storeState.nodeCleanupFunctions.forEach((cleanup) => cleanup());
  storeState.nodeCleanupFunctions.clear();
  return storeState;
}
let nextID = 0;
function RecoilRoot_INTERNAL({
  initializeState_DEPRECATED,
  initializeState,
  store_INTERNAL: storeProp,
  // For use with React "context bridging"
  children
}) {
  let storeStateRef;
  const getGraph = (version) => {
    const graphs = storeStateRef.current.graphsByVersion;
    if (graphs.has(version)) {
      return Recoil_nullthrows(graphs.get(version));
    }
    const newGraph = graph$2();
    graphs.set(version, newGraph);
    return newGraph;
  };
  const subscribeToTransactions = (callback, key) => {
    if (key == null) {
      const {
        transactionSubscriptions
      } = storeRef.current.getState();
      const id2 = nextID++;
      transactionSubscriptions.set(id2, callback);
      return {
        release: () => {
          transactionSubscriptions.delete(id2);
        }
      };
    } else {
      const {
        nodeTransactionSubscriptions
      } = storeRef.current.getState();
      if (!nodeTransactionSubscriptions.has(key)) {
        nodeTransactionSubscriptions.set(key, /* @__PURE__ */ new Map());
      }
      const id2 = nextID++;
      Recoil_nullthrows(nodeTransactionSubscriptions.get(key)).set(id2, callback);
      return {
        release: () => {
          const subs = nodeTransactionSubscriptions.get(key);
          if (subs) {
            subs.delete(id2);
            if (subs.size === 0) {
              nodeTransactionSubscriptions.delete(key);
            }
          }
        }
      };
    }
  };
  const addTransactionMetadata = (metadata) => {
    startNextTreeIfNeeded(storeRef.current);
    for (const k2 of Object.keys(metadata)) {
      Recoil_nullthrows(storeRef.current.getState().nextTree).transactionMetadata[k2] = metadata[k2];
    }
  };
  const replaceState = (replacer) => {
    startNextTreeIfNeeded(storeRef.current);
    const nextTree = Recoil_nullthrows(storeStateRef.current.nextTree);
    let replaced;
    try {
      stateReplacerIsBeingExecuted = true;
      replaced = replacer(nextTree);
    } finally {
      stateReplacerIsBeingExecuted = false;
    }
    if (replaced === nextTree) {
      return;
    }
    storeStateRef.current.nextTree = replaced;
    if (reactMode$2().early) {
      notifyComponents(storeRef.current, storeStateRef.current, replaced);
    }
    Recoil_nullthrows(notifyBatcherOfChange.current)();
  };
  const notifyBatcherOfChange = useRef$1(null);
  const setNotifyBatcherOfChange = useCallback$1((x) => {
    notifyBatcherOfChange.current = x;
  }, [notifyBatcherOfChange]);
  const storeRef = Recoil_useRefInitOnce(() => storeProp !== null && storeProp !== void 0 ? storeProp : {
    storeID: getNextStoreID$2(),
    getState: () => storeStateRef.current,
    replaceState,
    getGraph,
    subscribeToTransactions,
    addTransactionMetadata
  });
  if (storeProp != null) {
    storeRef.current = storeProp;
  }
  storeStateRef = Recoil_useRefInitOnce(() => initializeState_DEPRECATED != null ? initialStoreState_DEPRECATED(storeRef.current, initializeState_DEPRECATED) : initializeState != null ? initialStoreState(initializeState) : makeEmptyStoreState$2());
  const mutableSource = useMemo$1(() => createMutableSource$1 === null || createMutableSource$1 === void 0 ? void 0 : createMutableSource$1(storeStateRef, () => storeStateRef.current.currentTree.version), [storeStateRef]);
  useEffect(() => {
    const store = storeRef.current;
    for (const atomKey of new Set(store.getState().knownAtoms)) {
      initializeNode$2(store, atomKey, "get");
    }
    return () => {
      for (const atomKey of store.getState().knownAtoms) {
        cleanUpNode$2(store, atomKey);
      }
    };
  }, [storeRef]);
  return /* @__PURE__ */ React.createElement(AppContext$1.Provider, {
    value: storeRef
  }, /* @__PURE__ */ React.createElement(MutableSourceContext.Provider, {
    value: mutableSource
  }, /* @__PURE__ */ React.createElement(Batcher, {
    setNotifyBatcherOfChange
  }), children));
}
function RecoilRoot(props) {
  const {
    override,
    ...propsExceptOverride
  } = props;
  const ancestorStoreRef = useStoreRef();
  if (override === false && ancestorStoreRef.current !== defaultStore) {
    return props.children;
  }
  return /* @__PURE__ */ React.createElement(RecoilRoot_INTERNAL, propsExceptOverride);
}
function useRecoilStoreID() {
  return useStoreRef().current.storeID;
}
var Recoil_RecoilRoot = {
  RecoilRoot,
  useStoreRef,
  useRecoilMutableSource,
  useRecoilStoreID,
  notifyComponents_FOR_TESTING: notifyComponents,
  sendEndOfBatchNotifications_FOR_TESTING: sendEndOfBatchNotifications
};
function shallowArrayEqual(a2, b2) {
  if (a2 === b2) {
    return true;
  }
  if (a2.length !== b2.length) {
    return false;
  }
  for (let i2 = 0, l2 = a2.length; i2 < l2; i2++) {
    if (a2[i2] !== b2[i2]) {
      return false;
    }
  }
  return true;
}
var Recoil_shallowArrayEqual = shallowArrayEqual;
const {
  useEffect: useEffect$1,
  useRef: useRef$2
} = React;
function usePrevious$1(value) {
  const ref = useRef$2();
  useEffect$1(() => {
    ref.current = value;
  });
  return ref.current;
}
var Recoil_usePrevious = usePrevious$1;
const {
  useStoreRef: useStoreRef$1
} = Recoil_RecoilRoot;
const {
  SUSPENSE_TIMEOUT_MS: SUSPENSE_TIMEOUT_MS$1
} = Recoil_Retention;
const {
  updateRetainCount: updateRetainCount$2
} = Recoil_Retention;
const {
  RetentionZone: RetentionZone$3
} = Recoil_RetentionZone;
const {
  useEffect: useEffect$2,
  useRef: useRef$3
} = React;
const {
  isSSR: isSSR$2
} = Recoil_Environment;
function useRetain(toRetain) {
  if (!Recoil_gkx("recoil_memory_managament_2020")) {
    return;
  }
  return useRetain_ACTUAL(toRetain);
}
function useRetain_ACTUAL(toRetain) {
  const array = Array.isArray(toRetain) ? toRetain : [toRetain];
  const retainables = array.map((a2) => a2 instanceof RetentionZone$3 ? a2 : a2.key);
  const storeRef = useStoreRef$1();
  useEffect$2(() => {
    if (!Recoil_gkx("recoil_memory_managament_2020")) {
      return;
    }
    const store = storeRef.current;
    if (timeoutID.current && !isSSR$2) {
      window.clearTimeout(timeoutID.current);
      timeoutID.current = null;
    } else {
      for (const r2 of retainables) {
        updateRetainCount$2(store, r2, 1);
      }
    }
    return () => {
      for (const r2 of retainables) {
        updateRetainCount$2(store, r2, -1);
      }
    };
  }, [storeRef, ...retainables]);
  const timeoutID = useRef$3();
  const previousRetainables = Recoil_usePrevious(retainables);
  if (!isSSR$2 && (previousRetainables === void 0 || !Recoil_shallowArrayEqual(previousRetainables, retainables))) {
    const store = storeRef.current;
    for (const r2 of retainables) {
      updateRetainCount$2(store, r2, 1);
    }
    if (previousRetainables) {
      for (const r2 of previousRetainables) {
        updateRetainCount$2(store, r2, -1);
      }
    }
    if (timeoutID.current) {
      window.clearTimeout(timeoutID.current);
    }
    timeoutID.current = window.setTimeout(() => {
      timeoutID.current = null;
      for (const r2 of retainables) {
        updateRetainCount$2(store, r2, -1);
      }
    }, SUSPENSE_TIMEOUT_MS$1);
  }
}
var Recoil_useRetain = useRetain;
function useComponentName() {
  return "<component name not available>";
}
var Recoil_useComponentName = useComponentName;
const {
  batchUpdates: batchUpdates$2
} = Recoil_Batching;
const {
  DEFAULT_VALUE: DEFAULT_VALUE$2
} = Recoil_Node;
const {
  currentRendererSupportsUseSyncExternalStore: currentRendererSupportsUseSyncExternalStore$1,
  reactMode: reactMode$3,
  useMutableSource: useMutableSource$1,
  useSyncExternalStore: useSyncExternalStore$1
} = Recoil_ReactMode;
const {
  useRecoilMutableSource: useRecoilMutableSource$1,
  useStoreRef: useStoreRef$2
} = Recoil_RecoilRoot;
const {
  AbstractRecoilValue: AbstractRecoilValue$3,
  getRecoilValueAsLoadable: getRecoilValueAsLoadable$2,
  setRecoilValue: setRecoilValue$2,
  setUnvalidatedRecoilValue: setUnvalidatedRecoilValue$2,
  subscribeToRecoilValue: subscribeToRecoilValue$1
} = Recoil_RecoilValueInterface;
const {
  useCallback: useCallback$1$1,
  useEffect: useEffect$3,
  useMemo: useMemo$1$1,
  useRef: useRef$4,
  useState: useState$1
} = React;
const {
  setByAddingToSet: setByAddingToSet$2
} = Recoil_CopyOnWrite;
const {
  isSSR: isSSR$3
} = Recoil_Environment;
function handleLoadable(loadable, recoilValue, storeRef) {
  if (loadable.state === "hasValue") {
    return loadable.contents;
  } else if (loadable.state === "loading") {
    const promise = new Promise((resolve) => {
      const suspendedComponentResolvers = storeRef.current.getState().suspendedComponentResolvers;
      suspendedComponentResolvers.add(resolve);
      if (isSSR$3 && Recoil_isPromise(loadable.contents)) {
        loadable.contents.finally(() => {
          suspendedComponentResolvers.delete(resolve);
        });
      }
    });
    throw promise;
  } else if (loadable.state === "hasError") {
    throw loadable.contents;
  } else {
    throw Recoil_err(`Invalid value of loadable atom "${recoilValue.key}"`);
  }
}
function useRecoilInterface_DEPRECATED() {
  const componentName = Recoil_useComponentName();
  const storeRef = useStoreRef$2();
  const [, forceUpdate] = useState$1([]);
  const recoilValuesUsed = useRef$4(/* @__PURE__ */ new Set());
  recoilValuesUsed.current = /* @__PURE__ */ new Set();
  const previousSubscriptions = useRef$4(/* @__PURE__ */ new Set());
  const subscriptions = useRef$4(/* @__PURE__ */ new Map());
  const unsubscribeFrom = useCallback$1$1((key) => {
    const sub = subscriptions.current.get(key);
    if (sub) {
      sub.release();
      subscriptions.current.delete(key);
    }
  }, [subscriptions]);
  const updateState = useCallback$1$1((_state, key) => {
    if (subscriptions.current.has(key)) {
      forceUpdate([]);
    }
  }, []);
  useEffect$3(() => {
    const store = storeRef.current;
    Recoil_differenceSets(recoilValuesUsed.current, previousSubscriptions.current).forEach((key) => {
      if (subscriptions.current.has(key)) {
        return;
      }
      const sub = subscribeToRecoilValue$1(store, new AbstractRecoilValue$3(key), (state2) => updateState(state2, key), componentName);
      subscriptions.current.set(key, sub);
      const state = store.getState();
      if (state.nextTree) {
        store.getState().queuedComponentCallbacks_DEPRECATED.push(() => {
          updateState(store.getState(), key);
        });
      } else {
        updateState(store.getState(), key);
      }
    });
    Recoil_differenceSets(previousSubscriptions.current, recoilValuesUsed.current).forEach((key) => {
      unsubscribeFrom(key);
    });
    previousSubscriptions.current = recoilValuesUsed.current;
  });
  useEffect$3(() => {
    const currentSubscriptions = subscriptions.current;
    Recoil_differenceSets(recoilValuesUsed.current, new Set(currentSubscriptions.keys())).forEach((key) => {
      const sub = subscribeToRecoilValue$1(storeRef.current, new AbstractRecoilValue$3(key), (state) => updateState(state, key), componentName);
      currentSubscriptions.set(key, sub);
    });
    return () => currentSubscriptions.forEach((_2, key) => unsubscribeFrom(key));
  }, [componentName, storeRef, unsubscribeFrom, updateState]);
  return useMemo$1$1(() => {
    function useSetRecoilState2(recoilState) {
      return (newValueOrUpdater) => {
        setRecoilValue$2(storeRef.current, recoilState, newValueOrUpdater);
      };
    }
    function useResetRecoilState2(recoilState) {
      return () => setRecoilValue$2(storeRef.current, recoilState, DEFAULT_VALUE$2);
    }
    function useRecoilValueLoadable2(recoilValue) {
      var _storeState$nextTree;
      if (!recoilValuesUsed.current.has(recoilValue.key)) {
        recoilValuesUsed.current = setByAddingToSet$2(recoilValuesUsed.current, recoilValue.key);
      }
      const storeState = storeRef.current.getState();
      return getRecoilValueAsLoadable$2(storeRef.current, recoilValue, reactMode$3().early ? (_storeState$nextTree = storeState.nextTree) !== null && _storeState$nextTree !== void 0 ? _storeState$nextTree : storeState.currentTree : storeState.currentTree);
    }
    function useRecoilValue2(recoilValue) {
      const loadable = useRecoilValueLoadable2(recoilValue);
      return handleLoadable(loadable, recoilValue, storeRef);
    }
    function useRecoilState2(recoilState) {
      return [useRecoilValue2(recoilState), useSetRecoilState2(recoilState)];
    }
    function useRecoilStateLoadable2(recoilState) {
      return [useRecoilValueLoadable2(recoilState), useSetRecoilState2(recoilState)];
    }
    return {
      getRecoilValue: useRecoilValue2,
      getRecoilValueLoadable: useRecoilValueLoadable2,
      getRecoilState: useRecoilState2,
      getRecoilStateLoadable: useRecoilStateLoadable2,
      getSetRecoilState: useSetRecoilState2,
      getResetRecoilState: useResetRecoilState2
    };
  }, [recoilValuesUsed, storeRef]);
}
const recoilComponentGetRecoilValueCount_FOR_TESTING = {
  current: 0
};
function useRecoilValueLoadable_SYNC_EXTERNAL_STORE(recoilValue) {
  const storeRef = useStoreRef$2();
  const componentName = Recoil_useComponentName();
  const getSnapshot = useCallback$1$1(() => {
    var _storeState$nextTree2;
    const store = storeRef.current;
    const storeState = store.getState();
    const treeState = reactMode$3().early ? (_storeState$nextTree2 = storeState.nextTree) !== null && _storeState$nextTree2 !== void 0 ? _storeState$nextTree2 : storeState.currentTree : storeState.currentTree;
    const loadable = getRecoilValueAsLoadable$2(store, recoilValue, treeState);
    return {
      loadable,
      key: recoilValue.key
    };
  }, [storeRef, recoilValue]);
  const memoizePreviousSnapshot = useCallback$1$1((getState) => {
    let prevState;
    return () => {
      var _prevState, _prevState2;
      const nextState = getState();
      if ((_prevState = prevState) !== null && _prevState !== void 0 && _prevState.loadable.is(nextState.loadable) && ((_prevState2 = prevState) === null || _prevState2 === void 0 ? void 0 : _prevState2.key) === nextState.key) {
        return prevState;
      }
      prevState = nextState;
      return nextState;
    };
  }, []);
  const getMemoizedSnapshot = useMemo$1$1(() => memoizePreviousSnapshot(getSnapshot), [getSnapshot, memoizePreviousSnapshot]);
  const subscribe = useCallback$1$1((notify2) => {
    const store = storeRef.current;
    const subscription = subscribeToRecoilValue$1(store, recoilValue, notify2, componentName);
    return subscription.release;
  }, [storeRef, recoilValue, componentName]);
  return useSyncExternalStore$1(
    subscribe,
    getMemoizedSnapshot,
    // getSnapshot()
    getMemoizedSnapshot
    // getServerSnapshot() for SSR support
  ).loadable;
}
function useRecoilValueLoadable_MUTABLE_SOURCE(recoilValue) {
  const storeRef = useStoreRef$2();
  const getLoadable = useCallback$1$1(() => {
    var _storeState$nextTree3;
    const store = storeRef.current;
    const storeState = store.getState();
    const treeState = reactMode$3().early ? (_storeState$nextTree3 = storeState.nextTree) !== null && _storeState$nextTree3 !== void 0 ? _storeState$nextTree3 : storeState.currentTree : storeState.currentTree;
    return getRecoilValueAsLoadable$2(store, recoilValue, treeState);
  }, [storeRef, recoilValue]);
  const getLoadableWithTesting = useCallback$1$1(() => {
    return getLoadable();
  }, [getLoadable]);
  const componentName = Recoil_useComponentName();
  const subscribe = useCallback$1$1((_storeState, notify2) => {
    const store = storeRef.current;
    const subscription = subscribeToRecoilValue$1(store, recoilValue, () => {
      if (!Recoil_gkx("recoil_suppress_rerender_in_callback")) {
        return notify2();
      }
      const newLoadable = getLoadable();
      if (!prevLoadableRef.current.is(newLoadable)) {
        notify2();
      }
      prevLoadableRef.current = newLoadable;
    }, componentName);
    return subscription.release;
  }, [storeRef, recoilValue, componentName, getLoadable]);
  const source = useRecoilMutableSource$1();
  if (source == null) {
    throw Recoil_err("Recoil hooks must be used in components contained within a <RecoilRoot> component.");
  }
  const loadable = useMutableSource$1(source, getLoadableWithTesting, subscribe);
  const prevLoadableRef = useRef$4(loadable);
  useEffect$3(() => {
    prevLoadableRef.current = loadable;
  });
  return loadable;
}
function useRecoilValueLoadable_TRANSITION_SUPPORT(recoilValue) {
  const storeRef = useStoreRef$2();
  const componentName = Recoil_useComponentName();
  const getLoadable = useCallback$1$1(() => {
    var _storeState$nextTree4;
    const store = storeRef.current;
    const storeState = store.getState();
    const treeState = reactMode$3().early ? (_storeState$nextTree4 = storeState.nextTree) !== null && _storeState$nextTree4 !== void 0 ? _storeState$nextTree4 : storeState.currentTree : storeState.currentTree;
    return getRecoilValueAsLoadable$2(store, recoilValue, treeState);
  }, [storeRef, recoilValue]);
  const getState = useCallback$1$1(() => ({
    loadable: getLoadable(),
    key: recoilValue.key
  }), [getLoadable, recoilValue.key]);
  const updateState = useCallback$1$1((prevState) => {
    const nextState = getState();
    return prevState.loadable.is(nextState.loadable) && prevState.key === nextState.key ? prevState : nextState;
  }, [getState]);
  useEffect$3(() => {
    const subscription = subscribeToRecoilValue$1(storeRef.current, recoilValue, (_state) => {
      setState(updateState);
    }, componentName);
    setState(updateState);
    return subscription.release;
  }, [componentName, recoilValue, storeRef, updateState]);
  const [state, setState] = useState$1(getState);
  return state.key !== recoilValue.key ? getState().loadable : state.loadable;
}
function useRecoilValueLoadable_LEGACY(recoilValue) {
  const storeRef = useStoreRef$2();
  const [, forceUpdate] = useState$1([]);
  const componentName = Recoil_useComponentName();
  const getLoadable = useCallback$1$1(() => {
    var _storeState$nextTree5;
    const store = storeRef.current;
    const storeState = store.getState();
    const treeState = reactMode$3().early ? (_storeState$nextTree5 = storeState.nextTree) !== null && _storeState$nextTree5 !== void 0 ? _storeState$nextTree5 : storeState.currentTree : storeState.currentTree;
    return getRecoilValueAsLoadable$2(store, recoilValue, treeState);
  }, [storeRef, recoilValue]);
  const loadable = getLoadable();
  const prevLoadableRef = useRef$4(loadable);
  useEffect$3(() => {
    prevLoadableRef.current = loadable;
  });
  useEffect$3(() => {
    const store = storeRef.current;
    const storeState = store.getState();
    const subscription = subscribeToRecoilValue$1(store, recoilValue, (_state) => {
      var _prevLoadableRef$curr;
      if (!Recoil_gkx("recoil_suppress_rerender_in_callback")) {
        return forceUpdate([]);
      }
      const newLoadable = getLoadable();
      if (!((_prevLoadableRef$curr = prevLoadableRef.current) !== null && _prevLoadableRef$curr !== void 0 && _prevLoadableRef$curr.is(newLoadable))) {
        forceUpdate(newLoadable);
      }
      prevLoadableRef.current = newLoadable;
    }, componentName);
    if (storeState.nextTree) {
      store.getState().queuedComponentCallbacks_DEPRECATED.push(() => {
        prevLoadableRef.current = null;
        forceUpdate([]);
      });
    } else {
      var _prevLoadableRef$curr2;
      if (!Recoil_gkx("recoil_suppress_rerender_in_callback")) {
        return forceUpdate([]);
      }
      const newLoadable = getLoadable();
      if (!((_prevLoadableRef$curr2 = prevLoadableRef.current) !== null && _prevLoadableRef$curr2 !== void 0 && _prevLoadableRef$curr2.is(newLoadable))) {
        forceUpdate(newLoadable);
      }
      prevLoadableRef.current = newLoadable;
    }
    return subscription.release;
  }, [componentName, getLoadable, recoilValue, storeRef]);
  return loadable;
}
function useRecoilValueLoadable(recoilValue) {
  if (Recoil_gkx("recoil_memory_managament_2020")) {
    Recoil_useRetain(recoilValue);
  }
  return {
    TRANSITION_SUPPORT: useRecoilValueLoadable_TRANSITION_SUPPORT,
    // Recoil will attemp to detect if `useSyncExternalStore()` is supported with
    // `reactMode()` before calling it.  However, sometimes the host React
    // environment supports it but uses additional React renderers (such as with
    // `react-three-fiber`) which do not.  While this is technically a user issue
    // by using a renderer with React 18+ that doesn't fully support React 18 we
    // don't want to break users if it can be avoided. As the current renderer can
    // change at runtime, we need to dynamically check and fallback if necessary.
    SYNC_EXTERNAL_STORE: currentRendererSupportsUseSyncExternalStore$1() ? useRecoilValueLoadable_SYNC_EXTERNAL_STORE : useRecoilValueLoadable_TRANSITION_SUPPORT,
    MUTABLE_SOURCE: useRecoilValueLoadable_MUTABLE_SOURCE,
    LEGACY: useRecoilValueLoadable_LEGACY
  }[reactMode$3().mode](recoilValue);
}
function useRecoilValue(recoilValue) {
  const storeRef = useStoreRef$2();
  const loadable = useRecoilValueLoadable(recoilValue);
  return handleLoadable(loadable, recoilValue, storeRef);
}
function useSetRecoilState(recoilState) {
  const storeRef = useStoreRef$2();
  return useCallback$1$1((newValueOrUpdater) => {
    setRecoilValue$2(storeRef.current, recoilState, newValueOrUpdater);
  }, [storeRef, recoilState]);
}
function useResetRecoilState(recoilState) {
  const storeRef = useStoreRef$2();
  return useCallback$1$1(() => {
    setRecoilValue$2(storeRef.current, recoilState, DEFAULT_VALUE$2);
  }, [storeRef, recoilState]);
}
function useRecoilState(recoilState) {
  return [useRecoilValue(recoilState), useSetRecoilState(recoilState)];
}
function useRecoilStateLoadable(recoilState) {
  return [useRecoilValueLoadable(recoilState), useSetRecoilState(recoilState)];
}
function useSetUnvalidatedAtomValues() {
  const storeRef = useStoreRef$2();
  return (values2, transactionMetadata = {}) => {
    batchUpdates$2(() => {
      storeRef.current.addTransactionMetadata(transactionMetadata);
      values2.forEach((value, key) => setUnvalidatedRecoilValue$2(storeRef.current, new AbstractRecoilValue$3(key), value));
    });
  };
}
function useRecoilValueLoadable_TRANSITION_SUPPORT_UNSTABLE(recoilValue) {
  if (Recoil_gkx("recoil_memory_managament_2020")) {
    Recoil_useRetain(recoilValue);
  }
  return useRecoilValueLoadable_TRANSITION_SUPPORT(recoilValue);
}
function useRecoilValue_TRANSITION_SUPPORT_UNSTABLE(recoilValue) {
  const storeRef = useStoreRef$2();
  const loadable = useRecoilValueLoadable_TRANSITION_SUPPORT_UNSTABLE(recoilValue);
  return handleLoadable(loadable, recoilValue, storeRef);
}
function useRecoilState_TRANSITION_SUPPORT_UNSTABLE(recoilState) {
  return [useRecoilValue_TRANSITION_SUPPORT_UNSTABLE(recoilState), useSetRecoilState(recoilState)];
}
var Recoil_Hooks = {
  recoilComponentGetRecoilValueCount_FOR_TESTING,
  useRecoilInterface: useRecoilInterface_DEPRECATED,
  useRecoilState,
  useRecoilStateLoadable,
  useRecoilValue,
  useRecoilValueLoadable,
  useResetRecoilState,
  useSetRecoilState,
  useSetUnvalidatedAtomValues,
  useRecoilValueLoadable_TRANSITION_SUPPORT_UNSTABLE,
  useRecoilValue_TRANSITION_SUPPORT_UNSTABLE,
  useRecoilState_TRANSITION_SUPPORT_UNSTABLE
};
function filterMap(map, callback) {
  const result = /* @__PURE__ */ new Map();
  for (const [key, value] of map) {
    if (callback(value, key)) {
      result.set(key, value);
    }
  }
  return result;
}
var Recoil_filterMap = filterMap;
function filterSet(set, callback) {
  const result = /* @__PURE__ */ new Set();
  for (const value of set) {
    if (callback(value)) {
      result.add(value);
    }
  }
  return result;
}
var Recoil_filterSet = filterSet;
function mergeMaps(...maps) {
  const result = /* @__PURE__ */ new Map();
  for (let i2 = 0; i2 < maps.length; i2++) {
    const iterator = maps[i2].keys();
    let nextKey;
    while (!(nextKey = iterator.next()).done) {
      result.set(nextKey.value, maps[i2].get(nextKey.value));
    }
  }
  return result;
}
var Recoil_mergeMaps = mergeMaps;
const {
  batchUpdates: batchUpdates$3
} = Recoil_Batching;
const {
  DEFAULT_VALUE: DEFAULT_VALUE$3,
  getNode: getNode$4,
  nodes: nodes$1
} = Recoil_Node;
const {
  useStoreRef: useStoreRef$3
} = Recoil_RecoilRoot;
const {
  AbstractRecoilValue: AbstractRecoilValue$4,
  setRecoilValueLoadable: setRecoilValueLoadable$1
} = Recoil_RecoilValueInterface;
const {
  SUSPENSE_TIMEOUT_MS: SUSPENSE_TIMEOUT_MS$2
} = Recoil_Retention;
const {
  cloneSnapshot: cloneSnapshot$1
} = Recoil_Snapshot$1;
const {
  useCallback: useCallback$2,
  useEffect: useEffect$4,
  useRef: useRef$5,
  useState: useState$2
} = React;
const {
  isSSR: isSSR$4
} = Recoil_Environment;
function useTransactionSubscription(callback) {
  const storeRef = useStoreRef$3();
  useEffect$4(() => {
    const sub = storeRef.current.subscribeToTransactions(callback);
    return sub.release;
  }, [callback, storeRef]);
}
function externallyVisibleAtomValuesInState(state) {
  const atomValues = state.atomValues.toMap();
  const persistedAtomContentsValues = Recoil_mapMap(Recoil_filterMap(atomValues, (v2, k2) => {
    const node = getNode$4(k2);
    const persistence = node.persistence_UNSTABLE;
    return persistence != null && persistence.type !== "none" && v2.state === "hasValue";
  }), (v2) => v2.contents);
  return Recoil_mergeMaps(state.nonvalidatedAtoms.toMap(), persistedAtomContentsValues);
}
function useTransactionObservation_DEPRECATED(callback) {
  useTransactionSubscription(useCallback$2((store) => {
    let previousTree = store.getState().previousTree;
    const currentTree = store.getState().currentTree;
    if (!previousTree) {
      previousTree = store.getState().currentTree;
    }
    const atomValues = externallyVisibleAtomValuesInState(currentTree);
    const previousAtomValues = externallyVisibleAtomValuesInState(previousTree);
    const atomInfo = Recoil_mapMap(nodes$1, (node) => {
      var _node$persistence_UNS, _node$persistence_UNS2, _node$persistence_UNS3, _node$persistence_UNS4;
      return {
        persistence_UNSTABLE: {
          type: (_node$persistence_UNS = (_node$persistence_UNS2 = node.persistence_UNSTABLE) === null || _node$persistence_UNS2 === void 0 ? void 0 : _node$persistence_UNS2.type) !== null && _node$persistence_UNS !== void 0 ? _node$persistence_UNS : "none",
          backButton: (_node$persistence_UNS3 = (_node$persistence_UNS4 = node.persistence_UNSTABLE) === null || _node$persistence_UNS4 === void 0 ? void 0 : _node$persistence_UNS4.backButton) !== null && _node$persistence_UNS3 !== void 0 ? _node$persistence_UNS3 : false
        }
      };
    });
    const modifiedAtoms = Recoil_filterSet(currentTree.dirtyAtoms, (k2) => atomValues.has(k2) || previousAtomValues.has(k2));
    callback({
      atomValues,
      previousAtomValues,
      atomInfo,
      modifiedAtoms,
      transactionMetadata: {
        ...currentTree.transactionMetadata
      }
    });
  }, [callback]));
}
function useRecoilTransactionObserver(callback) {
  useTransactionSubscription(useCallback$2((store) => {
    const snapshot = cloneSnapshot$1(store, "latest");
    const previousSnapshot = cloneSnapshot$1(store, "previous");
    callback({
      snapshot,
      previousSnapshot
    });
  }, [callback]));
}
function useRecoilSnapshot() {
  const storeRef = useStoreRef$3();
  const [snapshot, setSnapshot] = useState$2(() => cloneSnapshot$1(storeRef.current));
  const previousSnapshot = Recoil_usePrevious(snapshot);
  const timeoutID = useRef$5();
  const releaseRef = useRef$5();
  useTransactionSubscription(useCallback$2((store) => setSnapshot(cloneSnapshot$1(store)), []));
  useEffect$4(() => {
    const release = snapshot.retain();
    if (timeoutID.current && !isSSR$4) {
      var _releaseRef$current;
      window.clearTimeout(timeoutID.current);
      timeoutID.current = null;
      (_releaseRef$current = releaseRef.current) === null || _releaseRef$current === void 0 ? void 0 : _releaseRef$current.call(releaseRef);
      releaseRef.current = null;
    }
    return () => {
      window.setTimeout(release, 10);
    };
  }, [snapshot]);
  if (previousSnapshot !== snapshot && !isSSR$4) {
    if (timeoutID.current) {
      var _releaseRef$current2;
      window.clearTimeout(timeoutID.current);
      timeoutID.current = null;
      (_releaseRef$current2 = releaseRef.current) === null || _releaseRef$current2 === void 0 ? void 0 : _releaseRef$current2.call(releaseRef);
      releaseRef.current = null;
    }
    releaseRef.current = snapshot.retain();
    timeoutID.current = window.setTimeout(() => {
      var _releaseRef$current3;
      timeoutID.current = null;
      (_releaseRef$current3 = releaseRef.current) === null || _releaseRef$current3 === void 0 ? void 0 : _releaseRef$current3.call(releaseRef);
      releaseRef.current = null;
    }, SUSPENSE_TIMEOUT_MS$2);
  }
  return snapshot;
}
function gotoSnapshot(store, snapshot) {
  var _storeState$nextTree;
  const storeState = store.getState();
  const prev = (_storeState$nextTree = storeState.nextTree) !== null && _storeState$nextTree !== void 0 ? _storeState$nextTree : storeState.currentTree;
  const next = snapshot.getStore_INTERNAL().getState().currentTree;
  batchUpdates$3(() => {
    const keysToUpdate = /* @__PURE__ */ new Set();
    for (const keys of [prev.atomValues.keys(), next.atomValues.keys()]) {
      for (const key of keys) {
        var _prev$atomValues$get, _next$atomValues$get;
        if (((_prev$atomValues$get = prev.atomValues.get(key)) === null || _prev$atomValues$get === void 0 ? void 0 : _prev$atomValues$get.contents) !== ((_next$atomValues$get = next.atomValues.get(key)) === null || _next$atomValues$get === void 0 ? void 0 : _next$atomValues$get.contents) && getNode$4(key).shouldRestoreFromSnapshots) {
          keysToUpdate.add(key);
        }
      }
    }
    keysToUpdate.forEach((key) => {
      setRecoilValueLoadable$1(store, new AbstractRecoilValue$4(key), next.atomValues.has(key) ? Recoil_nullthrows(next.atomValues.get(key)) : DEFAULT_VALUE$3);
    });
    store.replaceState((state) => ({
      ...state,
      stateID: snapshot.getID()
    }));
  });
}
function useGotoRecoilSnapshot() {
  const storeRef = useStoreRef$3();
  return useCallback$2((snapshot) => gotoSnapshot(storeRef.current, snapshot), [storeRef]);
}
var Recoil_SnapshotHooks = {
  useRecoilSnapshot,
  gotoSnapshot,
  useGotoRecoilSnapshot,
  useRecoilTransactionObserver,
  useTransactionObservation_DEPRECATED,
  useTransactionSubscription_DEPRECATED: useTransactionSubscription
};
const {
  peekNodeInfo: peekNodeInfo$2
} = Recoil_FunctionalCore;
const {
  useStoreRef: useStoreRef$4
} = Recoil_RecoilRoot;
function useGetRecoilValueInfo() {
  const storeRef = useStoreRef$4();
  return ({
    key
  }) => peekNodeInfo$2(storeRef.current, storeRef.current.getState().currentTree, key);
}
var Recoil_useGetRecoilValueInfo = useGetRecoilValueInfo;
const {
  reactMode: reactMode$4
} = Recoil_ReactMode;
const {
  RecoilRoot: RecoilRoot$1,
  useStoreRef: useStoreRef$5
} = Recoil_RecoilRoot;
const {
  useMemo: useMemo$2
} = React;
function useRecoilBridgeAcrossReactRoots() {
  if (reactMode$4().mode === "MUTABLE_SOURCE") {
    console.warn("Warning: There are known issues using useRecoilBridgeAcrossReactRoots() in recoil_mutable_source rendering mode.  Please consider upgrading to recoil_sync_external_store mode.");
  }
  const store = useStoreRef$5().current;
  return useMemo$2(() => {
    function RecoilBridge({
      children
    }) {
      return /* @__PURE__ */ React.createElement(RecoilRoot$1, {
        store_INTERNAL: store
      }, children);
    }
    return RecoilBridge;
  }, [store]);
}
var Recoil_useRecoilBridgeAcrossReactRoots = useRecoilBridgeAcrossReactRoots;
const {
  loadableWithValue: loadableWithValue$1
} = Recoil_Loadable$1;
const {
  initializeNode: initializeNode$3
} = Recoil_FunctionalCore;
const {
  DEFAULT_VALUE: DEFAULT_VALUE$4,
  getNode: getNode$5
} = Recoil_Node;
const {
  copyTreeState: copyTreeState$1,
  getRecoilValueAsLoadable: getRecoilValueAsLoadable$3,
  invalidateDownstreams: invalidateDownstreams$1,
  writeLoadableToTreeState: writeLoadableToTreeState$1
} = Recoil_RecoilValueInterface;
function isAtom(recoilValue) {
  return getNode$5(recoilValue.key).nodeType === "atom";
}
class TransactionInterfaceImpl {
  constructor(store, treeState) {
    _defineProperty$1(this, "_store", void 0);
    _defineProperty$1(this, "_treeState", void 0);
    _defineProperty$1(this, "_changes", void 0);
    _defineProperty$1(this, "get", (recoilValue) => {
      if (this._changes.has(recoilValue.key)) {
        return this._changes.get(recoilValue.key);
      }
      if (!isAtom(recoilValue)) {
        throw Recoil_err("Reading selectors within atomicUpdate is not supported");
      }
      const loadable = getRecoilValueAsLoadable$3(this._store, recoilValue, this._treeState);
      if (loadable.state === "hasValue") {
        return loadable.contents;
      } else if (loadable.state === "hasError") {
        throw loadable.contents;
      } else {
        throw Recoil_err(`Expected Recoil atom ${recoilValue.key} to have a value, but it is in a loading state.`);
      }
    });
    _defineProperty$1(this, "set", (recoilState, valueOrUpdater) => {
      if (!isAtom(recoilState)) {
        throw Recoil_err("Setting selectors within atomicUpdate is not supported");
      }
      if (typeof valueOrUpdater === "function") {
        const current = this.get(recoilState);
        this._changes.set(recoilState.key, valueOrUpdater(current));
      } else {
        initializeNode$3(this._store, recoilState.key, "set");
        this._changes.set(recoilState.key, valueOrUpdater);
      }
    });
    _defineProperty$1(this, "reset", (recoilState) => {
      this.set(recoilState, DEFAULT_VALUE$4);
    });
    this._store = store;
    this._treeState = treeState;
    this._changes = /* @__PURE__ */ new Map();
  }
  // Allow destructing
  // eslint-disable-next-line fb-www/extra-arrow-initializer
  newTreeState_INTERNAL() {
    if (this._changes.size === 0) {
      return this._treeState;
    }
    const newState = copyTreeState$1(this._treeState);
    for (const [k2, v2] of this._changes) {
      writeLoadableToTreeState$1(newState, k2, loadableWithValue$1(v2));
    }
    invalidateDownstreams$1(this._store, newState);
    return newState;
  }
}
function atomicUpdater(store) {
  return (fn2) => {
    store.replaceState((treeState) => {
      const changeset = new TransactionInterfaceImpl(store, treeState);
      fn2(changeset);
      return changeset.newTreeState_INTERNAL();
    });
  };
}
var Recoil_AtomicUpdates = {
  atomicUpdater
};
var Recoil_AtomicUpdates_1 = Recoil_AtomicUpdates.atomicUpdater;
var Recoil_AtomicUpdates$1 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  atomicUpdater: Recoil_AtomicUpdates_1
});
function invariant$2(condition, message) {
  if (!condition) {
    throw new Error(message);
  }
}
var invariant_1 = invariant$2;
var Recoil_invariant = invariant_1;
const {
  atomicUpdater: atomicUpdater$1
} = Recoil_AtomicUpdates$1;
const {
  batchUpdates: batchUpdates$4
} = Recoil_Batching;
const {
  DEFAULT_VALUE: DEFAULT_VALUE$5
} = Recoil_Node;
const {
  useStoreRef: useStoreRef$6
} = Recoil_RecoilRoot;
const {
  refreshRecoilValue: refreshRecoilValue$1,
  setRecoilValue: setRecoilValue$3
} = Recoil_RecoilValueInterface;
const {
  cloneSnapshot: cloneSnapshot$2
} = Recoil_Snapshot$1;
const {
  gotoSnapshot: gotoSnapshot$1
} = Recoil_SnapshotHooks;
const {
  useCallback: useCallback$3
} = React;
class Sentinel {
}
const SENTINEL = new Sentinel();
function recoilCallback(store, fn2, args, extraInterface) {
  let ret = SENTINEL;
  let releaseSnapshot;
  batchUpdates$4(() => {
    const errMsg = "useRecoilCallback() expects a function that returns a function: it accepts a function of the type (RecoilInterface) => (Args) => ReturnType and returns a callback function (Args) => ReturnType, where RecoilInterface is an object {snapshot, set, ...} and Args and ReturnType are the argument and return types of the callback you want to create.  Please see the docs at recoiljs.org for details.";
    if (typeof fn2 !== "function") {
      throw Recoil_err(errMsg);
    }
    const callbackInterface = Recoil_lazyProxy({
      ...extraInterface !== null && extraInterface !== void 0 ? extraInterface : {},
      // flowlint-line unclear-type:off
      // $FlowFixMe[missing-local-annot]
      set: (node, newValue) => setRecoilValue$3(store, node, newValue),
      // $FlowFixMe[missing-local-annot]
      reset: (node) => setRecoilValue$3(store, node, DEFAULT_VALUE$5),
      // $FlowFixMe[missing-local-annot]
      refresh: (node) => refreshRecoilValue$1(store, node),
      gotoSnapshot: (snapshot) => gotoSnapshot$1(store, snapshot),
      transact_UNSTABLE: (transaction) => atomicUpdater$1(store)(transaction)
    }, {
      snapshot: () => {
        const snapshot = cloneSnapshot$2(store);
        releaseSnapshot = snapshot.retain();
        return snapshot;
      }
    });
    const callback = fn2(callbackInterface);
    if (typeof callback !== "function") {
      throw Recoil_err(errMsg);
    }
    ret = callback(...args);
  });
  !!(ret instanceof Sentinel) ? Recoil_invariant(false) : void 0;
  if (Recoil_isPromise(ret)) {
    ret = ret.finally(() => {
      var _releaseSnapshot;
      (_releaseSnapshot = releaseSnapshot) === null || _releaseSnapshot === void 0 ? void 0 : _releaseSnapshot();
    });
  } else {
    var _releaseSnapshot2;
    (_releaseSnapshot2 = releaseSnapshot) === null || _releaseSnapshot2 === void 0 ? void 0 : _releaseSnapshot2();
  }
  return ret;
}
function useRecoilCallback(fn2, deps) {
  const storeRef = useStoreRef$6();
  return useCallback$3(
    // $FlowIssue[incompatible-call]
    (...args) => {
      return recoilCallback(storeRef.current, fn2, args);
    },
    deps != null ? [...deps, storeRef] : void 0
    // eslint-disable-line fb-www/react-hooks-deps
  );
}
var Recoil_useRecoilCallback = {
  recoilCallback,
  useRecoilCallback
};
const {
  useStoreRef: useStoreRef$7
} = Recoil_RecoilRoot;
const {
  refreshRecoilValue: refreshRecoilValue$2
} = Recoil_RecoilValueInterface;
const {
  useCallback: useCallback$4
} = React;
function useRecoilRefresher(recoilValue) {
  const storeRef = useStoreRef$7();
  return useCallback$4(() => {
    const store = storeRef.current;
    refreshRecoilValue$2(store, recoilValue);
  }, [recoilValue, storeRef]);
}
var Recoil_useRecoilRefresher = useRecoilRefresher;
const {
  atomicUpdater: atomicUpdater$2
} = Recoil_AtomicUpdates$1;
const {
  useStoreRef: useStoreRef$8
} = Recoil_RecoilRoot;
const {
  useMemo: useMemo$3
} = React;
function useRecoilTransaction(fn2, deps) {
  const storeRef = useStoreRef$8();
  return useMemo$3(
    () => (...args) => {
      const atomicUpdate = atomicUpdater$2(storeRef.current);
      atomicUpdate((transactionInterface) => {
        fn2(transactionInterface)(...args);
      });
    },
    deps != null ? [...deps, storeRef] : void 0
    // eslint-disable-line fb-www/react-hooks-deps
  );
}
var Recoil_useRecoilTransaction = useRecoilTransaction;
class WrappedValue {
  constructor(value) {
    _defineProperty$1(this, "value", void 0);
    this.value = value;
  }
}
var Recoil_Wrapper = {
  WrappedValue
};
var Recoil_Wrapper_1 = Recoil_Wrapper.WrappedValue;
var Recoil_Wrapper$1 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  WrappedValue: Recoil_Wrapper_1
});
const {
  isFastRefreshEnabled: isFastRefreshEnabled$2
} = Recoil_ReactMode;
class ChangedPathError extends Error {
}
class TreeCache {
  // $FlowIssue[unclear-type]
  constructor(options) {
    var _options$onHit, _options$onSet, _options$mapNodeValue;
    _defineProperty$1(this, "_name", void 0);
    _defineProperty$1(this, "_numLeafs", void 0);
    _defineProperty$1(this, "_root", void 0);
    _defineProperty$1(this, "_onHit", void 0);
    _defineProperty$1(this, "_onSet", void 0);
    _defineProperty$1(this, "_mapNodeValue", void 0);
    this._name = options === null || options === void 0 ? void 0 : options.name;
    this._numLeafs = 0;
    this._root = null;
    this._onHit = (_options$onHit = options === null || options === void 0 ? void 0 : options.onHit) !== null && _options$onHit !== void 0 ? _options$onHit : () => {
    };
    this._onSet = (_options$onSet = options === null || options === void 0 ? void 0 : options.onSet) !== null && _options$onSet !== void 0 ? _options$onSet : () => {
    };
    this._mapNodeValue = (_options$mapNodeValue = options === null || options === void 0 ? void 0 : options.mapNodeValue) !== null && _options$mapNodeValue !== void 0 ? _options$mapNodeValue : (val) => val;
  }
  size() {
    return this._numLeafs;
  }
  // $FlowIssue[unclear-type]
  root() {
    return this._root;
  }
  get(getNodeValue, handlers) {
    var _this$getLeafNode;
    return (_this$getLeafNode = this.getLeafNode(getNodeValue, handlers)) === null || _this$getLeafNode === void 0 ? void 0 : _this$getLeafNode.value;
  }
  getLeafNode(getNodeValue, handlers) {
    if (this._root == null) {
      return void 0;
    }
    let node = this._root;
    while (node) {
      handlers === null || handlers === void 0 ? void 0 : handlers.onNodeVisit(node);
      if (node.type === "leaf") {
        this._onHit(node);
        return node;
      }
      const nodeValue = this._mapNodeValue(getNodeValue(node.nodeKey));
      node = node.branches.get(nodeValue);
    }
    return void 0;
  }
  set(route, value, handlers) {
    const addLeaf = () => {
      var _node2, _node3, _this$_root2, _handlers$onNodeVisit2;
      let node;
      let branchKey;
      for (const [nodeKey, nodeValue] of route) {
        var _node, _handlers$onNodeVisit, _this$_root;
        const root = this._root;
        if ((root === null || root === void 0 ? void 0 : root.type) === "leaf") {
          throw this.invalidCacheError();
        }
        const parent = node;
        node = parent ? parent.branches.get(branchKey) : root;
        node = (_node = node) !== null && _node !== void 0 ? _node : {
          type: "branch",
          nodeKey,
          parent,
          branches: /* @__PURE__ */ new Map(),
          branchKey
        };
        if (node.type !== "branch" || node.nodeKey !== nodeKey) {
          throw this.invalidCacheError();
        }
        parent === null || parent === void 0 ? void 0 : parent.branches.set(branchKey, node);
        handlers === null || handlers === void 0 ? void 0 : (_handlers$onNodeVisit = handlers.onNodeVisit) === null || _handlers$onNodeVisit === void 0 ? void 0 : _handlers$onNodeVisit.call(handlers, node);
        branchKey = this._mapNodeValue(nodeValue);
        this._root = (_this$_root = this._root) !== null && _this$_root !== void 0 ? _this$_root : node;
      }
      const oldLeaf = node ? (_node2 = node) === null || _node2 === void 0 ? void 0 : _node2.branches.get(branchKey) : this._root;
      if (oldLeaf != null && (oldLeaf.type !== "leaf" || oldLeaf.branchKey !== branchKey)) {
        throw this.invalidCacheError();
      }
      const leafNode = {
        type: "leaf",
        value,
        parent: node,
        branchKey
      };
      (_node3 = node) === null || _node3 === void 0 ? void 0 : _node3.branches.set(branchKey, leafNode);
      this._root = (_this$_root2 = this._root) !== null && _this$_root2 !== void 0 ? _this$_root2 : leafNode;
      this._numLeafs++;
      this._onSet(leafNode);
      handlers === null || handlers === void 0 ? void 0 : (_handlers$onNodeVisit2 = handlers.onNodeVisit) === null || _handlers$onNodeVisit2 === void 0 ? void 0 : _handlers$onNodeVisit2.call(handlers, leafNode);
    };
    try {
      addLeaf();
    } catch (error) {
      if (error instanceof ChangedPathError) {
        this.clear();
        addLeaf();
      } else {
        throw error;
      }
    }
  }
  // Returns true if leaf was actually deleted from the tree
  delete(leaf) {
    const root = this.root();
    if (!root) {
      return false;
    }
    if (leaf === root) {
      this._root = null;
      this._numLeafs = 0;
      return true;
    }
    let node = leaf.parent;
    let branchKey = leaf.branchKey;
    while (node) {
      var _node4;
      node.branches.delete(branchKey);
      if (node === root) {
        if (node.branches.size === 0) {
          this._root = null;
          this._numLeafs = 0;
        } else {
          this._numLeafs--;
        }
        return true;
      }
      if (node.branches.size > 0) {
        break;
      }
      branchKey = (_node4 = node) === null || _node4 === void 0 ? void 0 : _node4.branchKey;
      node = node.parent;
    }
    for (; node !== root; node = node.parent) {
      if (node == null) {
        return false;
      }
    }
    this._numLeafs--;
    return true;
  }
  clear() {
    this._numLeafs = 0;
    this._root = null;
  }
  invalidCacheError() {
    const CHANGED_PATH_ERROR_MESSAGE = isFastRefreshEnabled$2() ? "Possible Fast Refresh module reload detected.  This may also be caused by an selector returning inconsistent values. Resetting cache." : "Invalid cache values.  This happens when selectors do not return consistent values for the same input dependency values.  That may also be caused when using Fast Refresh to change a selector implementation.  Resetting cache.";
    Recoil_recoverableViolation(CHANGED_PATH_ERROR_MESSAGE + (this._name != null ? ` - ${this._name}` : ""));
    throw new ChangedPathError();
  }
}
var Recoil_TreeCache = {
  TreeCache
};
var Recoil_TreeCache_1 = Recoil_TreeCache.TreeCache;
var Recoil_TreeCache$1 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  TreeCache: Recoil_TreeCache_1
});
class LRUCache {
  constructor(options) {
    var _options$mapKey;
    _defineProperty$1(this, "_maxSize", void 0);
    _defineProperty$1(this, "_size", void 0);
    _defineProperty$1(this, "_head", void 0);
    _defineProperty$1(this, "_tail", void 0);
    _defineProperty$1(this, "_map", void 0);
    _defineProperty$1(this, "_keyMapper", void 0);
    this._maxSize = options.maxSize;
    this._size = 0;
    this._head = null;
    this._tail = null;
    this._map = /* @__PURE__ */ new Map();
    this._keyMapper = (_options$mapKey = options.mapKey) !== null && _options$mapKey !== void 0 ? _options$mapKey : (v2) => v2;
  }
  head() {
    return this._head;
  }
  tail() {
    return this._tail;
  }
  size() {
    return this._size;
  }
  maxSize() {
    return this._maxSize;
  }
  has(key) {
    return this._map.has(this._keyMapper(key));
  }
  get(key) {
    const mappedKey = this._keyMapper(key);
    const node = this._map.get(mappedKey);
    if (!node) {
      return void 0;
    }
    this.set(key, node.value);
    return node.value;
  }
  set(key, val) {
    const mappedKey = this._keyMapper(key);
    const existingNode = this._map.get(mappedKey);
    if (existingNode) {
      this.delete(key);
    }
    const head = this.head();
    const node = {
      key,
      right: head,
      left: null,
      value: val
    };
    if (head) {
      head.left = node;
    } else {
      this._tail = node;
    }
    this._map.set(mappedKey, node);
    this._head = node;
    this._size++;
    this._maybeDeleteLRU();
  }
  _maybeDeleteLRU() {
    if (this.size() > this.maxSize()) {
      this.deleteLru();
    }
  }
  deleteLru() {
    const tail = this.tail();
    if (tail) {
      this.delete(tail.key);
    }
  }
  delete(key) {
    const mappedKey = this._keyMapper(key);
    if (!this._size || !this._map.has(mappedKey)) {
      return;
    }
    const node = Recoil_nullthrows(this._map.get(mappedKey));
    const right = node.right;
    const left = node.left;
    if (right) {
      right.left = node.left;
    }
    if (left) {
      left.right = node.right;
    }
    if (node === this.head()) {
      this._head = right;
    }
    if (node === this.tail()) {
      this._tail = left;
    }
    this._map.delete(mappedKey);
    this._size--;
  }
  clear() {
    this._size = 0;
    this._head = null;
    this._tail = null;
    this._map = /* @__PURE__ */ new Map();
  }
}
var Recoil_LRUCache = {
  LRUCache
};
var Recoil_LRUCache_1 = Recoil_LRUCache.LRUCache;
var Recoil_LRUCache$1 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  LRUCache: Recoil_LRUCache_1
});
const {
  LRUCache: LRUCache$1
} = Recoil_LRUCache$1;
const {
  TreeCache: TreeCache$1
} = Recoil_TreeCache$1;
function treeCacheLRU({
  name,
  maxSize,
  mapNodeValue = (v2) => v2
}) {
  const lruCache = new LRUCache$1({
    maxSize
  });
  const cache = new TreeCache$1({
    name,
    mapNodeValue,
    onHit: (node) => {
      lruCache.set(node, true);
    },
    onSet: (node) => {
      const lruNode = lruCache.tail();
      lruCache.set(node, true);
      if (lruNode && cache.size() > maxSize) {
        cache.delete(lruNode.key);
      }
    }
  });
  return cache;
}
var Recoil_treeCacheLRU = treeCacheLRU;
function stringify(x, opt, key) {
  if (typeof x === "string" && !x.includes('"') && !x.includes("\\")) {
    return `"${x}"`;
  }
  switch (typeof x) {
    case "undefined":
      return "";
    case "boolean":
      return x ? "true" : "false";
    case "number":
    case "symbol":
      return String(x);
    case "string":
      return JSON.stringify(x);
    case "function":
      if ((opt === null || opt === void 0 ? void 0 : opt.allowFunctions) !== true) {
        throw Recoil_err("Attempt to serialize function in a Recoil cache key");
      }
      return `__FUNCTION(${x.name})__`;
  }
  if (x === null) {
    return "null";
  }
  if (typeof x !== "object") {
    var _JSON$stringify;
    return (_JSON$stringify = JSON.stringify(x)) !== null && _JSON$stringify !== void 0 ? _JSON$stringify : "";
  }
  if (Recoil_isPromise(x)) {
    return "__PROMISE__";
  }
  if (Array.isArray(x)) {
    return `[${x.map((v2, i2) => stringify(v2, opt, i2.toString()))}]`;
  }
  if (typeof x.toJSON === "function") {
    return stringify(x.toJSON(key), opt, key);
  }
  if (x instanceof Map) {
    const obj = {};
    for (const [k2, v2] of x) {
      obj[typeof k2 === "string" ? k2 : stringify(k2, opt)] = v2;
    }
    return stringify(obj, opt, key);
  }
  if (x instanceof Set) {
    return stringify(
      // $FlowFixMe[missing-local-annot]
      Array.from(x).sort((a2, b2) => stringify(a2, opt).localeCompare(stringify(b2, opt))),
      opt,
      key
    );
  }
  if (Symbol !== void 0 && x[Symbol.iterator] != null && typeof x[Symbol.iterator] === "function") {
    return stringify(Array.from(x), opt, key);
  }
  return `{${Object.keys(x).filter((k2) => x[k2] !== void 0).sort().map((k2) => `${stringify(k2, opt)}:${stringify(x[k2], opt, k2)}`).join(",")}}`;
}
function stableStringify(x, opt = {
  allowFunctions: false
}) {
  return stringify(x, opt);
}
var Recoil_stableStringify = stableStringify;
const {
  TreeCache: TreeCache$2
} = Recoil_TreeCache$1;
const defaultPolicy = {
  equality: "reference",
  eviction: "keep-all",
  maxSize: Infinity
};
function treeCacheFromPolicy({
  equality = defaultPolicy.equality,
  eviction = defaultPolicy.eviction,
  maxSize = defaultPolicy.maxSize
} = defaultPolicy, name) {
  const valueMapper = getValueMapper(equality);
  return getTreeCache(eviction, maxSize, valueMapper, name);
}
function getValueMapper(equality) {
  switch (equality) {
    case "reference":
      return (val) => val;
    case "value":
      return (val) => Recoil_stableStringify(val);
  }
  throw Recoil_err(`Unrecognized equality policy ${equality}`);
}
function getTreeCache(eviction, maxSize, mapNodeValue, name) {
  switch (eviction) {
    case "keep-all":
      return new TreeCache$2({
        name,
        mapNodeValue
      });
    case "lru":
      return Recoil_treeCacheLRU({
        name,
        maxSize: Recoil_nullthrows(maxSize),
        mapNodeValue
      });
    case "most-recent":
      return Recoil_treeCacheLRU({
        name,
        maxSize: 1,
        mapNodeValue
      });
  }
  throw Recoil_err(`Unrecognized eviction policy ${eviction}`);
}
var Recoil_treeCacheFromPolicy = treeCacheFromPolicy;
function startPerfBlock(_id) {
  return () => null;
}
var Recoil_PerformanceTimings = {
  startPerfBlock
};
const {
  isLoadable: isLoadable$1,
  loadableWithError: loadableWithError$1,
  loadableWithPromise: loadableWithPromise$1,
  loadableWithValue: loadableWithValue$2
} = Recoil_Loadable$1;
const {
  WrappedValue: WrappedValue$1
} = Recoil_Wrapper$1;
const {
  getNodeLoadable: getNodeLoadable$2,
  peekNodeLoadable: peekNodeLoadable$1,
  setNodeValue: setNodeValue$3
} = Recoil_FunctionalCore;
const {
  saveDepsToStore: saveDepsToStore$1
} = Recoil_Graph;
const {
  DEFAULT_VALUE: DEFAULT_VALUE$6,
  getConfigDeletionHandler: getConfigDeletionHandler$1,
  getNode: getNode$6,
  registerNode: registerNode$1
} = Recoil_Node;
const {
  isRecoilValue: isRecoilValue$3
} = Recoil_RecoilValue$1;
const {
  markRecoilValueModified: markRecoilValueModified$1
} = Recoil_RecoilValueInterface;
const {
  retainedByOptionWithDefault: retainedByOptionWithDefault$1
} = Recoil_Retention;
const {
  recoilCallback: recoilCallback$1
} = Recoil_useRecoilCallback;
const {
  startPerfBlock: startPerfBlock$1
} = Recoil_PerformanceTimings;
class Canceled {
}
const CANCELED = new Canceled();
const dependencyStack = [];
const waitingStores = /* @__PURE__ */ new Map();
const getNewExecutionID = (() => {
  let executionID = 0;
  return () => executionID++;
})();
function selector(options) {
  let recoilValue = null;
  const {
    key,
    get: get2,
    cachePolicy_UNSTABLE: cachePolicy
  } = options;
  const set = options.set != null ? options.set : void 0;
  const discoveredDependencyNodeKeys = /* @__PURE__ */ new Set();
  const cache = Recoil_treeCacheFromPolicy(cachePolicy !== null && cachePolicy !== void 0 ? cachePolicy : {
    equality: "reference",
    eviction: "keep-all"
  }, key);
  const retainedBy = retainedByOptionWithDefault$1(options.retainedBy_UNSTABLE);
  const executionInfoMap = /* @__PURE__ */ new Map();
  let liveStoresCount = 0;
  function selectorIsLive() {
    return !Recoil_gkx("recoil_memory_managament_2020") || liveStoresCount > 0;
  }
  function selectorInit(store) {
    store.getState().knownSelectors.add(key);
    liveStoresCount++;
    return () => {
      liveStoresCount--;
    };
  }
  function selectorShouldDeleteConfigOnRelease() {
    return getConfigDeletionHandler$1(key) !== void 0 && !selectorIsLive();
  }
  function resolveAsync(store, state, executionID, loadable, depValues) {
    setCache(state, loadable, depValues);
    notifyStoresOfResolvedAsync(store, executionID);
  }
  function notifyStoresOfResolvedAsync(store, executionID) {
    if (isLatestExecution(store, executionID)) {
      clearExecutionInfo(store);
    }
    notifyWaitingStores(executionID, true);
  }
  function notifyStoresOfNewAsyncDep(store, executionID) {
    if (isLatestExecution(store, executionID)) {
      const executionInfo = Recoil_nullthrows(getExecutionInfo(store));
      executionInfo.stateVersions.clear();
      notifyWaitingStores(executionID, false);
    }
  }
  function notifyWaitingStores(executionID, clearWaitlist) {
    const stores = waitingStores.get(executionID);
    if (stores != null) {
      for (const waitingStore of stores) {
        markRecoilValueModified$1(waitingStore, Recoil_nullthrows(recoilValue));
      }
      if (clearWaitlist) {
        waitingStores.delete(executionID);
      }
    }
  }
  function markStoreWaitingForResolvedAsync(store, executionID) {
    let stores = waitingStores.get(executionID);
    if (stores == null) {
      waitingStores.set(executionID, stores = /* @__PURE__ */ new Set());
    }
    stores.add(store);
  }
  function wrapResultPromise(store, promise, state, depValues, executionID, loadingDepsState) {
    return promise.then((value) => {
      if (!selectorIsLive()) {
        clearExecutionInfo(store);
        throw CANCELED;
      }
      const loadable = loadableWithValue$2(value);
      resolveAsync(store, state, executionID, loadable, depValues);
      return value;
    }).catch((errorOrPromise) => {
      if (!selectorIsLive()) {
        clearExecutionInfo(store);
        throw CANCELED;
      }
      if (Recoil_isPromise(errorOrPromise)) {
        return wrapPendingDependencyPromise(store, errorOrPromise, state, depValues, executionID, loadingDepsState);
      }
      const loadable = loadableWithError$1(errorOrPromise);
      resolveAsync(store, state, executionID, loadable, depValues);
      throw errorOrPromise;
    });
  }
  function wrapPendingDependencyPromise(store, promise, state, existingDeps, executionID, loadingDepsState) {
    return promise.then((resolvedDep) => {
      if (!selectorIsLive()) {
        clearExecutionInfo(store);
        throw CANCELED;
      }
      if (loadingDepsState.loadingDepKey != null && loadingDepsState.loadingDepPromise === promise) {
        state.atomValues.set(loadingDepsState.loadingDepKey, loadableWithValue$2(resolvedDep));
      } else {
        store.getState().knownSelectors.forEach((nodeKey) => {
          state.atomValues.delete(nodeKey);
        });
      }
      const cachedLoadable = getLoadableFromCacheAndUpdateDeps(store, state);
      if (cachedLoadable && cachedLoadable.state !== "loading") {
        if (isLatestExecution(store, executionID) || getExecutionInfo(store) == null) {
          notifyStoresOfResolvedAsync(store, executionID);
        }
        if (cachedLoadable.state === "hasValue") {
          return cachedLoadable.contents;
        } else {
          throw cachedLoadable.contents;
        }
      }
      if (!isLatestExecution(store, executionID)) {
        const executionInfo = getInProgressExecutionInfo(store, state);
        if (executionInfo != null) {
          return executionInfo.loadingLoadable.contents;
        }
      }
      const [loadable, depValues] = evaluateSelectorGetter(store, state, executionID);
      if (loadable.state !== "loading") {
        resolveAsync(store, state, executionID, loadable, depValues);
      }
      if (loadable.state === "hasError") {
        throw loadable.contents;
      }
      return loadable.contents;
    }).catch((error) => {
      if (error instanceof Canceled) {
        throw CANCELED;
      }
      if (!selectorIsLive()) {
        clearExecutionInfo(store);
        throw CANCELED;
      }
      const loadable = loadableWithError$1(error);
      resolveAsync(store, state, executionID, loadable, existingDeps);
      throw error;
    });
  }
  function updateDeps(store, state, deps, executionID) {
    var _store$getState, _store$getState$curre, _store$getState2, _store$getState2$next;
    if (isLatestExecution(store, executionID) || state.version === ((_store$getState = store.getState()) === null || _store$getState === void 0 ? void 0 : (_store$getState$curre = _store$getState.currentTree) === null || _store$getState$curre === void 0 ? void 0 : _store$getState$curre.version) || state.version === ((_store$getState2 = store.getState()) === null || _store$getState2 === void 0 ? void 0 : (_store$getState2$next = _store$getState2.nextTree) === null || _store$getState2$next === void 0 ? void 0 : _store$getState2$next.version)) {
      var _store$getState$nextT, _store$getState3, _store$getState3$next;
      saveDepsToStore$1(key, deps, store, (_store$getState$nextT = (_store$getState3 = store.getState()) === null || _store$getState3 === void 0 ? void 0 : (_store$getState3$next = _store$getState3.nextTree) === null || _store$getState3$next === void 0 ? void 0 : _store$getState3$next.version) !== null && _store$getState$nextT !== void 0 ? _store$getState$nextT : store.getState().currentTree.version);
    }
    for (const nodeKey of deps) {
      discoveredDependencyNodeKeys.add(nodeKey);
    }
  }
  function evaluateSelectorGetter(store, state, executionID) {
    const endPerfBlock = startPerfBlock$1(key);
    let duringSynchronousExecution = true;
    let duringAsynchronousExecution = true;
    const finishEvaluation = () => {
      endPerfBlock();
      duringAsynchronousExecution = false;
    };
    let result;
    let resultIsError = false;
    let loadable;
    const loadingDepsState = {
      loadingDepKey: null,
      loadingDepPromise: null
    };
    const depValues = /* @__PURE__ */ new Map();
    function getRecoilValue({
      key: depKey
    }) {
      const depLoadable = getNodeLoadable$2(store, state, depKey);
      depValues.set(depKey, depLoadable);
      if (!duringSynchronousExecution) {
        updateDeps(store, state, new Set(depValues.keys()), executionID);
        notifyStoresOfNewAsyncDep(store, executionID);
      }
      switch (depLoadable.state) {
        case "hasValue":
          return depLoadable.contents;
        case "hasError":
          throw depLoadable.contents;
        case "loading":
          loadingDepsState.loadingDepKey = depKey;
          loadingDepsState.loadingDepPromise = depLoadable.contents;
          throw depLoadable.contents;
      }
      throw Recoil_err("Invalid Loadable state");
    }
    const getCallback = (fn2) => {
      return (...args) => {
        if (duringAsynchronousExecution) {
          throw Recoil_err("Callbacks from getCallback() should only be called asynchronously after the selector is evalutated.  It can be used for selectors to return objects with callbacks that can work with Recoil state without a subscription.");
        }
        !(recoilValue != null) ? Recoil_invariant(false) : void 0;
        return recoilCallback$1(
          store,
          fn2,
          args,
          {
            node: recoilValue
          }
          // flowlint-line unclear-type:off
        );
      };
    };
    try {
      result = get2({
        get: getRecoilValue,
        getCallback
      });
      result = isRecoilValue$3(result) ? getRecoilValue(result) : result;
      if (isLoadable$1(result)) {
        if (result.state === "hasError") {
          resultIsError = true;
        }
        result = result.contents;
      }
      if (Recoil_isPromise(result)) {
        result = wrapResultPromise(store, result, state, depValues, executionID, loadingDepsState).finally(finishEvaluation);
      } else {
        finishEvaluation();
      }
      result = result instanceof WrappedValue$1 ? result.value : result;
    } catch (errorOrDepPromise) {
      result = errorOrDepPromise;
      if (Recoil_isPromise(result)) {
        result = wrapPendingDependencyPromise(store, result, state, depValues, executionID, loadingDepsState).finally(finishEvaluation);
      } else {
        resultIsError = true;
        finishEvaluation();
      }
    }
    if (resultIsError) {
      loadable = loadableWithError$1(result);
    } else if (Recoil_isPromise(result)) {
      loadable = loadableWithPromise$1(result);
    } else {
      loadable = loadableWithValue$2(result);
    }
    duringSynchronousExecution = false;
    updateExecutionInfoDepValues(store, executionID, depValues);
    updateDeps(store, state, new Set(depValues.keys()), executionID);
    return [loadable, depValues];
  }
  function getLoadableFromCacheAndUpdateDeps(store, state) {
    let cachedLoadable = state.atomValues.get(key);
    if (cachedLoadable != null) {
      return cachedLoadable;
    }
    const depsAfterCacheLookup = /* @__PURE__ */ new Set();
    try {
      cachedLoadable = cache.get((nodeKey) => {
        !(typeof nodeKey === "string") ? false ? Recoil_invariant(false, "Cache nodeKey is type string") : Recoil_invariant(false) : void 0;
        return getNodeLoadable$2(store, state, nodeKey).contents;
      }, {
        onNodeVisit: (node) => {
          if (node.type === "branch" && node.nodeKey !== key) {
            depsAfterCacheLookup.add(node.nodeKey);
          }
        }
      });
    } catch (error) {
      throw Recoil_err(`Problem with cache lookup for selector "${key}": ${error.message}`);
    }
    if (cachedLoadable) {
      var _getExecutionInfo;
      state.atomValues.set(key, cachedLoadable);
      updateDeps(store, state, depsAfterCacheLookup, (_getExecutionInfo = getExecutionInfo(store)) === null || _getExecutionInfo === void 0 ? void 0 : _getExecutionInfo.executionID);
    }
    return cachedLoadable;
  }
  function getSelectorLoadableAndUpdateDeps(store, state) {
    const cachedVal = getLoadableFromCacheAndUpdateDeps(store, state);
    if (cachedVal != null) {
      clearExecutionInfo(store);
      return cachedVal;
    }
    const inProgressExecutionInfo = getInProgressExecutionInfo(store, state);
    if (inProgressExecutionInfo != null) {
      var _inProgressExecutionI;
      if (((_inProgressExecutionI = inProgressExecutionInfo.loadingLoadable) === null || _inProgressExecutionI === void 0 ? void 0 : _inProgressExecutionI.state) === "loading") {
        markStoreWaitingForResolvedAsync(store, inProgressExecutionInfo.executionID);
      }
      return inProgressExecutionInfo.loadingLoadable;
    }
    const newExecutionID = getNewExecutionID();
    const [loadable, newDepValues] = evaluateSelectorGetter(store, state, newExecutionID);
    if (loadable.state === "loading") {
      setExecutionInfo(store, newExecutionID, loadable, newDepValues, state);
      markStoreWaitingForResolvedAsync(store, newExecutionID);
    } else {
      clearExecutionInfo(store);
      setCache(state, loadable, newDepValues);
    }
    return loadable;
  }
  function getInProgressExecutionInfo(store, state) {
    const pendingExecutions = Recoil_concatIterables([executionInfoMap.has(store) ? [Recoil_nullthrows(executionInfoMap.get(store))] : [], Recoil_mapIterable(Recoil_filterIterable(executionInfoMap, ([s2]) => s2 !== store), ([, execInfo]) => execInfo)]);
    function anyDepChanged(execDepValues) {
      for (const [depKey, execLoadable] of execDepValues) {
        if (!getNodeLoadable$2(store, state, depKey).is(execLoadable)) {
          return true;
        }
      }
      return false;
    }
    for (const execInfo of pendingExecutions) {
      if (
        // If this execution was already checked to be valid with this version
        // of state, then let's use it!
        execInfo.stateVersions.get(state.version) || // If the deps for the execution match our current state, then it's valid
        !anyDepChanged(execInfo.depValuesDiscoveredSoFarDuringAsyncWork)
      ) {
        execInfo.stateVersions.set(state.version, true);
        return execInfo;
      } else {
        execInfo.stateVersions.set(state.version, false);
      }
    }
    return void 0;
  }
  function getExecutionInfo(store) {
    return executionInfoMap.get(store);
  }
  function setExecutionInfo(store, newExecutionID, loadable, depValues, state) {
    executionInfoMap.set(store, {
      depValuesDiscoveredSoFarDuringAsyncWork: depValues,
      executionID: newExecutionID,
      loadingLoadable: loadable,
      stateVersions: /* @__PURE__ */ new Map([[state.version, true]])
    });
  }
  function updateExecutionInfoDepValues(store, executionID, depValues) {
    if (isLatestExecution(store, executionID)) {
      const executionInfo = getExecutionInfo(store);
      if (executionInfo != null) {
        executionInfo.depValuesDiscoveredSoFarDuringAsyncWork = depValues;
      }
    }
  }
  function clearExecutionInfo(store) {
    executionInfoMap.delete(store);
  }
  function isLatestExecution(store, executionID) {
    var _getExecutionInfo2;
    return executionID === ((_getExecutionInfo2 = getExecutionInfo(store)) === null || _getExecutionInfo2 === void 0 ? void 0 : _getExecutionInfo2.executionID);
  }
  function depValuesToDepRoute(depValues) {
    return Array.from(depValues.entries()).map(([depKey, valLoadable]) => [depKey, valLoadable.contents]);
  }
  function setCache(state, loadable, depValues) {
    state.atomValues.set(key, loadable);
    try {
      cache.set(depValuesToDepRoute(depValues), loadable);
    } catch (error) {
      throw Recoil_err(`Problem with setting cache for selector "${key}": ${error.message}`);
    }
  }
  function detectCircularDependencies(fn2) {
    if (dependencyStack.includes(key)) {
      const message = `Recoil selector has circular dependencies: ${dependencyStack.slice(dependencyStack.indexOf(key)).join(" → ")}`;
      return loadableWithError$1(Recoil_err(message));
    }
    dependencyStack.push(key);
    try {
      return fn2();
    } finally {
      dependencyStack.pop();
    }
  }
  function selectorPeek(store, state) {
    const cachedLoadable = state.atomValues.get(key);
    if (cachedLoadable != null) {
      return cachedLoadable;
    }
    return cache.get((nodeKey) => {
      var _peekNodeLoadable;
      !(typeof nodeKey === "string") ? Recoil_invariant(false) : void 0;
      return (_peekNodeLoadable = peekNodeLoadable$1(store, state, nodeKey)) === null || _peekNodeLoadable === void 0 ? void 0 : _peekNodeLoadable.contents;
    });
  }
  function selectorGet(store, state) {
    return detectCircularDependencies(() => getSelectorLoadableAndUpdateDeps(store, state));
  }
  function invalidateSelector(state) {
    state.atomValues.delete(key);
  }
  function clearSelectorCache(store, treeState) {
    !(recoilValue != null) ? Recoil_invariant(false) : void 0;
    for (const nodeKey of discoveredDependencyNodeKeys) {
      var _node$clearCache;
      const node = getNode$6(nodeKey);
      (_node$clearCache = node.clearCache) === null || _node$clearCache === void 0 ? void 0 : _node$clearCache.call(node, store, treeState);
    }
    discoveredDependencyNodeKeys.clear();
    invalidateSelector(treeState);
    cache.clear();
    markRecoilValueModified$1(store, recoilValue);
  }
  if (set != null) {
    const selectorSet = (store, state, newValue) => {
      let syncSelectorSetFinished = false;
      const writes = /* @__PURE__ */ new Map();
      function getRecoilValue({
        key: depKey
      }) {
        if (syncSelectorSetFinished) {
          throw Recoil_err("Recoil: Async selector sets are not currently supported.");
        }
        const loadable = getNodeLoadable$2(store, state, depKey);
        if (loadable.state === "hasValue") {
          return loadable.contents;
        } else if (loadable.state === "loading") {
          const msg = `Getting value of asynchronous atom or selector "${depKey}" in a pending state while setting selector "${key}" is not yet supported.`;
          throw Recoil_err(msg);
        } else {
          throw loadable.contents;
        }
      }
      function setRecoilState(recoilState, valueOrUpdater) {
        if (syncSelectorSetFinished) {
          const msg = "Recoil: Async selector sets are not currently supported.";
          throw Recoil_err(msg);
        }
        const setValue = typeof valueOrUpdater === "function" ? (
          // cast to any because we can't restrict type S from being a function itself without losing support for opaque types
          // flowlint-next-line unclear-type:off
          valueOrUpdater(getRecoilValue(recoilState))
        ) : valueOrUpdater;
        const upstreamWrites = setNodeValue$3(store, state, recoilState.key, setValue);
        upstreamWrites.forEach((v2, k2) => writes.set(k2, v2));
      }
      function resetRecoilState(recoilState) {
        setRecoilState(recoilState, DEFAULT_VALUE$6);
      }
      const ret = set({
        set: setRecoilState,
        get: getRecoilValue,
        reset: resetRecoilState
      }, newValue);
      if (ret !== void 0) {
        throw Recoil_isPromise(ret) ? Recoil_err("Recoil: Async selector sets are not currently supported.") : Recoil_err("Recoil: selector set should be a void function.");
      }
      syncSelectorSetFinished = true;
      return writes;
    };
    return recoilValue = registerNode$1({
      key,
      nodeType: "selector",
      peek: selectorPeek,
      get: selectorGet,
      set: selectorSet,
      init: selectorInit,
      invalidate: invalidateSelector,
      clearCache: clearSelectorCache,
      shouldDeleteConfigOnRelease: selectorShouldDeleteConfigOnRelease,
      dangerouslyAllowMutability: options.dangerouslyAllowMutability,
      shouldRestoreFromSnapshots: false,
      retainedBy
    });
  } else {
    return recoilValue = registerNode$1({
      key,
      nodeType: "selector",
      peek: selectorPeek,
      get: selectorGet,
      init: selectorInit,
      invalidate: invalidateSelector,
      clearCache: clearSelectorCache,
      shouldDeleteConfigOnRelease: selectorShouldDeleteConfigOnRelease,
      dangerouslyAllowMutability: options.dangerouslyAllowMutability,
      shouldRestoreFromSnapshots: false,
      retainedBy
    });
  }
}
selector.value = (value) => new WrappedValue$1(value);
var Recoil_selector = selector;
const {
  isLoadable: isLoadable$2,
  loadableWithError: loadableWithError$2,
  loadableWithPromise: loadableWithPromise$2,
  loadableWithValue: loadableWithValue$3
} = Recoil_Loadable$1;
const {
  WrappedValue: WrappedValue$2
} = Recoil_Wrapper$1;
const {
  peekNodeInfo: peekNodeInfo$3
} = Recoil_FunctionalCore;
const {
  DEFAULT_VALUE: DEFAULT_VALUE$7,
  DefaultValue: DefaultValue$2,
  getConfigDeletionHandler: getConfigDeletionHandler$2,
  registerNode: registerNode$2,
  setConfigDeletionHandler: setConfigDeletionHandler$1
} = Recoil_Node;
const {
  isRecoilValue: isRecoilValue$4
} = Recoil_RecoilValue$1;
const {
  getRecoilValueAsLoadable: getRecoilValueAsLoadable$4,
  markRecoilValueModified: markRecoilValueModified$2,
  setRecoilValue: setRecoilValue$4,
  setRecoilValueLoadable: setRecoilValueLoadable$2
} = Recoil_RecoilValueInterface;
const {
  retainedByOptionWithDefault: retainedByOptionWithDefault$2
} = Recoil_Retention;
const unwrap = (x) => x instanceof WrappedValue$2 ? x.value : x;
function baseAtom(options) {
  const {
    key,
    persistence_UNSTABLE: persistence
  } = options;
  const retainedBy = retainedByOptionWithDefault$2(options.retainedBy_UNSTABLE);
  let liveStoresCount = 0;
  function unwrapPromise(promise) {
    return loadableWithPromise$2(promise.then((value) => {
      defaultLoadable = loadableWithValue$3(value);
      return value;
    }).catch((error) => {
      defaultLoadable = loadableWithError$2(error);
      throw error;
    }));
  }
  let defaultLoadable = Recoil_isPromise(options.default) ? unwrapPromise(options.default) : isLoadable$2(options.default) ? options.default.state === "loading" ? unwrapPromise(options.default.contents) : options.default : (
    // $FlowFixMe[incompatible-call]
    loadableWithValue$3(unwrap(options.default))
  );
  maybeFreezeValueOrPromise(defaultLoadable.contents);
  let cachedAnswerForUnvalidatedValue = void 0;
  const cleanupEffectsByStore = /* @__PURE__ */ new Map();
  function maybeFreezeValueOrPromise(valueOrPromise) {
    return valueOrPromise;
  }
  function wrapPendingPromise(store, promise) {
    const wrappedPromise = promise.then((value) => {
      var _store$getState$nextT, _state$atomValues$get;
      const state = (_store$getState$nextT = store.getState().nextTree) !== null && _store$getState$nextT !== void 0 ? _store$getState$nextT : store.getState().currentTree;
      if (((_state$atomValues$get = state.atomValues.get(key)) === null || _state$atomValues$get === void 0 ? void 0 : _state$atomValues$get.contents) === wrappedPromise) {
        setRecoilValue$4(store, node, value);
      }
      return value;
    }).catch((error) => {
      var _store$getState$nextT2, _state$atomValues$get2;
      const state = (_store$getState$nextT2 = store.getState().nextTree) !== null && _store$getState$nextT2 !== void 0 ? _store$getState$nextT2 : store.getState().currentTree;
      if (((_state$atomValues$get2 = state.atomValues.get(key)) === null || _state$atomValues$get2 === void 0 ? void 0 : _state$atomValues$get2.contents) === wrappedPromise) {
        setRecoilValueLoadable$2(store, node, loadableWithError$2(error));
      }
      throw error;
    });
    return wrappedPromise;
  }
  function initAtom(store, initState, trigger) {
    var _options$effects;
    liveStoresCount++;
    const cleanupAtom = () => {
      var _cleanupEffectsByStor;
      liveStoresCount--;
      (_cleanupEffectsByStor = cleanupEffectsByStore.get(store)) === null || _cleanupEffectsByStor === void 0 ? void 0 : _cleanupEffectsByStor.forEach((cleanup) => cleanup());
      cleanupEffectsByStore.delete(store);
    };
    store.getState().knownAtoms.add(key);
    if (defaultLoadable.state === "loading") {
      const notifyDefaultSubscribers = () => {
        var _store$getState$nextT3;
        const state = (_store$getState$nextT3 = store.getState().nextTree) !== null && _store$getState$nextT3 !== void 0 ? _store$getState$nextT3 : store.getState().currentTree;
        if (!state.atomValues.has(key)) {
          markRecoilValueModified$2(store, node);
        }
      };
      defaultLoadable.contents.finally(notifyDefaultSubscribers);
    }
    const effects = (_options$effects = options.effects) !== null && _options$effects !== void 0 ? _options$effects : options.effects_UNSTABLE;
    if (effects != null) {
      let getLoadable = function(recoilValue) {
        if (isDuringInit && recoilValue.key === key) {
          const retValue = initValue;
          return retValue instanceof DefaultValue$2 ? peekAtom(store, initState) : Recoil_isPromise(retValue) ? loadableWithPromise$2(retValue.then((v2) => v2 instanceof DefaultValue$2 ? (
            // Cast T to S
            defaultLoadable.toPromise()
          ) : v2)) : (
            // $FlowFixMe[incompatible-call]
            loadableWithValue$3(retValue)
          );
        }
        return getRecoilValueAsLoadable$4(store, recoilValue);
      }, getPromise = function(recoilValue) {
        return getLoadable(recoilValue).toPromise();
      }, getInfo_UNSTABLE = function(recoilValue) {
        var _store$getState$nextT4;
        const info = peekNodeInfo$3(store, (_store$getState$nextT4 = store.getState().nextTree) !== null && _store$getState$nextT4 !== void 0 ? _store$getState$nextT4 : store.getState().currentTree, recoilValue.key);
        return isDuringInit && recoilValue.key === key && !(initValue instanceof DefaultValue$2) ? {
          ...info,
          isSet: true,
          loadable: getLoadable(recoilValue)
        } : info;
      };
      let initValue = DEFAULT_VALUE$7;
      let isDuringInit = true;
      let isInitError = false;
      let pendingSetSelf = null;
      const setSelf = (effect) => (valueOrUpdater) => {
        if (isDuringInit) {
          const currentLoadable = getLoadable(node);
          const currentValue = currentLoadable.state === "hasValue" ? currentLoadable.contents : DEFAULT_VALUE$7;
          initValue = typeof valueOrUpdater === "function" ? (
            // cast to any because we can't restrict T from being a function without losing support for opaque types
            valueOrUpdater(currentValue)
          ) : valueOrUpdater;
          if (Recoil_isPromise(initValue)) {
            initValue = initValue.then((value) => {
              pendingSetSelf = {
                effect,
                value
              };
              return value;
            });
          }
        } else {
          if (Recoil_isPromise(valueOrUpdater)) {
            throw Recoil_err("Setting atoms to async values is not implemented.");
          }
          if (typeof valueOrUpdater !== "function") {
            pendingSetSelf = {
              effect,
              value: unwrap(valueOrUpdater)
            };
          }
          setRecoilValue$4(store, node, typeof valueOrUpdater === "function" ? (currentValue) => {
            const newValue = unwrap(
              // cast to any because we can't restrict T from being a function without losing support for opaque types
              valueOrUpdater(currentValue)
              // flowlint-line unclear-type:off
            );
            pendingSetSelf = {
              effect,
              value: newValue
            };
            return newValue;
          } : unwrap(valueOrUpdater));
        }
      };
      const resetSelf = (effect) => () => setSelf(effect)(DEFAULT_VALUE$7);
      const onSet = (effect) => (handler) => {
        var _cleanupEffectsByStor2;
        const {
          release
        } = store.subscribeToTransactions((currentStore) => {
          var _currentTree$atomValu;
          let {
            currentTree,
            previousTree
          } = currentStore.getState();
          if (!previousTree) {
            previousTree = currentTree;
          }
          const newLoadable = (_currentTree$atomValu = currentTree.atomValues.get(key)) !== null && _currentTree$atomValu !== void 0 ? _currentTree$atomValu : defaultLoadable;
          if (newLoadable.state === "hasValue") {
            var _previousTree$atomVal, _pendingSetSelf, _pendingSetSelf2, _pendingSetSelf3;
            const newValue = newLoadable.contents;
            const oldLoadable = (_previousTree$atomVal = previousTree.atomValues.get(key)) !== null && _previousTree$atomVal !== void 0 ? _previousTree$atomVal : defaultLoadable;
            const oldValue = oldLoadable.state === "hasValue" ? oldLoadable.contents : DEFAULT_VALUE$7;
            if (((_pendingSetSelf = pendingSetSelf) === null || _pendingSetSelf === void 0 ? void 0 : _pendingSetSelf.effect) !== effect || ((_pendingSetSelf2 = pendingSetSelf) === null || _pendingSetSelf2 === void 0 ? void 0 : _pendingSetSelf2.value) !== newValue) {
              handler(newValue, oldValue, !currentTree.atomValues.has(key));
            } else if (((_pendingSetSelf3 = pendingSetSelf) === null || _pendingSetSelf3 === void 0 ? void 0 : _pendingSetSelf3.effect) === effect) {
              pendingSetSelf = null;
            }
          }
        }, key);
        cleanupEffectsByStore.set(store, [...(_cleanupEffectsByStor2 = cleanupEffectsByStore.get(store)) !== null && _cleanupEffectsByStor2 !== void 0 ? _cleanupEffectsByStor2 : [], release]);
      };
      for (const effect of effects) {
        try {
          const cleanup = effect({
            node,
            storeID: store.storeID,
            parentStoreID_UNSTABLE: store.parentStoreID,
            trigger,
            setSelf: setSelf(effect),
            resetSelf: resetSelf(effect),
            onSet: onSet(effect),
            getPromise,
            getLoadable,
            getInfo_UNSTABLE
          });
          if (cleanup != null) {
            var _cleanupEffectsByStor3;
            cleanupEffectsByStore.set(store, [...(_cleanupEffectsByStor3 = cleanupEffectsByStore.get(store)) !== null && _cleanupEffectsByStor3 !== void 0 ? _cleanupEffectsByStor3 : [], cleanup]);
          }
        } catch (error) {
          initValue = error;
          isInitError = true;
        }
      }
      isDuringInit = false;
      if (!(initValue instanceof DefaultValue$2)) {
        var _store$getState$nextT5;
        const initLoadable = isInitError ? loadableWithError$2(initValue) : Recoil_isPromise(initValue) ? loadableWithPromise$2(wrapPendingPromise(store, initValue)) : loadableWithValue$3(unwrap(initValue));
        maybeFreezeValueOrPromise(initLoadable.contents);
        initState.atomValues.set(key, initLoadable);
        (_store$getState$nextT5 = store.getState().nextTree) === null || _store$getState$nextT5 === void 0 ? void 0 : _store$getState$nextT5.atomValues.set(key, initLoadable);
      }
    }
    return cleanupAtom;
  }
  function peekAtom(_store, state) {
    var _ref, _state$atomValues$get3;
    return (_ref = (_state$atomValues$get3 = state.atomValues.get(key)) !== null && _state$atomValues$get3 !== void 0 ? _state$atomValues$get3 : cachedAnswerForUnvalidatedValue) !== null && _ref !== void 0 ? _ref : defaultLoadable;
  }
  function getAtom(_store, state) {
    if (state.atomValues.has(key)) {
      return Recoil_nullthrows(state.atomValues.get(key));
    } else if (state.nonvalidatedAtoms.has(key)) {
      if (cachedAnswerForUnvalidatedValue != null) {
        return cachedAnswerForUnvalidatedValue;
      }
      if (persistence == null) {
        return defaultLoadable;
      }
      const nonvalidatedValue = state.nonvalidatedAtoms.get(key);
      const validatorResult = persistence.validator(nonvalidatedValue, DEFAULT_VALUE$7);
      const validatedValueLoadable = validatorResult instanceof DefaultValue$2 ? defaultLoadable : loadableWithValue$3(validatorResult);
      cachedAnswerForUnvalidatedValue = validatedValueLoadable;
      return cachedAnswerForUnvalidatedValue;
    } else {
      return defaultLoadable;
    }
  }
  function invalidateAtom() {
    cachedAnswerForUnvalidatedValue = void 0;
  }
  function setAtom(_store, state, newValue) {
    if (state.atomValues.has(key)) {
      const existing = Recoil_nullthrows(state.atomValues.get(key));
      if (existing.state === "hasValue" && newValue === existing.contents) {
        return /* @__PURE__ */ new Map();
      }
    } else if (!state.nonvalidatedAtoms.has(key) && newValue instanceof DefaultValue$2) {
      return /* @__PURE__ */ new Map();
    }
    cachedAnswerForUnvalidatedValue = void 0;
    return (/* @__PURE__ */ new Map()).set(key, loadableWithValue$3(newValue));
  }
  function shouldDeleteConfigOnReleaseAtom() {
    return getConfigDeletionHandler$2(key) !== void 0 && liveStoresCount <= 0;
  }
  const node = registerNode$2({
    key,
    nodeType: "atom",
    peek: peekAtom,
    get: getAtom,
    set: setAtom,
    init: initAtom,
    invalidate: invalidateAtom,
    shouldDeleteConfigOnRelease: shouldDeleteConfigOnReleaseAtom,
    dangerouslyAllowMutability: options.dangerouslyAllowMutability,
    persistence_UNSTABLE: options.persistence_UNSTABLE ? {
      type: options.persistence_UNSTABLE.type,
      backButton: options.persistence_UNSTABLE.backButton
    } : void 0,
    shouldRestoreFromSnapshots: true,
    retainedBy
  });
  return node;
}
function atom(options) {
  const {
    // @fb-only: scopeRules_APPEND_ONLY_READ_THE_DOCS,
    ...restOptions
  } = options;
  const optionsDefault = "default" in options ? (
    // $FlowIssue[incompatible-type] No way to refine in Flow that property is not defined
    options.default
  ) : new Promise(() => {
  });
  if (isRecoilValue$4(optionsDefault)) {
    return atomWithFallback({
      ...restOptions,
      default: optionsDefault
      // @fb-only: scopeRules_APPEND_ONLY_READ_THE_DOCS,
    });
  } else {
    return baseAtom({
      ...restOptions,
      default: optionsDefault
    });
  }
}
function atomWithFallback(options) {
  const base = atom({
    ...options,
    default: DEFAULT_VALUE$7,
    persistence_UNSTABLE: options.persistence_UNSTABLE === void 0 ? void 0 : {
      ...options.persistence_UNSTABLE,
      validator: (storedValue) => storedValue instanceof DefaultValue$2 ? storedValue : Recoil_nullthrows(options.persistence_UNSTABLE).validator(storedValue, DEFAULT_VALUE$7)
    },
    // TODO Hack for now.
    effects: options.effects,
    // flowlint-line unclear-type: off
    effects_UNSTABLE: options.effects_UNSTABLE
    // flowlint-line unclear-type: off
  });
  const sel = Recoil_selector({
    key: `${options.key}__withFallback`,
    get: ({
      get: get2
    }) => {
      const baseValue = get2(base);
      return baseValue instanceof DefaultValue$2 ? options.default : baseValue;
    },
    // $FlowFixMe[incompatible-call]
    set: ({
      set
    }, newValue) => set(base, newValue),
    // This selector does not need to cache as it is a wrapper selector
    // and the selector within the wrapper selector will have a cache
    // option by default
    cachePolicy_UNSTABLE: {
      eviction: "most-recent"
    },
    dangerouslyAllowMutability: options.dangerouslyAllowMutability
  });
  setConfigDeletionHandler$1(sel.key, getConfigDeletionHandler$2(options.key));
  return sel;
}
atom.value = (value) => new WrappedValue$2(value);
var Recoil_atom = atom;
class MapCache {
  constructor(options) {
    var _options$mapKey;
    _defineProperty$1(this, "_map", void 0);
    _defineProperty$1(this, "_keyMapper", void 0);
    this._map = /* @__PURE__ */ new Map();
    this._keyMapper = (_options$mapKey = options === null || options === void 0 ? void 0 : options.mapKey) !== null && _options$mapKey !== void 0 ? _options$mapKey : (v2) => v2;
  }
  size() {
    return this._map.size;
  }
  has(key) {
    return this._map.has(this._keyMapper(key));
  }
  get(key) {
    return this._map.get(this._keyMapper(key));
  }
  set(key, val) {
    this._map.set(this._keyMapper(key), val);
  }
  delete(key) {
    this._map.delete(this._keyMapper(key));
  }
  clear() {
    this._map.clear();
  }
}
var Recoil_MapCache = {
  MapCache
};
var Recoil_MapCache_1 = Recoil_MapCache.MapCache;
var Recoil_MapCache$1 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  MapCache: Recoil_MapCache_1
});
const {
  LRUCache: LRUCache$2
} = Recoil_LRUCache$1;
const {
  MapCache: MapCache$1
} = Recoil_MapCache$1;
const defaultPolicy$1 = {
  equality: "reference",
  eviction: "none",
  maxSize: Infinity
};
function cacheFromPolicy({
  equality = defaultPolicy$1.equality,
  eviction = defaultPolicy$1.eviction,
  maxSize = defaultPolicy$1.maxSize
} = defaultPolicy$1) {
  const valueMapper = getValueMapper$1(equality);
  const cache = getCache(eviction, maxSize, valueMapper);
  return cache;
}
function getValueMapper$1(equality) {
  switch (equality) {
    case "reference":
      return (val) => val;
    case "value":
      return (val) => Recoil_stableStringify(val);
  }
  throw Recoil_err(`Unrecognized equality policy ${equality}`);
}
function getCache(eviction, maxSize, mapKey) {
  switch (eviction) {
    case "keep-all":
      return new MapCache$1({
        mapKey
      });
    case "lru":
      return new LRUCache$2({
        mapKey,
        maxSize: Recoil_nullthrows(maxSize)
      });
    case "most-recent":
      return new LRUCache$2({
        mapKey,
        maxSize: 1
      });
  }
  throw Recoil_err(`Unrecognized eviction policy ${eviction}`);
}
var Recoil_cacheFromPolicy = cacheFromPolicy;
const {
  setConfigDeletionHandler: setConfigDeletionHandler$2
} = Recoil_Node;
function atomFamily(options) {
  var _options$cachePolicyF, _options$cachePolicyF2;
  const atomCache = Recoil_cacheFromPolicy({
    equality: (_options$cachePolicyF = (_options$cachePolicyF2 = options.cachePolicyForParams_UNSTABLE) === null || _options$cachePolicyF2 === void 0 ? void 0 : _options$cachePolicyF2.equality) !== null && _options$cachePolicyF !== void 0 ? _options$cachePolicyF : "value",
    eviction: "keep-all"
  });
  return (params) => {
    var _stableStringify, _options$effects;
    const cachedAtom = atomCache.get(params);
    if (cachedAtom != null) {
      return cachedAtom;
    }
    const {
      cachePolicyForParams_UNSTABLE,
      ...atomOptions
    } = options;
    const optionsDefault = "default" in options ? (
      // $FlowIssue[incompatible-type] No way to refine in Flow that property is not defined
      options.default
    ) : new Promise(() => {
    });
    const newAtom = Recoil_atom({
      ...atomOptions,
      key: `${options.key}__${(_stableStringify = Recoil_stableStringify(params)) !== null && _stableStringify !== void 0 ? _stableStringify : "void"}`,
      default: typeof optionsDefault === "function" ? (
        // The default was parameterized
        // Flow doesn't know that T isn't a function, so we need to case to any
        // $FlowIssue[incompatible-use]
        optionsDefault(params)
      ) : (
        // Default may be a static value, promise, or RecoilValue
        optionsDefault
      ),
      retainedBy_UNSTABLE: typeof options.retainedBy_UNSTABLE === "function" ? options.retainedBy_UNSTABLE(params) : options.retainedBy_UNSTABLE,
      effects: typeof options.effects === "function" ? options.effects(params) : typeof options.effects_UNSTABLE === "function" ? options.effects_UNSTABLE(params) : (_options$effects = options.effects) !== null && _options$effects !== void 0 ? _options$effects : options.effects_UNSTABLE
      // prettier-ignore
      // @fb-only: scopeRules_APPEND_ONLY_READ_THE_DOCS: mapScopeRules(
      // @fb-only: options.scopeRules_APPEND_ONLY_READ_THE_DOCS,
      // @fb-only: params,
      // @fb-only: ),
    });
    atomCache.set(params, newAtom);
    setConfigDeletionHandler$2(newAtom.key, () => {
      atomCache.delete(params);
    });
    return newAtom;
  };
}
var Recoil_atomFamily = atomFamily;
const {
  setConfigDeletionHandler: setConfigDeletionHandler$3
} = Recoil_Node;
let nextIndex = 0;
function selectorFamily(options) {
  var _options$cachePolicyF, _options$cachePolicyF2;
  const selectorCache = Recoil_cacheFromPolicy({
    equality: (_options$cachePolicyF = (_options$cachePolicyF2 = options.cachePolicyForParams_UNSTABLE) === null || _options$cachePolicyF2 === void 0 ? void 0 : _options$cachePolicyF2.equality) !== null && _options$cachePolicyF !== void 0 ? _options$cachePolicyF : "value",
    eviction: "keep-all"
  });
  return (params) => {
    var _stableStringify;
    let cachedSelector;
    try {
      cachedSelector = selectorCache.get(params);
    } catch (error) {
      throw Recoil_err(`Problem with cache lookup for selector ${options.key}: ${error.message}`);
    }
    if (cachedSelector != null) {
      return cachedSelector;
    }
    const myKey = `${options.key}__selectorFamily/${(_stableStringify = Recoil_stableStringify(params, {
      // It is possible to use functions in parameters if the user uses
      // a cache with reference equality thanks to the incrementing index.
      allowFunctions: true
    })) !== null && _stableStringify !== void 0 ? _stableStringify : "void"}/${nextIndex++}`;
    const myGet = (callbacks) => options.get(params)(callbacks);
    const myCachePolicy = options.cachePolicy_UNSTABLE;
    const retainedBy = typeof options.retainedBy_UNSTABLE === "function" ? options.retainedBy_UNSTABLE(params) : options.retainedBy_UNSTABLE;
    let newSelector;
    if (options.set != null) {
      const set = options.set;
      const mySet = (callbacks, newValue) => set(params)(callbacks, newValue);
      newSelector = Recoil_selector({
        key: myKey,
        get: myGet,
        set: mySet,
        cachePolicy_UNSTABLE: myCachePolicy,
        dangerouslyAllowMutability: options.dangerouslyAllowMutability,
        retainedBy_UNSTABLE: retainedBy
      });
    } else {
      newSelector = Recoil_selector({
        key: myKey,
        get: myGet,
        cachePolicy_UNSTABLE: myCachePolicy,
        dangerouslyAllowMutability: options.dangerouslyAllowMutability,
        retainedBy_UNSTABLE: retainedBy
      });
    }
    selectorCache.set(params, newSelector);
    setConfigDeletionHandler$3(newSelector.key, () => {
      selectorCache.delete(params);
    });
    return newSelector;
  };
}
var Recoil_selectorFamily = selectorFamily;
const constantSelector = Recoil_selectorFamily({
  key: "__constant",
  get: (constant) => () => constant,
  cachePolicyForParams_UNSTABLE: {
    equality: "reference"
  }
});
function constSelector(constant) {
  return constantSelector(constant);
}
var Recoil_constSelector = constSelector;
const throwingSelector = Recoil_selectorFamily({
  key: "__error",
  get: (message) => () => {
    throw Recoil_err(message);
  },
  // TODO Why?
  cachePolicyForParams_UNSTABLE: {
    equality: "reference"
  }
});
function errorSelector(message) {
  return throwingSelector(message);
}
var Recoil_errorSelector = errorSelector;
function readOnlySelector(atom2) {
  return atom2;
}
var Recoil_readOnlySelector = readOnlySelector;
const {
  loadableWithError: loadableWithError$3,
  loadableWithPromise: loadableWithPromise$3,
  loadableWithValue: loadableWithValue$4
} = Recoil_Loadable$1;
function concurrentRequests(getRecoilValue, deps) {
  const results = Array(deps.length).fill(void 0);
  const exceptions = Array(deps.length).fill(void 0);
  for (const [i2, dep] of deps.entries()) {
    try {
      results[i2] = getRecoilValue(dep);
    } catch (e2) {
      exceptions[i2] = e2;
    }
  }
  return [results, exceptions];
}
function isError(exp) {
  return exp != null && !Recoil_isPromise(exp);
}
function unwrapDependencies(dependencies) {
  return Array.isArray(dependencies) ? dependencies : Object.getOwnPropertyNames(dependencies).map((key) => dependencies[key]);
}
function wrapResults(dependencies, results) {
  return Array.isArray(dependencies) ? results : (
    // Object.getOwnPropertyNames() has consistent key ordering with ES6
    Object.getOwnPropertyNames(dependencies).reduce((out, key, idx) => ({
      ...out,
      [key]: results[idx]
    }), {})
  );
}
function wrapLoadables(dependencies, results, exceptions) {
  const output = exceptions.map((exception, idx) => exception == null ? loadableWithValue$4(results[idx]) : Recoil_isPromise(exception) ? loadableWithPromise$3(exception) : loadableWithError$3(exception));
  return wrapResults(dependencies, output);
}
function combineAsyncResultsWithSyncResults(syncResults, asyncResults) {
  return asyncResults.map((result, idx) => (
    /**
     * it's important we use === undefined as opposed to == null, because the
     * resolved value of the async promise could be `null`, in which case we
     * don't want to use syncResults[idx], which would be undefined. If async
     * promise resolves to `undefined`, that's ok because `syncResults[idx]`
     * will also be `undefined`. That's a little hacky, but it works.
     */
    result === void 0 ? syncResults[idx] : result
  ));
}
const waitForNone = Recoil_selectorFamily({
  key: "__waitForNone",
  get: (dependencies) => ({
    get: get2
  }) => {
    const deps = unwrapDependencies(dependencies);
    const [results, exceptions] = concurrentRequests(get2, deps);
    return wrapLoadables(dependencies, results, exceptions);
  },
  dangerouslyAllowMutability: true
});
const waitForAny = Recoil_selectorFamily({
  key: "__waitForAny",
  get: (dependencies) => ({
    get: get2
  }) => {
    const deps = unwrapDependencies(dependencies);
    const [results, exceptions] = concurrentRequests(get2, deps);
    if (exceptions.some((exp) => !Recoil_isPromise(exp))) {
      return wrapLoadables(dependencies, results, exceptions);
    }
    return new Promise((resolve) => {
      for (const [i2, exp] of exceptions.entries()) {
        if (Recoil_isPromise(exp)) {
          exp.then((result) => {
            results[i2] = result;
            exceptions[i2] = void 0;
            resolve(wrapLoadables(dependencies, results, exceptions));
          }).catch((error) => {
            exceptions[i2] = error;
            resolve(wrapLoadables(dependencies, results, exceptions));
          });
        }
      }
    });
  },
  dangerouslyAllowMutability: true
});
const waitForAll = Recoil_selectorFamily({
  key: "__waitForAll",
  get: (dependencies) => ({
    get: get2
  }) => {
    const deps = unwrapDependencies(dependencies);
    const [results, exceptions] = concurrentRequests(get2, deps);
    if (exceptions.every((exp) => exp == null)) {
      return wrapResults(dependencies, results);
    }
    const error = exceptions.find(isError);
    if (error != null) {
      throw error;
    }
    return Promise.all(exceptions).then((exceptionResults) => wrapResults(dependencies, combineAsyncResultsWithSyncResults(results, exceptionResults)));
  },
  dangerouslyAllowMutability: true
});
const waitForAllSettled = Recoil_selectorFamily({
  key: "__waitForAllSettled",
  get: (dependencies) => ({
    get: get2
  }) => {
    const deps = unwrapDependencies(dependencies);
    const [results, exceptions] = concurrentRequests(get2, deps);
    if (exceptions.every((exp) => !Recoil_isPromise(exp))) {
      return wrapLoadables(dependencies, results, exceptions);
    }
    return Promise.all(exceptions.map((exp, i2) => Recoil_isPromise(exp) ? exp.then((result) => {
      results[i2] = result;
      exceptions[i2] = void 0;
    }).catch((error) => {
      results[i2] = void 0;
      exceptions[i2] = error;
    }) : null)).then(() => wrapLoadables(dependencies, results, exceptions));
  },
  dangerouslyAllowMutability: true
});
const noWait = Recoil_selectorFamily({
  key: "__noWait",
  get: (dependency) => ({
    get: get2
  }) => {
    try {
      return Recoil_selector.value(loadableWithValue$4(get2(dependency)));
    } catch (exception) {
      return Recoil_selector.value(Recoil_isPromise(exception) ? loadableWithPromise$3(exception) : loadableWithError$3(exception));
    }
  },
  dangerouslyAllowMutability: true
});
var Recoil_WaitFor = {
  waitForNone,
  waitForAny,
  waitForAll,
  waitForAllSettled,
  noWait
};
const {
  RecoilLoadable
} = Recoil_Loadable$1;
const {
  DefaultValue: DefaultValue$3
} = Recoil_Node;
const {
  RecoilRoot: RecoilRoot$2,
  useRecoilStoreID: useRecoilStoreID$1
} = Recoil_RecoilRoot;
const {
  isRecoilValue: isRecoilValue$5
} = Recoil_RecoilValue$1;
const {
  retentionZone: retentionZone$1
} = Recoil_RetentionZone;
const {
  freshSnapshot: freshSnapshot$2
} = Recoil_Snapshot$1;
const {
  useRecoilState: useRecoilState$1,
  useRecoilState_TRANSITION_SUPPORT_UNSTABLE: useRecoilState_TRANSITION_SUPPORT_UNSTABLE$1,
  useRecoilStateLoadable: useRecoilStateLoadable$1,
  useRecoilValue: useRecoilValue$1,
  useRecoilValue_TRANSITION_SUPPORT_UNSTABLE: useRecoilValue_TRANSITION_SUPPORT_UNSTABLE$1,
  useRecoilValueLoadable: useRecoilValueLoadable$1,
  useRecoilValueLoadable_TRANSITION_SUPPORT_UNSTABLE: useRecoilValueLoadable_TRANSITION_SUPPORT_UNSTABLE$1,
  useResetRecoilState: useResetRecoilState$1,
  useSetRecoilState: useSetRecoilState$1
} = Recoil_Hooks;
const {
  useGotoRecoilSnapshot: useGotoRecoilSnapshot$1,
  useRecoilSnapshot: useRecoilSnapshot$1,
  useRecoilTransactionObserver: useRecoilTransactionObserver$1
} = Recoil_SnapshotHooks;
const {
  useRecoilCallback: useRecoilCallback$1
} = Recoil_useRecoilCallback;
const {
  noWait: noWait$1,
  waitForAll: waitForAll$1,
  waitForAllSettled: waitForAllSettled$1,
  waitForAny: waitForAny$1,
  waitForNone: waitForNone$1
} = Recoil_WaitFor;
var Recoil_index = {
  // Types
  DefaultValue: DefaultValue$3,
  isRecoilValue: isRecoilValue$5,
  RecoilLoadable,
  // Global Recoil environment settiongs
  RecoilEnv: Recoil_RecoilEnv,
  // Recoil Root
  RecoilRoot: RecoilRoot$2,
  useRecoilStoreID: useRecoilStoreID$1,
  useRecoilBridgeAcrossReactRoots_UNSTABLE: Recoil_useRecoilBridgeAcrossReactRoots,
  // Atoms/Selectors
  atom: Recoil_atom,
  selector: Recoil_selector,
  // Convenience Atoms/Selectors
  atomFamily: Recoil_atomFamily,
  selectorFamily: Recoil_selectorFamily,
  constSelector: Recoil_constSelector,
  errorSelector: Recoil_errorSelector,
  readOnlySelector: Recoil_readOnlySelector,
  // Concurrency Helpers for Atoms/Selectors
  noWait: noWait$1,
  waitForNone: waitForNone$1,
  waitForAny: waitForAny$1,
  waitForAll: waitForAll$1,
  waitForAllSettled: waitForAllSettled$1,
  // Hooks for Atoms/Selectors
  useRecoilValue: useRecoilValue$1,
  useRecoilValueLoadable: useRecoilValueLoadable$1,
  useRecoilState: useRecoilState$1,
  useRecoilStateLoadable: useRecoilStateLoadable$1,
  useSetRecoilState: useSetRecoilState$1,
  useResetRecoilState: useResetRecoilState$1,
  useGetRecoilValueInfo_UNSTABLE: Recoil_useGetRecoilValueInfo,
  useRecoilRefresher_UNSTABLE: Recoil_useRecoilRefresher,
  useRecoilValueLoadable_TRANSITION_SUPPORT_UNSTABLE: useRecoilValueLoadable_TRANSITION_SUPPORT_UNSTABLE$1,
  useRecoilValue_TRANSITION_SUPPORT_UNSTABLE: useRecoilValue_TRANSITION_SUPPORT_UNSTABLE$1,
  useRecoilState_TRANSITION_SUPPORT_UNSTABLE: useRecoilState_TRANSITION_SUPPORT_UNSTABLE$1,
  // Hooks for complex operations
  useRecoilCallback: useRecoilCallback$1,
  useRecoilTransaction_UNSTABLE: Recoil_useRecoilTransaction,
  // Snapshots
  useGotoRecoilSnapshot: useGotoRecoilSnapshot$1,
  useRecoilSnapshot: useRecoilSnapshot$1,
  useRecoilTransactionObserver_UNSTABLE: useRecoilTransactionObserver$1,
  snapshot_UNSTABLE: freshSnapshot$2,
  // Memory Management
  useRetain: Recoil_useRetain,
  retentionZone: retentionZone$1
};
var Recoil_index_5 = Recoil_index.RecoilRoot;
var Recoil_index_8 = Recoil_index.atom;
var Recoil_index_9 = Recoil_index.selector;
var Recoil_index_10 = Recoil_index.atomFamily;
var Recoil_index_18 = Recoil_index.waitForAll;
var Recoil_index_20 = Recoil_index.useRecoilValue;
var Recoil_index_22 = Recoil_index.useRecoilState;
var Recoil_index_24 = Recoil_index.useSetRecoilState;
const flowbite_min = "";
const App$2 = "";
const accessTokenKey = "accessTokenKey";
const refreshTokenKey = "refreshTokenKey";
const ofUserIdKey = "currentOFUserId";
const onlyFansHeadersKey = "onlyFansHeaders";
const expiredFansListIdKey = "expiredFansListId";
const ofCreatorDataKey = "ofCreatorData";
const ofAuthRulesKey = "ofAuthRules";
const environmentKey = "environmentKey";
const featureFlagsOverrideKey = "spicy_feature_flags_override";
const messageLabelsCacheKeyPrefix = "messageLabelsCacheKey";
const confirmCreatorAddedDismissedKey = "confirmCreatorAddedDismissed";
class LocalStorageManager {
  static async getCurrentTab() {
    let queryOptions = { active: true, lastFocusedWindow: true };
    let [tab2] = await chrome.tabs.query(queryOptions);
    return tab2;
  }
  static async getTabSpecificKey(key) {
    const tab2 = await this.getCurrentTab();
    const result = (tab2 == null ? void 0 : tab2.id) ? `${key}_${tab2.id}` : key;
    return result;
  }
  static async clear() {
    try {
      const ofUserIdTabKey = await this.getTabSpecificKey(ofUserIdKey);
      const onlyFansHeadersTabKey = await this.getTabSpecificKey(onlyFansHeadersKey);
      const expiredFansListIdTabKey = await this.getTabSpecificKey(expiredFansListIdKey);
      await new Promise((resolve, reject) => {
        chrome.storage.local.remove(
          [
            accessTokenKey,
            refreshTokenKey,
            ofUserIdTabKey,
            onlyFansHeadersTabKey,
            expiredFansListIdTabKey,
            ofCreatorDataKey,
            featureFlagsOverrideKey,
            confirmCreatorAddedDismissedKey
          ],
          () => {
            if (chrome.runtime.lastError) {
              reject(chrome.runtime.lastError);
            } else {
              resolve();
            }
          }
        );
      });
      await this.clearAllMessageLabelCaches();
    } catch (error) {
      throw error;
    }
  }
  static async getAccessToken() {
    try {
      const result = await new Promise((resolve, reject) => {
        chrome.storage.local.get([accessTokenKey], (result2) => {
          if (chrome.runtime.lastError) {
            reject(chrome.runtime.lastError);
          } else {
            resolve(result2);
          }
        });
      });
      return result[accessTokenKey];
    } catch (error) {
      throw error;
    }
  }
  static async setAccessToken(accessToken) {
    try {
      await new Promise((resolve, reject) => {
        chrome.storage.local.set({ [accessTokenKey]: accessToken }, () => {
          if (chrome.runtime.lastError) {
            reject(chrome.runtime.lastError);
          } else {
            resolve();
          }
        });
      });
    } catch (error) {
      throw error;
    }
  }
  static async getRefreshToken() {
    try {
      const result = await new Promise((resolve, reject) => {
        chrome.storage.local.get([refreshTokenKey], (result2) => {
          if (chrome.runtime.lastError) {
            reject(chrome.runtime.lastError);
          } else {
            resolve(result2);
          }
        });
      });
      return result[refreshTokenKey];
    } catch (error) {
      throw error;
    }
  }
  static async setRefreshToken(refreshToken) {
    try {
      await new Promise((resolve, reject) => {
        chrome.storage.local.set({ [refreshTokenKey]: refreshToken }, () => {
          if (chrome.runtime.lastError) {
            reject(chrome.runtime.lastError);
          } else {
            resolve();
          }
        });
      });
    } catch (error) {
      throw error;
    }
  }
  static async setOnlyFansHeaders(headers) {
    try {
      const key = await this.getTabSpecificKey(onlyFansHeadersKey);
      await new Promise((resolve, reject) => {
        chrome.storage.local.set({ [key]: headers }, () => {
          if (chrome.runtime.lastError) {
            reject(chrome.runtime.lastError);
          } else {
            resolve();
          }
        });
      });
    } catch (error) {
      throw error;
    }
  }
  static async getOnlyFansHeaders() {
    try {
      const key = await this.getTabSpecificKey(onlyFansHeadersKey);
      const result = await new Promise((resolve, reject) => {
        chrome.storage.local.get([key], (result2) => {
          if (chrome.runtime.lastError) {
            reject(chrome.runtime.lastError);
          } else {
            resolve(result2);
          }
        });
      });
      return result[key];
    } catch (error) {
      throw error;
    }
  }
  static async setOfUserId(ofUserId) {
    try {
      const key = await this.getTabSpecificKey(ofUserIdKey);
      await new Promise((resolve, reject) => {
        chrome.storage.local.set({ [key]: ofUserId }, () => {
          if (chrome.runtime.lastError) {
            reject(chrome.runtime.lastError);
          } else {
            resolve();
          }
        });
      });
    } catch (error) {
      throw error;
    }
  }
  static async getOfUserId() {
    try {
      const key = await this.getTabSpecificKey(ofUserIdKey);
      const result = await new Promise((resolve, reject) => {
        chrome.storage.local.get([key], (result2) => {
          if (chrome.runtime.lastError) {
            reject(chrome.runtime.lastError);
          } else {
            resolve(result2);
          }
        });
      });
      return result[key];
    } catch (error) {
      throw error;
    }
  }
  static async setExpiredFansListId(listId, creatorId) {
    try {
      const key = `${expiredFansListIdKey}_${creatorId}`;
      await new Promise((resolve, reject) => {
        chrome.storage.local.set({ [key]: listId }, () => {
          if (chrome.runtime.lastError) {
            reject(chrome.runtime.lastError);
          } else {
            resolve();
          }
        });
      });
    } catch (error) {
      throw error;
    }
  }
  static async getExpiredFansListId(creatorId) {
    try {
      const key = `${expiredFansListIdKey}_${creatorId}`;
      const result = await new Promise((resolve, reject) => {
        chrome.storage.local.get([key], (result2) => {
          if (chrome.runtime.lastError) {
            reject(chrome.runtime.lastError);
          } else {
            resolve(result2);
          }
        });
      });
      return result[key];
    } catch (error) {
      throw error;
    }
  }
  static async setOfCreatorData(data) {
    try {
      await new Promise((resolve, reject) => {
        chrome.storage.local.set({ [ofCreatorDataKey]: data }, () => {
          if (chrome.runtime.lastError) {
            reject(chrome.runtime.lastError);
          } else {
            resolve();
          }
        });
      });
    } catch (error) {
      throw error;
    }
  }
  static async getOfCreatorData() {
    try {
      const result = await new Promise((resolve, reject) => {
        chrome.storage.local.get([ofCreatorDataKey], (result2) => {
          if (chrome.runtime.lastError) {
            reject(chrome.runtime.lastError);
          } else {
            resolve(result2);
          }
        });
      });
      return result[ofCreatorDataKey] || { userId: null, expiredFansListId: null };
    } catch (error) {
      throw error;
    }
  }
  static async setOfAuthRules(rules) {
    try {
      await new Promise((resolve, reject) => {
        chrome.storage.local.set({ [ofAuthRulesKey]: rules }, () => {
          if (chrome.runtime.lastError) {
            reject(chrome.runtime.lastError);
          } else {
            resolve();
          }
        });
      });
    } catch (error) {
      throw error;
    }
  }
  static async getOfAuthRules() {
    try {
      const result = await new Promise((resolve, reject) => {
        chrome.storage.local.get([ofAuthRulesKey], (result2) => {
          if (chrome.runtime.lastError) {
            reject(chrome.runtime.lastError);
          } else {
            resolve(result2);
          }
        });
      });
      return result[ofAuthRulesKey];
    } catch (error) {
      throw error;
    }
  }
  static async setEnvironment(environment) {
    try {
      await new Promise((resolve, reject) => {
        chrome.storage.local.set({ [environmentKey]: environment }, () => {
          if (chrome.runtime.lastError) {
            reject(chrome.runtime.lastError);
          } else {
            resolve();
          }
        });
      });
      try {
        localStorage.setItem("environmentKey", environment);
      } catch (err2) {
        console.warn("Could not set environment in localStorage:", err2);
      }
    } catch (error) {
      throw error;
    }
  }
  static async getEnvironment() {
    try {
      const result = await new Promise((resolve, reject) => {
        chrome.storage.local.get([environmentKey], (result2) => {
          if (chrome.runtime.lastError) {
            reject(chrome.runtime.lastError);
          } else {
            resolve(result2);
          }
        });
      });
      if (result[environmentKey]) {
        return result[environmentKey];
      }
      try {
        const localEnv = localStorage.getItem("environmentKey");
        if (localEnv) {
          await this.setEnvironment(localEnv);
          return localEnv;
        }
      } catch (err2) {
        console.warn("Could not get environment from localStorage:", err2);
      }
      return "prod";
    } catch (error) {
      throw error;
    }
  }
  static async setFeatureFlagOverrides(overrides) {
    try {
      await new Promise((resolve, reject) => {
        chrome.storage.local.set({ [featureFlagsOverrideKey]: overrides }, () => {
          if (chrome.runtime.lastError) {
            reject(chrome.runtime.lastError);
          } else {
            resolve();
          }
        });
      });
    } catch (error) {
      throw error;
    }
  }
  static async getFeatureFlagOverrides() {
    try {
      const result = await new Promise((resolve, reject) => {
        chrome.storage.local.get([featureFlagsOverrideKey], (result2) => {
          if (chrome.runtime.lastError) {
            reject(chrome.runtime.lastError);
          } else {
            resolve(result2);
          }
        });
      });
      return result[featureFlagsOverrideKey];
    } catch (error) {
      throw error;
    }
  }
  static async removeFeatureFlagOverrides() {
    try {
      await new Promise((resolve, reject) => {
        chrome.storage.local.remove([featureFlagsOverrideKey], () => {
          if (chrome.runtime.lastError) {
            reject(chrome.runtime.lastError);
          } else {
            resolve();
          }
        });
      });
    } catch (error) {
      throw error;
    }
  }
  // Message label cache methods
  static getMessageLabelsCacheKey(creatorId) {
    return `${messageLabelsCacheKeyPrefix}_${creatorId}`;
  }
  static async setMessageLabelsCache(creatorId, data) {
    try {
      const key = this.getMessageLabelsCacheKey(creatorId);
      const existingData = await this.getMessageLabelsCache(creatorId) || {};
      const mergedData = {
        ...existingData,
        ...data
      };
      await new Promise((resolve, reject) => {
        chrome.storage.local.set({ [key]: mergedData }, () => {
          if (chrome.runtime.lastError) {
            reject(chrome.runtime.lastError);
          } else {
            resolve();
          }
        });
      });
      console.log(
        `[LocalStorageManager] Upserted message labels cache for creator ${creatorId}, updated ${Object.keys(data).length} fans`
      );
    } catch (error) {
      console.error(
        `[LocalStorageManager] Error saving message labels cache for creator ${creatorId}:`,
        error
      );
      throw error;
    }
  }
  static async getMessageLabelsCache(creatorId) {
    try {
      const key = this.getMessageLabelsCacheKey(creatorId);
      const result = await new Promise((resolve, reject) => {
        chrome.storage.local.get([key], (result2) => {
          if (chrome.runtime.lastError) {
            reject(chrome.runtime.lastError);
          } else {
            resolve(result2);
          }
        });
      });
      return result[key];
    } catch (error) {
      console.error(
        `[LocalStorageManager] Error getting message labels cache for creator ${creatorId}:`,
        error
      );
      throw error;
    }
  }
  static async clearAllMessageLabelCaches() {
    try {
      const allKeys = await new Promise((resolve, reject) => {
        chrome.storage.local.get(null, (items) => {
          if (chrome.runtime.lastError) {
            reject(chrome.runtime.lastError);
          } else {
            resolve(Object.keys(items));
          }
        });
      });
      const messageLabelKeys = allKeys.filter(
        (key) => key.startsWith(`${messageLabelsCacheKeyPrefix}_`)
      );
      if (messageLabelKeys.length > 0) {
        await new Promise((resolve, reject) => {
          chrome.storage.local.remove(messageLabelKeys, () => {
            if (chrome.runtime.lastError) {
              reject(chrome.runtime.lastError);
            } else {
              resolve();
            }
          });
        });
        console.log("[LocalStorageManager] Cleared all message label caches");
      }
    } catch (error) {
      console.error("[LocalStorageManager] Error clearing message label caches:", error);
      throw error;
    }
  }
  // Specific method for getting the Spicy Toolbox explore clicked flag
  static async getConfirmCreatorAddedDismissed() {
    try {
      const result = await new Promise((resolve, reject) => {
        chrome.storage.local.get([confirmCreatorAddedDismissedKey], (result2) => {
          if (chrome.runtime.lastError) {
            reject(chrome.runtime.lastError);
          } else {
            resolve(result2);
          }
        });
      });
      return result[confirmCreatorAddedDismissedKey];
    } catch (error) {
      console.error("[LocalStorageManager] Error getting confirmCreatorAddedDismissed:", error);
      throw error;
    }
  }
  // Specific method for setting the Spicy Toolbox explore clicked flag
  static async setConfirmCreatorAddedDismissed(value) {
    try {
      await new Promise((resolve, reject) => {
        chrome.storage.local.set({ [confirmCreatorAddedDismissedKey]: value }, () => {
          if (chrome.runtime.lastError) {
            reject(chrome.runtime.lastError);
          } else {
            resolve();
          }
        });
      });
    } catch (error) {
      console.error("[LocalStorageManager] Error setting confirmCreatorAddedDismissed:", error);
      throw error;
    }
  }
}
const hasCachedAccessToken = async () => {
  const token = await LocalStorageManager.getAccessToken();
  console.log(`[hasCachedAccessToken] ${token}`);
  if (!token) {
    return false;
  }
  const isValid = token.length > 0;
  return isValid;
};
const isLoggedInAtom = Recoil_index_8({
  key: "isLoggedInAtom",
  default: hasCachedAccessToken()
});
const localhost = "http://127.0.0.1:3001/";
const dev = "https://spicyservice-dev-e61f517a47c9.herokuapp.com/";
const staging = "https://spicyservice-staging-03e53510911a.herokuapp.com/";
const prod = "https://spicyservice-d2293c546f39.herokuapp.com/";
let currentEnv = "prod";
let url = prod;
try {
  const storedEnv = localStorage.getItem("environmentKey");
  if (storedEnv && ["localhost", "dev", "staging", "prod"].includes(storedEnv)) {
    currentEnv = storedEnv;
    url = storedEnv === "localhost" ? localhost : storedEnv === "dev" ? dev : storedEnv === "staging" ? staging : prod;
    console.log(`Initialized routes with environment: ${currentEnv}`);
  }
} catch (error) {
  console.error("Error reading environment from localStorage:", error);
}
const apiRoute = "api/";
const authRoute = "auth/";
const getEnvUrl = (env2) => {
  switch (env2) {
    case "localhost":
      return localhost;
    case "dev":
      return dev;
    case "staging":
      return staging;
    case "prod":
    default:
      return prod;
  }
};
const setEnvironment = (env2) => {
  if (["localhost", "dev", "staging", "prod"].includes(env2)) {
    currentEnv = env2;
    url = getEnvUrl(env2);
    try {
      localStorage.setItem("environmentKey", env2);
    } catch (error) {
      console.error("Error saving environment to localStorage:", error);
    }
    console.log(`Environment changed to: ${currentEnv}`);
    return true;
  }
  return false;
};
const getCurrentEnvironment = () => currentEnv;
const generateRoutes = () => ({
  // Auth
  login: `${url}${authRoute}login`,
  signUpOrContinueWithOTP: `${url}${authRoute}signUpOrContinueWithOTP`,
  // API
  token: `${url}${apiRoute}token`,
  getOfAuthRules: `${url}${apiRoute}rules`,
  deleteUser: `${url}${apiRoute}deleteUser`,
  getPrice: `${url}${apiRoute}getPrice`,
  getSubscriptionInfo: `${url}${apiRoute}getSubscriptionInfo`,
  getSubscriptionSettings: `${url}${apiRoute}getSubscriptionSettings`,
  createSubscriptionSettings: `${url}${apiRoute}createSubscriptionSettings`,
  updateSubscriptionSettings: `${url}${apiRoute}updateSubscriptionSettings`,
  updateCreatorSettings: `${url}${apiRoute}updateCreatorSettings`,
  updateTemplates: `${url}${apiRoute}updateTemplates`,
  upsertFanLikes: `${url}${apiRoute}upsertFanLikes`,
  getPendingRewards: `${url}${apiRoute}getPendingRewards`,
  confirmRewardMessageSent: `${url}${apiRoute}confirmRewardMessageSent`,
  getCreatorDataSync: `${url}${apiRoute}getCreatorDataSync`,
  updateCreatorDataSync: `${url}${apiRoute}updateCreatorDataSync`,
  getChargebackDataSync: `${url}${apiRoute}chargebackDataSync/get`,
  updateChargebackDataSync: `${url}${apiRoute}chargebackDataSync/update`,
  upsertChargebacks: `${url}${apiRoute}chargebacks/upsert`,
  getRewards: `${url}${apiRoute}getRewards`,
  createReward: `${url}${apiRoute}createReward`,
  updateReward: `${url}${apiRoute}updateReward`,
  createPortalSession: `${url}${apiRoute}create-portal-session`,
  downgradeToFreePlan: `${url}${apiRoute}downgradeToFreePlan`,
  upgradeToPaid: `${url}${apiRoute}upgradeToPaid`,
  getTeam: `${url}${apiRoute}getTeam`,
  getFollowExpiredFansCounter: `${url}${apiRoute}getFollowExpiredFansCounter`,
  incrementFollowExpiredFansCounter: `${url}${apiRoute}incrementFollowExpiredFansCounter`,
  chatCompletions: `${url}${apiRoute}chat/completions`,
  replySuggestion: `${url}${apiRoute}chat/replySuggestion`,
  getFanInfo: `${url}${apiRoute}getFanInfo`,
  getFanChargebacks: `${url}${apiRoute}getFanChargebacks`,
  updateFanInfo: `${url}${apiRoute}updateFanInfo`
});
const environments = {
  localhost,
  dev,
  staging,
  prod
};
const Routes = generateRoutes();
const refreshRoutes = () => {
  Object.assign(Routes, generateRoutes());
  console.log(`Routes refreshed for environment: ${currentEnv}`);
  return Routes;
};
const environmentAtom = Recoil_index_8({
  key: "environment",
  default: "prod",
  // Default to production
  effects: [
    // Effect to initialize from LocalStorageManager
    ({ setSelf }) => {
      const loadEnvironment = async () => {
        try {
          const env2 = await LocalStorageManager.getEnvironment();
          if (env2) {
            setSelf(env2);
          } else {
            const currentEnv2 = getCurrentEnvironment();
            setSelf(currentEnv2);
          }
        } catch (error) {
          console.error("Error loading environment from storage:", error);
        }
      };
      loadEnvironment();
    },
    // Effect to sync changes to LocalStorageManager
    ({ onSet }) => {
      onSet(async (newEnv) => {
        try {
          await LocalStorageManager.setEnvironment(newEnv);
        } catch (error) {
          console.error("Error saving environment to storage:", error);
        }
      });
    }
  ]
});
const isDevEnvironmentSelector = Recoil_index_9({
  key: "isDevEnvironment",
  get: ({ get: get2 }) => {
    const environment = get2(environmentAtom);
    return environment === "dev" || environment === "localhost";
  }
});
Recoil_index_9({
  key: "pricingUrl",
  get: ({ get: get2 }) => {
    const isDev = get2(isDevEnvironmentSelector);
    return isDev ? "https://spicytoolbox.com/test/pricing" : "https://spicytoolbox.com/pricing";
  }
});
let lastShowComponent$4 = null;
const useEnvStatusBar = () => {
  const showEnvStatusBar = (environment, componentId2) => {
    try {
      console.log(`Showing environment status bar: ${environment} from component ${componentId2}`);
      lastShowComponent$4 = componentId2;
      chrome.tabs.query({ active: true, currentWindow: true }, (tabs) => {
        if (!tabs || !tabs[0] || !tabs[0].id) {
          console.error("No active tab found when trying to show environment status bar");
          return;
        }
        chrome.tabs.sendMessage(
          tabs[0].id,
          {
            type: "showEnvStatusBar",
            environment,
            componentId: componentId2
          },
          (response) => {
            if (chrome.runtime.lastError) {
              console.error("Error sending showEnvStatusBar message:", chrome.runtime.lastError);
            } else if (response) {
              console.log("showEnvStatusBar response:", response);
            }
          }
        );
      });
    } catch (error) {
      console.error("Error in showEnvStatusBar:", error);
    }
  };
  const hideEnvStatusBar = (componentId2) => {
    try {
      console.log(`Hiding environment status bar from component ${componentId2}`);
      if (!componentId2 || componentId2 === lastShowComponent$4) {
        chrome.tabs.query({ active: true, currentWindow: true }, (tabs) => {
          if (!tabs || !tabs[0] || !tabs[0].id) {
            console.error("No active tab found when trying to hide environment status bar");
            return;
          }
          chrome.tabs.sendMessage(
            tabs[0].id,
            {
              type: "hideEnvStatusBar",
              componentId: componentId2
            },
            (response) => {
              if (chrome.runtime.lastError) {
                console.error("Error sending hideEnvStatusBar message:", chrome.runtime.lastError);
              } else if (response) {
                console.log("hideEnvStatusBar response:", response);
              }
            }
          );
        });
        lastShowComponent$4 = null;
      }
    } catch (error) {
      console.error("Error in hideEnvStatusBar:", error);
    }
  };
  return { showEnvStatusBar, hideEnvStatusBar };
};
const EnvStatusBarManager = () => {
  const currentEnvironment = Recoil_index_20(environmentAtom);
  const { showEnvStatusBar, hideEnvStatusBar } = useEnvStatusBar();
  reactExports.useEffect(() => {
    console.log("[EnvStatusBarManager] Environment changed to:", currentEnvironment);
    const timeoutId2 = setTimeout(() => {
      if (currentEnvironment && currentEnvironment !== "prod") {
        console.log(
          "[EnvStatusBarManager] Showing environment status bar for:",
          currentEnvironment
        );
        showEnvStatusBar(currentEnvironment, "EnvStatusBarManager");
      } else {
        console.log("[EnvStatusBarManager] Hiding environment status bar for prod environment");
        hideEnvStatusBar("EnvStatusBarManager");
      }
    }, 300);
    return () => {
      clearTimeout(timeoutId2);
    };
  }, [currentEnvironment, showEnvStatusBar, hideEnvStatusBar]);
  reactExports.useEffect(() => {
    console.log("[EnvStatusBarManager] Component mounted, initializing status bar");
    const timeoutId2 = setTimeout(() => {
      if (currentEnvironment && currentEnvironment !== "prod") {
        console.log(
          "[EnvStatusBarManager] Initial show of environment status bar for:",
          currentEnvironment
        );
        showEnvStatusBar(currentEnvironment, "EnvStatusBarManager");
      }
    }, 1e3);
    return () => {
      clearTimeout(timeoutId2);
      console.log("[EnvStatusBarManager] Component unmounting, hiding status bar");
      hideEnvStatusBar("EnvStatusBarManager");
    };
  }, []);
  return null;
};
const spriteContent = `
<svg xmlns="http://www.w3.org/2000/svg">
  <!-- Copy only the symbols you need -->
  <symbol id="icon-media" viewBox="0 0 24 24">
    <path d="M12,2A10,10,0,1,0,22,12,10,10,0,0,0,12,2Zm0,18a8,8,0,1,1,8-8A8,8,0,0,1,12,20ZM8.5,11A1.5,1.5,0,1,0,7,9.5,1.5,1.5,0,0,0,8.5,11Zm7-3A1.5,1.5,0,1,0,17,9.5,1.5,1.5,0,0,0,15.5,8Zm.5,6c-1.08,0-1.31,2-4,2s-2.92-2-4-2a1,1,0,0,0-1,1c0,.66,1.9,3,5,3s5-2.34,5-3A1,1,0,0,0,16,14Z"/>
  </symbol>
  <!-- Add other symbols as needed -->
</svg>
`;
const IconSprite = () => /* @__PURE__ */ jsxRuntimeExports.jsx(
  "div",
  {
    style: { display: "none" },
    dangerouslySetInnerHTML: { __html: spriteContent }
  }
);
const LoginStatusHandler = () => {
  const isLoggedIn = Recoil_index_20(isLoggedInAtom);
  reactExports.useEffect(() => {
    console.log(`[LoginStatusHandler] ${isLoggedIn}`);
    const handleMessage = (event) => {
      if (event.data.type === "GET_LOGIN_STATUS") {
        window.parent.postMessage({ type: "LOGIN_STATUS_UPDATE", isLoggedIn }, "*");
      }
    };
    window.addEventListener("message", handleMessage);
    window.parent.postMessage({ type: "LOGIN_STATUS_UPDATE", isLoggedIn }, "*");
    return () => {
      window.removeEventListener("message", handleMessage);
    };
  }, [isLoggedIn]);
  return null;
};
const inAppBannerAtom = Recoil_index_8({
  key: "inAppBannerState",
  default: {
    isVisible: false,
    message: "",
    componentId: null
  }
});
const DEFAULT_FEATURE_FLAGS = {
  enableDevMenu: false
};
const subscriptionSettingsAtom = Recoil_index_8({
  key: "subscriptionSettings",
  default: null
});
const subscriptionSettingsIdSelector = Recoil_index_9({
  key: "subscriptionSettingsId",
  get: ({ get: get2 }) => {
    const subscriptionSettings = get2(subscriptionSettingsAtom);
    return (subscriptionSettings == null ? void 0 : subscriptionSettings._id) || null;
  }
});
const featureFlagsSelector = Recoil_index_9({
  key: "featureFlags",
  get: ({ get: get2 }) => {
    const subscriptionSettings = get2(subscriptionSettingsAtom);
    return (subscriptionSettings == null ? void 0 : subscriptionSettings.featureFlags) || DEFAULT_FEATURE_FLAGS;
  }
});
const planTypeSelector = Recoil_index_9({
  key: "planType",
  get: ({ get: get2 }) => {
    const subscriptionSettings = get2(subscriptionSettingsAtom);
    return (subscriptionSettings == null ? void 0 : subscriptionSettings.planType) || "free";
  }
});
const ofUserIdAtom = Recoil_index_8({
  key: "ofUserIdAtom",
  default: null,
  effects: [
    ({ setSelf, onSet, set }) => {
      const loadUserId = async () => {
        try {
          const userId = await LocalStorageManager.getOfUserId();
          console.log("[ofUserIdAtom] getOfUserId", userId);
          if (userId) {
            setSelf(userId);
            return;
          }
          const currentTab = await LocalStorageManager.getCurrentTab();
          if (currentTab == null ? void 0 : currentTab.id) {
            const key = `currentOFUserId_${currentTab.id}`;
            chrome.storage.local.get([key], (result) => {
              const directUserId = result[key];
              console.log("[ofUserIdAtom] Direct storage lookup", directUserId);
              if (directUserId) {
                setSelf(directUserId);
                LocalStorageManager.setOfUserId(directUserId);
              }
            });
          }
        } catch (error) {
          console.error("[ofUserIdAtom] Error loading user ID:", error);
        }
      };
      loadUserId();
      onSet((newValue, oldValue) => {
        console.log("[ofUserIdAtom] onSet", newValue, oldValue);
        LocalStorageManager.setOfUserId(newValue);
      });
    }
  ]
});
let lastShowComponent$3 = null;
const useCreatorNotLinkedStatusBar = () => {
  const showCreatorNotLinkedStatusBar = (message, componentId2) => {
    try {
      console.log(
        `Showing creator not linked status bar: ${message} from component ${componentId2}`
      );
      lastShowComponent$3 = componentId2;
      chrome.tabs.query({ active: true, currentWindow: true }, (tabs) => {
        if (!tabs || !tabs[0] || !tabs[0].id) {
          console.error("No active tab found when trying to show creator not linked status bar");
          return;
        }
        chrome.tabs.sendMessage(
          tabs[0].id,
          {
            type: "showCreatorNotLinkedStatusBar",
            message,
            componentId: componentId2
          },
          (response) => {
            if (chrome.runtime.lastError) {
              console.error(
                "Error sending showCreatorNotLinkedStatusBar message:",
                chrome.runtime.lastError
              );
            } else if (response) {
              console.log("showCreatorNotLinkedStatusBar response:", response);
            }
          }
        );
      });
    } catch (error) {
      console.error("Error in showCreatorNotLinkedStatusBar:", error);
    }
  };
  const hideCreatorNotLinkedStatusBar = (componentId2) => {
    try {
      console.log(`Hiding creator not linked status bar from component ${componentId2}`);
      if (!componentId2 || componentId2 === lastShowComponent$3) {
        chrome.tabs.query({ active: true, currentWindow: true }, (tabs) => {
          if (!tabs || !tabs[0] || !tabs[0].id) {
            console.error("No active tab found when trying to hide creator not linked status bar");
            return;
          }
          chrome.tabs.sendMessage(
            tabs[0].id,
            {
              type: "hideCreatorNotLinkedStatusBar",
              componentId: componentId2
            },
            (response) => {
              if (chrome.runtime.lastError) {
                console.error(
                  "Error sending hideCreatorNotLinkedStatusBar message:",
                  chrome.runtime.lastError
                );
              } else if (response) {
                console.log("hideCreatorNotLinkedStatusBar response:", response);
              }
            }
          );
        });
        lastShowComponent$3 = null;
      }
    } catch (error) {
      console.error("Error in hideCreatorNotLinkedStatusBar:", error);
    }
  };
  return { showCreatorNotLinkedStatusBar, hideCreatorNotLinkedStatusBar };
};
const CreatorNotLinkedStatusBarManager = () => {
  const ofUserId = Recoil_index_20(ofUserIdAtom);
  const subscriptionSettings = Recoil_index_20(subscriptionSettingsAtom);
  const { showCreatorNotLinkedStatusBar, hideCreatorNotLinkedStatusBar } = useCreatorNotLinkedStatusBar();
  reactExports.useEffect(() => {
    console.log("[CreatorNotLinkedStatusBarManager] rendered");
  });
  reactExports.useEffect(() => {
    const checkCreatorLinkStatus = () => {
      var _a;
      try {
        const shouldShowBanner = ofUserId && subscriptionSettings && !((_a = subscriptionSettings == null ? void 0 : subscriptionSettings.ofCreatorIds) == null ? void 0 : _a.includes(ofUserId));
        console.log("[CreatorNotLinkedStatusBarManager] ofUserId:", ofUserId);
        console.log(
          "[CreatorNotLinkedStatusBarManager] subscriptionSettings:",
          subscriptionSettings
        );
        console.log("[CreatorNotLinkedStatusBarManager] shouldShowBanner:", shouldShowBanner);
        if (shouldShowBanner) {
          const message = `🚨 Chargeback protection is disabled because this account isn't linked! <span style="text-decoration: underline; margin-left: 4px; margin-right: 4px; color: #FBCFE8; cursor: pointer; font-weight: 600;" id="linkAccountButton">Click here</span> to link your account 🚨`;
          console.log("[CreatorNotLinkedStatusBarManager] Showing creator not linked banner");
          showCreatorNotLinkedStatusBar(message, "CreatorNotLinkedStatusBarManager");
        } else {
          console.log("[CreatorNotLinkedStatusBarManager] Hiding creator not linked banner");
          hideCreatorNotLinkedStatusBar("CreatorNotLinkedStatusBarManager");
        }
      } catch (error) {
        console.error(
          "[CreatorNotLinkedStatusBarManager] Error checking creator link status:",
          error
        );
        hideCreatorNotLinkedStatusBar("CreatorNotLinkedStatusBarManager");
      }
    };
    checkCreatorLinkStatus();
  }, [
    ofUserId,
    subscriptionSettings,
    showCreatorNotLinkedStatusBar,
    hideCreatorNotLinkedStatusBar
  ]);
  return null;
};
const lastSeenActiveTabAtom = Recoil_index_8({
  key: "lastSeenActiveTabAtom",
  default: false
});
const useLastSeenActiveTab = () => {
  const setIsLastSeenActiveTab = Recoil_index_24(lastSeenActiveTabAtom);
  reactExports.useEffect(() => {
    const handleMessage = (message) => {
      if (message.type === "LAST_ACTIVE_TAB_UPDATE") {
        console.log(
          "[useLastSeenActiveTab] Last seen active tab update received:",
          message.isLastSeenActive
        );
        setIsLastSeenActiveTab(message.isLastSeenActive);
      }
    };
    chrome.runtime.sendMessage({ type: "REGISTER_TAB" }, (response) => {
      if (chrome.runtime.lastError) {
        console.error("Error registering tab:", chrome.runtime.lastError);
        return;
      }
    });
    chrome.runtime.onMessage.addListener(handleMessage);
    return () => {
      chrome.runtime.onMessage.removeListener(handleMessage);
    };
  }, []);
};
const LastSeenActiveTabTracker = () => {
  useLastSeenActiveTab();
  return null;
};
class InvalidTokenError extends Error {
}
InvalidTokenError.prototype.name = "InvalidTokenError";
function b64DecodeUnicode(str) {
  return decodeURIComponent(atob(str).replace(/(.)/g, (m2, p2) => {
    let code = p2.charCodeAt(0).toString(16).toUpperCase();
    if (code.length < 2) {
      code = "0" + code;
    }
    return "%" + code;
  }));
}
function base64UrlDecode(str) {
  let output = str.replace(/-/g, "+").replace(/_/g, "/");
  switch (output.length % 4) {
    case 0:
      break;
    case 2:
      output += "==";
      break;
    case 3:
      output += "=";
      break;
    default:
      throw new Error("base64 string is not of the correct length");
  }
  try {
    return b64DecodeUnicode(output);
  } catch (err2) {
    return atob(output);
  }
}
function jwtDecode(token, options) {
  if (typeof token !== "string") {
    throw new InvalidTokenError("Invalid token specified: must be a string");
  }
  options || (options = {});
  const pos = options.header === true ? 0 : 1;
  const part = token.split(".")[pos];
  if (typeof part !== "string") {
    throw new InvalidTokenError(`Invalid token specified: missing part #${pos + 1}`);
  }
  let decoded;
  try {
    decoded = base64UrlDecode(part);
  } catch (e2) {
    throw new InvalidTokenError(`Invalid token specified: invalid base64 for part #${pos + 1} (${e2.message})`);
  }
  try {
    return JSON.parse(decoded);
  } catch (e2) {
    throw new InvalidTokenError(`Invalid token specified: invalid json for part #${pos + 1} (${e2.message})`);
  }
}
const SPICY_SECRET = "efxsVGwTQ6BX5aM7JAGGlYBYPuKeadhkOBSFOz0lQlY";
const useNetworkManager = () => {
  const setIsLoggedIn = Recoil_index_24(isLoggedInAtom);
  const setSubscriptionSettings = Recoil_index_24(subscriptionSettingsAtom);
  const subscriptionSettingsId = Recoil_index_20(subscriptionSettingsIdSelector);
  const ofCreatorId = Recoil_index_20(ofUserIdAtom);
  async function makeAuthenticatedRequest(route, request) {
    try {
      request.headers = {
        ...request.headers,
        "Cache-Control": "no-cache, no-store, must-revalidate",
        Pragma: "no-cache",
        Expires: "0"
      };
      request.headers["x-spicy-secret"] = SPICY_SECRET;
      let response = await fetch(route, {
        ...request,
        cache: "no-store"
      });
      let body = {};
      if (response.status === 404) {
        return response;
      }
      if (response.status !== 403) {
        body = await response.json();
        return {
          status: response.status,
          body
        };
      }
      const responseWhenRefreshingToken = await refreshAccessToken();
      if (responseWhenRefreshingToken.status === 403) {
        setIsLoggedIn(false);
        await LocalStorageManager.clear();
        return;
      }
      request.headers.Authorization = responseWhenRefreshingToken.body.accessToken;
      response = await fetch(route, request);
      if (response.status === 404) {
        return response;
      }
      body = await response.json();
      return {
        status: response.status,
        body
      };
    } catch (err2) {
      console.log("[NetworkManager] err in makeRequest is " + err2);
      throw new Error(err2);
    }
  }
  async function refreshAccessToken() {
    try {
      const refreshToken = await LocalStorageManager.getRefreshToken();
      const request = {
        method: "POST",
        headers: {
          Accept: "application/json",
          "Content-Type": "application/json",
          Authorization: refreshToken,
          "x-spicy-secret": SPICY_SECRET
        }
      };
      const response = await fetch(Routes.token, request);
      if (response.status === 403) {
        return response;
      }
      const body = await response.json();
      if (!body.accessToken) {
        throw Error("Could not refresh accessToken!");
      }
      await LocalStorageManager.setAccessToken(body.accessToken);
      return {
        status: response.status,
        body
      };
    } catch (err2) {
      throw new Error(err2);
    }
  }
  async function signUpOrContinueWithOTP(email, autoLoginNewUser = false) {
    const request = {
      method: "POST",
      headers: {
        Accept: "application/json",
        "Content-Type": "application/json",
        "x-spicy-secret": SPICY_SECRET
      },
      body: JSON.stringify({ email, autoLoginNewUser })
    };
    return await makeAuthenticatedRequest(Routes.signUpOrContinueWithOTP, request);
  }
  async function login(loginBody) {
    try {
      const request = {
        method: "POST",
        headers: {
          Accept: "application/json",
          "Content-Type": "application/json",
          "x-spicy-secret": SPICY_SECRET
        },
        body: JSON.stringify(loginBody)
      };
      return await makeAuthenticatedRequest(Routes.login, request);
    } catch (err2) {
      throw new Error(err2);
    }
  }
  async function getSubscriptionSettings() {
    try {
      const accessToken = await LocalStorageManager.getAccessToken();
      const request = {
        method: "GET",
        headers: {
          Accept: "application/json",
          "Content-Type": "application/json",
          Authorization: accessToken,
          "Cache-Control": "no-cache, no-store, must-revalidate",
          Pragma: "no-cache",
          Expires: "0"
        }
      };
      const response = await makeAuthenticatedRequest(
        `${Routes.getSubscriptionSettings}?ofCreatorId=${ofCreatorId}`,
        request
      );
      return response;
    } catch (err2) {
      throw Error(err2);
    }
  }
  async function createSubscriptionSettings() {
    try {
      const accessToken = await LocalStorageManager.getAccessToken();
      const request = {
        method: "POST",
        headers: {
          Accept: "application/json",
          "Content-Type": "application/json",
          Authorization: accessToken
        }
      };
      const response = await makeAuthenticatedRequest(Routes.createSubscriptionSettings, request);
      if (response.status === 200) {
        setSubscriptionSettings(response.body);
      }
      return response;
    } catch (err2) {
      console.error("Error creating subscription settings:", err2);
      throw Error(err2);
    }
  }
  async function updateSubscriptionSettings(updateData, skipSettingsUpdate = false) {
    try {
      const accessToken = await LocalStorageManager.getAccessToken();
      const request = {
        method: "PUT",
        headers: {
          Accept: "application/json",
          "Content-Type": "application/json",
          Authorization: accessToken
        },
        body: JSON.stringify({ subscriptionSettingsId, ...updateData })
      };
      const response = await makeAuthenticatedRequest(Routes.updateSubscriptionSettings, request);
      if (response.status === 200 && !skipSettingsUpdate) {
        setSubscriptionSettings(response.body);
      }
      return response;
    } catch (err2) {
      throw Error(err2);
    }
  }
  async function updateCreatorSettings(settings) {
    try {
      const accessToken = await LocalStorageManager.getAccessToken();
      const request = {
        method: "PUT",
        headers: {
          Accept: "application/json",
          "Content-Type": "application/json",
          Authorization: accessToken
        },
        body: JSON.stringify({ subscriptionSettingsId, settings, ofCreatorId })
      };
      const response = await makeAuthenticatedRequest(Routes.updateCreatorSettings, request);
      if (response.status === 200) {
        setSubscriptionSettings(response.body);
      }
      return response;
    } catch (err2) {
      console.error("Error updating creator settings:", err2);
      throw Error(err2);
    }
  }
  async function updateTemplates(settings) {
    try {
      const accessToken = await LocalStorageManager.getAccessToken();
      const request = {
        method: "PUT",
        headers: {
          Accept: "application/json",
          "Content-Type": "application/json",
          Authorization: accessToken
        },
        body: JSON.stringify({ subscriptionSettingsId, settings, ofCreatorId })
      };
      const response = await makeAuthenticatedRequest(Routes.updateTemplates, request);
      if (response.status === 200) {
        setSubscriptionSettings(response.body);
      }
      return response;
    } catch (err2) {
      console.error("Error updating templates:", err2);
      throw Error(err2);
    }
  }
  async function upsertFanLikes(list, fanSubscriptionDates) {
    try {
      const accessToken = await LocalStorageManager.getAccessToken();
      const request = {
        method: "POST",
        headers: {
          Accept: "application/json",
          "Content-Type": "application/json",
          Authorization: accessToken
        },
        body: JSON.stringify({
          subscriptionSettingsId,
          fanLikes: list,
          fanSubscriptionDates,
          ofCreatorId
        })
      };
      const response = await makeAuthenticatedRequest(Routes.upsertFanLikes, request);
      return response;
    } catch (err2) {
      console.error("Error upserting fan likes:", err2);
      throw Error(err2);
    }
  }
  async function getPendingRewardMessages(limit = 20, offset3 = 0) {
    try {
      const accessToken = await LocalStorageManager.getAccessToken();
      const request = {
        method: "GET",
        headers: {
          Accept: "application/json",
          "Content-Type": "application/json",
          Authorization: accessToken
        }
      };
      const response = await makeAuthenticatedRequest(
        `${Routes.getPendingRewards}?limit=${limit}&offset=${offset3}&ofCreatorId=${ofCreatorId}`,
        request
      );
      return response;
    } catch (err2) {
      console.error("Error fetching pending rewards:", err2);
      throw Error(err2);
    }
  }
  async function confirmRewardMessageSent(rewardMessageId) {
    try {
      const accessToken = await LocalStorageManager.getAccessToken();
      const request = {
        method: "POST",
        headers: {
          Accept: "application/json",
          "Content-Type": "application/json",
          Authorization: accessToken,
          "x-spicy-secret": SPICY_SECRET
        },
        body: JSON.stringify({ rewardMessageId, ofCreatorId })
      };
      const response = await makeAuthenticatedRequest(Routes.confirmRewardMessageSent, request);
      return response.body;
    } catch (err2) {
      console.error("Error confirming reward message sent:", err2);
      throw Error(err2);
    }
  }
  async function updateCreatorDataSync(updateData) {
    console.log(
      `updateCreatorDataSync subscriptionSettingsId: ${JSON.stringify(subscriptionSettingsId)} ofCreatorId: ${ofCreatorId}`
    );
    try {
      const accessToken = await LocalStorageManager.getAccessToken();
      const request = {
        method: "PUT",
        headers: {
          Accept: "application/json",
          "Content-Type": "application/json",
          Authorization: accessToken
        },
        body: JSON.stringify({
          subscriptionSettingsId,
          ...updateData,
          ofCreatorId
        })
      };
      const response = await makeAuthenticatedRequest(Routes.updateCreatorDataSync, request);
      return response.body;
    } catch (err2) {
      console.error("Error updating creator data sync:", err2);
      throw Error(err2);
    }
  }
  async function getCreatorDataSync() {
    try {
      const accessToken = await LocalStorageManager.getAccessToken();
      const request = {
        method: "GET",
        headers: {
          Accept: "application/json",
          "Content-Type": "application/json",
          Authorization: accessToken
        }
      };
      const response = await makeAuthenticatedRequest(
        `${Routes.getCreatorDataSync}?subscriptionSettingsId=${subscriptionSettingsId}&ofCreatorId=${ofCreatorId}`,
        request
      );
      return response.body;
    } catch (err2) {
      console.error("Error getting creator data sync:", err2);
      throw Error(err2);
    }
  }
  async function getRewards() {
    try {
      const accessToken = await LocalStorageManager.getAccessToken();
      const request = {
        method: "GET",
        headers: {
          Accept: "application/json",
          "Content-Type": "application/json",
          Authorization: accessToken
        }
      };
      const response = await makeAuthenticatedRequest(
        `${Routes.getRewards}?subscriptionSettingsId=${subscriptionSettingsId}&ofCreatorId=${ofCreatorId}`,
        request
      );
      return response.body;
    } catch (err2) {
      console.error("Error fetching rewards:", err2);
      throw Error(err2);
    }
  }
  async function createReward(rewardData) {
    try {
      const accessToken = await LocalStorageManager.getAccessToken();
      const request = {
        method: "POST",
        headers: {
          Accept: "application/json",
          "Content-Type": "application/json",
          Authorization: accessToken
        },
        body: JSON.stringify({
          subscriptionSettingsId,
          ...rewardData,
          ofCreatorId
        })
      };
      const response = await makeAuthenticatedRequest(Routes.createReward, request);
      return response.body;
    } catch (err2) {
      console.error("Error creating reward:", err2);
      throw Error(err2);
    }
  }
  async function updateReward(rewardId, updateData) {
    try {
      const accessToken = await LocalStorageManager.getAccessToken();
      const request = {
        method: "PUT",
        headers: {
          Accept: "application/json",
          "Content-Type": "application/json",
          Authorization: accessToken
        },
        body: JSON.stringify(updateData)
      };
      const response = await makeAuthenticatedRequest(
        `${Routes.updateReward}/${rewardId}`,
        request
      );
      return response.body;
    } catch (err2) {
      console.error("Error updating reward:", err2);
      throw Error(err2);
    }
  }
  async function getPortalSession() {
    try {
      const accessToken = await LocalStorageManager.getAccessToken();
      const request = {
        method: "GET",
        headers: {
          Accept: "application/json",
          "Content-Type": "application/json",
          Authorization: accessToken
        }
      };
      const response = await makeAuthenticatedRequest(`${Routes.createPortalSession}`, request);
      return response.body;
    } catch (err2) {
      console.error("Error getting portal session:", err2);
      throw Error(err2);
    }
  }
  async function getTeam() {
    var _a;
    try {
      const accessToken = await LocalStorageManager.getAccessToken();
      const request = {
        method: "GET",
        headers: {
          Accept: "application/json",
          "Content-Type": "application/json",
          Authorization: accessToken
        }
      };
      const response = await makeAuthenticatedRequest(Routes.getTeam, request);
      return ((_a = response.body) == null ? void 0 : _a.team) || [];
    } catch (err2) {
      console.error("Error getting team data:", err2);
      throw Error(err2);
    }
  }
  async function getFollowExpiredFansCounter() {
    try {
      const accessToken = await LocalStorageManager.getAccessToken();
      const request = {
        method: "GET",
        headers: {
          Accept: "application/json",
          "Content-Type": "application/json",
          Authorization: accessToken
        }
      };
      const response = await makeAuthenticatedRequest(
        `${Routes.getFollowExpiredFansCounter}?subscriptionSettingsId=${subscriptionSettingsId}&ofCreatorId=${ofCreatorId}`,
        request
      );
      return response.body;
    } catch (err2) {
      console.error("Error getting follow expired fans counter:", err2);
      throw Error(err2);
    }
  }
  async function getFanInfo(fanId) {
    try {
      const accessToken = await LocalStorageManager.getAccessToken();
      const request = {
        method: "GET",
        headers: {
          Accept: "application/json",
          "Content-Type": "application/json",
          Authorization: accessToken
        }
      };
      const response = await makeAuthenticatedRequest(
        `${Routes.getFanInfo}?subscriptionSettingsId=${subscriptionSettingsId}&ofCreatorId=${ofCreatorId}&fanId=${fanId}`,
        request
      );
      return response.body;
    } catch (err2) {
      console.error("Error getting fan info:", err2);
      throw Error(err2);
    }
  }
  async function getFanChargebacks(fanId, fanUsername = null) {
    try {
      const accessToken = await LocalStorageManager.getAccessToken();
      const request = {
        method: "GET",
        headers: {
          Accept: "application/json",
          "Content-Type": "application/json",
          Authorization: accessToken
        }
      };
      const response = await makeAuthenticatedRequest(
        `${Routes.getFanChargebacks}?ofCreatorId=${ofCreatorId}&fanId=${fanId}${fanUsername ? `&fanUsername=${encodeURIComponent(fanUsername)}` : ""}`,
        request
      );
      return response.body;
    } catch (err2) {
      console.error("Error getting fan chargebacks:", err2);
      throw Error(err2);
    }
  }
  async function updateFanInfo(fanId, notes) {
    try {
      const accessToken = await LocalStorageManager.getAccessToken();
      const request = {
        method: "PUT",
        headers: {
          Accept: "application/json",
          "Content-Type": "application/json",
          Authorization: accessToken
        },
        body: JSON.stringify({
          subscriptionSettingsId,
          ofCreatorId,
          fanId,
          notes
        })
      };
      const response = await makeAuthenticatedRequest(Routes.updateFanInfo, request);
      return response.body;
    } catch (err2) {
      console.error("Error updating fan info:", err2);
      throw Error(err2);
    }
  }
  async function incrementFollowExpiredFansCounter(currentOffset, shouldIncrementCounter = true) {
    try {
      const accessToken = await LocalStorageManager.getAccessToken();
      const request = {
        method: "POST",
        headers: {
          Accept: "application/json",
          "Content-Type": "application/json",
          Authorization: accessToken
        },
        body: JSON.stringify({
          subscriptionSettingsId,
          ofCreatorId,
          currentOffset,
          shouldIncrementCounter
        })
      };
      const response = await makeAuthenticatedRequest(
        Routes.incrementFollowExpiredFansCounter,
        request
      );
      return response.body;
    } catch (err2) {
      console.error("Error incrementing follow expired fans counter:", err2);
      throw Error(err2);
    }
  }
  async function getChatCompletions(messages, options = {}) {
    try {
      const accessToken = await LocalStorageManager.getAccessToken();
      const request = {
        method: "POST",
        headers: {
          Accept: "application/json",
          "Content-Type": "application/json",
          Authorization: accessToken
        },
        body: JSON.stringify({
          messages,
          ...options
        })
      };
      const response = await makeAuthenticatedRequest(Routes.chatCompletions, request);
      return response.body;
    } catch (err2) {
      console.error("Error getting chat completions:", err2);
      throw Error(err2);
    }
  }
  async function getReplySuggestions(messages, ofRecipientId, useTemplates = false, replyToMessage = null) {
    try {
      const accessToken = await LocalStorageManager.getAccessToken();
      const request = {
        method: "POST",
        headers: {
          Accept: "application/json",
          "Content-Type": "application/json",
          Authorization: accessToken
        },
        body: JSON.stringify({
          messages,
          ofCreatorId,
          ofRecipientId,
          subscriptionSettingsId,
          useTemplates,
          replyToMessage
        })
      };
      const response = await makeAuthenticatedRequest(Routes.replySuggestion, request);
      return response.body;
    } catch (err2) {
      console.error("Error getting reply suggestions:", err2);
      throw Error(err2);
    }
  }
  async function getOfAuthRules() {
    try {
      const accessToken = await LocalStorageManager.getAccessToken();
      const request = {
        method: "GET",
        headers: {
          Accept: "application/json",
          "Content-Type": "application/json",
          Authorization: accessToken,
          "Cache-Control": "no-cache, no-store, must-revalidate",
          Pragma: "no-cache",
          Expires: "0"
        }
      };
      const response = await makeAuthenticatedRequest(Routes.getOfAuthRules, request);
      return response.body;
    } catch (err2) {
      console.error("Error fetching OF auth rules:", err2);
      throw Error(err2);
    }
  }
  async function getPrice() {
    try {
      const accessToken = await LocalStorageManager.getAccessToken();
      const request = {
        method: "GET",
        headers: {
          Accept: "application/json",
          "Content-Type": "application/json",
          Authorization: accessToken
        }
      };
      const response = await makeAuthenticatedRequest(
        `${Routes.getPrice}?subscriptionSettingsId=${subscriptionSettingsId}`,
        request
      );
      return response.body;
    } catch (err2) {
      console.error("Error getting price:", err2);
      throw Error(err2);
    }
  }
  async function getSubscriptionInfo() {
    try {
      const accessToken = await LocalStorageManager.getAccessToken();
      const request = {
        method: "GET",
        headers: {
          Accept: "application/json",
          "Content-Type": "application/json",
          Authorization: accessToken
        }
      };
      const response = await makeAuthenticatedRequest(
        `${Routes.getSubscriptionInfo}?subscriptionSettingsId=${subscriptionSettingsId}`,
        request
      );
      return response.body;
    } catch (err2) {
      console.error("Error getting subscription info:", err2);
      throw Error(err2);
    }
  }
  async function downgradeToFreePlan() {
    try {
      const accessToken = await LocalStorageManager.getAccessToken();
      const request = {
        method: "POST",
        headers: {
          Accept: "application/json",
          "Content-Type": "application/json",
          Authorization: accessToken
        }
      };
      const response = await makeAuthenticatedRequest(Routes.downgradeToFreePlan, request);
      if (response.status === 200) {
        setSubscriptionSettings(response.body.subscriptionSettings);
      }
      return response;
    } catch (err2) {
      console.error("Error downgrading to free plan:", err2);
      throw Error(err2);
    }
  }
  async function upgradeToPaid() {
    try {
      const accessToken = await LocalStorageManager.getAccessToken();
      const request = {
        method: "POST",
        headers: {
          Accept: "application/json",
          "Content-Type": "application/json",
          Authorization: accessToken
        }
      };
      const response = await makeAuthenticatedRequest(Routes.upgradeToPaid, request);
      if (response.status === 200) {
        setSubscriptionSettings(response.body.subscriptionSettings);
      }
      return response;
    } catch (err2) {
      console.error("Error upgrading to paid plan:", err2);
      throw Error(err2);
    }
  }
  async function getCurrentUserId() {
    const accessToken = await LocalStorageManager.getAccessToken();
    if (!accessToken)
      return null;
    const token = accessToken.replace("JWT ", "");
    try {
      const decoded = jwtDecode(token);
      return decoded.userId;
    } catch (error) {
      console.error("Error decoding access token:", error);
      return null;
    }
  }
  async function getCurrentUserIsOwner() {
    var _a;
    const currentUserId = await getCurrentUserId();
    if (!currentUserId)
      return false;
    const settings = await getSubscriptionSettings();
    if (!((_a = settings == null ? void 0 : settings.body) == null ? void 0 : _a.ownerId))
      return false;
    return currentUserId === settings.body.ownerId.toString();
  }
  async function getChargebackDataSync() {
    try {
      const accessToken = await LocalStorageManager.getAccessToken();
      const request = {
        method: "GET",
        headers: {
          Accept: "application/json",
          "Content-Type": "application/json",
          Authorization: accessToken
        }
      };
      const response = await makeAuthenticatedRequest(
        `${Routes.getChargebackDataSync}?ofCreatorId=${ofCreatorId}`,
        request
      );
      return response.body;
    } catch (err2) {
      console.error("Error getting chargeback data sync:", err2);
      throw Error(err2);
    }
  }
  async function updateChargebackDataSync(updateData) {
    try {
      const accessToken = await LocalStorageManager.getAccessToken();
      const request = {
        method: "PUT",
        headers: {
          Accept: "application/json",
          "Content-Type": "application/json",
          Authorization: accessToken
        },
        body: JSON.stringify(updateData)
      };
      const response = await makeAuthenticatedRequest(Routes.updateChargebackDataSync, request);
      return response.body;
    } catch (err2) {
      console.error("Error updating chargeback data sync:", err2);
      throw Error(err2);
    }
  }
  async function upsertChargebacks(chargebacks, fullSyncStartDate, fullSyncOffset) {
    try {
      const accessToken = await LocalStorageManager.getAccessToken();
      const request = {
        method: "POST",
        headers: {
          Accept: "application/json",
          "Content-Type": "application/json",
          Authorization: accessToken
        },
        body: JSON.stringify({
          chargebacks,
          ofCreatorId,
          fullSyncStartDate,
          fullSyncOffset,
          subscriptionSettingsId
        })
      };
      const response = await makeAuthenticatedRequest(Routes.upsertChargebacks, request);
      return response.body;
    } catch (err2) {
      console.error("Error upserting chargebacks:", err2);
      throw Error(err2);
    }
  }
  return {
    signUpOrContinueWithOTP,
    login,
    getPrice,
    getSubscriptionSettings,
    createSubscriptionSettings,
    updateSubscriptionSettings,
    updateCreatorSettings,
    updateTemplates,
    upsertFanLikes,
    getPendingRewardMessages,
    confirmRewardMessageSent,
    updateCreatorDataSync,
    getCreatorDataSync,
    getRewards,
    createReward,
    updateReward,
    getPortalSession,
    getTeam,
    getFollowExpiredFansCounter,
    getFanInfo,
    getFanChargebacks,
    updateFanInfo,
    incrementFollowExpiredFansCounter,
    getChatCompletions,
    getReplySuggestions,
    getOfAuthRules,
    getCurrentUserId,
    getCurrentUserIsOwner,
    getChargebackDataSync,
    updateChargebackDataSync,
    upsertChargebacks,
    getSubscriptionInfo,
    downgradeToFreePlan,
    upgradeToPaid
  };
};
const subscriptionInfoAtom = Recoil_index_8({
  key: "subscriptionInfoAtom",
  default: null
});
const hasBillingInfoSelector = Recoil_index_9({
  key: "hasBillingInfoSelector",
  get: ({ get: get2 }) => {
    const subscriptionInfo = get2(subscriptionInfoAtom);
    return (subscriptionInfo == null ? void 0 : subscriptionInfo.hasBillingInfo) || false;
  }
});
const daysUntilTrialExpirationSelector = Recoil_index_9({
  key: "daysUntilTrialExpirationSelector",
  get: ({ get: get2 }) => {
    const subscriptionInfo = get2(subscriptionInfoAtom);
    if (!(subscriptionInfo == null ? void 0 : subscriptionInfo.trialExpirationDate))
      return null;
    const trialDate = new Date(subscriptionInfo.trialExpirationDate);
    const now = /* @__PURE__ */ new Date();
    const diffMs = trialDate.getTime() - now.getTime();
    const days = Math.max(0, Math.floor(diffMs / (1e3 * 60 * 60 * 24)));
    return days;
  }
});
let lastShowComponent$2 = null;
const useSubscriptionStatusBar = () => {
  const showSubscriptionStatusBar = (message, messageType = "info", componentId2) => {
    try {
      console.log(`Showing subscription status bar: ${message} from component ${componentId2}`);
      lastShowComponent$2 = componentId2;
      chrome.tabs.query({ active: true, currentWindow: true }, (tabs) => {
        if (!tabs || !tabs[0] || !tabs[0].id) {
          console.error("No active tab found when trying to show subscription status bar");
          return;
        }
        chrome.tabs.sendMessage(
          tabs[0].id,
          {
            type: "showSubscriptionStatusBar",
            message,
            messageType,
            componentId: componentId2
          },
          (response) => {
            if (chrome.runtime.lastError) {
              console.error(
                "Error sending showSubscriptionStatusBar message:",
                chrome.runtime.lastError
              );
            } else if (response) {
              console.log("showSubscriptionStatusBar response:", response);
            }
          }
        );
      });
    } catch (error) {
      console.error("Error in showSubscriptionStatusBar:", error);
    }
  };
  const hideSubscriptionStatusBar = (componentId2) => {
    try {
      console.log(`Hiding subscription status bar from component ${componentId2}`);
      if (!componentId2 || componentId2 === lastShowComponent$2) {
        chrome.tabs.query({ active: true, currentWindow: true }, (tabs) => {
          if (!tabs || !tabs[0] || !tabs[0].id) {
            console.error("No active tab found when trying to hide subscription status bar");
            return;
          }
          chrome.tabs.sendMessage(
            tabs[0].id,
            {
              type: "hideSubscriptionStatusBar",
              componentId: componentId2
            },
            (response) => {
              if (chrome.runtime.lastError) {
                console.error(
                  "Error sending hideSubscriptionStatusBar message:",
                  chrome.runtime.lastError
                );
              } else if (response) {
                console.log("hideSubscriptionStatusBar response:", response);
              }
            }
          );
        });
        lastShowComponent$2 = null;
      }
    } catch (error) {
      console.error("Error in hideSubscriptionStatusBar:", error);
    }
  };
  return { showSubscriptionStatusBar, hideSubscriptionStatusBar };
};
const SubscriptionStatusBarManager = () => {
  const subscriptionSettings = Recoil_index_20(subscriptionSettingsAtom);
  const daysUntilTrialExpiration = Recoil_index_20(daysUntilTrialExpirationSelector);
  const hasBillingInfo = Recoil_index_20(hasBillingInfoSelector);
  const planType = Recoil_index_20(planTypeSelector);
  const { showSubscriptionStatusBar, hideSubscriptionStatusBar } = useSubscriptionStatusBar();
  const { getSubscriptionInfo } = useNetworkManager();
  const setSubscriptionInfo = Recoil_index_24(subscriptionInfoAtom);
  const createClickHereSpan = (color) => {
    return `<span style="text-decoration: underline; margin-left: 4px; margin-right: 4px; color: ${color}; cursor: pointer; font-weight: 600;" id="clickHereLink">Click here</span>`;
  };
  reactExports.useEffect(() => {
    console.log("[SubscriptionStatusBarManager] subscriptionSettings", subscriptionSettings);
    if (!(subscriptionSettings == null ? void 0 : subscriptionSettings._id)) {
      return;
    }
    const fetchSubscriptionInfo = async () => {
      try {
        const info = await getSubscriptionInfo();
        console.log("[SubscriptionStatusBarManager] subscriptionInfo", info);
        setSubscriptionInfo(info);
      } catch (error) {
        console.error("Error fetching subscription info:", error);
        hideSubscriptionStatusBar("SubscriptionStatusBarManager");
      }
    };
    fetchSubscriptionInfo();
  }, [subscriptionSettings == null ? void 0 : subscriptionSettings._id]);
  reactExports.useEffect(() => {
    const checkSubscriptionStatus = () => {
      try {
        console.log("[SubscriptionStatusBarManager] hasBillingInfo", hasBillingInfo);
        console.log(
          "[SubscriptionStatusBarManager] daysUntilTrialExpiration",
          daysUntilTrialExpiration
        );
        if (planType === "paid" && // Is paid and about to expire
        hasBillingInfo === false && daysUntilTrialExpiration !== null && daysUntilTrialExpiration > 0 && daysUntilTrialExpiration <= 7) {
          let messageType = "info";
          let message = "";
          if (daysUntilTrialExpiration <= 1) {
            messageType = "error";
            const timeText = daysUntilTrialExpiration === 0 ? "today" : `${daysUntilTrialExpiration} day`;
            message = `💔️ Your trial is expiring ${timeText === "today" ? timeText : `in ${timeText}`}! ${createClickHereSpan("black")} to learn what this means 💔`;
          } else if (daysUntilTrialExpiration <= 3) {
            messageType = "warning";
            const dayText = daysUntilTrialExpiration === 1 ? "day" : "days";
            message = `💕 Your free trial is expiring in ${daysUntilTrialExpiration} ${dayText}! ${createClickHereSpan("#111827")} to learn what this means 💕`;
          } else {
            messageType = "info";
            const dayText = daysUntilTrialExpiration === 1 ? "day" : "days";
            message = `✨ Your free trial is expiring in ${daysUntilTrialExpiration} ${dayText}! ${createClickHereSpan("#FBCFE8")} to learn what this means ✨`;
          }
          console.log(
            "[SubscriptionStatusBarManager] Showing subscription status bar",
            message,
            messageType
          );
          showSubscriptionStatusBar(message, messageType, "SubscriptionStatusBarManager");
          return;
        }
        console.log("[SubscriptionStatusBarManager] Hiding subscription status bar");
        hideSubscriptionStatusBar("SubscriptionStatusBarManager");
      } catch (error) {
        console.error("Error checking subscription status:", error);
        hideSubscriptionStatusBar("SubscriptionStatusBarManager");
      }
    };
    checkSubscriptionStatus();
    const interval = setInterval(checkSubscriptionStatus, 60 * 60 * 1e3);
    return () => {
      clearInterval(interval);
    };
  }, [daysUntilTrialExpiration, hasBillingInfo, planType]);
  return null;
};
const InAppStatusBanner = () => {
  const { isVisible: isVisible3, message, isError: isError2 } = Recoil_index_20(inAppBannerAtom);
  if (!isVisible3)
    return null;
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    "div",
    {
      className: `fixed left-0 top-0 flex h-[28px] w-full items-center justify-center ${isError2 ? "bg-orange-400" : "animate-shimmer"}`,
      style: {
        background: isError2 ? void 0 : "linear-gradient(to right, rgb(225, 254, 188) 0%, rgb(189, 223, 255) 50%, rgb(225, 254, 188) 100%)",
        backgroundSize: isError2 ? void 0 : "200% auto",
        boxShadow: isError2 ? "0 2px 8px rgba(251, 140, 0, 0.2)" : "0 2px 4px rgba(0,0,0,0.1)",
        zIndex: isError2 ? "10001" : "10000"
      },
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(
        "span",
        {
          className: `font-roboto text-xs font-semibold ${isError2 ? "text-black-spicy" : "text-black-spicy"}`,
          children: message
        }
      )
    }
  );
};
const featureFlagOverridesAtom = Recoil_index_8({
  key: "featureFlagOverrides",
  default: null,
  effects: [
    ({ setSelf, onSet }) => {
      const loadOverrides = async () => {
        try {
          const savedOverrides = await LocalStorageManager.getFeatureFlagOverrides();
          if (savedOverrides) {
            setSelf(savedOverrides);
          }
        } catch (error) {
          console.error("Error loading feature flag overrides:", error);
        }
      };
      loadOverrides();
      onSet((newValue) => {
        if (newValue === null) {
          LocalStorageManager.removeFeatureFlagOverrides();
        } else {
          LocalStorageManager.setFeatureFlagOverrides(newValue);
        }
      });
    }
  ]
});
const effectiveFeatureFlagsSelector = Recoil_index_9({
  key: "effectiveFeatureFlags",
  get: ({ get: get2 }) => {
    const serverFeatureFlags = get2(featureFlagsSelector) || {};
    const overrides = get2(featureFlagOverridesAtom);
    if (!overrides) {
      return serverFeatureFlags;
    }
    return {
      ...serverFeatureFlags,
      ...overrides
    };
  }
});
const hasFeatureFlagOverridesSelector = Recoil_index_9({
  key: "hasFeatureFlagOverrides",
  get: ({ get: get2 }) => {
    return get2(featureFlagOverridesAtom) !== null;
  }
});
const hasUnsavedChangesAtom = Recoil_index_8({
  key: "hasUnsavedChangesAtom",
  default: false
});
function e$2(e2, t2) {
  var i2 = Object.keys(e2);
  if (Object.getOwnPropertySymbols) {
    var n2 = Object.getOwnPropertySymbols(e2);
    t2 && (n2 = n2.filter(function(t3) {
      return Object.getOwnPropertyDescriptor(e2, t3).enumerable;
    })), i2.push.apply(i2, n2);
  }
  return i2;
}
function t$1(t2) {
  for (var n2 = 1; n2 < arguments.length; n2++) {
    var r2 = null != arguments[n2] ? arguments[n2] : {};
    n2 % 2 ? e$2(Object(r2), true).forEach(function(e2) {
      i$1(t2, e2, r2[e2]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t2, Object.getOwnPropertyDescriptors(r2)) : e$2(Object(r2)).forEach(function(e2) {
      Object.defineProperty(t2, e2, Object.getOwnPropertyDescriptor(r2, e2));
    });
  }
  return t2;
}
function i$1(e2, t2, i2) {
  return t2 in e2 ? Object.defineProperty(e2, t2, { value: i2, enumerable: true, configurable: true, writable: true }) : e2[t2] = i2, e2;
}
function n$3(e2, t2) {
  if (null == e2)
    return {};
  var i2, n2, r2 = function(e3, t3) {
    if (null == e3)
      return {};
    var i3, n3, r3 = {}, s3 = Object.keys(e3);
    for (n3 = 0; n3 < s3.length; n3++)
      i3 = s3[n3], t3.indexOf(i3) >= 0 || (r3[i3] = e3[i3]);
    return r3;
  }(e2, t2);
  if (Object.getOwnPropertySymbols) {
    var s2 = Object.getOwnPropertySymbols(e2);
    for (n2 = 0; n2 < s2.length; n2++)
      i2 = s2[n2], t2.indexOf(i2) >= 0 || Object.prototype.propertyIsEnumerable.call(e2, i2) && (r2[i2] = e2[i2]);
  }
  return r2;
}
var r$3, s$1 = { DEBUG: false, LIB_VERSION: "1.200.1" }, o$1 = "undefined" != typeof window ? window : void 0, a$1 = "undefined" != typeof globalThis ? globalThis : o$1, l$3 = Array.prototype, u$1 = l$3.forEach, c$3 = l$3.indexOf, d$2 = null == a$1 ? void 0 : a$1.navigator, h$2 = null == a$1 ? void 0 : a$1.document, _ = null == a$1 ? void 0 : a$1.location, p$2 = null == a$1 ? void 0 : a$1.fetch, v$2 = null != a$1 && a$1.XMLHttpRequest && "withCredentials" in new a$1.XMLHttpRequest() ? a$1.XMLHttpRequest : void 0, g$2 = null == a$1 ? void 0 : a$1.AbortController, f$2 = null == d$2 ? void 0 : d$2.userAgent, m$2 = null != o$1 ? o$1 : {}, b$2 = "$copy_autocapture", y$2 = ["$snapshot", "$pageview", "$pageleave", "$set", "survey dismissed", "survey sent", "survey shown", "$identify", "$groupidentify", "$create_alias", "$$client_ingestion_warning", "$web_experiment_applied", "$feature_enrollment_update", "$feature_flag_called"];
!function(e2) {
  e2.GZipJS = "gzip-js", e2.Base64 = "base64";
}(r$3 || (r$3 = {}));
var S = Array.isArray, E$1 = Object.prototype, k$2 = E$1.hasOwnProperty, x$2 = E$1.toString, I$1 = S || function(e2) {
  return "[object Array]" === x$2.call(e2);
}, C$1 = (e2) => "function" == typeof e2, P = (e2) => e2 === Object(e2) && !I$1(e2), R = (e2) => {
  if (P(e2)) {
    for (var t2 in e2)
      if (k$2.call(e2, t2))
        return false;
    return true;
  }
  return false;
}, F$1 = (e2) => void 0 === e2, T = (e2) => "[object String]" == x$2.call(e2), $ = (e2) => T(e2) && 0 === e2.trim().length, O = (e2) => null === e2, L = (e2) => F$1(e2) || O(e2), M = (e2) => "[object Number]" == x$2.call(e2), A$2 = (e2) => "[object Boolean]" === x$2.call(e2), D$1 = (e2) => e2 instanceof FormData, N = (e2) => V(y$2, e2), q$2 = (e2) => {
  var t2 = { _log: function(t3) {
    if (o$1 && (s$1.DEBUG || m$2.POSTHOG_DEBUG) && !F$1(o$1.console) && o$1.console) {
      for (var i2 = ("__rrweb_original__" in o$1.console[t3]) ? o$1.console[t3].__rrweb_original__ : o$1.console[t3], n2 = arguments.length, r2 = new Array(n2 > 1 ? n2 - 1 : 0), a2 = 1; a2 < n2; a2++)
        r2[a2 - 1] = arguments[a2];
      i2(e2, ...r2);
    }
  }, info: function() {
    for (var e3 = arguments.length, i2 = new Array(e3), n2 = 0; n2 < e3; n2++)
      i2[n2] = arguments[n2];
    t2._log("log", ...i2);
  }, warn: function() {
    for (var e3 = arguments.length, i2 = new Array(e3), n2 = 0; n2 < e3; n2++)
      i2[n2] = arguments[n2];
    t2._log("warn", ...i2);
  }, error: function() {
    for (var e3 = arguments.length, i2 = new Array(e3), n2 = 0; n2 < e3; n2++)
      i2[n2] = arguments[n2];
    t2._log("error", ...i2);
  }, critical: function() {
    for (var t3 = arguments.length, i2 = new Array(t3), n2 = 0; n2 < t3; n2++)
      i2[n2] = arguments[n2];
    console.error(e2, ...i2);
  }, uninitializedWarning: (e3) => {
    t2.error("You must initialize PostHog before calling ".concat(e3));
  }, createLogger: (t3) => q$2("".concat(e2, " ").concat(t3)) };
  return t2;
}, B$1 = q$2("[PostHog.js]"), H$1 = B$1.createLogger, U = {}, z$2 = function(e2) {
  return e2.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, "");
};
function j(e2, t2, i2) {
  if (I$1(e2)) {
    if (u$1 && e2.forEach === u$1)
      e2.forEach(t2, i2);
    else if ("length" in e2 && e2.length === +e2.length) {
      for (var n2 = 0, r2 = e2.length; n2 < r2; n2++)
        if (n2 in e2 && t2.call(i2, e2[n2], n2) === U)
          return;
    }
  }
}
function W(e2, t2, i2) {
  if (!L(e2)) {
    if (I$1(e2))
      return j(e2, t2, i2);
    if (D$1(e2)) {
      for (var n2 of e2.entries())
        if (t2.call(i2, n2[1], n2[0]) === U)
          return;
    } else
      for (var r2 in e2)
        if (k$2.call(e2, r2) && t2.call(i2, e2[r2], r2) === U)
          return;
  }
}
var G$1 = function(e2) {
  for (var t2 = arguments.length, i2 = new Array(t2 > 1 ? t2 - 1 : 0), n2 = 1; n2 < t2; n2++)
    i2[n2 - 1] = arguments[n2];
  return j(i2, function(t3) {
    for (var i3 in t3)
      void 0 !== t3[i3] && (e2[i3] = t3[i3]);
  }), e2;
};
function V(e2, t2) {
  return -1 !== e2.indexOf(t2);
}
function J(e2) {
  for (var t2 = Object.keys(e2), i2 = t2.length, n2 = new Array(i2); i2--; )
    n2[i2] = [t2[i2], e2[t2[i2]]];
  return n2;
}
var Y = function(e2) {
  try {
    return e2();
  } catch (e3) {
    return;
  }
}, X = function(e2) {
  return function() {
    try {
      for (var t2 = arguments.length, i2 = new Array(t2), n2 = 0; n2 < t2; n2++)
        i2[n2] = arguments[n2];
      return e2.apply(this, i2);
    } catch (e3) {
      B$1.critical("Implementation error. Please turn on debug mode and open a ticket on https://app.posthog.com/home#panel=support%3Asupport%3A."), B$1.critical(e3);
    }
  };
}, K = function(e2) {
  var t2 = {};
  return W(e2, function(e3, i2) {
    T(e3) && e3.length > 0 && (t2[i2] = e3);
  }), t2;
}, Q = function(e2) {
  return e2.replace(/^\$/, "");
};
function Z(e2, t2) {
  return i2 = e2, n2 = (e3) => T(e3) && !O(t2) ? e3.slice(0, t2) : e3, r2 = /* @__PURE__ */ new Set(), function e3(t3, i3) {
    return t3 !== Object(t3) ? n2 ? n2(t3, i3) : t3 : r2.has(t3) ? void 0 : (r2.add(t3), I$1(t3) ? (s2 = [], j(t3, (t4) => {
      s2.push(e3(t4));
    })) : (s2 = {}, W(t3, (t4, i4) => {
      r2.has(t4) || (s2[i4] = e3(t4, i4));
    })), s2);
    var s2;
  }(i2);
  var i2, n2, r2;
}
var ee = function(e2) {
  var t2, i2, n2, r2, s2 = "";
  for (t2 = i2 = 0, n2 = (e2 = (e2 + "").replace(/\r\n/g, "\n").replace(/\r/g, "\n")).length, r2 = 0; r2 < n2; r2++) {
    var o2 = e2.charCodeAt(r2), a2 = null;
    o2 < 128 ? i2++ : a2 = o2 > 127 && o2 < 2048 ? String.fromCharCode(o2 >> 6 | 192, 63 & o2 | 128) : String.fromCharCode(o2 >> 12 | 224, o2 >> 6 & 63 | 128, 63 & o2 | 128), O(a2) || (i2 > t2 && (s2 += e2.substring(t2, i2)), s2 += a2, t2 = i2 = r2 + 1);
  }
  return i2 > t2 && (s2 += e2.substring(t2, e2.length)), s2;
}, te = function() {
  function e2(t2) {
    return t2 && (t2.preventDefault = e2.preventDefault, t2.stopPropagation = e2.stopPropagation), t2;
  }
  return e2.preventDefault = function() {
    this.returnValue = false;
  }, e2.stopPropagation = function() {
    this.cancelBubble = true;
  }, function(t2, i2, n2, r2, s2) {
    if (t2)
      if (t2.addEventListener && !r2)
        t2.addEventListener(i2, n2, !!s2);
      else {
        var a2 = "on" + i2, l2 = t2[a2];
        t2[a2] = function(t3, i3, n3) {
          return function(r3) {
            if (r3 = r3 || e2(null == o$1 ? void 0 : o$1.event)) {
              var s3, a3 = true;
              C$1(n3) && (s3 = n3(r3));
              var l3 = i3.call(t3, r3);
              return false !== s3 && false !== l3 || (a3 = false), a3;
            }
          };
        }(t2, n2, l2);
      }
    else
      B$1.error("No valid element provided to register_event");
  };
}();
function ie(e2, t2) {
  for (var i2 = 0; i2 < e2.length; i2++)
    if (t2(e2[i2]))
      return e2[i2];
}
var ne = "$people_distinct_id", re = "__alias", se = "__timers", oe = "$autocapture_disabled_server_side", ae = "$heatmaps_enabled_server_side", le = "$exception_capture_enabled_server_side", ue = "$web_vitals_enabled_server_side", ce = "$dead_clicks_enabled_server_side", de = "$web_vitals_allowed_metrics", he = "$session_recording_enabled_server_side", _e = "$console_log_recording_enabled_server_side", pe = "$session_recording_network_payload_capture", ve = "$session_recording_canvas_recording", ge = "$replay_sample_rate", fe = "$replay_minimum_duration", me = "$replay_script_config", be = "$sesid", ye = "$session_is_sampled", we = "$session_recording_url_trigger_activated_session", Se = "$session_recording_event_trigger_activated_session", Ee = "$enabled_feature_flags", ke = "$early_access_features", xe = "$stored_person_properties", Ie = "$stored_group_properties", Ce = "$surveys", Pe = "$surveys_activated", Re = "$flag_call_reported", Fe = "$user_state", Te = "$client_session_props", $e = "$capture_rate_limit", Oe = "$initial_campaign_params", Le = "$initial_referrer_info", Me = "$initial_person_info", Ae = "$epp", De = "__POSTHOG_TOOLBAR__", Ne = [ne, re, "__cmpns", se, he, ae, be, Ee, Fe, ke, Ie, xe, Ce, Re, Te, $e, Oe, Le, Ae], qe = H$1("[FeatureFlags]"), Be = "$active_feature_flags", He = "$override_feature_flags", Ue = "$feature_flag_payloads", ze = (e2) => {
  var t2 = {};
  for (var [i2, n2] of J(e2 || {}))
    n2 && (t2[i2] = n2);
  return t2;
};
class je {
  constructor(e2) {
    i$1(this, "_override_warning", false), i$1(this, "_hasLoadedFlags", false), i$1(this, "_requestInFlight", false), i$1(this, "_reloadingDisabled", false), i$1(this, "_additionalReloadRequested", false), i$1(this, "_decideCalled", false), i$1(this, "_flagsLoadedFromRemote", false), this.instance = e2, this.featureFlagEventHandlers = [];
  }
  decide() {
    if (this.instance.config.__preview_remote_config)
      this._decideCalled = true;
    else {
      var e2 = !this._reloadDebouncer && (this.instance.config.advanced_disable_feature_flags || this.instance.config.advanced_disable_feature_flags_on_first_load);
      this._callDecideEndpoint({ disableFlags: e2 });
    }
  }
  get hasLoadedFlags() {
    return this._hasLoadedFlags;
  }
  getFlags() {
    return Object.keys(this.getFlagVariants());
  }
  getFlagVariants() {
    var e2 = this.instance.get_property(Ee), t2 = this.instance.get_property(He);
    if (!t2)
      return e2 || {};
    for (var i2 = G$1({}, e2), n2 = Object.keys(t2), r2 = 0; r2 < n2.length; r2++)
      i2[n2[r2]] = t2[n2[r2]];
    return this._override_warning || (qe.warn(" Overriding feature flags!", { enabledFlags: e2, overriddenFlags: t2, finalFlags: i2 }), this._override_warning = true), i2;
  }
  getFlagPayloads() {
    return this.instance.get_property(Ue) || {};
  }
  reloadFeatureFlags() {
    this._reloadingDisabled || this.instance.config.advanced_disable_feature_flags || this._reloadDebouncer || (this._reloadDebouncer = setTimeout(() => {
      this._callDecideEndpoint();
    }, 5));
  }
  clearDebouncer() {
    clearTimeout(this._reloadDebouncer), this._reloadDebouncer = void 0;
  }
  ensureFlagsLoaded() {
    this._hasLoadedFlags || this._requestInFlight || this._reloadDebouncer || this.reloadFeatureFlags();
  }
  setAnonymousDistinctId(e2) {
    this.$anon_distinct_id = e2;
  }
  setReloadingPaused(e2) {
    this._reloadingDisabled = e2;
  }
  _callDecideEndpoint(e2) {
    if (this.clearDebouncer(), !this.instance.config.advanced_disable_decide)
      if (this._requestInFlight)
        this._additionalReloadRequested = true;
      else {
        var t2 = { token: this.instance.config.token, distinct_id: this.instance.get_distinct_id(), groups: this.instance.getGroups(), $anon_distinct_id: this.$anon_distinct_id, person_properties: this.instance.get_property(xe), group_properties: this.instance.get_property(Ie) };
        (null != e2 && e2.disableFlags || this.instance.config.advanced_disable_feature_flags) && (t2.disable_flags = true), this._requestInFlight = true, this.instance._send_request({ method: "POST", url: this.instance.requestRouter.endpointFor("api", "/decide/?v=3"), data: t2, compression: this.instance.config.disable_compression ? void 0 : r$3.Base64, timeout: this.instance.config.feature_flag_request_timeout_ms, callback: (e3) => {
          var i2, n2, r2 = true;
          (200 === e3.statusCode && (this.$anon_distinct_id = void 0, r2 = false), this._requestInFlight = false, this._decideCalled) || (this._decideCalled = true, this.instance._onRemoteConfig(null !== (n2 = e3.json) && void 0 !== n2 ? n2 : {}));
          t2.disable_flags || (this._flagsLoadedFromRemote = !r2, this.receivedFeatureFlags(null !== (i2 = e3.json) && void 0 !== i2 ? i2 : {}, r2), this._additionalReloadRequested && (this._additionalReloadRequested = false, this._callDecideEndpoint()));
        } });
      }
  }
  getFeatureFlag(e2) {
    var t2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
    if (this._hasLoadedFlags || this.getFlags() && this.getFlags().length > 0) {
      var i2, n2, r2, s2, o2, a2 = this.getFlagVariants()[e2], l2 = "".concat(a2), u2 = this.instance.get_property(Re) || {};
      if (t2.send_event || !("send_event" in t2)) {
        if (!(e2 in u2) || !u2[e2].includes(l2))
          I$1(u2[e2]) ? u2[e2].push(l2) : u2[e2] = [l2], null === (i2 = this.instance.persistence) || void 0 === i2 || i2.register({ [Re]: u2 }), this.instance.capture("$feature_flag_called", { $feature_flag: e2, $feature_flag_response: a2, $feature_flag_payload: this.getFeatureFlagPayload(e2) || null, $feature_flag_bootstrapped_response: (null === (n2 = this.instance.config.bootstrap) || void 0 === n2 || null === (r2 = n2.featureFlags) || void 0 === r2 ? void 0 : r2[e2]) || null, $feature_flag_bootstrapped_payload: (null === (s2 = this.instance.config.bootstrap) || void 0 === s2 || null === (o2 = s2.featureFlagPayloads) || void 0 === o2 ? void 0 : o2[e2]) || null, $used_bootstrap_value: !this._flagsLoadedFromRemote });
      }
      return a2;
    }
    qe.warn('getFeatureFlag for key "' + e2 + `" failed. Feature flags didn't load in time.`);
  }
  getFeatureFlagPayload(e2) {
    return this.getFlagPayloads()[e2];
  }
  isFeatureEnabled(e2) {
    var t2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
    if (this._hasLoadedFlags || this.getFlags() && this.getFlags().length > 0)
      return !!this.getFeatureFlag(e2, t2);
    qe.warn('isFeatureEnabled for key "' + e2 + `" failed. Feature flags didn't load in time.`);
  }
  addFeatureFlagsHandler(e2) {
    this.featureFlagEventHandlers.push(e2);
  }
  removeFeatureFlagsHandler(e2) {
    this.featureFlagEventHandlers = this.featureFlagEventHandlers.filter((t2) => t2 !== e2);
  }
  receivedFeatureFlags(e2, i2) {
    if (this.instance.persistence) {
      this._hasLoadedFlags = true;
      var n2 = this.getFlagVariants(), r2 = this.getFlagPayloads();
      !function(e3, i3) {
        var n3 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {}, r3 = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : {}, s2 = e3.featureFlags, o2 = e3.featureFlagPayloads;
        if (s2)
          if (I$1(s2)) {
            var a2 = {};
            if (s2)
              for (var l2 = 0; l2 < s2.length; l2++)
                a2[s2[l2]] = true;
            i3 && i3.register({ [Be]: s2, [Ee]: a2 });
          } else {
            var u2 = s2, c2 = o2;
            e3.errorsWhileComputingFlags && (u2 = t$1(t$1({}, n3), u2), c2 = t$1(t$1({}, r3), c2)), i3 && i3.register({ [Be]: Object.keys(ze(u2)), [Ee]: u2 || {}, [Ue]: c2 || {} });
          }
      }(e2, this.instance.persistence, n2, r2), this._fireFeatureFlagsCallbacks(i2);
    }
  }
  override(e2) {
    var t2 = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
    if (!this.instance.__loaded || !this.instance.persistence)
      return qe.uninitializedWarning("posthog.feature_flags.override");
    if (this._override_warning = t2, false === e2)
      this.instance.persistence.unregister(He);
    else if (I$1(e2)) {
      for (var i2 = {}, n2 = 0; n2 < e2.length; n2++)
        i2[e2[n2]] = true;
      this.instance.persistence.register({ [He]: i2 });
    } else
      this.instance.persistence.register({ [He]: e2 });
  }
  onFeatureFlags(e2) {
    if (this.addFeatureFlagsHandler(e2), this._hasLoadedFlags) {
      var { flags: t2, flagVariants: i2 } = this._prepareFeatureFlagsForCallbacks();
      e2(t2, i2);
    }
    return () => this.removeFeatureFlagsHandler(e2);
  }
  updateEarlyAccessFeatureEnrollment(e2, i2) {
    var n2, r2 = { ["$feature_enrollment/".concat(e2)]: i2 };
    this.instance.capture("$feature_enrollment_update", { $feature_flag: e2, $feature_enrollment: i2, $set: r2 }), this.setPersonPropertiesForFlags(r2, false);
    var s2 = t$1(t$1({}, this.getFlagVariants()), {}, { [e2]: i2 });
    null === (n2 = this.instance.persistence) || void 0 === n2 || n2.register({ [Be]: Object.keys(ze(s2)), [Ee]: s2 }), this._fireFeatureFlagsCallbacks();
  }
  getEarlyAccessFeatures(e2) {
    var t2 = arguments.length > 1 && void 0 !== arguments[1] && arguments[1], i2 = this.instance.get_property(ke);
    if (i2 && !t2)
      return e2(i2);
    this.instance._send_request({ transport: "XHR", url: this.instance.requestRouter.endpointFor("api", "/api/early_access_features/?token=".concat(this.instance.config.token)), method: "GET", callback: (t3) => {
      var i3;
      if (t3.json) {
        var n2 = t3.json.earlyAccessFeatures;
        return null === (i3 = this.instance.persistence) || void 0 === i3 || i3.register({ [ke]: n2 }), e2(n2);
      }
    } });
  }
  _prepareFeatureFlagsForCallbacks() {
    var e2 = this.getFlags(), t2 = this.getFlagVariants();
    return { flags: e2.filter((e3) => t2[e3]), flagVariants: Object.keys(t2).filter((e3) => t2[e3]).reduce((e3, i2) => (e3[i2] = t2[i2], e3), {}) };
  }
  _fireFeatureFlagsCallbacks(e2) {
    var { flags: t2, flagVariants: i2 } = this._prepareFeatureFlagsForCallbacks();
    this.featureFlagEventHandlers.forEach((n2) => n2(t2, i2, { errorsLoading: e2 }));
  }
  setPersonPropertiesForFlags(e2) {
    var i2 = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1], n2 = this.instance.get_property(xe) || {};
    this.instance.register({ [xe]: t$1(t$1({}, n2), e2) }), i2 && this.instance.reloadFeatureFlags();
  }
  resetPersonPropertiesForFlags() {
    this.instance.unregister(xe);
  }
  setGroupPropertiesForFlags(e2) {
    var i2 = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1], n2 = this.instance.get_property(Ie) || {};
    0 !== Object.keys(n2).length && Object.keys(n2).forEach((i3) => {
      n2[i3] = t$1(t$1({}, n2[i3]), e2[i3]), delete e2[i3];
    }), this.instance.register({ [Ie]: t$1(t$1({}, n2), e2) }), i2 && this.instance.reloadFeatureFlags();
  }
  resetGroupPropertiesForFlags(e2) {
    if (e2) {
      var i2 = this.instance.get_property(Ie) || {};
      this.instance.register({ [Ie]: t$1(t$1({}, i2), {}, { [e2]: {} }) });
    } else
      this.instance.unregister(Ie);
  }
}
Math.trunc || (Math.trunc = function(e2) {
  return e2 < 0 ? Math.ceil(e2) : Math.floor(e2);
}), Number.isInteger || (Number.isInteger = function(e2) {
  return M(e2) && isFinite(e2) && Math.floor(e2) === e2;
});
var We = "0123456789abcdef";
class Ge {
  constructor(e2) {
    if (this.bytes = e2, 16 !== e2.length)
      throw new TypeError("not 128-bit length");
  }
  static fromFieldsV7(e2, t2, i2, n2) {
    if (!Number.isInteger(e2) || !Number.isInteger(t2) || !Number.isInteger(i2) || !Number.isInteger(n2) || e2 < 0 || t2 < 0 || i2 < 0 || n2 < 0 || e2 > 281474976710655 || t2 > 4095 || i2 > 1073741823 || n2 > 4294967295)
      throw new RangeError("invalid field value");
    var r2 = new Uint8Array(16);
    return r2[0] = e2 / Math.pow(2, 40), r2[1] = e2 / Math.pow(2, 32), r2[2] = e2 / Math.pow(2, 24), r2[3] = e2 / Math.pow(2, 16), r2[4] = e2 / Math.pow(2, 8), r2[5] = e2, r2[6] = 112 | t2 >>> 8, r2[7] = t2, r2[8] = 128 | i2 >>> 24, r2[9] = i2 >>> 16, r2[10] = i2 >>> 8, r2[11] = i2, r2[12] = n2 >>> 24, r2[13] = n2 >>> 16, r2[14] = n2 >>> 8, r2[15] = n2, new Ge(r2);
  }
  toString() {
    for (var e2 = "", t2 = 0; t2 < this.bytes.length; t2++)
      e2 = e2 + We.charAt(this.bytes[t2] >>> 4) + We.charAt(15 & this.bytes[t2]), 3 !== t2 && 5 !== t2 && 7 !== t2 && 9 !== t2 || (e2 += "-");
    if (36 !== e2.length)
      throw new Error("Invalid UUIDv7 was generated");
    return e2;
  }
  clone() {
    return new Ge(this.bytes.slice(0));
  }
  equals(e2) {
    return 0 === this.compareTo(e2);
  }
  compareTo(e2) {
    for (var t2 = 0; t2 < 16; t2++) {
      var i2 = this.bytes[t2] - e2.bytes[t2];
      if (0 !== i2)
        return Math.sign(i2);
    }
    return 0;
  }
}
class Ve {
  constructor() {
    i$1(this, "timestamp", 0), i$1(this, "counter", 0), i$1(this, "random", new Xe());
  }
  generate() {
    var e2 = this.generateOrAbort();
    if (F$1(e2)) {
      this.timestamp = 0;
      var t2 = this.generateOrAbort();
      if (F$1(t2))
        throw new Error("Could not generate UUID after timestamp reset");
      return t2;
    }
    return e2;
  }
  generateOrAbort() {
    var e2 = Date.now();
    if (e2 > this.timestamp)
      this.timestamp = e2, this.resetCounter();
    else {
      if (!(e2 + 1e4 > this.timestamp))
        return;
      this.counter++, this.counter > 4398046511103 && (this.timestamp++, this.resetCounter());
    }
    return Ge.fromFieldsV7(this.timestamp, Math.trunc(this.counter / Math.pow(2, 30)), this.counter & Math.pow(2, 30) - 1, this.random.nextUint32());
  }
  resetCounter() {
    this.counter = 1024 * this.random.nextUint32() + (1023 & this.random.nextUint32());
  }
}
var Je, Ye = (e2) => {
  if ("undefined" != typeof UUIDV7_DENY_WEAK_RNG && UUIDV7_DENY_WEAK_RNG)
    throw new Error("no cryptographically strong RNG available");
  for (var t2 = 0; t2 < e2.length; t2++)
    e2[t2] = 65536 * Math.trunc(65536 * Math.random()) + Math.trunc(65536 * Math.random());
  return e2;
};
o$1 && !F$1(o$1.crypto) && crypto.getRandomValues && (Ye = (e2) => crypto.getRandomValues(e2));
class Xe {
  constructor() {
    i$1(this, "buffer", new Uint32Array(8)), i$1(this, "cursor", 1 / 0);
  }
  nextUint32() {
    return this.cursor >= this.buffer.length && (Ye(this.buffer), this.cursor = 0), this.buffer[this.cursor++];
  }
}
var Ke = () => Qe().toString(), Qe = () => (Je || (Je = new Ve())).generate(), Ze = "Thu, 01 Jan 1970 00:00:00 GMT", et = "";
var tt = /[a-z0-9][a-z0-9-]+\.[a-z]{2,}$/i;
function it(e2, t2) {
  if (t2) {
    var i2 = function(e3) {
      var t3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : h$2;
      if (et)
        return et;
      if (!t3)
        return "";
      if (["localhost", "127.0.0.1"].includes(e3))
        return "";
      for (var i3 = e3.split("."), n3 = Math.min(i3.length, 8), r2 = "dmn_chk_" + Ke(), s2 = new RegExp("(^|;)\\s*" + r2 + "=1"); !et && n3--; ) {
        var o2 = i3.slice(n3).join("."), a2 = r2 + "=1;domain=." + o2;
        t3.cookie = a2, s2.test(t3.cookie) && (t3.cookie = a2 + ";expires=" + Ze, et = o2);
      }
      return et;
    }(e2);
    if (!i2) {
      var n2 = ((e3) => {
        var t3 = e3.match(tt);
        return t3 ? t3[0] : "";
      })(e2);
      n2 !== i2 && B$1.info("Warning: cookie subdomain discovery mismatch", n2, i2), i2 = n2;
    }
    return i2 ? "; domain=." + i2 : "";
  }
  return "";
}
var nt = { is_supported: () => !!h$2, error: function(e2) {
  B$1.error("cookieStore error: " + e2);
}, get: function(e2) {
  if (h$2) {
    try {
      for (var t2 = e2 + "=", i2 = h$2.cookie.split(";").filter((e3) => e3.length), n2 = 0; n2 < i2.length; n2++) {
        for (var r2 = i2[n2]; " " == r2.charAt(0); )
          r2 = r2.substring(1, r2.length);
        if (0 === r2.indexOf(t2))
          return decodeURIComponent(r2.substring(t2.length, r2.length));
      }
    } catch (e3) {
    }
    return null;
  }
}, parse: function(e2) {
  var t2;
  try {
    t2 = JSON.parse(nt.get(e2)) || {};
  } catch (e3) {
  }
  return t2;
}, set: function(e2, t2, i2, n2, r2) {
  if (h$2)
    try {
      var s2 = "", o2 = "", a2 = it(h$2.location.hostname, n2);
      if (i2) {
        var l2 = /* @__PURE__ */ new Date();
        l2.setTime(l2.getTime() + 24 * i2 * 60 * 60 * 1e3), s2 = "; expires=" + l2.toUTCString();
      }
      r2 && (o2 = "; secure");
      var u2 = e2 + "=" + encodeURIComponent(JSON.stringify(t2)) + s2 + "; SameSite=Lax; path=/" + a2 + o2;
      return u2.length > 3686.4 && B$1.warn("cookieStore warning: large cookie, len=" + u2.length), h$2.cookie = u2, u2;
    } catch (e3) {
      return;
    }
}, remove: function(e2, t2) {
  try {
    nt.set(e2, "", -1, t2);
  } catch (e3) {
    return;
  }
} }, rt = null, st = { is_supported: function() {
  if (!O(rt))
    return rt;
  var e2 = true;
  if (F$1(o$1))
    e2 = false;
  else
    try {
      var t2 = "__mplssupport__";
      st.set(t2, "xyz"), '"xyz"' !== st.get(t2) && (e2 = false), st.remove(t2);
    } catch (t3) {
      e2 = false;
    }
  return e2 || B$1.error("localStorage unsupported; falling back to cookie store"), rt = e2, e2;
}, error: function(e2) {
  B$1.error("localStorage error: " + e2);
}, get: function(e2) {
  try {
    return null == o$1 ? void 0 : o$1.localStorage.getItem(e2);
  } catch (e3) {
    st.error(e3);
  }
  return null;
}, parse: function(e2) {
  try {
    return JSON.parse(st.get(e2)) || {};
  } catch (e3) {
  }
  return null;
}, set: function(e2, t2) {
  try {
    null == o$1 || o$1.localStorage.setItem(e2, JSON.stringify(t2));
  } catch (e3) {
    st.error(e3);
  }
}, remove: function(e2) {
  try {
    null == o$1 || o$1.localStorage.removeItem(e2);
  } catch (e3) {
    st.error(e3);
  }
} }, ot = ["distinct_id", be, ye, Ae, Me], at = t$1(t$1({}, st), {}, { parse: function(e2) {
  try {
    var t2 = {};
    try {
      t2 = nt.parse(e2) || {};
    } catch (e3) {
    }
    var i2 = G$1(t2, JSON.parse(st.get(e2) || "{}"));
    return st.set(e2, i2), i2;
  } catch (e3) {
  }
  return null;
}, set: function(e2, t2, i2, n2, r2, s2) {
  try {
    st.set(e2, t2, void 0, void 0, s2);
    var o2 = {};
    ot.forEach((e3) => {
      t2[e3] && (o2[e3] = t2[e3]);
    }), Object.keys(o2).length && nt.set(e2, o2, i2, n2, r2, s2);
  } catch (e3) {
    st.error(e3);
  }
}, remove: function(e2, t2) {
  try {
    null == o$1 || o$1.localStorage.removeItem(e2), nt.remove(e2, t2);
  } catch (e3) {
    st.error(e3);
  }
} }), lt = {}, ut = { is_supported: function() {
  return true;
}, error: function(e2) {
  B$1.error("memoryStorage error: " + e2);
}, get: function(e2) {
  return lt[e2] || null;
}, parse: function(e2) {
  return lt[e2] || null;
}, set: function(e2, t2) {
  lt[e2] = t2;
}, remove: function(e2) {
  delete lt[e2];
} }, ct = null, dt = { is_supported: function() {
  if (!O(ct))
    return ct;
  if (ct = true, F$1(o$1))
    ct = false;
  else
    try {
      var e2 = "__support__";
      dt.set(e2, "xyz"), '"xyz"' !== dt.get(e2) && (ct = false), dt.remove(e2);
    } catch (e3) {
      ct = false;
    }
  return ct;
}, error: function(e2) {
  B$1.error("sessionStorage error: ", e2);
}, get: function(e2) {
  try {
    return null == o$1 ? void 0 : o$1.sessionStorage.getItem(e2);
  } catch (e3) {
    dt.error(e3);
  }
  return null;
}, parse: function(e2) {
  try {
    return JSON.parse(dt.get(e2)) || null;
  } catch (e3) {
  }
  return null;
}, set: function(e2, t2) {
  try {
    null == o$1 || o$1.sessionStorage.setItem(e2, JSON.stringify(t2));
  } catch (e3) {
    dt.error(e3);
  }
}, remove: function(e2) {
  try {
    null == o$1 || o$1.sessionStorage.removeItem(e2);
  } catch (e3) {
    dt.error(e3);
  }
} }, ht = ["localhost", "127.0.0.1"], _t = (e2) => {
  var t2 = null == h$2 ? void 0 : h$2.createElement("a");
  return F$1(t2) ? null : (t2.href = e2, t2);
}, pt = function(e2, t2) {
  return !!function(e3) {
    try {
      new RegExp(e3);
    } catch (e4) {
      return false;
    }
    return true;
  }(t2) && new RegExp(t2).test(e2);
}, vt = function(e2) {
  var t2, i2, n2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "&", r2 = [];
  return W(e2, function(e3, n3) {
    F$1(e3) || F$1(n3) || "undefined" === n3 || (t2 = encodeURIComponent(((e4) => e4 instanceof File)(e3) ? e3.name : e3.toString()), i2 = encodeURIComponent(n3), r2[r2.length] = i2 + "=" + t2);
  }), r2.join(n2);
}, gt = function(e2, t2) {
  for (var i2, n2 = ((e2.split("#")[0] || "").split("?")[1] || "").split("&"), r2 = 0; r2 < n2.length; r2++) {
    var s2 = n2[r2].split("=");
    if (s2[0] === t2) {
      i2 = s2;
      break;
    }
  }
  if (!I$1(i2) || i2.length < 2)
    return "";
  var o2 = i2[1];
  try {
    o2 = decodeURIComponent(o2);
  } catch (e3) {
    B$1.error("Skipping decoding for malformed query param: " + o2);
  }
  return o2.replace(/\+/g, " ");
}, ft = function(e2, t2) {
  var i2 = e2.match(new RegExp(t2 + "=([^&]*)"));
  return i2 ? i2[1] : null;
}, mt = "Mobile", bt = "iOS", yt = "Android", wt = "Tablet", St = yt + " " + wt, Et = "iPad", kt = "Apple", xt = kt + " Watch", It = "Safari", Ct = "BlackBerry", Pt = "Samsung", Rt = Pt + "Browser", Ft = Pt + " Internet", Tt = "Chrome", $t = Tt + " OS", Ot = Tt + " " + bt, Lt = "Internet Explorer", Mt = Lt + " " + mt, At = "Opera", Dt = At + " Mini", Nt = "Edge", qt = "Microsoft " + Nt, Bt = "Firefox", Ht = Bt + " " + bt, Ut = "Nintendo", zt = "PlayStation", jt = "Xbox", Wt = yt + " " + mt, Gt = mt + " " + It, Vt = "Windows", Jt = Vt + " Phone", Yt = "Nokia", Xt = "Ouya", Kt = "Generic", Qt = Kt + " " + mt.toLowerCase(), Zt = Kt + " " + wt.toLowerCase(), ei = "Konqueror", ti = "(\\d+(\\.\\d+)?)", ii = new RegExp("Version/" + ti), ni = new RegExp(jt, "i"), ri = new RegExp(zt + " \\w+", "i"), si = new RegExp(Ut + " \\w+", "i"), oi = new RegExp(Ct + "|PlayBook|BB10", "i"), ai = { "NT3.51": "NT 3.11", "NT4.0": "NT 4.0", "5.0": "2000", 5.1: "XP", 5.2: "XP", "6.0": "Vista", 6.1: "7", 6.2: "8", 6.3: "8.1", 6.4: "10", "10.0": "10" };
var li = (e2, t2) => t2 && V(t2, kt) || function(e3) {
  return V(e3, It) && !V(e3, Tt) && !V(e3, yt);
}(e2), ui = function(e2, t2) {
  return t2 = t2 || "", V(e2, " OPR/") && V(e2, "Mini") ? Dt : V(e2, " OPR/") ? At : oi.test(e2) ? Ct : V(e2, "IE" + mt) || V(e2, "WPDesktop") ? Mt : V(e2, Rt) ? Ft : V(e2, Nt) || V(e2, "Edg/") ? qt : V(e2, "FBIOS") ? "Facebook " + mt : V(e2, "UCWEB") || V(e2, "UCBrowser") ? "UC Browser" : V(e2, "CriOS") ? Ot : V(e2, "CrMo") || V(e2, Tt) ? Tt : V(e2, yt) && V(e2, It) ? Wt : V(e2, "FxiOS") ? Ht : V(e2.toLowerCase(), ei.toLowerCase()) ? ei : li(e2, t2) ? V(e2, mt) ? Gt : It : V(e2, Bt) ? Bt : V(e2, "MSIE") || V(e2, "Trident/") ? Lt : V(e2, "Gecko") ? Bt : "";
}, ci = { [Mt]: [new RegExp("rv:" + ti)], [qt]: [new RegExp(Nt + "?\\/" + ti)], [Tt]: [new RegExp("(" + Tt + "|CrMo)\\/" + ti)], [Ot]: [new RegExp("CriOS\\/" + ti)], "UC Browser": [new RegExp("(UCBrowser|UCWEB)\\/" + ti)], [It]: [ii], [Gt]: [ii], [At]: [new RegExp("(Opera|OPR)\\/" + ti)], [Bt]: [new RegExp(Bt + "\\/" + ti)], [Ht]: [new RegExp("FxiOS\\/" + ti)], [ei]: [new RegExp("Konqueror[:/]?" + ti, "i")], [Ct]: [new RegExp(Ct + " " + ti), ii], [Wt]: [new RegExp("android\\s" + ti, "i")], [Ft]: [new RegExp(Rt + "\\/" + ti)], [Lt]: [new RegExp("(rv:|MSIE )" + ti)], Mozilla: [new RegExp("rv:" + ti)] }, di = [[new RegExp(jt + "; " + jt + " (.*?)[);]", "i"), (e2) => [jt, e2 && e2[1] || ""]], [new RegExp(Ut, "i"), [Ut, ""]], [new RegExp(zt, "i"), [zt, ""]], [oi, [Ct, ""]], [new RegExp(Vt, "i"), (e2, t2) => {
  if (/Phone/.test(t2) || /WPDesktop/.test(t2))
    return [Jt, ""];
  if (new RegExp(mt).test(t2) && !/IEMobile\b/.test(t2))
    return [Vt + " " + mt, ""];
  var i2 = /Windows NT ([0-9.]+)/i.exec(t2);
  if (i2 && i2[1]) {
    var n2 = i2[1], r2 = ai[n2] || "";
    return /arm/i.test(t2) && (r2 = "RT"), [Vt, r2];
  }
  return [Vt, ""];
}], [/((iPhone|iPad|iPod).*?OS (\d+)_(\d+)_?(\d+)?|iPhone)/, (e2) => {
  if (e2 && e2[3]) {
    var t2 = [e2[3], e2[4], e2[5] || "0"];
    return [bt, t2.join(".")];
  }
  return [bt, ""];
}], [/(watch.*\/(\d+\.\d+\.\d+)|watch os,(\d+\.\d+),)/i, (e2) => {
  var t2 = "";
  return e2 && e2.length >= 3 && (t2 = F$1(e2[2]) ? e2[3] : e2[2]), ["watchOS", t2];
}], [new RegExp("(" + yt + " (\\d+)\\.(\\d+)\\.?(\\d+)?|" + yt + ")", "i"), (e2) => {
  if (e2 && e2[2]) {
    var t2 = [e2[2], e2[3], e2[4] || "0"];
    return [yt, t2.join(".")];
  }
  return [yt, ""];
}], [/Mac OS X (\d+)[_.](\d+)[_.]?(\d+)?/i, (e2) => {
  var t2 = ["Mac OS X", ""];
  if (e2 && e2[1]) {
    var i2 = [e2[1], e2[2], e2[3] || "0"];
    t2[1] = i2.join(".");
  }
  return t2;
}], [/Mac/i, ["Mac OS X", ""]], [/CrOS/, [$t, ""]], [/Linux|debian/i, ["Linux", ""]]], hi = function(e2) {
  return si.test(e2) ? Ut : ri.test(e2) ? zt : ni.test(e2) ? jt : new RegExp(Xt, "i").test(e2) ? Xt : new RegExp("(" + Jt + "|WPDesktop)", "i").test(e2) ? Jt : /iPad/.test(e2) ? Et : /iPod/.test(e2) ? "iPod Touch" : /iPhone/.test(e2) ? "iPhone" : /(watch)(?: ?os[,/]|\d,\d\/)[\d.]+/i.test(e2) ? xt : oi.test(e2) ? Ct : /(kobo)\s(ereader|touch)/i.test(e2) ? "Kobo" : new RegExp(Yt, "i").test(e2) ? Yt : /(kf[a-z]{2}wi|aeo[c-r]{2})( bui|\))/i.test(e2) || /(kf[a-z]+)( bui|\)).+silk\//i.test(e2) ? "Kindle Fire" : /(Android|ZTE)/i.test(e2) ? !new RegExp(mt).test(e2) || /(9138B|TB782B|Nexus [97]|pixel c|HUAWEISHT|BTV|noble nook|smart ultra 6)/i.test(e2) ? /pixel[\daxl ]{1,6}/i.test(e2) && !/pixel c/i.test(e2) || /(huaweimed-al00|tah-|APA|SM-G92|i980|zte|U304AA)/i.test(e2) || /lmy47v/i.test(e2) && !/QTAQZ3/i.test(e2) ? yt : St : yt : new RegExp("(pda|" + mt + ")", "i").test(e2) ? Qt : new RegExp(wt, "i").test(e2) && !new RegExp(wt + " pc", "i").test(e2) ? Zt : "";
}, _i = "https?://(.*)", pi = ["utm_source", "utm_medium", "utm_campaign", "utm_content", "utm_term", "gclid", "gad_source", "gclsrc", "dclid", "gbraid", "wbraid", "fbclid", "msclkid", "twclid", "li_fat_id", "mc_cid", "igshid", "ttclid", "rdt_cid"], vi = { campaignParams: function(e2) {
  return h$2 ? this._campaignParamsFromUrl(h$2.URL, e2) : {};
}, _campaignParamsFromUrl: function(e2, t2) {
  var i2 = pi.concat(t2 || []), n2 = {};
  return W(i2, function(t3) {
    var i3 = gt(e2, t3);
    n2[t3] = i3 || null;
  }), n2;
}, _searchEngine: function(e2) {
  return e2 ? 0 === e2.search(_i + "google.([^/?]*)") ? "google" : 0 === e2.search(_i + "bing.com") ? "bing" : 0 === e2.search(_i + "yahoo.com") ? "yahoo" : 0 === e2.search(_i + "duckduckgo.com") ? "duckduckgo" : null : null;
}, _searchInfoFromReferrer: function(e2) {
  var t2 = vi._searchEngine(e2), i2 = "yahoo" != t2 ? "q" : "p", n2 = {};
  if (!O(t2)) {
    n2.$search_engine = t2;
    var r2 = h$2 ? gt(h$2.referrer, i2) : "";
    r2.length && (n2.ph_keyword = r2);
  }
  return n2;
}, searchInfo: function() {
  var e2 = null == h$2 ? void 0 : h$2.referrer;
  return e2 ? this._searchInfoFromReferrer(e2) : {};
}, browser: ui, browserVersion: function(e2, t2) {
  var i2 = ui(e2, t2), n2 = ci[i2];
  if (F$1(n2))
    return null;
  for (var r2 = 0; r2 < n2.length; r2++) {
    var s2 = n2[r2], o2 = e2.match(s2);
    if (o2)
      return parseFloat(o2[o2.length - 2]);
  }
  return null;
}, browserLanguage: function() {
  return navigator.language || navigator.userLanguage;
}, browserLanguagePrefix: function() {
  var e2 = this.browserLanguage();
  return "string" == typeof e2 ? e2.split("-")[0] : void 0;
}, os: function(e2) {
  for (var t2 = 0; t2 < di.length; t2++) {
    var [i2, n2] = di[t2], r2 = i2.exec(e2), s2 = r2 && (C$1(n2) ? n2(r2, e2) : n2);
    if (s2)
      return s2;
  }
  return ["", ""];
}, device: hi, deviceType: function(e2) {
  var t2 = hi(e2);
  return t2 === Et || t2 === St || "Kobo" === t2 || "Kindle Fire" === t2 || t2 === Zt ? wt : t2 === Ut || t2 === jt || t2 === zt || t2 === Xt ? "Console" : t2 === xt ? "Wearable" : t2 ? mt : "Desktop";
}, referrer: function() {
  return (null == h$2 ? void 0 : h$2.referrer) || "$direct";
}, referringDomain: function() {
  var e2;
  return null != h$2 && h$2.referrer && (null === (e2 = _t(h$2.referrer)) || void 0 === e2 ? void 0 : e2.host) || "$direct";
}, referrerInfo: function() {
  return { $referrer: this.referrer(), $referring_domain: this.referringDomain() };
}, initialPersonInfo: function() {
  return { r: this.referrer().substring(0, 1e3), u: null == _ ? void 0 : _.href.substring(0, 1e3) };
}, initialPersonPropsFromInfo: function(e2) {
  var t2, { r: i2, u: n2 } = e2, r2 = { $initial_referrer: i2, $initial_referring_domain: null == i2 ? void 0 : "$direct" == i2 ? "$direct" : null === (t2 = _t(i2)) || void 0 === t2 ? void 0 : t2.host };
  if (n2) {
    r2.$initial_current_url = n2;
    var s2 = _t(n2);
    r2.$initial_host = null == s2 ? void 0 : s2.host, r2.$initial_pathname = null == s2 ? void 0 : s2.pathname, W(this._campaignParamsFromUrl(n2), function(e3, t3) {
      r2["$initial_" + Q(t3)] = e3;
    });
  }
  i2 && W(this._searchInfoFromReferrer(i2), function(e3, t3) {
    r2["$initial_" + Q(t3)] = e3;
  });
  return r2;
}, timezone: function() {
  try {
    return Intl.DateTimeFormat().resolvedOptions().timeZone;
  } catch (e2) {
    return;
  }
}, timezoneOffset: function() {
  try {
    return (/* @__PURE__ */ new Date()).getTimezoneOffset();
  } catch (e2) {
    return;
  }
}, properties: function() {
  if (!f$2)
    return {};
  var [e2, t2] = vi.os(f$2);
  return G$1(K({ $os: e2, $os_version: t2, $browser: vi.browser(f$2, navigator.vendor), $device: vi.device(f$2), $device_type: vi.deviceType(f$2), $timezone: vi.timezone(), $timezone_offset: vi.timezoneOffset() }), { $current_url: null == _ ? void 0 : _.href, $host: null == _ ? void 0 : _.host, $pathname: null == _ ? void 0 : _.pathname, $raw_user_agent: f$2.length > 1e3 ? f$2.substring(0, 997) + "..." : f$2, $browser_version: vi.browserVersion(f$2, navigator.vendor), $browser_language: vi.browserLanguage(), $browser_language_prefix: vi.browserLanguagePrefix(), $screen_height: null == o$1 ? void 0 : o$1.screen.height, $screen_width: null == o$1 ? void 0 : o$1.screen.width, $viewport_height: null == o$1 ? void 0 : o$1.innerHeight, $viewport_width: null == o$1 ? void 0 : o$1.innerWidth, $lib: "web", $lib_version: s$1.LIB_VERSION, $insert_id: Math.random().toString(36).substring(2, 10) + Math.random().toString(36).substring(2, 10), $time: Date.now() / 1e3 });
}, people_properties: function() {
  if (!f$2)
    return {};
  var [e2, t2] = vi.os(f$2);
  return G$1(K({ $os: e2, $os_version: t2, $browser: vi.browser(f$2, navigator.vendor) }), { $browser_version: vi.browserVersion(f$2, navigator.vendor) });
} }, gi = ["cookie", "localstorage", "localstorage+cookie", "sessionstorage", "memory"];
class fi {
  constructor(e2) {
    this.config = e2, this.props = {}, this.campaign_params_saved = false, this.name = ((e3) => {
      var t2 = "";
      return e3.token && (t2 = e3.token.replace(/\+/g, "PL").replace(/\//g, "SL").replace(/=/g, "EQ")), e3.persistence_name ? "ph_" + e3.persistence_name : "ph_" + t2 + "_posthog";
    })(e2), this.storage = this.buildStorage(e2), this.load(), e2.debug && B$1.info("Persistence loaded", e2.persistence, t$1({}, this.props)), this.update_config(e2, e2), this.save();
  }
  buildStorage(e2) {
    -1 === gi.indexOf(e2.persistence.toLowerCase()) && (B$1.critical("Unknown persistence type " + e2.persistence + "; falling back to localStorage+cookie"), e2.persistence = "localStorage+cookie");
    var t2 = e2.persistence.toLowerCase();
    return "localstorage" === t2 && st.is_supported() ? st : "localstorage+cookie" === t2 && at.is_supported() ? at : "sessionstorage" === t2 && dt.is_supported() ? dt : "memory" === t2 ? ut : "cookie" === t2 ? nt : at.is_supported() ? at : nt;
  }
  properties() {
    var e2 = {};
    return W(this.props, function(t2, i2) {
      if (i2 === Ee && P(t2))
        for (var n2 = Object.keys(t2), r2 = 0; r2 < n2.length; r2++)
          e2["$feature/".concat(n2[r2])] = t2[n2[r2]];
      else
        o2 = i2, a2 = false, (O(s2 = Ne) ? a2 : c$3 && s2.indexOf === c$3 ? -1 != s2.indexOf(o2) : (W(s2, function(e3) {
          if (a2 || (a2 = e3 === o2))
            return U;
        }), a2)) || (e2[i2] = t2);
      var s2, o2, a2;
    }), e2;
  }
  load() {
    if (!this.disabled) {
      var e2 = this.storage.parse(this.name);
      e2 && (this.props = G$1({}, e2));
    }
  }
  save() {
    this.disabled || this.storage.set(this.name, this.props, this.expire_days, this.cross_subdomain, this.secure, this.config.debug);
  }
  remove() {
    this.storage.remove(this.name, false), this.storage.remove(this.name, true);
  }
  clear() {
    this.remove(), this.props = {};
  }
  register_once(e2, t2, i2) {
    if (P(e2)) {
      F$1(t2) && (t2 = "None"), this.expire_days = F$1(i2) ? this.default_expiry : i2;
      var n2 = false;
      if (W(e2, (e3, i3) => {
        this.props.hasOwnProperty(i3) && this.props[i3] !== t2 || (this.props[i3] = e3, n2 = true);
      }), n2)
        return this.save(), true;
    }
    return false;
  }
  register(e2, t2) {
    if (P(e2)) {
      this.expire_days = F$1(t2) ? this.default_expiry : t2;
      var i2 = false;
      if (W(e2, (t3, n2) => {
        e2.hasOwnProperty(n2) && this.props[n2] !== t3 && (this.props[n2] = t3, i2 = true);
      }), i2)
        return this.save(), true;
    }
    return false;
  }
  unregister(e2) {
    e2 in this.props && (delete this.props[e2], this.save());
  }
  update_campaign_params() {
    if (!this.campaign_params_saved) {
      var e2 = vi.campaignParams(this.config.custom_campaign_params);
      R(K(e2)) || this.register(e2), this.campaign_params_saved = true;
    }
  }
  update_search_keyword() {
    this.register(vi.searchInfo());
  }
  update_referrer_info() {
    this.register_once(vi.referrerInfo(), void 0);
  }
  set_initial_person_info() {
    this.props[Oe] || this.props[Le] || this.register_once({ [Me]: vi.initialPersonInfo() }, void 0);
  }
  get_referrer_info() {
    return K({ $referrer: this.props.$referrer, $referring_domain: this.props.$referring_domain });
  }
  get_initial_props() {
    var e2 = {};
    W([Le, Oe], (t3) => {
      var i3 = this.props[t3];
      i3 && W(i3, function(t4, i4) {
        e2["$initial_" + Q(i4)] = t4;
      });
    });
    var t2 = this.props[Me];
    if (t2) {
      var i2 = vi.initialPersonPropsFromInfo(t2);
      G$1(e2, i2);
    }
    return e2;
  }
  safe_merge(e2) {
    return W(this.props, function(t2, i2) {
      i2 in e2 || (e2[i2] = t2);
    }), e2;
  }
  update_config(e2, t2) {
    if (this.default_expiry = this.expire_days = e2.cookie_expiration, this.set_disabled(e2.disable_persistence), this.set_cross_subdomain(e2.cross_subdomain_cookie), this.set_secure(e2.secure_cookie), e2.persistence !== t2.persistence) {
      var i2 = this.buildStorage(e2), n2 = this.props;
      this.clear(), this.storage = i2, this.props = n2, this.save();
    }
  }
  set_disabled(e2) {
    this.disabled = e2, this.disabled ? this.remove() : this.save();
  }
  set_cross_subdomain(e2) {
    e2 !== this.cross_subdomain && (this.cross_subdomain = e2, this.remove(), this.save());
  }
  get_cross_subdomain() {
    return !!this.cross_subdomain;
  }
  set_secure(e2) {
    e2 !== this.secure && (this.secure = e2, this.remove(), this.save());
  }
  set_event_timer(e2, t2) {
    var i2 = this.props[se] || {};
    i2[e2] = t2, this.props[se] = i2, this.save();
  }
  remove_event_timer(e2) {
    var t2 = (this.props[se] || {})[e2];
    return F$1(t2) || (delete this.props[se][e2], this.save()), t2;
  }
  get_property(e2) {
    return this.props[e2];
  }
  set_property(e2, t2) {
    this.props[e2] = t2, this.save();
  }
}
function mi(e2) {
  var t2, i2;
  return (null === (t2 = JSON.stringify(e2, (i2 = [], function(e3, t3) {
    if (P(t3)) {
      for (; i2.length > 0 && i2[i2.length - 1] !== this; )
        i2.pop();
      return i2.includes(t3) ? "[Circular]" : (i2.push(t3), t3);
    }
    return t3;
  }))) || void 0 === t2 ? void 0 : t2.length) || 0;
}
function bi(e2) {
  var t2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 66060288e-1;
  if (e2.size >= t2 && e2.data.length > 1) {
    var i2 = Math.floor(e2.data.length / 2), n2 = e2.data.slice(0, i2), r2 = e2.data.slice(i2);
    return [bi({ size: mi(n2), data: n2, sessionId: e2.sessionId, windowId: e2.windowId }), bi({ size: mi(r2), data: r2, sessionId: e2.sessionId, windowId: e2.windowId })].flatMap((e3) => e3);
  }
  return [e2];
}
var yi = ((e2) => (e2[e2.DomContentLoaded = 0] = "DomContentLoaded", e2[e2.Load = 1] = "Load", e2[e2.FullSnapshot = 2] = "FullSnapshot", e2[e2.IncrementalSnapshot = 3] = "IncrementalSnapshot", e2[e2.Meta = 4] = "Meta", e2[e2.Custom = 5] = "Custom", e2[e2.Plugin = 6] = "Plugin", e2))(yi || {}), wi = ((e2) => (e2[e2.Mutation = 0] = "Mutation", e2[e2.MouseMove = 1] = "MouseMove", e2[e2.MouseInteraction = 2] = "MouseInteraction", e2[e2.Scroll = 3] = "Scroll", e2[e2.ViewportResize = 4] = "ViewportResize", e2[e2.Input = 5] = "Input", e2[e2.TouchMove = 6] = "TouchMove", e2[e2.MediaInteraction = 7] = "MediaInteraction", e2[e2.StyleSheetRule = 8] = "StyleSheetRule", e2[e2.CanvasMutation = 9] = "CanvasMutation", e2[e2.Font = 10] = "Font", e2[e2.Log = 11] = "Log", e2[e2.Drag = 12] = "Drag", e2[e2.StyleDeclaration = 13] = "StyleDeclaration", e2[e2.Selection = 14] = "Selection", e2[e2.AdoptedStyleSheet = 15] = "AdoptedStyleSheet", e2[e2.CustomElement = 16] = "CustomElement", e2))(wi || {});
function Si(e2) {
  var t2;
  return e2.id === De || !(null === (t2 = e2.closest) || void 0 === t2 || !t2.call(e2, ".toolbar-global-fade-container"));
}
function Ei(e2) {
  return !!e2 && 1 === e2.nodeType;
}
function ki(e2, t2) {
  return !!e2 && !!e2.tagName && e2.tagName.toLowerCase() === t2.toLowerCase();
}
function xi(e2) {
  return !!e2 && 3 === e2.nodeType;
}
function Ii(e2) {
  return !!e2 && 11 === e2.nodeType;
}
function Ci(e2) {
  return e2 ? z$2(e2).split(/\s+/) : [];
}
function Pi(e2) {
  var t2 = null == o$1 ? void 0 : o$1.location.href;
  return !!(t2 && e2 && e2.some((e3) => t2.match(e3)));
}
function Ri(e2) {
  var t2 = "";
  switch (typeof e2.className) {
    case "string":
      t2 = e2.className;
      break;
    case "object":
      t2 = (e2.className && "baseVal" in e2.className ? e2.className.baseVal : null) || e2.getAttribute("class") || "";
      break;
    default:
      t2 = "";
  }
  return Ci(t2);
}
function Fi(e2) {
  return L(e2) ? null : z$2(e2).split(/(\s+)/).filter((e3) => ji(e3)).join("").replace(/[\r\n]/g, " ").replace(/[ ]+/g, " ").substring(0, 255);
}
function Ti(e2) {
  var t2 = "";
  return Ai(e2) && !Di(e2) && e2.childNodes && e2.childNodes.length && W(e2.childNodes, function(e3) {
    var i2;
    xi(e3) && e3.textContent && (t2 += null !== (i2 = Fi(e3.textContent)) && void 0 !== i2 ? i2 : "");
  }), z$2(t2);
}
function $i(e2) {
  return F$1(e2.target) ? e2.srcElement || null : null !== (t2 = e2.target) && void 0 !== t2 && t2.shadowRoot ? e2.composedPath()[0] || null : e2.target || null;
  var t2;
}
var Oi = ["a", "button", "form", "input", "select", "textarea", "label"];
function Li(e2) {
  var t2 = e2.parentNode;
  return !(!t2 || !Ei(t2)) && t2;
}
function Mi(e2, t2) {
  var i2 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : void 0, n2 = arguments.length > 3 ? arguments[3] : void 0, r2 = arguments.length > 4 ? arguments[4] : void 0;
  if (!o$1 || !e2 || ki(e2, "html") || !Ei(e2))
    return false;
  if (null != i2 && i2.url_allowlist && !Pi(i2.url_allowlist))
    return false;
  if (null != i2 && i2.url_ignorelist && Pi(i2.url_ignorelist))
    return false;
  if (null != i2 && i2.dom_event_allowlist) {
    var s2 = i2.dom_event_allowlist;
    if (s2 && !s2.some((e3) => t2.type === e3))
      return false;
  }
  for (var a2 = false, l2 = [e2], u2 = true, c2 = e2; c2.parentNode && !ki(c2, "body"); )
    if (Ii(c2.parentNode))
      l2.push(c2.parentNode.host), c2 = c2.parentNode.host;
    else {
      if (!(u2 = Li(c2)))
        break;
      if (n2 || Oi.indexOf(u2.tagName.toLowerCase()) > -1)
        a2 = true;
      else {
        var d2 = o$1.getComputedStyle(u2);
        d2 && "pointer" === d2.getPropertyValue("cursor") && (a2 = true);
      }
      l2.push(u2), c2 = u2;
    }
  if (!function(e3, t3) {
    var i3 = null == t3 ? void 0 : t3.element_allowlist;
    if (F$1(i3))
      return true;
    var n3 = function(e4) {
      if (i3.some((t4) => e4.tagName.toLowerCase() === t4))
        return { v: true };
    };
    for (var r3 of e3) {
      var s3 = n3(r3);
      if ("object" == typeof s3)
        return s3.v;
    }
    return false;
  }(l2, i2))
    return false;
  if (!function(e3, t3) {
    var i3 = null == t3 ? void 0 : t3.css_selector_allowlist;
    if (F$1(i3))
      return true;
    var n3 = function(e4) {
      if (i3.some((t4) => e4.matches(t4)))
        return { v: true };
    };
    for (var r3 of e3) {
      var s3 = n3(r3);
      if ("object" == typeof s3)
        return s3.v;
    }
    return false;
  }(l2, i2))
    return false;
  var h2 = o$1.getComputedStyle(e2);
  if (h2 && "pointer" === h2.getPropertyValue("cursor") && "click" === t2.type)
    return true;
  var _2 = e2.tagName.toLowerCase();
  switch (_2) {
    case "html":
      return false;
    case "form":
      return (r2 || ["submit"]).indexOf(t2.type) >= 0;
    case "input":
    case "select":
    case "textarea":
      return (r2 || ["change", "click"]).indexOf(t2.type) >= 0;
    default:
      return a2 ? (r2 || ["click"]).indexOf(t2.type) >= 0 : (r2 || ["click"]).indexOf(t2.type) >= 0 && (Oi.indexOf(_2) > -1 || "true" === e2.getAttribute("contenteditable"));
  }
}
function Ai(e2) {
  for (var t2 = e2; t2.parentNode && !ki(t2, "body"); t2 = t2.parentNode) {
    var i2 = Ri(t2);
    if (V(i2, "ph-sensitive") || V(i2, "ph-no-capture"))
      return false;
  }
  if (V(Ri(e2), "ph-include"))
    return true;
  var n2 = e2.type || "";
  if (T(n2))
    switch (n2.toLowerCase()) {
      case "hidden":
      case "password":
        return false;
    }
  var r2 = e2.name || e2.id || "";
  if (T(r2)) {
    if (/^cc|cardnum|ccnum|creditcard|csc|cvc|cvv|exp|pass|pwd|routing|seccode|securitycode|securitynum|socialsec|socsec|ssn/i.test(r2.replace(/[^a-zA-Z0-9]/g, "")))
      return false;
  }
  return true;
}
function Di(e2) {
  return !!(ki(e2, "input") && !["button", "checkbox", "submit", "reset"].includes(e2.type) || ki(e2, "select") || ki(e2, "textarea") || "true" === e2.getAttribute("contenteditable"));
}
var Ni = "(4[0-9]{12}(?:[0-9]{3})?)|(5[1-5][0-9]{14})|(6(?:011|5[0-9]{2})[0-9]{12})|(3[47][0-9]{13})|(3(?:0[0-5]|[68][0-9])[0-9]{11})|((?:2131|1800|35[0-9]{3})[0-9]{11})", qi = new RegExp("^(?:".concat(Ni, ")$")), Bi = new RegExp(Ni), Hi = "\\d{3}-?\\d{2}-?\\d{4}", Ui = new RegExp("^(".concat(Hi, ")$")), zi = new RegExp("(".concat(Hi, ")"));
function ji(e2) {
  var t2 = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1];
  if (L(e2))
    return false;
  if (T(e2)) {
    if (e2 = z$2(e2), (t2 ? qi : Bi).test((e2 || "").replace(/[- ]/g, "")))
      return false;
    if ((t2 ? Ui : zi).test(e2))
      return false;
  }
  return true;
}
function Wi(e2) {
  var t2 = Ti(e2);
  return ji(t2 = "".concat(t2, " ").concat(Gi(e2)).trim()) ? t2 : "";
}
function Gi(e2) {
  var t2 = "";
  return e2 && e2.childNodes && e2.childNodes.length && W(e2.childNodes, function(e3) {
    var i2;
    if (e3 && "span" === (null === (i2 = e3.tagName) || void 0 === i2 ? void 0 : i2.toLowerCase()))
      try {
        var n2 = Ti(e3);
        t2 = "".concat(t2, " ").concat(n2).trim(), e3.childNodes && e3.childNodes.length && (t2 = "".concat(t2, " ").concat(Gi(e3)).trim());
      } catch (e4) {
        B$1.error("[AutoCapture]", e4);
      }
  }), t2;
}
function Vi(e2) {
  return function(e3) {
    var i2 = e3.map((e4) => {
      var i3, n2, r2 = "";
      if (e4.tag_name && (r2 += e4.tag_name), e4.attr_class)
        for (var s2 of (e4.attr_class.sort(), e4.attr_class))
          r2 += ".".concat(s2.replace(/"/g, ""));
      var o2 = t$1(t$1(t$1(t$1({}, e4.text ? { text: e4.text } : {}), {}, { "nth-child": null !== (i3 = e4.nth_child) && void 0 !== i3 ? i3 : 0, "nth-of-type": null !== (n2 = e4.nth_of_type) && void 0 !== n2 ? n2 : 0 }, e4.href ? { href: e4.href } : {}), e4.attr_id ? { attr_id: e4.attr_id } : {}), e4.attributes), a2 = {};
      return J(o2).sort((e5, t2) => {
        var [i4] = e5, [n3] = t2;
        return i4.localeCompare(n3);
      }).forEach((e5) => {
        var [t2, i4] = e5;
        return a2[Ji(t2.toString())] = Ji(i4.toString());
      }), r2 += ":", r2 += J(o2).map((e5) => {
        var [t2, i4] = e5;
        return "".concat(t2, '="').concat(i4, '"');
      }).join("");
    });
    return i2.join(";");
  }(function(e3) {
    return e3.map((e4) => {
      var t2, i2, n2 = { text: null === (t2 = e4.$el_text) || void 0 === t2 ? void 0 : t2.slice(0, 400), tag_name: e4.tag_name, href: null === (i2 = e4.attr__href) || void 0 === i2 ? void 0 : i2.slice(0, 2048), attr_class: Yi(e4), attr_id: e4.attr__id, nth_child: e4.nth_child, nth_of_type: e4.nth_of_type, attributes: {} };
      return J(e4).filter((e5) => {
        var [t3] = e5;
        return 0 === t3.indexOf("attr__");
      }).forEach((e5) => {
        var [t3, i3] = e5;
        return n2.attributes[t3] = i3;
      }), n2;
    });
  }(e2));
}
function Ji(e2) {
  return e2.replace(/"|\\"/g, '\\"');
}
function Yi(e2) {
  var t2 = e2.attr__class;
  return t2 ? I$1(t2) ? t2 : Ci(t2) : void 0;
}
var Xi = "[SessionRecording]", Ki = "redacted", Qi = { initiatorTypes: ["audio", "beacon", "body", "css", "early-hint", "embed", "fetch", "frame", "iframe", "icon", "image", "img", "input", "link", "navigation", "object", "ping", "script", "track", "video", "xmlhttprequest"], maskRequestFn: (e2) => e2, recordHeaders: false, recordBody: false, recordInitialRequests: false, recordPerformance: false, performanceEntryTypeToObserve: ["first-input", "navigation", "paint", "resource"], payloadSizeLimitBytes: 1e6, payloadHostDenyList: [".lr-ingest.io", ".ingest.sentry.io"] }, Zi = ["authorization", "x-forwarded-for", "authorization", "cookie", "set-cookie", "x-api-key", "x-real-ip", "remote-addr", "forwarded", "proxy-authorization", "x-csrf-token", "x-csrftoken", "x-xsrf-token"], en = ["password", "secret", "passwd", "api_key", "apikey", "auth", "credentials", "mysql_pwd", "privatekey", "private_key", "token"], tn = ["/s/", "/e/", "/i/"];
function nn(e2, t2, i2, n2) {
  if (L(e2))
    return e2;
  var r2 = (null == t2 ? void 0 : t2["content-length"]) || function(e3) {
    return new Blob([e3]).size;
  }(e2);
  return T(r2) && (r2 = parseInt(r2)), r2 > i2 ? Xi + " ".concat(n2, " body too large to record (").concat(r2, " bytes)") : e2;
}
function rn(e2, t2) {
  if (L(e2))
    return e2;
  var i2 = e2;
  return ji(i2, false) || (i2 = Xi + " " + t2 + " body " + Ki), W(en, (e3) => {
    var n2, r2;
    null !== (n2 = i2) && void 0 !== n2 && n2.length && -1 !== (null === (r2 = i2) || void 0 === r2 ? void 0 : r2.indexOf(e3)) && (i2 = Xi + " " + t2 + " body " + Ki + " as might contain: " + e3);
  }), i2;
}
var sn = (e2, i2) => {
  var n2, r2, s2, o2 = { payloadSizeLimitBytes: Qi.payloadSizeLimitBytes, performanceEntryTypeToObserve: [...Qi.performanceEntryTypeToObserve], payloadHostDenyList: [...i2.payloadHostDenyList || [], ...Qi.payloadHostDenyList] }, a2 = false !== e2.session_recording.recordHeaders && i2.recordHeaders, l2 = false !== e2.session_recording.recordBody && i2.recordBody, u2 = false !== e2.capture_performance && i2.recordPerformance, c2 = (n2 = o2, s2 = Math.min(1e6, null !== (r2 = n2.payloadSizeLimitBytes) && void 0 !== r2 ? r2 : 1e6), (e3) => (null != e3 && e3.requestBody && (e3.requestBody = nn(e3.requestBody, e3.requestHeaders, s2, "Request")), null != e3 && e3.responseBody && (e3.responseBody = nn(e3.responseBody, e3.responseHeaders, s2, "Response")), e3)), d2 = (t2) => {
    return c2(((e3, t3) => {
      var i4, n4 = _t(e3.name), r3 = 0 === t3.indexOf("http") ? null === (i4 = _t(t3)) || void 0 === i4 ? void 0 : i4.pathname : t3;
      "/" === r3 && (r3 = "");
      var s3 = null == n4 ? void 0 : n4.pathname.replace(r3 || "", "");
      if (!(n4 && s3 && tn.some((e4) => 0 === s3.indexOf(e4))))
        return e3;
    })((n3 = (i3 = t2).requestHeaders, L(n3) || W(Object.keys(null != n3 ? n3 : {}), (e3) => {
      Zi.includes(e3.toLowerCase()) && (n3[e3] = Ki);
    }), i3), e2.api_host));
    var i3, n3;
  }, h2 = C$1(e2.session_recording.maskNetworkRequestFn);
  return h2 && C$1(e2.session_recording.maskCapturedNetworkRequestFn) && B$1.warn("Both `maskNetworkRequestFn` and `maskCapturedNetworkRequestFn` are defined. `maskNetworkRequestFn` will be ignored."), h2 && (e2.session_recording.maskCapturedNetworkRequestFn = (i3) => {
    var n3 = e2.session_recording.maskNetworkRequestFn({ url: i3.name });
    return t$1(t$1({}, i3), {}, { name: null == n3 ? void 0 : n3.url });
  }), o2.maskRequestFn = C$1(e2.session_recording.maskCapturedNetworkRequestFn) ? (t2) => {
    var i3, n3, r3, s3 = d2(t2);
    return s3 && null !== (i3 = null === (n3 = (r3 = e2.session_recording).maskCapturedNetworkRequestFn) || void 0 === n3 ? void 0 : n3.call(r3, s3)) && void 0 !== i3 ? i3 : void 0;
  } : (e3) => function(e4) {
    if (!F$1(e4))
      return e4.requestBody = rn(e4.requestBody, "Request"), e4.responseBody = rn(e4.responseBody, "Response"), e4;
  }(d2(e3)), t$1(t$1(t$1({}, Qi), o2), {}, { recordHeaders: a2, recordBody: l2, recordPerformance: u2, recordInitialRequests: u2 });
};
function on(e2, t2, i2, n2, r2) {
  return t2 > i2 && (B$1.warn("min cannot be greater than max."), t2 = i2), M(e2) ? e2 > i2 ? (n2 && B$1.warn(n2 + " cannot be  greater than max: " + i2 + ". Using max value instead."), i2) : e2 < t2 ? (n2 && B$1.warn(n2 + " cannot be less than min: " + t2 + ". Using min value instead."), t2) : e2 : (n2 && B$1.warn(n2 + " must be a number. using max or fallback. max: " + i2 + ", fallback: " + r2), on(r2 || i2, t2, i2, n2));
}
class an {
  constructor(e2) {
    var t2, n2, r2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
    i$1(this, "bucketSize", 100), i$1(this, "refillRate", 10), i$1(this, "mutationBuckets", {}), i$1(this, "loggedTracker", {}), i$1(this, "refillBuckets", () => {
      Object.keys(this.mutationBuckets).forEach((e3) => {
        this.mutationBuckets[e3] = this.mutationBuckets[e3] + this.refillRate, this.mutationBuckets[e3] >= this.bucketSize && delete this.mutationBuckets[e3];
      });
    }), i$1(this, "getNodeOrRelevantParent", (e3) => {
      var t3 = this.rrweb.mirror.getNode(e3);
      if ("svg" !== (null == t3 ? void 0 : t3.nodeName) && t3 instanceof Element) {
        var i2 = t3.closest("svg");
        if (i2)
          return [this.rrweb.mirror.getId(i2), i2];
      }
      return [e3, t3];
    }), i$1(this, "numberOfChanges", (e3) => {
      var t3, i2, n3, r3, s2, o2, a2, l2;
      return (null !== (t3 = null === (i2 = e3.removes) || void 0 === i2 ? void 0 : i2.length) && void 0 !== t3 ? t3 : 0) + (null !== (n3 = null === (r3 = e3.attributes) || void 0 === r3 ? void 0 : r3.length) && void 0 !== n3 ? n3 : 0) + (null !== (s2 = null === (o2 = e3.texts) || void 0 === o2 ? void 0 : o2.length) && void 0 !== s2 ? s2 : 0) + (null !== (a2 = null === (l2 = e3.adds) || void 0 === l2 ? void 0 : l2.length) && void 0 !== a2 ? a2 : 0);
    }), i$1(this, "throttleMutations", (e3) => {
      if (3 !== e3.type || 0 !== e3.data.source)
        return e3;
      var t3 = e3.data, i2 = this.numberOfChanges(t3);
      t3.attributes && (t3.attributes = t3.attributes.filter((e4) => {
        var t4, i3, n4, [r3, s2] = this.getNodeOrRelevantParent(e4.id);
        if (0 === this.mutationBuckets[r3])
          return false;
        (this.mutationBuckets[r3] = null !== (t4 = this.mutationBuckets[r3]) && void 0 !== t4 ? t4 : this.bucketSize, this.mutationBuckets[r3] = Math.max(this.mutationBuckets[r3] - 1, 0), 0 === this.mutationBuckets[r3]) && (this.loggedTracker[r3] || (this.loggedTracker[r3] = true, null === (i3 = (n4 = this.options).onBlockedNode) || void 0 === i3 || i3.call(n4, r3, s2)));
        return e4;
      }));
      var n3 = this.numberOfChanges(t3);
      return 0 !== n3 || i2 === n3 ? e3 : void 0;
    }), this.rrweb = e2, this.options = r2, this.refillRate = on(null !== (t2 = this.options.refillRate) && void 0 !== t2 ? t2 : this.refillRate, 0, 100, "mutation throttling refill rate"), this.bucketSize = on(null !== (n2 = this.options.bucketSize) && void 0 !== n2 ? n2 : this.bucketSize, 0, 100, "mutation throttling bucket size"), setInterval(() => {
      this.refillBuckets();
    }, 1e3);
  }
}
var ln = Uint8Array, un = Uint16Array, cn = Uint32Array, dn = new ln([0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, 0, 0, 0]), hn = new ln([0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13, 0, 0]), _n = new ln([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]), pn = function(e2, t2) {
  for (var i2 = new un(31), n2 = 0; n2 < 31; ++n2)
    i2[n2] = t2 += 1 << e2[n2 - 1];
  var r2 = new cn(i2[30]);
  for (n2 = 1; n2 < 30; ++n2)
    for (var s2 = i2[n2]; s2 < i2[n2 + 1]; ++s2)
      r2[s2] = s2 - i2[n2] << 5 | n2;
  return [i2, r2];
}, vn = pn(dn, 2), gn = vn[0], fn = vn[1];
gn[28] = 258, fn[258] = 28;
for (var mn = pn(hn, 0)[1], bn = new un(32768), yn = 0; yn < 32768; ++yn) {
  var wn = (43690 & yn) >>> 1 | (21845 & yn) << 1;
  wn = (61680 & (wn = (52428 & wn) >>> 2 | (13107 & wn) << 2)) >>> 4 | (3855 & wn) << 4, bn[yn] = ((65280 & wn) >>> 8 | (255 & wn) << 8) >>> 1;
}
var Sn = function(e2, t2, i2) {
  for (var n2 = e2.length, r2 = 0, s2 = new un(t2); r2 < n2; ++r2)
    ++s2[e2[r2] - 1];
  var o2, a2 = new un(t2);
  for (r2 = 0; r2 < t2; ++r2)
    a2[r2] = a2[r2 - 1] + s2[r2 - 1] << 1;
  if (i2) {
    o2 = new un(1 << t2);
    var l2 = 15 - t2;
    for (r2 = 0; r2 < n2; ++r2)
      if (e2[r2])
        for (var u2 = r2 << 4 | e2[r2], c2 = t2 - e2[r2], d2 = a2[e2[r2] - 1]++ << c2, h2 = d2 | (1 << c2) - 1; d2 <= h2; ++d2)
          o2[bn[d2] >>> l2] = u2;
  } else
    for (o2 = new un(n2), r2 = 0; r2 < n2; ++r2)
      o2[r2] = bn[a2[e2[r2] - 1]++] >>> 15 - e2[r2];
  return o2;
}, En = new ln(288);
for (yn = 0; yn < 144; ++yn)
  En[yn] = 8;
for (yn = 144; yn < 256; ++yn)
  En[yn] = 9;
for (yn = 256; yn < 280; ++yn)
  En[yn] = 7;
for (yn = 280; yn < 288; ++yn)
  En[yn] = 8;
var kn = new ln(32);
for (yn = 0; yn < 32; ++yn)
  kn[yn] = 5;
var xn = Sn(En, 9, 0), In = Sn(kn, 5, 0), Cn = function(e2) {
  return (e2 / 8 >> 0) + (7 & e2 && 1);
}, Pn = function(e2, t2, i2) {
  (null == i2 || i2 > e2.length) && (i2 = e2.length);
  var n2 = new (e2 instanceof un ? un : e2 instanceof cn ? cn : ln)(i2 - t2);
  return n2.set(e2.subarray(t2, i2)), n2;
}, Rn = function(e2, t2, i2) {
  i2 <<= 7 & t2;
  var n2 = t2 / 8 >> 0;
  e2[n2] |= i2, e2[n2 + 1] |= i2 >>> 8;
}, Fn = function(e2, t2, i2) {
  i2 <<= 7 & t2;
  var n2 = t2 / 8 >> 0;
  e2[n2] |= i2, e2[n2 + 1] |= i2 >>> 8, e2[n2 + 2] |= i2 >>> 16;
}, Tn = function(e2, t2) {
  for (var i2 = [], n2 = 0; n2 < e2.length; ++n2)
    e2[n2] && i2.push({ s: n2, f: e2[n2] });
  var r2 = i2.length, s2 = i2.slice();
  if (!r2)
    return [new ln(0), 0];
  if (1 == r2) {
    var o2 = new ln(i2[0].s + 1);
    return o2[i2[0].s] = 1, [o2, 1];
  }
  i2.sort(function(e3, t3) {
    return e3.f - t3.f;
  }), i2.push({ s: -1, f: 25001 });
  var a2 = i2[0], l2 = i2[1], u2 = 0, c2 = 1, d2 = 2;
  for (i2[0] = { s: -1, f: a2.f + l2.f, l: a2, r: l2 }; c2 != r2 - 1; )
    a2 = i2[i2[u2].f < i2[d2].f ? u2++ : d2++], l2 = i2[u2 != c2 && i2[u2].f < i2[d2].f ? u2++ : d2++], i2[c2++] = { s: -1, f: a2.f + l2.f, l: a2, r: l2 };
  var h2 = s2[0].s;
  for (n2 = 1; n2 < r2; ++n2)
    s2[n2].s > h2 && (h2 = s2[n2].s);
  var _2 = new un(h2 + 1), p2 = $n(i2[c2 - 1], _2, 0);
  if (p2 > t2) {
    n2 = 0;
    var v2 = 0, g2 = p2 - t2, f2 = 1 << g2;
    for (s2.sort(function(e3, t3) {
      return _2[t3.s] - _2[e3.s] || e3.f - t3.f;
    }); n2 < r2; ++n2) {
      var m2 = s2[n2].s;
      if (!(_2[m2] > t2))
        break;
      v2 += f2 - (1 << p2 - _2[m2]), _2[m2] = t2;
    }
    for (v2 >>>= g2; v2 > 0; ) {
      var b2 = s2[n2].s;
      _2[b2] < t2 ? v2 -= 1 << t2 - _2[b2]++ - 1 : ++n2;
    }
    for (; n2 >= 0 && v2; --n2) {
      var y2 = s2[n2].s;
      _2[y2] == t2 && (--_2[y2], ++v2);
    }
    p2 = t2;
  }
  return [new ln(_2), p2];
}, $n = function(e2, t2, i2) {
  return -1 == e2.s ? Math.max($n(e2.l, t2, i2 + 1), $n(e2.r, t2, i2 + 1)) : t2[e2.s] = i2;
}, On = function(e2) {
  for (var t2 = e2.length; t2 && !e2[--t2]; )
    ;
  for (var i2 = new un(++t2), n2 = 0, r2 = e2[0], s2 = 1, o2 = function(e3) {
    i2[n2++] = e3;
  }, a2 = 1; a2 <= t2; ++a2)
    if (e2[a2] == r2 && a2 != t2)
      ++s2;
    else {
      if (!r2 && s2 > 2) {
        for (; s2 > 138; s2 -= 138)
          o2(32754);
        s2 > 2 && (o2(s2 > 10 ? s2 - 11 << 5 | 28690 : s2 - 3 << 5 | 12305), s2 = 0);
      } else if (s2 > 3) {
        for (o2(r2), --s2; s2 > 6; s2 -= 6)
          o2(8304);
        s2 > 2 && (o2(s2 - 3 << 5 | 8208), s2 = 0);
      }
      for (; s2--; )
        o2(r2);
      s2 = 1, r2 = e2[a2];
    }
  return [i2.subarray(0, n2), t2];
}, Ln = function(e2, t2) {
  for (var i2 = 0, n2 = 0; n2 < t2.length; ++n2)
    i2 += e2[n2] * t2[n2];
  return i2;
}, Mn = function(e2, t2, i2) {
  var n2 = i2.length, r2 = Cn(t2 + 2);
  e2[r2] = 255 & n2, e2[r2 + 1] = n2 >>> 8, e2[r2 + 2] = 255 ^ e2[r2], e2[r2 + 3] = 255 ^ e2[r2 + 1];
  for (var s2 = 0; s2 < n2; ++s2)
    e2[r2 + s2 + 4] = i2[s2];
  return 8 * (r2 + 4 + n2);
}, An = function(e2, t2, i2, n2, r2, s2, o2, a2, l2, u2, c2) {
  Rn(t2, c2++, i2), ++r2[256];
  for (var d2 = Tn(r2, 15), h2 = d2[0], _2 = d2[1], p2 = Tn(s2, 15), v2 = p2[0], g2 = p2[1], f2 = On(h2), m2 = f2[0], b2 = f2[1], y2 = On(v2), w2 = y2[0], S2 = y2[1], E2 = new un(19), k2 = 0; k2 < m2.length; ++k2)
    E2[31 & m2[k2]]++;
  for (k2 = 0; k2 < w2.length; ++k2)
    E2[31 & w2[k2]]++;
  for (var x = Tn(E2, 7), I2 = x[0], C2 = x[1], P2 = 19; P2 > 4 && !I2[_n[P2 - 1]]; --P2)
    ;
  var R2, F2, T2, $2, O2 = u2 + 5 << 3, L2 = Ln(r2, En) + Ln(s2, kn) + o2, M2 = Ln(r2, h2) + Ln(s2, v2) + o2 + 14 + 3 * P2 + Ln(E2, I2) + (2 * E2[16] + 3 * E2[17] + 7 * E2[18]);
  if (O2 <= L2 && O2 <= M2)
    return Mn(t2, c2, e2.subarray(l2, l2 + u2));
  if (Rn(t2, c2, 1 + (M2 < L2)), c2 += 2, M2 < L2) {
    R2 = Sn(h2, _2, 0), F2 = h2, T2 = Sn(v2, g2, 0), $2 = v2;
    var A2 = Sn(I2, C2, 0);
    Rn(t2, c2, b2 - 257), Rn(t2, c2 + 5, S2 - 1), Rn(t2, c2 + 10, P2 - 4), c2 += 14;
    for (k2 = 0; k2 < P2; ++k2)
      Rn(t2, c2 + 3 * k2, I2[_n[k2]]);
    c2 += 3 * P2;
    for (var D2 = [m2, w2], N2 = 0; N2 < 2; ++N2) {
      var q2 = D2[N2];
      for (k2 = 0; k2 < q2.length; ++k2) {
        var B2 = 31 & q2[k2];
        Rn(t2, c2, A2[B2]), c2 += I2[B2], B2 > 15 && (Rn(t2, c2, q2[k2] >>> 5 & 127), c2 += q2[k2] >>> 12);
      }
    }
  } else
    R2 = xn, F2 = En, T2 = In, $2 = kn;
  for (k2 = 0; k2 < a2; ++k2)
    if (n2[k2] > 255) {
      B2 = n2[k2] >>> 18 & 31;
      Fn(t2, c2, R2[B2 + 257]), c2 += F2[B2 + 257], B2 > 7 && (Rn(t2, c2, n2[k2] >>> 23 & 31), c2 += dn[B2]);
      var H2 = 31 & n2[k2];
      Fn(t2, c2, T2[H2]), c2 += $2[H2], H2 > 3 && (Fn(t2, c2, n2[k2] >>> 5 & 8191), c2 += hn[H2]);
    } else
      Fn(t2, c2, R2[n2[k2]]), c2 += F2[n2[k2]];
  return Fn(t2, c2, R2[256]), c2 + F2[256];
}, Dn = new cn([65540, 131080, 131088, 131104, 262176, 1048704, 1048832, 2114560, 2117632]), Nn = function() {
  for (var e2 = new cn(256), t2 = 0; t2 < 256; ++t2) {
    for (var i2 = t2, n2 = 9; --n2; )
      i2 = (1 & i2 && 3988292384) ^ i2 >>> 1;
    e2[t2] = i2;
  }
  return e2;
}(), qn = function() {
  var e2 = 4294967295;
  return { p: function(t2) {
    for (var i2 = e2, n2 = 0; n2 < t2.length; ++n2)
      i2 = Nn[255 & i2 ^ t2[n2]] ^ i2 >>> 8;
    e2 = i2;
  }, d: function() {
    return 4294967295 ^ e2;
  } };
}, Bn = function(e2, t2, i2, n2, r2) {
  return function(e3, t3, i3, n3, r3, s2) {
    var o2 = e3.length, a2 = new ln(n3 + o2 + 5 * (1 + Math.floor(o2 / 7e3)) + r3), l2 = a2.subarray(n3, a2.length - r3), u2 = 0;
    if (!t3 || o2 < 8)
      for (var c2 = 0; c2 <= o2; c2 += 65535) {
        var d2 = c2 + 65535;
        d2 < o2 ? u2 = Mn(l2, u2, e3.subarray(c2, d2)) : (l2[c2] = s2, u2 = Mn(l2, u2, e3.subarray(c2, o2)));
      }
    else {
      for (var h2 = Dn[t3 - 1], _2 = h2 >>> 13, p2 = 8191 & h2, v2 = (1 << i3) - 1, g2 = new un(32768), f2 = new un(v2 + 1), m2 = Math.ceil(i3 / 3), b2 = 2 * m2, y2 = function(t4) {
        return (e3[t4] ^ e3[t4 + 1] << m2 ^ e3[t4 + 2] << b2) & v2;
      }, w2 = new cn(25e3), S2 = new un(288), E2 = new un(32), k2 = 0, x = 0, I2 = (c2 = 0, 0), C2 = 0, P2 = 0; c2 < o2; ++c2) {
        var R2 = y2(c2), F2 = 32767 & c2, T2 = f2[R2];
        if (g2[F2] = T2, f2[R2] = F2, C2 <= c2) {
          var $2 = o2 - c2;
          if ((k2 > 7e3 || I2 > 24576) && $2 > 423) {
            u2 = An(e3, l2, 0, w2, S2, E2, x, I2, P2, c2 - P2, u2), I2 = k2 = x = 0, P2 = c2;
            for (var O2 = 0; O2 < 286; ++O2)
              S2[O2] = 0;
            for (O2 = 0; O2 < 30; ++O2)
              E2[O2] = 0;
          }
          var L2 = 2, M2 = 0, A2 = p2, D2 = F2 - T2 & 32767;
          if ($2 > 2 && R2 == y2(c2 - D2))
            for (var N2 = Math.min(_2, $2) - 1, q2 = Math.min(32767, c2), B2 = Math.min(258, $2); D2 <= q2 && --A2 && F2 != T2; ) {
              if (e3[c2 + L2] == e3[c2 + L2 - D2]) {
                for (var H2 = 0; H2 < B2 && e3[c2 + H2] == e3[c2 + H2 - D2]; ++H2)
                  ;
                if (H2 > L2) {
                  if (L2 = H2, M2 = D2, H2 > N2)
                    break;
                  var U2 = Math.min(D2, H2 - 2), z2 = 0;
                  for (O2 = 0; O2 < U2; ++O2) {
                    var j2 = c2 - D2 + O2 + 32768 & 32767, W2 = j2 - g2[j2] + 32768 & 32767;
                    W2 > z2 && (z2 = W2, T2 = j2);
                  }
                }
              }
              D2 += (F2 = T2) - (T2 = g2[F2]) + 32768 & 32767;
            }
          if (M2) {
            w2[I2++] = 268435456 | fn[L2] << 18 | mn[M2];
            var G2 = 31 & fn[L2], V2 = 31 & mn[M2];
            x += dn[G2] + hn[V2], ++S2[257 + G2], ++E2[V2], C2 = c2 + L2, ++k2;
          } else
            w2[I2++] = e3[c2], ++S2[e3[c2]];
        }
      }
      u2 = An(e3, l2, s2, w2, S2, E2, x, I2, P2, c2 - P2, u2);
    }
    return Pn(a2, 0, n3 + Cn(u2) + r3);
  }(e2, null == t2.level ? 6 : t2.level, null == t2.mem ? Math.ceil(1.5 * Math.max(8, Math.min(13, Math.log(e2.length)))) : 12 + t2.mem, i2, n2, !r2);
}, Hn = function(e2, t2, i2) {
  for (; i2; ++t2)
    e2[t2] = i2, i2 >>>= 8;
}, Un = function(e2, t2) {
  var i2 = t2.filename;
  if (e2[0] = 31, e2[1] = 139, e2[2] = 8, e2[8] = t2.level < 2 ? 4 : 9 == t2.level ? 2 : 0, e2[9] = 3, 0 != t2.mtime && Hn(e2, 4, Math.floor(new Date(t2.mtime || Date.now()) / 1e3)), i2) {
    e2[3] = 8;
    for (var n2 = 0; n2 <= i2.length; ++n2)
      e2[n2 + 10] = i2.charCodeAt(n2);
  }
}, zn = function(e2) {
  return 10 + (e2.filename && e2.filename.length + 1 || 0);
};
function jn(e2, t2) {
  void 0 === t2 && (t2 = {});
  var i2 = qn(), n2 = e2.length;
  i2.p(e2);
  var r2 = Bn(e2, t2, zn(t2), 8), s2 = r2.length;
  return Un(r2, t2), Hn(r2, s2 - 8, i2.d()), Hn(r2, s2 - 4, n2), r2;
}
function Wn(e2, t2) {
  var i2 = e2.length;
  if ("undefined" != typeof TextEncoder)
    return new TextEncoder().encode(e2);
  for (var n2 = new ln(e2.length + (e2.length >>> 1)), r2 = 0, s2 = function(e3) {
    n2[r2++] = e3;
  }, o2 = 0; o2 < i2; ++o2) {
    if (r2 + 5 > n2.length) {
      var a2 = new ln(r2 + 8 + (i2 - o2 << 1));
      a2.set(n2), n2 = a2;
    }
    var l2 = e2.charCodeAt(o2);
    l2 < 128 || t2 ? s2(l2) : l2 < 2048 ? (s2(192 | l2 >>> 6), s2(128 | 63 & l2)) : l2 > 55295 && l2 < 57344 ? (s2(240 | (l2 = 65536 + (1047552 & l2) | 1023 & e2.charCodeAt(++o2)) >>> 18), s2(128 | l2 >>> 12 & 63), s2(128 | l2 >>> 6 & 63), s2(128 | 63 & l2)) : (s2(224 | l2 >>> 12), s2(128 | l2 >>> 6 & 63), s2(128 | 63 & l2));
  }
  return Pn(n2, 0, r2);
}
var Gn = "[SessionRecording]", Vn = H$1(Gn), Jn = 3e5, Yn = [wi.MouseMove, wi.MouseInteraction, wi.Scroll, wi.ViewportResize, wi.Input, wi.TouchMove, wi.MediaInteraction, wi.Drag], Xn = (e2) => ({ rrwebMethod: e2, enqueuedAt: Date.now(), attempt: 1 });
function Kn(e2) {
  return function(e3, t2) {
    for (var i2 = "", n2 = 0; n2 < e3.length; ) {
      var r2 = e3[n2++];
      r2 < 128 || t2 ? i2 += String.fromCharCode(r2) : r2 < 224 ? i2 += String.fromCharCode((31 & r2) << 6 | 63 & e3[n2++]) : r2 < 240 ? i2 += String.fromCharCode((15 & r2) << 12 | (63 & e3[n2++]) << 6 | 63 & e3[n2++]) : (r2 = ((15 & r2) << 18 | (63 & e3[n2++]) << 12 | (63 & e3[n2++]) << 6 | 63 & e3[n2++]) - 65536, i2 += String.fromCharCode(55296 | r2 >> 10, 56320 | 1023 & r2));
    }
    return i2;
  }(jn(Wn(JSON.stringify(e2))), true);
}
function Qn(e2) {
  return e2.type === yi.Custom && "sessionIdle" === e2.data.tag;
}
function Zn(e2, t2) {
  return t2.some((t3) => "regex" === t3.matching && new RegExp(t3.url).test(e2));
}
class er {
  get sessionIdleThresholdMilliseconds() {
    return this.instance.config.session_recording.session_idle_threshold_ms || 3e5;
  }
  get rrwebRecord() {
    var e2, t2;
    return null == m$2 || null === (e2 = m$2.__PosthogExtensions__) || void 0 === e2 || null === (t2 = e2.rrweb) || void 0 === t2 ? void 0 : t2.record;
  }
  get started() {
    return this._captureStarted;
  }
  get sessionManager() {
    if (!this.instance.sessionManager)
      throw new Error(Gn + " must be started with a valid sessionManager.");
    return this.instance.sessionManager;
  }
  get fullSnapshotIntervalMillis() {
    var e2, t2;
    return "trigger_pending" === this.triggerStatus ? 6e4 : null !== (e2 = null === (t2 = this.instance.config.session_recording) || void 0 === t2 ? void 0 : t2.full_snapshot_interval_millis) && void 0 !== e2 ? e2 : Jn;
  }
  get isSampled() {
    var e2 = this.instance.get_property(ye);
    return A$2(e2) ? e2 : null;
  }
  get sessionDuration() {
    var e2, t2, i2 = null === (e2 = this.buffer) || void 0 === e2 ? void 0 : e2.data[(null === (t2 = this.buffer) || void 0 === t2 ? void 0 : t2.data.length) - 1], { sessionStartTimestamp: n2 } = this.sessionManager.checkAndGetSessionAndWindowId(true);
    return i2 ? i2.timestamp - n2 : null;
  }
  get isRecordingEnabled() {
    var e2 = !!this.instance.get_property(he), t2 = !this.instance.config.disable_session_recording;
    return o$1 && e2 && t2;
  }
  get isConsoleLogCaptureEnabled() {
    var e2 = !!this.instance.get_property(_e), t2 = this.instance.config.enable_recording_console_log;
    return null != t2 ? t2 : e2;
  }
  get canvasRecording() {
    var e2, t2, i2, n2, r2, s2, o2 = this.instance.config.session_recording.captureCanvas, a2 = this.instance.get_property(ve), l2 = null !== (e2 = null !== (t2 = null == o2 ? void 0 : o2.recordCanvas) && void 0 !== t2 ? t2 : null == a2 ? void 0 : a2.enabled) && void 0 !== e2 && e2, u2 = null !== (i2 = null !== (n2 = null == o2 ? void 0 : o2.canvasFps) && void 0 !== n2 ? n2 : null == a2 ? void 0 : a2.fps) && void 0 !== i2 ? i2 : 0, c2 = null !== (r2 = null !== (s2 = null == o2 ? void 0 : o2.canvasQuality) && void 0 !== s2 ? s2 : null == a2 ? void 0 : a2.quality) && void 0 !== r2 ? r2 : 0;
    return { enabled: l2, fps: on(u2, 0, 12, "canvas recording fps"), quality: on(c2, 0, 1, "canvas recording quality") };
  }
  get networkPayloadCapture() {
    var e2, t2, i2 = this.instance.get_property(pe), n2 = { recordHeaders: null === (e2 = this.instance.config.session_recording) || void 0 === e2 ? void 0 : e2.recordHeaders, recordBody: null === (t2 = this.instance.config.session_recording) || void 0 === t2 ? void 0 : t2.recordBody }, r2 = (null == n2 ? void 0 : n2.recordHeaders) || (null == i2 ? void 0 : i2.recordHeaders), s2 = (null == n2 ? void 0 : n2.recordBody) || (null == i2 ? void 0 : i2.recordBody), o2 = P(this.instance.config.capture_performance) ? this.instance.config.capture_performance.network_timing : this.instance.config.capture_performance, a2 = !!(A$2(o2) ? o2 : null == i2 ? void 0 : i2.capturePerformance);
    return r2 || s2 || a2 ? { recordHeaders: r2, recordBody: s2, recordPerformance: a2 } : void 0;
  }
  get sampleRate() {
    var e2 = this.instance.get_property(ge);
    return M(e2) ? e2 : null;
  }
  get minimumDuration() {
    var e2 = this.instance.get_property(fe);
    return M(e2) ? e2 : null;
  }
  get status() {
    return this.receivedDecide ? this.isRecordingEnabled ? this._urlBlocked ? "paused" : L(this._linkedFlag) || this._linkedFlagSeen ? "trigger_pending" === this.triggerStatus ? "buffering" : A$2(this.isSampled) ? this.isSampled ? "sampled" : "disabled" : "active" : "buffering" : "disabled" : "buffering";
  }
  get urlTriggerStatus() {
    var e2;
    return 0 === this._urlTriggers.length ? "trigger_disabled" : (null === (e2 = this.instance) || void 0 === e2 ? void 0 : e2.get_property(we)) === this.sessionId ? "trigger_activated" : "trigger_pending";
  }
  get eventTriggerStatus() {
    var e2;
    return 0 === this._eventTriggers.length ? "trigger_disabled" : (null === (e2 = this.instance) || void 0 === e2 ? void 0 : e2.get_property(Se)) === this.sessionId ? "trigger_activated" : "trigger_pending";
  }
  get triggerStatus() {
    var e2 = "trigger_activated" === this.eventTriggerStatus || "trigger_activated" === this.urlTriggerStatus, t2 = "trigger_pending" === this.eventTriggerStatus || "trigger_pending" === this.urlTriggerStatus;
    return e2 ? "trigger_activated" : t2 ? "trigger_pending" : "trigger_disabled";
  }
  constructor(e2) {
    if (i$1(this, "queuedRRWebEvents", []), i$1(this, "isIdle", false), i$1(this, "_linkedFlagSeen", false), i$1(this, "_lastActivityTimestamp", Date.now()), i$1(this, "_linkedFlag", null), i$1(this, "_removePageViewCaptureHook", void 0), i$1(this, "_onSessionIdListener", void 0), i$1(this, "_persistDecideOnSessionListener", void 0), i$1(this, "_samplingSessionListener", void 0), i$1(this, "_urlTriggers", []), i$1(this, "_urlBlocklist", []), i$1(this, "_urlBlocked", false), i$1(this, "_eventTriggers", []), i$1(this, "_removeEventTriggerCaptureHook", void 0), i$1(this, "_forceAllowLocalhostNetworkCapture", false), i$1(this, "_onBeforeUnload", () => {
      this._flushBuffer();
    }), i$1(this, "_onOffline", () => {
      this._tryAddCustomEvent("browser offline", {});
    }), i$1(this, "_onOnline", () => {
      this._tryAddCustomEvent("browser online", {});
    }), i$1(this, "_onVisibilityChange", () => {
      if (null != h$2 && h$2.visibilityState) {
        var e3 = "window " + h$2.visibilityState;
        this._tryAddCustomEvent(e3, {});
      }
    }), this.instance = e2, this._captureStarted = false, this._endpoint = "/s/", this.stopRrweb = void 0, this.receivedDecide = false, !this.instance.sessionManager)
      throw Vn.error("started without valid sessionManager"), new Error(Gn + " started without valid sessionManager. This is a bug.");
    var { sessionId: t2, windowId: n2 } = this.sessionManager.checkAndGetSessionAndWindowId();
    this.sessionId = t2, this.windowId = n2, this.buffer = this.clearBuffer(), this.sessionIdleThresholdMilliseconds >= this.sessionManager.sessionTimeoutMs && Vn.warn("session_idle_threshold_ms (".concat(this.sessionIdleThresholdMilliseconds, ") is greater than the session timeout (").concat(this.sessionManager.sessionTimeoutMs, "). Session will never be detected as idle"));
  }
  startIfEnabledOrStop(e2) {
    this.isRecordingEnabled ? (this._startCapture(e2), null == o$1 || o$1.addEventListener("beforeunload", this._onBeforeUnload), null == o$1 || o$1.addEventListener("offline", this._onOffline), null == o$1 || o$1.addEventListener("online", this._onOnline), null == o$1 || o$1.addEventListener("visibilitychange", this._onVisibilityChange), this._setupSampling(), this._addEventTriggerListener(), L(this._removePageViewCaptureHook) && (this._removePageViewCaptureHook = this.instance.on("eventCaptured", (e3) => {
      try {
        if ("$pageview" === e3.event) {
          var t2 = null != e3 && e3.properties.$current_url ? this._maskUrl(null == e3 ? void 0 : e3.properties.$current_url) : "";
          if (!t2)
            return;
          this._tryAddCustomEvent("$pageview", { href: t2 });
        }
      } catch (e4) {
        Vn.error("Could not add $pageview to rrweb session", e4);
      }
    })), this._onSessionIdListener || (this._onSessionIdListener = this.sessionManager.onSessionId((e3, t2, i2) => {
      var n2, r2, s2, o2;
      i2 && (this._tryAddCustomEvent("$session_id_change", { sessionId: e3, windowId: t2, changeReason: i2 }), null === (n2 = this.instance) || void 0 === n2 || null === (r2 = n2.persistence) || void 0 === r2 || r2.unregister(Se), null === (s2 = this.instance) || void 0 === s2 || null === (o2 = s2.persistence) || void 0 === o2 || o2.unregister(we));
    }))) : this.stopRecording();
  }
  stopRecording() {
    var e2, t2, i2, n2;
    this._captureStarted && this.stopRrweb && (this.stopRrweb(), this.stopRrweb = void 0, this._captureStarted = false, null == o$1 || o$1.removeEventListener("beforeunload", this._onBeforeUnload), null == o$1 || o$1.removeEventListener("offline", this._onOffline), null == o$1 || o$1.removeEventListener("online", this._onOnline), null == o$1 || o$1.removeEventListener("visibilitychange", this._onVisibilityChange), this.clearBuffer(), clearInterval(this._fullSnapshotTimer), null === (e2 = this._removePageViewCaptureHook) || void 0 === e2 || e2.call(this), this._removePageViewCaptureHook = void 0, null === (t2 = this._removeEventTriggerCaptureHook) || void 0 === t2 || t2.call(this), this._removeEventTriggerCaptureHook = void 0, null === (i2 = this._onSessionIdListener) || void 0 === i2 || i2.call(this), this._onSessionIdListener = void 0, null === (n2 = this._samplingSessionListener) || void 0 === n2 || n2.call(this), this._samplingSessionListener = void 0, Vn.info("stopped"));
  }
  makeSamplingDecision(e2) {
    var t2, i2 = this.sessionId !== e2, n2 = this.sampleRate;
    if (M(n2)) {
      var r2, s2 = this.isSampled, o2 = i2 || !A$2(s2);
      if (o2)
        r2 = Math.random() < n2;
      else
        r2 = s2;
      o2 && (r2 ? this._reportStarted("sampled") : Vn.warn("Sample rate (".concat(n2, ") has determined that this sessionId (").concat(e2, ") will not be sent to the server.")), this._tryAddCustomEvent("samplingDecisionMade", { sampleRate: n2, isSampled: r2 })), null === (t2 = this.instance.persistence) || void 0 === t2 || t2.register({ [ye]: r2 });
    } else {
      var a2;
      null === (a2 = this.instance.persistence) || void 0 === a2 || a2.register({ [ye]: null });
    }
  }
  onRemoteConfig(e2) {
    var t2, i2, n2, r2, s2, o2;
    (this._persistRemoteConfig(e2), this._linkedFlag = (null === (t2 = e2.sessionRecording) || void 0 === t2 ? void 0 : t2.linkedFlag) || null, null !== (i2 = e2.sessionRecording) && void 0 !== i2 && i2.endpoint) && (this._endpoint = null === (o2 = e2.sessionRecording) || void 0 === o2 ? void 0 : o2.endpoint);
    if (this._setupSampling(), !L(this._linkedFlag) && !this._linkedFlagSeen) {
      var a2 = T(this._linkedFlag) ? this._linkedFlag : this._linkedFlag.flag, l2 = T(this._linkedFlag) ? null : this._linkedFlag.variant;
      this.instance.onFeatureFlags((e3, t3) => {
        var i3 = P(t3) && a2 in t3, n3 = l2 ? t3[a2] === l2 : i3;
        n3 && this._reportStarted("linked_flag_matched", { linkedFlag: a2, linkedVariant: l2 }), this._linkedFlagSeen = n3;
      });
    }
    null !== (n2 = e2.sessionRecording) && void 0 !== n2 && n2.urlTriggers && (this._urlTriggers = e2.sessionRecording.urlTriggers), null !== (r2 = e2.sessionRecording) && void 0 !== r2 && r2.urlBlocklist && (this._urlBlocklist = e2.sessionRecording.urlBlocklist), null !== (s2 = e2.sessionRecording) && void 0 !== s2 && s2.eventTriggers && (this._eventTriggers = e2.sessionRecording.eventTriggers), this.receivedDecide = true, this.startIfEnabledOrStop();
  }
  _setupSampling() {
    M(this.sampleRate) && L(this._samplingSessionListener) && (this._samplingSessionListener = this.sessionManager.onSessionId((e2) => {
      this.makeSamplingDecision(e2);
    }));
  }
  _persistRemoteConfig(e2) {
    if (this.instance.persistence) {
      var i2, n2 = this.instance.persistence, r2 = () => {
        var i3, r3, s2, o2, a2, l2, u2, c2, d2 = null === (i3 = e2.sessionRecording) || void 0 === i3 ? void 0 : i3.sampleRate, h2 = L(d2) ? null : parseFloat(d2), _2 = null === (r3 = e2.sessionRecording) || void 0 === r3 ? void 0 : r3.minimumDurationMilliseconds;
        n2.register({ [he]: !!e2.sessionRecording, [_e]: null === (s2 = e2.sessionRecording) || void 0 === s2 ? void 0 : s2.consoleLogRecordingEnabled, [pe]: t$1({ capturePerformance: e2.capturePerformance }, null === (o2 = e2.sessionRecording) || void 0 === o2 ? void 0 : o2.networkPayloadCapture), [ve]: { enabled: null === (a2 = e2.sessionRecording) || void 0 === a2 ? void 0 : a2.recordCanvas, fps: null === (l2 = e2.sessionRecording) || void 0 === l2 ? void 0 : l2.canvasFps, quality: null === (u2 = e2.sessionRecording) || void 0 === u2 ? void 0 : u2.canvasQuality }, [ge]: h2, [fe]: F$1(_2) ? null : _2, [me]: null === (c2 = e2.sessionRecording) || void 0 === c2 ? void 0 : c2.scriptConfig });
      };
      r2(), null === (i2 = this._persistDecideOnSessionListener) || void 0 === i2 || i2.call(this), this._persistDecideOnSessionListener = this.sessionManager.onSessionId(r2);
    }
  }
  log(e2) {
    var t2, i2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "log";
    null === (t2 = this.instance.sessionRecording) || void 0 === t2 || t2.onRRwebEmit({ type: 6, data: { plugin: "rrweb/console@1", payload: { level: i2, trace: [], payload: [JSON.stringify(e2)] } }, timestamp: Date.now() });
  }
  _startCapture(e2) {
    if (!F$1(Object.assign) && !F$1(Array.from) && !(this._captureStarted || this.instance.config.disable_session_recording || this.instance.consent.isOptedOut())) {
      var t2, i2;
      if (this._captureStarted = true, this.sessionManager.checkAndGetSessionAndWindowId(), this.rrwebRecord)
        this._onScriptLoaded();
      else
        null === (t2 = m$2.__PosthogExtensions__) || void 0 === t2 || null === (i2 = t2.loadExternalDependency) || void 0 === i2 || i2.call(t2, this.instance, this.scriptName, (e3) => {
          if (e3)
            return Vn.error("could not load recorder", e3);
          this._onScriptLoaded();
        });
      Vn.info("starting"), "active" === this.status && this._reportStarted(e2 || "recording_initialized");
    }
  }
  get scriptName() {
    var e2, t2, i2;
    return (null === (e2 = this.instance) || void 0 === e2 || null === (t2 = e2.persistence) || void 0 === t2 || null === (i2 = t2.get_property(me)) || void 0 === i2 ? void 0 : i2.script) || "recorder";
  }
  isInteractiveEvent(e2) {
    var t2;
    return 3 === e2.type && -1 !== Yn.indexOf(null === (t2 = e2.data) || void 0 === t2 ? void 0 : t2.source);
  }
  _updateWindowAndSessionIds(e2) {
    var t2 = this.isInteractiveEvent(e2);
    t2 || this.isIdle || e2.timestamp - this._lastActivityTimestamp > this.sessionIdleThresholdMilliseconds && (this.isIdle = true, clearInterval(this._fullSnapshotTimer), this._tryAddCustomEvent("sessionIdle", { eventTimestamp: e2.timestamp, lastActivityTimestamp: this._lastActivityTimestamp, threshold: this.sessionIdleThresholdMilliseconds, bufferLength: this.buffer.data.length, bufferSize: this.buffer.size }), this._flushBuffer());
    var i2 = false;
    if (t2 && (this._lastActivityTimestamp = e2.timestamp, this.isIdle && (this.isIdle = false, this._tryAddCustomEvent("sessionNoLongerIdle", { reason: "user activity", type: e2.type }), i2 = true)), !this.isIdle) {
      var { windowId: n2, sessionId: r2 } = this.sessionManager.checkAndGetSessionAndWindowId(!t2, e2.timestamp), s2 = this.sessionId !== r2, o2 = this.windowId !== n2;
      this.windowId = n2, this.sessionId = r2, s2 || o2 ? (this.stopRecording(), this.startIfEnabledOrStop("session_id_changed")) : i2 && this._scheduleFullSnapshot();
    }
  }
  _tryRRWebMethod(e2) {
    try {
      return e2.rrwebMethod(), true;
    } catch (t2) {
      return this.queuedRRWebEvents.length < 10 ? this.queuedRRWebEvents.push({ enqueuedAt: e2.enqueuedAt || Date.now(), attempt: e2.attempt++, rrwebMethod: e2.rrwebMethod }) : Vn.warn("could not emit queued rrweb event.", t2, e2), false;
    }
  }
  _tryAddCustomEvent(e2, t2) {
    return this._tryRRWebMethod(Xn(() => this.rrwebRecord.addCustomEvent(e2, t2)));
  }
  _tryTakeFullSnapshot() {
    return this._tryRRWebMethod(Xn(() => this.rrwebRecord.takeFullSnapshot()));
  }
  _onScriptLoaded() {
    var e2, i2 = { blockClass: "ph-no-capture", blockSelector: void 0, ignoreClass: "ph-ignore-input", maskTextClass: "ph-mask", maskTextSelector: void 0, maskTextFn: void 0, maskAllInputs: true, maskInputOptions: { password: true }, maskInputFn: void 0, slimDOMOptions: {}, collectFonts: false, inlineStylesheet: true, recordCrossOriginIframes: false }, n2 = this.instance.config.session_recording;
    for (var [r2, s2] of Object.entries(n2 || {}))
      r2 in i2 && ("maskInputOptions" === r2 ? i2.maskInputOptions = t$1({ password: true }, s2) : i2[r2] = s2);
    if (this.canvasRecording && this.canvasRecording.enabled && (i2.recordCanvas = true, i2.sampling = { canvas: this.canvasRecording.fps }, i2.dataURLOptions = { type: "image/webp", quality: this.canvasRecording.quality }), this.rrwebRecord) {
      this.mutationRateLimiter = null !== (e2 = this.mutationRateLimiter) && void 0 !== e2 ? e2 : new an(this.rrwebRecord, { refillRate: this.instance.config.session_recording.__mutationRateLimiterRefillRate, bucketSize: this.instance.config.session_recording.__mutationRateLimiterBucketSize, onBlockedNode: (e3, t2) => {
        var i3 = "Too many mutations on node '".concat(e3, "'. Rate limiting. This could be due to SVG animations or something similar");
        Vn.info(i3, { node: t2 }), this.log(Gn + " " + i3, "warn");
      } });
      var o2 = this._gatherRRWebPlugins();
      this.stopRrweb = this.rrwebRecord(t$1({ emit: (e3) => {
        this.onRRwebEmit(e3);
      }, plugins: o2 }, i2)), this._lastActivityTimestamp = Date.now(), this.isIdle = false, this._tryAddCustomEvent("$session_options", { sessionRecordingOptions: i2, activePlugins: o2.map((e3) => null == e3 ? void 0 : e3.name) }), this._tryAddCustomEvent("$posthog_config", { config: this.instance.config });
    } else
      Vn.error("onScriptLoaded was called but rrwebRecord is not available. This indicates something has gone wrong.");
  }
  _scheduleFullSnapshot() {
    if (this._fullSnapshotTimer && clearInterval(this._fullSnapshotTimer), !this.isIdle) {
      var e2 = this.fullSnapshotIntervalMillis;
      e2 && (this._fullSnapshotTimer = setInterval(() => {
        this._tryTakeFullSnapshot();
      }, e2));
    }
  }
  _gatherRRWebPlugins() {
    var e2, t2, i2, n2, r2 = [], s2 = null === (e2 = m$2.__PosthogExtensions__) || void 0 === e2 || null === (t2 = e2.rrwebPlugins) || void 0 === t2 ? void 0 : t2.getRecordConsolePlugin;
    s2 && this.isConsoleLogCaptureEnabled && r2.push(s2());
    var o2 = null === (i2 = m$2.__PosthogExtensions__) || void 0 === i2 || null === (n2 = i2.rrwebPlugins) || void 0 === n2 ? void 0 : n2.getRecordNetworkPlugin;
    this.networkPayloadCapture && C$1(o2) && (!ht.includes(location.hostname) || this._forceAllowLocalhostNetworkCapture ? r2.push(o2(sn(this.instance.config, this.networkPayloadCapture))) : Vn.info("NetworkCapture not started because we are on localhost."));
    return r2;
  }
  onRRwebEmit(e2) {
    var i2;
    if (this._processQueuedEvents(), e2 && P(e2)) {
      if (e2.type === yi.Meta) {
        var n2 = this._maskUrl(e2.data.href);
        if (this._lastHref = n2, !n2)
          return;
        e2.data.href = n2;
      } else
        this._pageViewFallBack();
      if (this._checkUrlTriggerConditions(), "paused" !== this.status || function(e3) {
        return e3.type === yi.Custom && "recording paused" === e3.data.tag;
      }(e2)) {
        e2.type === yi.FullSnapshot && this._scheduleFullSnapshot(), e2.type === yi.FullSnapshot && "trigger_pending" === this.triggerStatus && this.clearBuffer();
        var r2 = this.mutationRateLimiter ? this.mutationRateLimiter.throttleMutations(e2) : e2;
        if (r2) {
          var s2 = function(e3) {
            var t2 = e3;
            if (t2 && P(t2) && 6 === t2.type && P(t2.data) && "rrweb/console@1" === t2.data.plugin) {
              t2.data.payload.payload.length > 10 && (t2.data.payload.payload = t2.data.payload.payload.slice(0, 10), t2.data.payload.payload.push("...[truncated]"));
              for (var i3 = [], n3 = 0; n3 < t2.data.payload.payload.length; n3++)
                t2.data.payload.payload[n3] && t2.data.payload.payload[n3].length > 2e3 ? i3.push(t2.data.payload.payload[n3].slice(0, 2e3) + "...[truncated]") : i3.push(t2.data.payload.payload[n3]);
              return t2.data.payload.payload = i3, e3;
            }
            return e3;
          }(r2);
          if (this._updateWindowAndSessionIds(s2), !this.isIdle || Qn(s2)) {
            if (Qn(s2)) {
              var o2 = s2.data.payload;
              if (o2) {
                var a2 = o2.lastActivityTimestamp, l2 = o2.threshold;
                s2.timestamp = a2 + l2;
              }
            }
            var u2 = null === (i2 = this.instance.config.session_recording.compress_events) || void 0 === i2 || i2 ? function(e3) {
              if (mi(e3) < 1024)
                return e3;
              try {
                if (e3.type === yi.FullSnapshot)
                  return t$1(t$1({}, e3), {}, { data: Kn(e3.data), cv: "2024-10" });
                if (e3.type === yi.IncrementalSnapshot && e3.data.source === wi.Mutation)
                  return t$1(t$1({}, e3), {}, { cv: "2024-10", data: t$1(t$1({}, e3.data), {}, { texts: Kn(e3.data.texts), attributes: Kn(e3.data.attributes), removes: Kn(e3.data.removes), adds: Kn(e3.data.adds) }) });
                if (e3.type === yi.IncrementalSnapshot && e3.data.source === wi.StyleSheetRule)
                  return t$1(t$1({}, e3), {}, { cv: "2024-10", data: t$1(t$1({}, e3.data), {}, { adds: Kn(e3.data.adds), removes: Kn(e3.data.removes) }) });
              } catch (e4) {
                Vn.error("could not compress event - will use uncompressed event", e4);
              }
              return e3;
            }(s2) : s2, c2 = { $snapshot_bytes: mi(u2), $snapshot_data: u2, $session_id: this.sessionId, $window_id: this.windowId };
            "disabled" !== this.status ? this._captureSnapshotBuffered(c2) : this.clearBuffer();
          }
        }
      }
    }
  }
  _pageViewFallBack() {
    if (!this.instance.config.capture_pageview && o$1) {
      var e2 = this._maskUrl(o$1.location.href);
      this._lastHref !== e2 && (this._tryAddCustomEvent("$url_changed", { href: e2 }), this._lastHref = e2);
    }
  }
  _processQueuedEvents() {
    if (this.queuedRRWebEvents.length) {
      var e2 = [...this.queuedRRWebEvents];
      this.queuedRRWebEvents = [], e2.forEach((e3) => {
        Date.now() - e3.enqueuedAt <= 2e3 && this._tryRRWebMethod(e3);
      });
    }
  }
  _maskUrl(e2) {
    var t2 = this.instance.config.session_recording;
    if (t2.maskNetworkRequestFn) {
      var i2, n2 = { url: e2 };
      return null === (i2 = n2 = t2.maskNetworkRequestFn(n2)) || void 0 === i2 ? void 0 : i2.url;
    }
    return e2;
  }
  clearBuffer() {
    return this.buffer = { size: 0, data: [], sessionId: this.sessionId, windowId: this.windowId }, this.buffer;
  }
  _flushBuffer() {
    this.flushBufferTimer && (clearTimeout(this.flushBufferTimer), this.flushBufferTimer = void 0);
    var e2 = this.minimumDuration, t2 = this.sessionDuration, i2 = M(t2) && t2 >= 0, n2 = M(e2) && i2 && t2 < e2;
    if ("buffering" === this.status || n2)
      return this.flushBufferTimer = setTimeout(() => {
        this._flushBuffer();
      }, 2e3), this.buffer;
    this.buffer.data.length > 0 && bi(this.buffer).forEach((e3) => {
      this._captureSnapshot({ $snapshot_bytes: e3.size, $snapshot_data: e3.data, $session_id: e3.sessionId, $window_id: e3.windowId, $lib: "web", $lib_version: s$1.LIB_VERSION });
    });
    return this.clearBuffer();
  }
  _captureSnapshotBuffered(e2) {
    var t2, i2 = 2 + ((null === (t2 = this.buffer) || void 0 === t2 ? void 0 : t2.data.length) || 0);
    !this.isIdle && (this.buffer.size + e2.$snapshot_bytes + i2 > 943718.4 || this.buffer.sessionId !== this.sessionId) && (this.buffer = this._flushBuffer()), this.buffer.size += e2.$snapshot_bytes, this.buffer.data.push(e2.$snapshot_data), this.flushBufferTimer || this.isIdle || (this.flushBufferTimer = setTimeout(() => {
      this._flushBuffer();
    }, 2e3));
  }
  _captureSnapshot(e2) {
    this.instance.capture("$snapshot", e2, { _url: this.instance.requestRouter.endpointFor("api", this._endpoint), _noTruncate: true, _batchKey: "recordings", skip_client_rate_limiting: true });
  }
  _checkUrlTriggerConditions() {
    if (void 0 !== o$1 && o$1.location.href) {
      var e2 = o$1.location.href, t2 = "paused" === this.status, i2 = Zn(e2, this._urlBlocklist);
      i2 && !t2 ? this._pauseRecording() : !i2 && t2 && this._resumeRecording(), Zn(e2, this._urlTriggers) && this._activateTrigger("url");
    }
  }
  _activateTrigger(e2) {
    var t2, i2;
    "trigger_pending" === this.triggerStatus && (null === (t2 = this.instance) || void 0 === t2 || null === (i2 = t2.persistence) || void 0 === i2 || i2.register({ ["url" === e2 ? we : Se]: this.sessionId }), this._flushBuffer(), this._reportStarted(e2 + "_trigger_matched"));
  }
  _pauseRecording() {
    var e2, t2;
    "paused" !== this.status && (this._urlBlocked = true, null == h$2 || null === (e2 = h$2.body) || void 0 === e2 || null === (t2 = e2.classList) || void 0 === t2 || t2.add("ph-no-capture"), clearInterval(this._fullSnapshotTimer), setTimeout(() => {
      this._flushBuffer();
    }, 100), Vn.info("recording paused due to URL blocker"), this._tryAddCustomEvent("recording paused", { reason: "url blocker" }));
  }
  _resumeRecording() {
    var e2, t2;
    "paused" === this.status && (this._urlBlocked = false, null == h$2 || null === (e2 = h$2.body) || void 0 === e2 || null === (t2 = e2.classList) || void 0 === t2 || t2.remove("ph-no-capture"), this._tryTakeFullSnapshot(), this._scheduleFullSnapshot(), this._tryAddCustomEvent("recording resumed", { reason: "left blocked url" }), Vn.info("recording resumed"));
  }
  _addEventTriggerListener() {
    0 !== this._eventTriggers.length && L(this._removeEventTriggerCaptureHook) && (this._removeEventTriggerCaptureHook = this.instance.on("eventCaptured", (e2) => {
      try {
        this._eventTriggers.includes(e2.event) && this._activateTrigger("event");
      } catch (e3) {
        Vn.error("Could not activate event trigger", e3);
      }
    }));
  }
  overrideLinkedFlag() {
    this._linkedFlagSeen = true, this._reportStarted("linked_flag_overridden");
  }
  overrideSampling() {
    var e2;
    null === (e2 = this.instance.persistence) || void 0 === e2 || e2.register({ [ye]: true }), this._reportStarted("sampling_overridden");
  }
  overrideTrigger(e2) {
    this._activateTrigger(e2);
  }
  _reportStarted(e2, t2) {
    this.instance.register_for_session({ $session_recording_start_reason: e2 }), Vn.info(e2.replace("_", " "), t2), V(["recording_initialized", "session_id_changed"], e2) || this._tryAddCustomEvent(e2, t2);
  }
}
var tr = H$1("[Decide]");
class ir {
  constructor(e2) {
    this.instance = e2;
  }
  _loadRemoteConfigJs(e2) {
    var t2, i2, n2;
    null !== (t2 = m$2.__PosthogExtensions__) && void 0 !== t2 && t2.loadExternalDependency ? null === (i2 = m$2.__PosthogExtensions__) || void 0 === i2 || null === (n2 = i2.loadExternalDependency) || void 0 === n2 || n2.call(i2, this.instance, "remote-config", () => e2(m$2._POSTHOG_CONFIG)) : (tr.error("PostHog Extensions not found. Cannot load remote config."), e2());
  }
  _loadRemoteConfigJSON(e2) {
    this.instance._send_request({ method: "GET", url: this.instance.requestRouter.endpointFor("assets", "/array/".concat(this.instance.config.token, "/config")), callback: (t2) => {
      e2(t2.json);
    } });
  }
  load() {
    if (this.instance.config.__preview_remote_config)
      return m$2._POSTHOG_CONFIG ? (tr.info("Using preloaded remote config", m$2._POSTHOG_CONFIG), void this.onRemoteConfig(m$2._POSTHOG_CONFIG)) : void (this.instance.config.advanced_disable_decide ? tr.warn("Remote config is disabled. Falling back to local config.") : this._loadRemoteConfigJs((e2) => {
        if (!e2)
          return tr.info("No config found after loading remote JS config. Falling back to JSON."), void this._loadRemoteConfigJSON((e3) => {
            this.onRemoteConfig(e3);
          });
        this.onRemoteConfig(e2);
      }));
  }
  onRemoteConfig(e2) {
    e2 ? (this.instance._onRemoteConfig(e2), false !== e2.hasFeatureFlags && this.instance.featureFlags.ensureFlagsLoaded()) : tr.error("Failed to fetch remote config from PostHog.");
  }
}
var nr, rr = null != o$1 && o$1.location ? ft(o$1.location.hash, "__posthog") || ft(location.hash, "state") : null, sr = "_postHogToolbarParams";
!function(e2) {
  e2[e2.UNINITIALIZED = 0] = "UNINITIALIZED", e2[e2.LOADING = 1] = "LOADING", e2[e2.LOADED = 2] = "LOADED";
}(nr || (nr = {}));
class or {
  constructor(e2) {
    this.instance = e2;
  }
  setToolbarState(e2) {
    m$2.ph_toolbar_state = e2;
  }
  getToolbarState() {
    var e2;
    return null !== (e2 = m$2.ph_toolbar_state) && void 0 !== e2 ? e2 : nr.UNINITIALIZED;
  }
  maybeLoadToolbar() {
    var e2, t2, i2 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : void 0, n2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : void 0, r2 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : void 0;
    if (!o$1 || !h$2)
      return false;
    i2 = null !== (e2 = i2) && void 0 !== e2 ? e2 : o$1.location, r2 = null !== (t2 = r2) && void 0 !== t2 ? t2 : o$1.history;
    try {
      if (!n2) {
        try {
          o$1.localStorage.setItem("test", "test"), o$1.localStorage.removeItem("test");
        } catch (e3) {
          return false;
        }
        n2 = null == o$1 ? void 0 : o$1.localStorage;
      }
      var s2, a2 = rr || ft(i2.hash, "__posthog") || ft(i2.hash, "state"), l2 = a2 ? Y(() => JSON.parse(atob(decodeURIComponent(a2)))) || Y(() => JSON.parse(decodeURIComponent(a2))) : null;
      return l2 && "ph_authorize" === l2.action ? ((s2 = l2).source = "url", s2 && Object.keys(s2).length > 0 && (l2.desiredHash ? i2.hash = l2.desiredHash : r2 ? r2.replaceState(r2.state, "", i2.pathname + i2.search) : i2.hash = "")) : ((s2 = JSON.parse(n2.getItem(sr) || "{}")).source = "localstorage", delete s2.userIntent), !(!s2.token || this.instance.config.token !== s2.token) && (this.loadToolbar(s2), true);
    } catch (e3) {
      return false;
    }
  }
  _callLoadToolbar(e2) {
    (m$2.ph_load_toolbar || m$2.ph_load_editor)(e2, this.instance);
  }
  loadToolbar(e2) {
    var i2 = !(null == h$2 || !h$2.getElementById(De));
    if (!o$1 || i2)
      return false;
    var n2 = "custom" === this.instance.requestRouter.region && this.instance.config.advanced_disable_toolbar_metrics, r2 = t$1(t$1({ token: this.instance.config.token }, e2), {}, { apiURL: this.instance.requestRouter.endpointFor("ui") }, n2 ? { instrument: false } : {});
    if (o$1.localStorage.setItem(sr, JSON.stringify(t$1(t$1({}, r2), {}, { source: void 0 }))), this.getToolbarState() === nr.LOADED)
      this._callLoadToolbar(r2);
    else if (this.getToolbarState() === nr.UNINITIALIZED) {
      var s2, a2;
      this.setToolbarState(nr.LOADING), null === (s2 = m$2.__PosthogExtensions__) || void 0 === s2 || null === (a2 = s2.loadExternalDependency) || void 0 === a2 || a2.call(s2, this.instance, "toolbar", (e3) => {
        if (e3)
          return B$1.error("[Toolbar] Failed to load", e3), void this.setToolbarState(nr.UNINITIALIZED);
        this.setToolbarState(nr.LOADED), this._callLoadToolbar(r2);
      }), te(o$1, "turbolinks:load", () => {
        this.setToolbarState(nr.UNINITIALIZED), this.loadToolbar(r2);
      });
    }
    return true;
  }
  _loadEditor(e2) {
    return this.loadToolbar(e2);
  }
  maybeLoadEditor() {
    var e2 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : void 0, t2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : void 0, i2 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : void 0;
    return this.maybeLoadToolbar(e2, t2, i2);
  }
}
class ar {
  constructor(e2) {
    i$1(this, "isPaused", true), i$1(this, "queue", []), i$1(this, "flushTimeoutMs", 3e3), this.sendRequest = e2;
  }
  enqueue(e2) {
    this.queue.push(e2), this.flushTimeout || this.setFlushTimeout();
  }
  unload() {
    this.clearFlushTimeout();
    var e2 = this.queue.length > 0 ? this.formatQueue() : {}, i2 = Object.values(e2), n2 = [...i2.filter((e3) => 0 === e3.url.indexOf("/e")), ...i2.filter((e3) => 0 !== e3.url.indexOf("/e"))];
    n2.map((e3) => {
      this.sendRequest(t$1(t$1({}, e3), {}, { transport: "sendBeacon" }));
    });
  }
  enable() {
    this.isPaused = false, this.setFlushTimeout();
  }
  setFlushTimeout() {
    var e2 = this;
    this.isPaused || (this.flushTimeout = setTimeout(() => {
      if (this.clearFlushTimeout(), this.queue.length > 0) {
        var t2 = this.formatQueue(), i2 = function(i3) {
          var n3 = t2[i3], r2 = (/* @__PURE__ */ new Date()).getTime();
          n3.data && I$1(n3.data) && W(n3.data, (e3) => {
            e3.offset = Math.abs(e3.timestamp - r2), delete e3.timestamp;
          }), e2.sendRequest(n3);
        };
        for (var n2 in t2)
          i2(n2);
      }
    }, this.flushTimeoutMs));
  }
  clearFlushTimeout() {
    clearTimeout(this.flushTimeout), this.flushTimeout = void 0;
  }
  formatQueue() {
    var e2 = {};
    return W(this.queue, (i2) => {
      var n2, r2 = i2, s2 = (r2 ? r2.batchKey : null) || r2.url;
      F$1(e2[s2]) && (e2[s2] = t$1(t$1({}, r2), {}, { data: [] })), null === (n2 = e2[s2].data) || void 0 === n2 || n2.push(r2.data);
    }), this.queue = [], e2;
  }
}
var lr = !!v$2 || !!p$2, ur = "text/plain", cr = (e2, i2) => {
  var [n2, r2] = e2.split("?"), s2 = t$1({}, i2);
  null == r2 || r2.split("&").forEach((e3) => {
    var [t2] = e3.split("=");
    delete s2[t2];
  });
  var o2 = vt(s2);
  return o2 = o2 ? (r2 ? r2 + "&" : "") + o2 : r2, "".concat(n2, "?").concat(o2);
}, dr = (e2, t2) => JSON.stringify(e2, (e3, t3) => "bigint" == typeof t3 ? t3.toString() : t3, t2), hr = (e2) => {
  var { data: t2, compression: i2 } = e2;
  if (t2) {
    if (i2 === r$3.GZipJS) {
      var n2 = jn(Wn(dr(t2)), { mtime: 0 }), s2 = new Blob([n2], { type: ur });
      return { contentType: ur, body: s2, estimatedSize: s2.size };
    }
    if (i2 === r$3.Base64) {
      var o2 = function(e3) {
        var t3, i3, n3, r2, s3, o3 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=", a3 = 0, l3 = 0, u2 = "", c2 = [];
        if (!e3)
          return e3;
        e3 = ee(e3);
        do {
          t3 = (s3 = e3.charCodeAt(a3++) << 16 | e3.charCodeAt(a3++) << 8 | e3.charCodeAt(a3++)) >> 18 & 63, i3 = s3 >> 12 & 63, n3 = s3 >> 6 & 63, r2 = 63 & s3, c2[l3++] = o3.charAt(t3) + o3.charAt(i3) + o3.charAt(n3) + o3.charAt(r2);
        } while (a3 < e3.length);
        switch (u2 = c2.join(""), e3.length % 3) {
          case 1:
            u2 = u2.slice(0, -2) + "==";
            break;
          case 2:
            u2 = u2.slice(0, -1) + "=";
        }
        return u2;
      }(dr(t2)), a2 = ((e3) => "data=" + encodeURIComponent("string" == typeof e3 ? e3 : dr(e3)))(o2);
      return { contentType: "application/x-www-form-urlencoded", body: a2, estimatedSize: new Blob([a2]).size };
    }
    var l2 = dr(t2);
    return { contentType: "application/json", body: l2, estimatedSize: new Blob([l2]).size };
  }
}, _r = [];
v$2 && _r.push({ transport: "XHR", method: (e2) => {
  var t2, i2 = new v$2();
  i2.open(e2.method || "GET", e2.url, true);
  var { contentType: n2, body: r2 } = null !== (t2 = hr(e2)) && void 0 !== t2 ? t2 : {};
  W(e2.headers, function(e3, t3) {
    i2.setRequestHeader(t3, e3);
  }), n2 && i2.setRequestHeader("Content-Type", n2), e2.timeout && (i2.timeout = e2.timeout), i2.withCredentials = true, i2.onreadystatechange = () => {
    if (4 === i2.readyState) {
      var t3, n3 = { statusCode: i2.status, text: i2.responseText };
      if (200 === i2.status)
        try {
          n3.json = JSON.parse(i2.responseText);
        } catch (e3) {
        }
      null === (t3 = e2.callback) || void 0 === t3 || t3.call(e2, n3);
    }
  }, i2.send(r2);
} }), p$2 && _r.push({ transport: "fetch", method: (e2) => {
  var i2, n2, { contentType: r2, body: s2, estimatedSize: o2 } = null !== (i2 = hr(e2)) && void 0 !== i2 ? i2 : {}, a2 = new Headers();
  W(e2.headers, function(e3, t2) {
    a2.append(t2, e3);
  }), r2 && a2.append("Content-Type", r2);
  var l2 = e2.url, u2 = null;
  if (g$2) {
    var c2 = new g$2();
    u2 = { signal: c2.signal, timeout: setTimeout(() => c2.abort(), e2.timeout) };
  }
  p$2(l2, t$1({ method: (null == e2 ? void 0 : e2.method) || "GET", headers: a2, keepalive: "POST" === e2.method && (o2 || 0) < 52428.8, body: s2, signal: null === (n2 = u2) || void 0 === n2 ? void 0 : n2.signal }, e2.fetchOptions)).then((t2) => t2.text().then((i3) => {
    var n3, r3 = { statusCode: t2.status, text: i3 };
    if (200 === t2.status)
      try {
        r3.json = JSON.parse(i3);
      } catch (e3) {
        B$1.error(e3);
      }
    null === (n3 = e2.callback) || void 0 === n3 || n3.call(e2, r3);
  })).catch((t2) => {
    var i3;
    B$1.error(t2), null === (i3 = e2.callback) || void 0 === i3 || i3.call(e2, { statusCode: 0, text: t2 });
  }).finally(() => u2 ? clearTimeout(u2.timeout) : null);
} }), null != d$2 && d$2.sendBeacon && _r.push({ transport: "sendBeacon", method: (e2) => {
  var t2 = cr(e2.url, { beacon: "1" });
  try {
    var i2, { contentType: n2, body: r2 } = null !== (i2 = hr(e2)) && void 0 !== i2 ? i2 : {}, s2 = "string" == typeof r2 ? new Blob([r2], { type: n2 }) : r2;
    d$2.sendBeacon(t2, s2);
  } catch (e3) {
  }
} });
var pr = ["retriesPerformedSoFar"];
class vr {
  constructor(e2) {
    i$1(this, "isPolling", false), i$1(this, "pollIntervalMs", 3e3), i$1(this, "queue", []), this.instance = e2, this.queue = [], this.areWeOnline = true, !F$1(o$1) && "onLine" in o$1.navigator && (this.areWeOnline = o$1.navigator.onLine, o$1.addEventListener("online", () => {
      this.areWeOnline = true, this.flush();
    }), o$1.addEventListener("offline", () => {
      this.areWeOnline = false;
    }));
  }
  retriableRequest(e2) {
    var { retriesPerformedSoFar: i2 } = e2, r2 = n$3(e2, pr);
    M(i2) && i2 > 0 && (r2.url = cr(r2.url, { retry_count: i2 })), this.instance._send_request(t$1(t$1({}, r2), {}, { callback: (e3) => {
      var n2;
      200 !== e3.statusCode && (e3.statusCode < 400 || e3.statusCode >= 500) && (null != i2 ? i2 : 0) < 10 ? this.enqueue(t$1({ retriesPerformedSoFar: i2 }, r2)) : null === (n2 = r2.callback) || void 0 === n2 || n2.call(r2, e3);
    } }));
  }
  enqueue(e2) {
    var t2 = e2.retriesPerformedSoFar || 0;
    e2.retriesPerformedSoFar = t2 + 1;
    var i2 = function(e3) {
      var t3 = 3e3 * Math.pow(2, e3), i3 = t3 / 2, n3 = Math.min(18e5, t3), r3 = (Math.random() - 0.5) * (n3 - i3);
      return Math.ceil(n3 + r3);
    }(t2), n2 = Date.now() + i2;
    this.queue.push({ retryAt: n2, requestOptions: e2 });
    var r2 = "Enqueued failed request for retry in ".concat(i2);
    navigator.onLine || (r2 += " (Browser is offline)"), B$1.warn(r2), this.isPolling || (this.isPolling = true, this.poll());
  }
  poll() {
    this.poller && clearTimeout(this.poller), this.poller = setTimeout(() => {
      this.areWeOnline && this.queue.length > 0 && this.flush(), this.poll();
    }, this.pollIntervalMs);
  }
  flush() {
    var e2 = Date.now(), t2 = [], i2 = this.queue.filter((i3) => i3.retryAt < e2 || (t2.push(i3), false));
    if (this.queue = t2, i2.length > 0)
      for (var { requestOptions: n2 } of i2)
        this.retriableRequest(n2);
  }
  unload() {
    for (var { requestOptions: e2 } of (this.poller && (clearTimeout(this.poller), this.poller = void 0), this.queue))
      try {
        this.instance._send_request(t$1(t$1({}, e2), {}, { transport: "sendBeacon" }));
      } catch (e3) {
        B$1.error(e3);
      }
    this.queue = [];
  }
}
var gr, fr = H$1("[SessionId]");
class mr {
  constructor(e2, t2, n2) {
    var r2;
    if (i$1(this, "_sessionIdChangedHandlers", []), !e2.persistence)
      throw new Error("SessionIdManager requires a PostHogPersistence instance");
    this.config = e2.config, this.persistence = e2.persistence, this._windowId = void 0, this._sessionId = void 0, this._sessionStartTimestamp = null, this._sessionActivityTimestamp = null, this._sessionIdGenerator = t2 || Ke, this._windowIdGenerator = n2 || Ke;
    var s2 = this.config.persistence_name || this.config.token, o2 = this.config.session_idle_timeout_seconds || 1800;
    if (this._sessionTimeoutMs = 1e3 * on(o2, 60, 36e3, "session_idle_timeout_seconds", 1800), e2.register({ $configured_session_timeout_ms: this._sessionTimeoutMs }), this._window_id_storage_key = "ph_" + s2 + "_window_id", this._primary_window_exists_storage_key = "ph_" + s2 + "_primary_window_exists", this._canUseSessionStorage()) {
      var a2 = dt.parse(this._window_id_storage_key), l2 = dt.parse(this._primary_window_exists_storage_key);
      a2 && !l2 ? this._windowId = a2 : dt.remove(this._window_id_storage_key), dt.set(this._primary_window_exists_storage_key, true);
    }
    if (null !== (r2 = this.config.bootstrap) && void 0 !== r2 && r2.sessionID)
      try {
        var u2 = ((e3) => {
          var t3 = e3.replace(/-/g, "");
          if (32 !== t3.length)
            throw new Error("Not a valid UUID");
          if ("7" !== t3[12])
            throw new Error("Not a UUIDv7");
          return parseInt(t3.substring(0, 12), 16);
        })(this.config.bootstrap.sessionID);
        this._setSessionId(this.config.bootstrap.sessionID, (/* @__PURE__ */ new Date()).getTime(), u2);
      } catch (e3) {
        fr.error("Invalid sessionID in bootstrap", e3);
      }
    this._listenToReloadWindow();
  }
  get sessionTimeoutMs() {
    return this._sessionTimeoutMs;
  }
  onSessionId(e2) {
    return F$1(this._sessionIdChangedHandlers) && (this._sessionIdChangedHandlers = []), this._sessionIdChangedHandlers.push(e2), this._sessionId && e2(this._sessionId, this._windowId), () => {
      this._sessionIdChangedHandlers = this._sessionIdChangedHandlers.filter((t2) => t2 !== e2);
    };
  }
  _canUseSessionStorage() {
    return "memory" !== this.config.persistence && !this.persistence.disabled && dt.is_supported();
  }
  _setWindowId(e2) {
    e2 !== this._windowId && (this._windowId = e2, this._canUseSessionStorage() && dt.set(this._window_id_storage_key, e2));
  }
  _getWindowId() {
    return this._windowId ? this._windowId : this._canUseSessionStorage() ? dt.parse(this._window_id_storage_key) : null;
  }
  _setSessionId(e2, t2, i2) {
    e2 === this._sessionId && t2 === this._sessionActivityTimestamp && i2 === this._sessionStartTimestamp || (this._sessionStartTimestamp = i2, this._sessionActivityTimestamp = t2, this._sessionId = e2, this.persistence.register({ [be]: [t2, e2, i2] }));
  }
  _getSessionId() {
    if (this._sessionId && this._sessionActivityTimestamp && this._sessionStartTimestamp)
      return [this._sessionActivityTimestamp, this._sessionId, this._sessionStartTimestamp];
    var e2 = this.persistence.props[be];
    return I$1(e2) && 2 === e2.length && e2.push(e2[0]), e2 || [0, null, 0];
  }
  resetSessionId() {
    this._setSessionId(null, null, null);
  }
  _listenToReloadWindow() {
    null == o$1 || o$1.addEventListener("beforeunload", () => {
      this._canUseSessionStorage() && dt.remove(this._primary_window_exists_storage_key);
    });
  }
  checkAndGetSessionAndWindowId() {
    var e2 = arguments.length > 0 && void 0 !== arguments[0] && arguments[0], t2 = (arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null) || (/* @__PURE__ */ new Date()).getTime(), [i2, n2, r2] = this._getSessionId(), s2 = this._getWindowId(), o2 = M(r2) && r2 > 0 && Math.abs(t2 - r2) > 864e5, a2 = false, l2 = !n2, u2 = !e2 && Math.abs(t2 - i2) > this.sessionTimeoutMs;
    l2 || u2 || o2 ? (n2 = this._sessionIdGenerator(), s2 = this._windowIdGenerator(), fr.info("new session ID generated", { sessionId: n2, windowId: s2, changeReason: { noSessionId: l2, activityTimeout: u2, sessionPastMaximumLength: o2 } }), r2 = t2, a2 = true) : s2 || (s2 = this._windowIdGenerator(), a2 = true);
    var c2 = 0 === i2 || !e2 || o2 ? t2 : i2, d2 = 0 === r2 ? (/* @__PURE__ */ new Date()).getTime() : r2;
    return this._setWindowId(s2), this._setSessionId(n2, c2, d2), a2 && this._sessionIdChangedHandlers.forEach((e3) => e3(n2, s2, a2 ? { noSessionId: l2, activityTimeout: u2, sessionPastMaximumLength: o2 } : void 0)), { sessionId: n2, windowId: s2, sessionStartTimestamp: d2, changeReason: a2 ? { noSessionId: l2, activityTimeout: u2, sessionPastMaximumLength: o2 } : void 0, lastActivityTimestamp: i2 };
  }
}
!function(e2) {
  e2.US = "us", e2.EU = "eu", e2.CUSTOM = "custom";
}(gr || (gr = {}));
var br = "i.posthog.com";
class yr {
  constructor(e2) {
    i$1(this, "_regionCache", {}), this.instance = e2;
  }
  get apiHost() {
    var e2 = this.instance.config.api_host.trim().replace(/\/$/, "");
    return "https://app.posthog.com" === e2 ? "https://us.i.posthog.com" : e2;
  }
  get uiHost() {
    var e2, t2 = null === (e2 = this.instance.config.ui_host) || void 0 === e2 ? void 0 : e2.replace(/\/$/, "");
    return t2 || (t2 = this.apiHost.replace(".".concat(br), ".posthog.com")), "https://app.posthog.com" === t2 ? "https://us.posthog.com" : t2;
  }
  get region() {
    return this._regionCache[this.apiHost] || (/https:\/\/(app|us|us-assets)(\.i)?\.posthog\.com/i.test(this.apiHost) ? this._regionCache[this.apiHost] = gr.US : /https:\/\/(eu|eu-assets)(\.i)?\.posthog\.com/i.test(this.apiHost) ? this._regionCache[this.apiHost] = gr.EU : this._regionCache[this.apiHost] = gr.CUSTOM), this._regionCache[this.apiHost];
  }
  endpointFor(e2) {
    var t2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "";
    if (t2 && (t2 = "/" === t2[0] ? t2 : "/".concat(t2)), "ui" === e2)
      return this.uiHost + t2;
    if (this.region === gr.CUSTOM)
      return this.apiHost + t2;
    var i2 = br + t2;
    switch (e2) {
      case "assets":
        return "https://".concat(this.region, "-assets.").concat(i2);
      case "api":
        return "https://".concat(this.region, ".").concat(i2);
    }
  }
}
var wr = "posthog-js";
function Sr(e2) {
  var { organization: t2, projectId: i2, prefix: n2, severityAllowList: r2 = ["error"] } = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
  return (s2) => {
    var o2, a2, l2, u2, c2;
    if (!("*" === r2 || r2.includes(s2.level)) || !e2.__loaded)
      return s2;
    s2.tags || (s2.tags = {});
    var d2 = e2.requestRouter.endpointFor("ui", "/project/".concat(e2.config.token, "/person/").concat(e2.get_distinct_id()));
    s2.tags["PostHog Person URL"] = d2, e2.sessionRecordingStarted() && (s2.tags["PostHog Recording URL"] = e2.get_session_replay_url({ withTimestamp: true }));
    var h2 = (null === (o2 = s2.exception) || void 0 === o2 ? void 0 : o2.values) || [];
    h2.map((e3) => {
      e3.stacktrace && (e3.stacktrace.type = "raw");
    });
    var _2 = { $exception_message: (null === (a2 = h2[0]) || void 0 === a2 ? void 0 : a2.value) || s2.message, $exception_type: null === (l2 = h2[0]) || void 0 === l2 ? void 0 : l2.type, $exception_personURL: d2, $exception_level: s2.level, $exception_list: h2, $sentry_event_id: s2.event_id, $sentry_exception: s2.exception, $sentry_exception_message: (null === (u2 = h2[0]) || void 0 === u2 ? void 0 : u2.value) || s2.message, $sentry_exception_type: null === (c2 = h2[0]) || void 0 === c2 ? void 0 : c2.type, $sentry_tags: s2.tags };
    return t2 && i2 && (_2.$sentry_url = (n2 || "https://sentry.io/organizations/") + t2 + "/issues/?project=" + i2 + "&query=" + s2.event_id), e2.exceptions.sendExceptionEvent(_2), s2;
  };
}
class Er {
  constructor(e2, t2, i2, n2, r2) {
    this.name = wr, this.setupOnce = function(s2) {
      s2(Sr(e2, { organization: t2, projectId: i2, prefix: n2, severityAllowList: r2 }));
    };
  }
}
var kr, xr, Ir, Cr = H$1("[SegmentIntegration]");
function Pr(e2, t2) {
  var i2 = e2.config.segment;
  if (!i2)
    return t2();
  !function(e3, t3) {
    var i3 = e3.config.segment;
    if (!i3)
      return t3();
    var n2 = (i4) => {
      var n3 = () => i4.anonymousId() || Ke();
      e3.config.get_device_id = n3, i4.id() && (e3.register({ distinct_id: i4.id(), $device_id: n3() }), e3.persistence.set_property(Fe, "identified")), t3();
    }, r2 = i3.user();
    "then" in r2 && C$1(r2.then) ? r2.then((e4) => n2(e4)) : n2(r2);
  }(e2, () => {
    i2.register(((e3) => {
      Promise && Promise.resolve || Cr.warn("This browser does not have Promise support, and can not use the segment integration");
      var t3 = (t4, i3) => {
        var n2;
        if (!i3)
          return t4;
        t4.event.userId || t4.event.anonymousId === e3.get_distinct_id() || (Cr.info("No userId set, resetting PostHog"), e3.reset()), t4.event.userId && t4.event.userId !== e3.get_distinct_id() && (Cr.info("UserId set, identifying with PostHog"), e3.identify(t4.event.userId));
        var r2 = e3._calculate_event_properties(i3, null !== (n2 = t4.event.properties) && void 0 !== n2 ? n2 : {}, /* @__PURE__ */ new Date());
        return t4.event.properties = Object.assign({}, r2, t4.event.properties), t4;
      };
      return { name: "PostHog JS", type: "enrichment", version: "1.0.0", isLoaded: () => true, load: () => Promise.resolve(), track: (e4) => t3(e4, e4.event.event), page: (e4) => t3(e4, "$pageview"), identify: (e4) => t3(e4, "$identify"), screen: (e4) => t3(e4, "$screen") };
    })(e2)).then(() => {
      t2();
    });
  });
}
class Rr {
  constructor(e2) {
    this._instance = e2;
  }
  doPageView(e2) {
    var t2, i2 = this._previousPageViewProperties(e2);
    return this._currentPath = null !== (t2 = null == o$1 ? void 0 : o$1.location.pathname) && void 0 !== t2 ? t2 : "", this._instance.scrollManager.resetContext(), this._prevPageviewTimestamp = e2, i2;
  }
  doPageLeave(e2) {
    return this._previousPageViewProperties(e2);
  }
  _previousPageViewProperties(e2) {
    var t2 = this._currentPath, i2 = this._prevPageviewTimestamp, n2 = this._instance.scrollManager.getContext();
    if (!i2)
      return {};
    var r2 = {};
    if (n2) {
      var { maxScrollHeight: s2, lastScrollY: o2, maxScrollY: a2, maxContentHeight: l2, lastContentY: u2, maxContentY: c2 } = n2;
      if (!(F$1(s2) || F$1(o2) || F$1(a2) || F$1(l2) || F$1(u2) || F$1(c2)))
        s2 = Math.ceil(s2), o2 = Math.ceil(o2), a2 = Math.ceil(a2), l2 = Math.ceil(l2), u2 = Math.ceil(u2), c2 = Math.ceil(c2), r2 = { $prev_pageview_last_scroll: o2, $prev_pageview_last_scroll_percentage: s2 <= 1 ? 1 : on(o2 / s2, 0, 1), $prev_pageview_max_scroll: a2, $prev_pageview_max_scroll_percentage: s2 <= 1 ? 1 : on(a2 / s2, 0, 1), $prev_pageview_last_content: u2, $prev_pageview_last_content_percentage: l2 <= 1 ? 1 : on(u2 / l2, 0, 1), $prev_pageview_max_content: c2, $prev_pageview_max_content_percentage: l2 <= 1 ? 1 : on(c2 / l2, 0, 1) };
    }
    return t2 && (r2.$prev_pageview_pathname = t2), i2 && (r2.$prev_pageview_duration = (e2.getTime() - i2.getTime()) / 1e3), r2;
  }
}
!function(e2) {
  e2.Popover = "popover", e2.API = "api", e2.Widget = "widget";
}(kr || (kr = {})), function(e2) {
  e2.Open = "open", e2.MultipleChoice = "multiple_choice", e2.SingleChoice = "single_choice", e2.Rating = "rating", e2.Link = "link";
}(xr || (xr = {})), function(e2) {
  e2.NextQuestion = "next_question", e2.End = "end", e2.ResponseBased = "response_based", e2.SpecificQuestion = "specific_question";
}(Ir || (Ir = {}));
class Fr {
  constructor() {
    i$1(this, "events", {}), this.events = {};
  }
  on(e2, t2) {
    return this.events[e2] || (this.events[e2] = []), this.events[e2].push(t2), () => {
      this.events[e2] = this.events[e2].filter((e3) => e3 !== t2);
    };
  }
  emit(e2, t2) {
    for (var i2 of this.events[e2] || [])
      i2(t2);
    for (var n2 of this.events["*"] || [])
      n2(e2, t2);
  }
}
class Tr {
  constructor(e2) {
    i$1(this, "_debugEventEmitter", new Fr()), i$1(this, "checkStep", (e3, t2) => this.checkStepEvent(e3, t2) && this.checkStepUrl(e3, t2) && this.checkStepElement(e3, t2)), i$1(this, "checkStepEvent", (e3, t2) => null == t2 || !t2.event || (null == e3 ? void 0 : e3.event) === (null == t2 ? void 0 : t2.event)), this.instance = e2, this.actionEvents = /* @__PURE__ */ new Set(), this.actionRegistry = /* @__PURE__ */ new Set();
  }
  init() {
    var e2;
    if (!F$1(null === (e2 = this.instance) || void 0 === e2 ? void 0 : e2._addCaptureHook)) {
      var t2;
      null === (t2 = this.instance) || void 0 === t2 || t2._addCaptureHook((e3, t3) => {
        this.on(e3, t3);
      });
    }
  }
  register(e2) {
    var t2, i2;
    if (!F$1(null === (t2 = this.instance) || void 0 === t2 ? void 0 : t2._addCaptureHook) && (e2.forEach((e3) => {
      var t3, i3;
      null === (t3 = this.actionRegistry) || void 0 === t3 || t3.add(e3), null === (i3 = e3.steps) || void 0 === i3 || i3.forEach((e4) => {
        var t4;
        null === (t4 = this.actionEvents) || void 0 === t4 || t4.add((null == e4 ? void 0 : e4.event) || "");
      });
    }), null !== (i2 = this.instance) && void 0 !== i2 && i2.autocapture)) {
      var n2, r2 = /* @__PURE__ */ new Set();
      e2.forEach((e3) => {
        var t3;
        null === (t3 = e3.steps) || void 0 === t3 || t3.forEach((e4) => {
          null != e4 && e4.selector && r2.add(null == e4 ? void 0 : e4.selector);
        });
      }), null === (n2 = this.instance) || void 0 === n2 || n2.autocapture.setElementSelectors(r2);
    }
  }
  on(e2, t2) {
    var i2;
    null != t2 && 0 != e2.length && (this.actionEvents.has(e2) || this.actionEvents.has(null == t2 ? void 0 : t2.event)) && this.actionRegistry && (null === (i2 = this.actionRegistry) || void 0 === i2 ? void 0 : i2.size) > 0 && this.actionRegistry.forEach((e3) => {
      this.checkAction(t2, e3) && this._debugEventEmitter.emit("actionCaptured", e3.name);
    });
  }
  _addActionHook(e2) {
    this.onAction("actionCaptured", (t2) => e2(t2));
  }
  checkAction(e2, t2) {
    if (null == (null == t2 ? void 0 : t2.steps))
      return false;
    for (var i2 of t2.steps)
      if (this.checkStep(e2, i2))
        return true;
    return false;
  }
  onAction(e2, t2) {
    return this._debugEventEmitter.on(e2, t2);
  }
  checkStepUrl(e2, t2) {
    if (null != t2 && t2.url) {
      var i2, n2 = null == e2 || null === (i2 = e2.properties) || void 0 === i2 ? void 0 : i2.$current_url;
      if (!n2 || "string" != typeof n2)
        return false;
      if (!Tr.matchString(n2, null == t2 ? void 0 : t2.url, (null == t2 ? void 0 : t2.url_matching) || "contains"))
        return false;
    }
    return true;
  }
  static matchString(e2, t2, i2) {
    switch (i2) {
      case "regex":
        return !!o$1 && pt(e2, t2);
      case "exact":
        return t2 === e2;
      case "contains":
        var n2 = Tr.escapeStringRegexp(t2).replace(/_/g, ".").replace(/%/g, ".*");
        return pt(e2, n2);
      default:
        return false;
    }
  }
  static escapeStringRegexp(e2) {
    return e2.replace(/[|\\{}()[\]^$+*?.]/g, "\\$&").replace(/-/g, "\\x2d");
  }
  checkStepElement(e2, t2) {
    if ((null != t2 && t2.href || null != t2 && t2.tag_name || null != t2 && t2.text) && !this.getElementsList(e2).some((e3) => !(null != t2 && t2.href && !Tr.matchString(e3.href || "", null == t2 ? void 0 : t2.href, (null == t2 ? void 0 : t2.href_matching) || "exact")) && ((null == t2 || !t2.tag_name || e3.tag_name === (null == t2 ? void 0 : t2.tag_name)) && !(null != t2 && t2.text && !Tr.matchString(e3.text || "", null == t2 ? void 0 : t2.text, (null == t2 ? void 0 : t2.text_matching) || "exact") && !Tr.matchString(e3.$el_text || "", null == t2 ? void 0 : t2.text, (null == t2 ? void 0 : t2.text_matching) || "exact")))))
      return false;
    if (null != t2 && t2.selector) {
      var i2, n2 = null == e2 || null === (i2 = e2.properties) || void 0 === i2 ? void 0 : i2.$element_selectors;
      if (!n2)
        return false;
      if (!n2.includes(null == t2 ? void 0 : t2.selector))
        return false;
    }
    return true;
  }
  getElementsList(e2) {
    return null == (null == e2 ? void 0 : e2.properties.$elements) ? [] : null == e2 ? void 0 : e2.properties.$elements;
  }
}
class $r {
  constructor(e2) {
    this.instance = e2, this.eventToSurveys = /* @__PURE__ */ new Map(), this.actionToSurveys = /* @__PURE__ */ new Map();
  }
  register(e2) {
    var t2;
    F$1(null === (t2 = this.instance) || void 0 === t2 ? void 0 : t2._addCaptureHook) || (this.setupEventBasedSurveys(e2), this.setupActionBasedSurveys(e2));
  }
  setupActionBasedSurveys(e2) {
    var t2 = e2.filter((e3) => {
      var t3, i2, n2, r2;
      return (null === (t3 = e3.conditions) || void 0 === t3 ? void 0 : t3.actions) && (null === (i2 = e3.conditions) || void 0 === i2 || null === (n2 = i2.actions) || void 0 === n2 || null === (r2 = n2.values) || void 0 === r2 ? void 0 : r2.length) > 0;
    });
    if (0 !== t2.length) {
      if (null == this.actionMatcher) {
        this.actionMatcher = new Tr(this.instance), this.actionMatcher.init();
        this.actionMatcher._addActionHook((e3) => {
          this.onAction(e3);
        });
      }
      t2.forEach((e3) => {
        var t3, i2, n2, r2, s2, o2, a2, l2, u2, c2;
        e3.conditions && null !== (t3 = e3.conditions) && void 0 !== t3 && t3.actions && null !== (i2 = e3.conditions) && void 0 !== i2 && null !== (n2 = i2.actions) && void 0 !== n2 && n2.values && (null === (r2 = e3.conditions) || void 0 === r2 || null === (s2 = r2.actions) || void 0 === s2 || null === (o2 = s2.values) || void 0 === o2 ? void 0 : o2.length) > 0 && (null === (a2 = this.actionMatcher) || void 0 === a2 || a2.register(e3.conditions.actions.values), null === (l2 = e3.conditions) || void 0 === l2 || null === (u2 = l2.actions) || void 0 === u2 || null === (c2 = u2.values) || void 0 === c2 || c2.forEach((t4) => {
          if (t4 && t4.name) {
            var i3 = this.actionToSurveys.get(t4.name);
            i3 && i3.push(e3.id), this.actionToSurveys.set(t4.name, i3 || [e3.id]);
          }
        }));
      });
    }
  }
  setupEventBasedSurveys(e2) {
    var t2;
    if (0 !== e2.filter((e3) => {
      var t3, i2, n2, r2;
      return (null === (t3 = e3.conditions) || void 0 === t3 ? void 0 : t3.events) && (null === (i2 = e3.conditions) || void 0 === i2 || null === (n2 = i2.events) || void 0 === n2 || null === (r2 = n2.values) || void 0 === r2 ? void 0 : r2.length) > 0;
    }).length) {
      null === (t2 = this.instance) || void 0 === t2 || t2._addCaptureHook((e3, t3) => {
        this.onEvent(e3, t3);
      }), e2.forEach((e3) => {
        var t3, i2, n2;
        null === (t3 = e3.conditions) || void 0 === t3 || null === (i2 = t3.events) || void 0 === i2 || null === (n2 = i2.values) || void 0 === n2 || n2.forEach((t4) => {
          if (t4 && t4.name) {
            var i3 = this.eventToSurveys.get(t4.name);
            i3 && i3.push(e3.id), this.eventToSurveys.set(t4.name, i3 || [e3.id]);
          }
        });
      });
    }
  }
  onEvent(e2, t2) {
    var i2, n2, r2 = (null === (i2 = this.instance) || void 0 === i2 || null === (n2 = i2.persistence) || void 0 === n2 ? void 0 : n2.props[Pe]) || [];
    if ($r.SURVEY_SHOWN_EVENT_NAME == e2 && t2 && r2.length > 0) {
      var s2, o2 = null == t2 || null === (s2 = t2.properties) || void 0 === s2 ? void 0 : s2.$survey_id;
      if (o2) {
        var a2 = r2.indexOf(o2);
        a2 >= 0 && (r2.splice(a2, 1), this._updateActivatedSurveys(r2));
      }
    } else
      this.eventToSurveys.has(e2) && this._updateActivatedSurveys(r2.concat(this.eventToSurveys.get(e2) || []));
  }
  onAction(e2) {
    var t2, i2, n2 = (null === (t2 = this.instance) || void 0 === t2 || null === (i2 = t2.persistence) || void 0 === i2 ? void 0 : i2.props[Pe]) || [];
    this.actionToSurveys.has(e2) && this._updateActivatedSurveys(n2.concat(this.actionToSurveys.get(e2) || []));
  }
  _updateActivatedSurveys(e2) {
    var t2, i2;
    null === (t2 = this.instance) || void 0 === t2 || null === (i2 = t2.persistence) || void 0 === i2 || i2.register({ [Pe]: [...new Set(e2)] });
  }
  getSurveys() {
    var e2, t2, i2 = null === (e2 = this.instance) || void 0 === e2 || null === (t2 = e2.persistence) || void 0 === t2 ? void 0 : t2.props[Pe];
    return i2 || [];
  }
  getEventToSurveys() {
    return this.eventToSurveys;
  }
  _getActionMatcher() {
    return this.actionMatcher;
  }
}
i$1($r, "SURVEY_SHOWN_EVENT_NAME", "survey shown");
var Or, Lr, Mr, Ar, Dr, Nr, qr, Br, Hr = {}, Ur = [], zr = /acit|ex(?:s|g|n|p|$)|rph|grid|ows|mnc|ntw|ine[ch]|zoo|^ord|itera/i, jr = Array.isArray;
function Wr(e2, t2) {
  for (var i2 in t2)
    e2[i2] = t2[i2];
  return e2;
}
function Gr(e2) {
  var t2 = e2.parentNode;
  t2 && t2.removeChild(e2);
}
function Vr(e2, t2, i2, n2, r2) {
  var s2 = { type: e2, props: t2, key: i2, ref: n2, __k: null, __: null, __b: 0, __e: null, __d: void 0, __c: null, constructor: void 0, __v: null == r2 ? ++Mr : r2, __i: -1, __u: 0 };
  return null == r2 && null != Lr.vnode && Lr.vnode(s2), s2;
}
function Jr(e2) {
  return e2.children;
}
function Yr(e2, t2) {
  this.props = e2, this.context = t2;
}
function Xr(e2, t2) {
  if (null == t2)
    return e2.__ ? Xr(e2.__, e2.__i + 1) : null;
  for (var i2; t2 < e2.__k.length; t2++)
    if (null != (i2 = e2.__k[t2]) && null != i2.__e)
      return i2.__e;
  return "function" == typeof e2.type ? Xr(e2) : null;
}
function Kr(e2) {
  var t2, i2;
  if (null != (e2 = e2.__) && null != e2.__c) {
    for (e2.__e = e2.__c.base = null, t2 = 0; t2 < e2.__k.length; t2++)
      if (null != (i2 = e2.__k[t2]) && null != i2.__e) {
        e2.__e = e2.__c.base = i2.__e;
        break;
      }
    return Kr(e2);
  }
}
function Qr(e2) {
  (!e2.__d && (e2.__d = true) && Ar.push(e2) && !Zr.__r++ || Dr !== Lr.debounceRendering) && ((Dr = Lr.debounceRendering) || Nr)(Zr);
}
function Zr() {
  var e2, t2, i2, n2, r2, s2, o2, a2, l2;
  for (Ar.sort(qr); e2 = Ar.shift(); )
    e2.__d && (t2 = Ar.length, n2 = void 0, s2 = (r2 = (i2 = e2).__v).__e, a2 = [], l2 = [], (o2 = i2.__P) && ((n2 = Wr({}, r2)).__v = r2.__v + 1, Lr.vnode && Lr.vnode(n2), ls(o2, n2, r2, i2.__n, void 0 !== o2.ownerSVGElement, 32 & r2.__u ? [s2] : null, a2, null == s2 ? Xr(r2) : s2, !!(32 & r2.__u), l2), n2.__.__k[n2.__i] = n2, us(a2, n2, l2), n2.__e != s2 && Kr(n2)), Ar.length > t2 && Ar.sort(qr));
  Zr.__r = 0;
}
function es(e2, t2, i2, n2, r2, s2, o2, a2, l2, u2, c2) {
  var d2, h2, _2, p2, v2, g2 = n2 && n2.__k || Ur, f2 = t2.length;
  for (i2.__d = l2, ts(i2, t2, g2), l2 = i2.__d, d2 = 0; d2 < f2; d2++)
    null != (_2 = i2.__k[d2]) && "boolean" != typeof _2 && "function" != typeof _2 && (h2 = -1 === _2.__i ? Hr : g2[_2.__i] || Hr, _2.__i = d2, ls(e2, _2, h2, r2, s2, o2, a2, l2, u2, c2), p2 = _2.__e, _2.ref && h2.ref != _2.ref && (h2.ref && ds(h2.ref, null, _2), c2.push(_2.ref, _2.__c || p2, _2)), null == v2 && null != p2 && (v2 = p2), 65536 & _2.__u || h2.__k === _2.__k ? l2 = is$1(_2, l2, e2) : "function" == typeof _2.type && void 0 !== _2.__d ? l2 = _2.__d : p2 && (l2 = p2.nextSibling), _2.__d = void 0, _2.__u &= -196609);
  i2.__d = l2, i2.__e = v2;
}
function ts(e2, t2, i2) {
  var n2, r2, s2, o2, a2, l2 = t2.length, u2 = i2.length, c2 = u2, d2 = 0;
  for (e2.__k = [], n2 = 0; n2 < l2; n2++)
    null != (r2 = e2.__k[n2] = null == (r2 = t2[n2]) || "boolean" == typeof r2 || "function" == typeof r2 ? null : "string" == typeof r2 || "number" == typeof r2 || "bigint" == typeof r2 || r2.constructor == String ? Vr(null, r2, null, null, r2) : jr(r2) ? Vr(Jr, { children: r2 }, null, null, null) : void 0 === r2.constructor && r2.__b > 0 ? Vr(r2.type, r2.props, r2.key, r2.ref ? r2.ref : null, r2.__v) : r2) ? (r2.__ = e2, r2.__b = e2.__b + 1, a2 = ns(r2, i2, o2 = n2 + d2, c2), r2.__i = a2, s2 = null, -1 !== a2 && (c2--, (s2 = i2[a2]) && (s2.__u |= 131072)), null == s2 || null === s2.__v ? (-1 == a2 && d2--, "function" != typeof r2.type && (r2.__u |= 65536)) : a2 !== o2 && (a2 === o2 + 1 ? d2++ : a2 > o2 ? c2 > l2 - o2 ? d2 += a2 - o2 : d2-- : d2 = a2 < o2 && a2 == o2 - 1 ? a2 - o2 : 0, a2 !== n2 + d2 && (r2.__u |= 65536))) : (s2 = i2[n2]) && null == s2.key && s2.__e && (s2.__e == e2.__d && (e2.__d = Xr(s2)), hs(s2, s2, false), i2[n2] = null, c2--);
  if (c2)
    for (n2 = 0; n2 < u2; n2++)
      null != (s2 = i2[n2]) && 0 == (131072 & s2.__u) && (s2.__e == e2.__d && (e2.__d = Xr(s2)), hs(s2, s2));
}
function is$1(e2, t2, i2) {
  var n2, r2;
  if ("function" == typeof e2.type) {
    for (n2 = e2.__k, r2 = 0; n2 && r2 < n2.length; r2++)
      n2[r2] && (n2[r2].__ = e2, t2 = is$1(n2[r2], t2, i2));
    return t2;
  }
  return e2.__e != t2 && (i2.insertBefore(e2.__e, t2 || null), t2 = e2.__e), t2 && t2.nextSibling;
}
function ns(e2, t2, i2, n2) {
  var r2 = e2.key, s2 = e2.type, o2 = i2 - 1, a2 = i2 + 1, l2 = t2[i2];
  if (null === l2 || l2 && r2 == l2.key && s2 === l2.type)
    return i2;
  if (n2 > (null != l2 && 0 == (131072 & l2.__u) ? 1 : 0))
    for (; o2 >= 0 || a2 < t2.length; ) {
      if (o2 >= 0) {
        if ((l2 = t2[o2]) && 0 == (131072 & l2.__u) && r2 == l2.key && s2 === l2.type)
          return o2;
        o2--;
      }
      if (a2 < t2.length) {
        if ((l2 = t2[a2]) && 0 == (131072 & l2.__u) && r2 == l2.key && s2 === l2.type)
          return a2;
        a2++;
      }
    }
  return -1;
}
function rs(e2, t2, i2) {
  "-" === t2[0] ? e2.setProperty(t2, null == i2 ? "" : i2) : e2[t2] = null == i2 ? "" : "number" != typeof i2 || zr.test(t2) ? i2 : i2 + "px";
}
function ss(e2, t2, i2, n2, r2) {
  var s2;
  e:
    if ("style" === t2)
      if ("string" == typeof i2)
        e2.style.cssText = i2;
      else {
        if ("string" == typeof n2 && (e2.style.cssText = n2 = ""), n2)
          for (t2 in n2)
            i2 && t2 in i2 || rs(e2.style, t2, "");
        if (i2)
          for (t2 in i2)
            n2 && i2[t2] === n2[t2] || rs(e2.style, t2, i2[t2]);
      }
    else if ("o" === t2[0] && "n" === t2[1])
      s2 = t2 !== (t2 = t2.replace(/(PointerCapture)$|Capture$/, "$1")), t2 = t2.toLowerCase() in e2 ? t2.toLowerCase().slice(2) : t2.slice(2), e2.l || (e2.l = {}), e2.l[t2 + s2] = i2, i2 ? n2 ? i2.u = n2.u : (i2.u = Date.now(), e2.addEventListener(t2, s2 ? as : os, s2)) : e2.removeEventListener(t2, s2 ? as : os, s2);
    else {
      if (r2)
        t2 = t2.replace(/xlink(H|:h)/, "h").replace(/sName$/, "s");
      else if ("width" !== t2 && "height" !== t2 && "href" !== t2 && "list" !== t2 && "form" !== t2 && "tabIndex" !== t2 && "download" !== t2 && "rowSpan" !== t2 && "colSpan" !== t2 && "role" !== t2 && t2 in e2)
        try {
          e2[t2] = null == i2 ? "" : i2;
          break e;
        } catch (e3) {
        }
      "function" == typeof i2 || (null == i2 || false === i2 && "-" !== t2[4] ? e2.removeAttribute(t2) : e2.setAttribute(t2, i2));
    }
}
function os(e2) {
  var t2 = this.l[e2.type + false];
  if (e2.t) {
    if (e2.t <= t2.u)
      return;
  } else
    e2.t = Date.now();
  return t2(Lr.event ? Lr.event(e2) : e2);
}
function as(e2) {
  return this.l[e2.type + true](Lr.event ? Lr.event(e2) : e2);
}
function ls(e2, t2, i2, n2, r2, s2, o2, a2, l2, u2) {
  var c2, d2, h2, _2, p2, v2, g2, f2, m2, b2, y2, w2, S2, E2, k2, x = t2.type;
  if (void 0 !== t2.constructor)
    return null;
  128 & i2.__u && (l2 = !!(32 & i2.__u), s2 = [a2 = t2.__e = i2.__e]), (c2 = Lr.__b) && c2(t2);
  e:
    if ("function" == typeof x)
      try {
        if (f2 = t2.props, m2 = (c2 = x.contextType) && n2[c2.__c], b2 = c2 ? m2 ? m2.props.value : c2.__ : n2, i2.__c ? g2 = (d2 = t2.__c = i2.__c).__ = d2.__E : ("prototype" in x && x.prototype.render ? t2.__c = d2 = new x(f2, b2) : (t2.__c = d2 = new Yr(f2, b2), d2.constructor = x, d2.render = _s), m2 && m2.sub(d2), d2.props = f2, d2.state || (d2.state = {}), d2.context = b2, d2.__n = n2, h2 = d2.__d = true, d2.__h = [], d2._sb = []), null == d2.__s && (d2.__s = d2.state), null != x.getDerivedStateFromProps && (d2.__s == d2.state && (d2.__s = Wr({}, d2.__s)), Wr(d2.__s, x.getDerivedStateFromProps(f2, d2.__s))), _2 = d2.props, p2 = d2.state, d2.__v = t2, h2)
          null == x.getDerivedStateFromProps && null != d2.componentWillMount && d2.componentWillMount(), null != d2.componentDidMount && d2.__h.push(d2.componentDidMount);
        else {
          if (null == x.getDerivedStateFromProps && f2 !== _2 && null != d2.componentWillReceiveProps && d2.componentWillReceiveProps(f2, b2), !d2.__e && (null != d2.shouldComponentUpdate && false === d2.shouldComponentUpdate(f2, d2.__s, b2) || t2.__v === i2.__v)) {
            for (t2.__v !== i2.__v && (d2.props = f2, d2.state = d2.__s, d2.__d = false), t2.__e = i2.__e, t2.__k = i2.__k, t2.__k.forEach(function(e3) {
              e3 && (e3.__ = t2);
            }), y2 = 0; y2 < d2._sb.length; y2++)
              d2.__h.push(d2._sb[y2]);
            d2._sb = [], d2.__h.length && o2.push(d2);
            break e;
          }
          null != d2.componentWillUpdate && d2.componentWillUpdate(f2, d2.__s, b2), null != d2.componentDidUpdate && d2.__h.push(function() {
            d2.componentDidUpdate(_2, p2, v2);
          });
        }
        if (d2.context = b2, d2.props = f2, d2.__P = e2, d2.__e = false, w2 = Lr.__r, S2 = 0, "prototype" in x && x.prototype.render) {
          for (d2.state = d2.__s, d2.__d = false, w2 && w2(t2), c2 = d2.render(d2.props, d2.state, d2.context), E2 = 0; E2 < d2._sb.length; E2++)
            d2.__h.push(d2._sb[E2]);
          d2._sb = [];
        } else
          do {
            d2.__d = false, w2 && w2(t2), c2 = d2.render(d2.props, d2.state, d2.context), d2.state = d2.__s;
          } while (d2.__d && ++S2 < 25);
        d2.state = d2.__s, null != d2.getChildContext && (n2 = Wr(Wr({}, n2), d2.getChildContext())), h2 || null == d2.getSnapshotBeforeUpdate || (v2 = d2.getSnapshotBeforeUpdate(_2, p2)), es(e2, jr(k2 = null != c2 && c2.type === Jr && null == c2.key ? c2.props.children : c2) ? k2 : [k2], t2, i2, n2, r2, s2, o2, a2, l2, u2), d2.base = t2.__e, t2.__u &= -161, d2.__h.length && o2.push(d2), g2 && (d2.__E = d2.__ = null);
      } catch (e3) {
        t2.__v = null, l2 || null != s2 ? (t2.__e = a2, t2.__u |= l2 ? 160 : 32, s2[s2.indexOf(a2)] = null) : (t2.__e = i2.__e, t2.__k = i2.__k), Lr.__e(e3, t2, i2);
      }
    else
      null == s2 && t2.__v === i2.__v ? (t2.__k = i2.__k, t2.__e = i2.__e) : t2.__e = cs(i2.__e, t2, i2, n2, r2, s2, o2, l2, u2);
  (c2 = Lr.diffed) && c2(t2);
}
function us(e2, t2, i2) {
  t2.__d = void 0;
  for (var n2 = 0; n2 < i2.length; n2++)
    ds(i2[n2], i2[++n2], i2[++n2]);
  Lr.__c && Lr.__c(t2, e2), e2.some(function(t3) {
    try {
      e2 = t3.__h, t3.__h = [], e2.some(function(e3) {
        e3.call(t3);
      });
    } catch (e3) {
      Lr.__e(e3, t3.__v);
    }
  });
}
function cs(e2, t2, i2, n2, r2, s2, o2, a2, l2) {
  var u2, c2, d2, h2, _2, p2, v2, g2 = i2.props, f2 = t2.props, m2 = t2.type;
  if ("svg" === m2 && (r2 = true), null != s2) {
    for (u2 = 0; u2 < s2.length; u2++)
      if ((_2 = s2[u2]) && "setAttribute" in _2 == !!m2 && (m2 ? _2.localName === m2 : 3 === _2.nodeType)) {
        e2 = _2, s2[u2] = null;
        break;
      }
  }
  if (null == e2) {
    if (null === m2)
      return document.createTextNode(f2);
    e2 = r2 ? document.createElementNS("http://www.w3.org/2000/svg", m2) : document.createElement(m2, f2.is && f2), s2 = null, a2 = false;
  }
  if (null === m2)
    g2 === f2 || a2 && e2.data === f2 || (e2.data = f2);
  else {
    if (s2 = s2 && Or.call(e2.childNodes), g2 = i2.props || Hr, !a2 && null != s2)
      for (g2 = {}, u2 = 0; u2 < e2.attributes.length; u2++)
        g2[(_2 = e2.attributes[u2]).name] = _2.value;
    for (u2 in g2)
      _2 = g2[u2], "children" == u2 || ("dangerouslySetInnerHTML" == u2 ? d2 = _2 : "key" === u2 || u2 in f2 || ss(e2, u2, null, _2, r2));
    for (u2 in f2)
      _2 = f2[u2], "children" == u2 ? h2 = _2 : "dangerouslySetInnerHTML" == u2 ? c2 = _2 : "value" == u2 ? p2 = _2 : "checked" == u2 ? v2 = _2 : "key" === u2 || a2 && "function" != typeof _2 || g2[u2] === _2 || ss(e2, u2, _2, g2[u2], r2);
    if (c2)
      a2 || d2 && (c2.__html === d2.__html || c2.__html === e2.innerHTML) || (e2.innerHTML = c2.__html), t2.__k = [];
    else if (d2 && (e2.innerHTML = ""), es(e2, jr(h2) ? h2 : [h2], t2, i2, n2, r2 && "foreignObject" !== m2, s2, o2, s2 ? s2[0] : i2.__k && Xr(i2, 0), a2, l2), null != s2)
      for (u2 = s2.length; u2--; )
        null != s2[u2] && Gr(s2[u2]);
    a2 || (u2 = "value", void 0 !== p2 && (p2 !== e2[u2] || "progress" === m2 && !p2 || "option" === m2 && p2 !== g2[u2]) && ss(e2, u2, p2, g2[u2], false), u2 = "checked", void 0 !== v2 && v2 !== e2[u2] && ss(e2, u2, v2, g2[u2], false));
  }
  return e2;
}
function ds(e2, t2, i2) {
  try {
    "function" == typeof e2 ? e2(t2) : e2.current = t2;
  } catch (e3) {
    Lr.__e(e3, i2);
  }
}
function hs(e2, t2, i2) {
  var n2, r2;
  if (Lr.unmount && Lr.unmount(e2), (n2 = e2.ref) && (n2.current && n2.current !== e2.__e || ds(n2, null, t2)), null != (n2 = e2.__c)) {
    if (n2.componentWillUnmount)
      try {
        n2.componentWillUnmount();
      } catch (e3) {
        Lr.__e(e3, t2);
      }
    n2.base = n2.__P = null, e2.__c = void 0;
  }
  if (n2 = e2.__k)
    for (r2 = 0; r2 < n2.length; r2++)
      n2[r2] && hs(n2[r2], t2, i2 || "function" != typeof e2.type);
  i2 || null == e2.__e || Gr(e2.__e), e2.__ = e2.__e = e2.__d = void 0;
}
function _s(e2, t2, i2) {
  return this.constructor(e2, i2);
}
Or = Ur.slice, Lr = { __e: function(e2, t2, i2, n2) {
  for (var r2, s2, o2; t2 = t2.__; )
    if ((r2 = t2.__c) && !r2.__)
      try {
        if ((s2 = r2.constructor) && null != s2.getDerivedStateFromError && (r2.setState(s2.getDerivedStateFromError(e2)), o2 = r2.__d), null != r2.componentDidCatch && (r2.componentDidCatch(e2, n2 || {}), o2 = r2.__d), o2)
          return r2.__E = r2;
      } catch (t3) {
        e2 = t3;
      }
  throw e2;
} }, Mr = 0, Yr.prototype.setState = function(e2, t2) {
  var i2;
  i2 = null != this.__s && this.__s !== this.state ? this.__s : this.__s = Wr({}, this.state), "function" == typeof e2 && (e2 = e2(Wr({}, i2), this.props)), e2 && Wr(i2, e2), null != e2 && this.__v && (t2 && this._sb.push(t2), Qr(this));
}, Yr.prototype.forceUpdate = function(e2) {
  this.__v && (this.__e = true, e2 && this.__h.push(e2), Qr(this));
}, Yr.prototype.render = Jr, Ar = [], Nr = "function" == typeof Promise ? Promise.prototype.then.bind(Promise.resolve()) : setTimeout, qr = function(e2, t2) {
  return e2.__v.__b - t2.__v.__b;
}, Zr.__r = 0, Br = 0;
!function(e2, t2) {
  var i2 = { __c: t2 = "__cC" + Br++, __: e2, Consumer: function(e3, t3) {
    return e3.children(t3);
  }, Provider: function(e3) {
    var i3, n2;
    return this.getChildContext || (i3 = [], (n2 = {})[t2] = this, this.getChildContext = function() {
      return n2;
    }, this.shouldComponentUpdate = function(e4) {
      this.props.value !== e4.value && i3.some(function(e5) {
        e5.__e = true, Qr(e5);
      });
    }, this.sub = function(e4) {
      i3.push(e4);
      var t3 = e4.componentWillUnmount;
      e4.componentWillUnmount = function() {
        i3.splice(i3.indexOf(e4), 1), t3 && t3.call(e4);
      };
    }), e3.children;
  } };
  i2.Provider.__ = i2.Consumer.contextType = i2;
}({ isPreviewMode: false, previewPageIndex: 0, handleCloseSurveyPopup: () => {
}, isPopup: true });
var ps = H$1("[Surveys]"), vs = { icontains: (e2) => !!o$1 && o$1.location.href.toLowerCase().indexOf(e2.toLowerCase()) > -1, not_icontains: (e2) => !!o$1 && -1 === o$1.location.href.toLowerCase().indexOf(e2.toLowerCase()), regex: (e2) => !!o$1 && pt(o$1.location.href, e2), not_regex: (e2) => !!o$1 && !pt(o$1.location.href, e2), exact: (e2) => (null == o$1 ? void 0 : o$1.location.href) === e2, is_not: (e2) => (null == o$1 ? void 0 : o$1.location.href) !== e2 };
class gs {
  constructor(e2) {
    this.instance = e2, this._surveyEventReceiver = null;
  }
  onRemoteConfig(e2) {
    this._decideServerResponse = !!e2.surveys, this.loadIfEnabled();
  }
  reset() {
    localStorage.removeItem("lastSeenSurveyDate");
    var e2 = (() => {
      for (var e3 = [], t2 = 0; t2 < localStorage.length; t2++) {
        var i2 = localStorage.key(t2);
        null != i2 && i2.startsWith("seenSurvey_") && e3.push(i2);
      }
      return e3;
    })();
    e2.forEach((e3) => localStorage.removeItem(e3));
  }
  loadIfEnabled() {
    var e2, t2, i2, n2 = null == m$2 || null === (e2 = m$2.__PosthogExtensions__) || void 0 === e2 ? void 0 : e2.generateSurveys;
    this.instance.config.disable_surveys || !this._decideServerResponse || n2 || (null == this._surveyEventReceiver && (this._surveyEventReceiver = new $r(this.instance)), null === (t2 = m$2.__PosthogExtensions__) || void 0 === t2 || null === (i2 = t2.loadExternalDependency) || void 0 === i2 || i2.call(t2, this.instance, "surveys", (e3) => {
      var t3, i3;
      if (e3)
        return ps.error("Could not load surveys script", e3);
      this._surveyManager = null === (t3 = m$2.__PosthogExtensions__) || void 0 === t3 || null === (i3 = t3.generateSurveys) || void 0 === i3 ? void 0 : i3.call(t3, this.instance);
    }));
  }
  getSurveys(e2) {
    var t2 = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
    if (this.instance.config.disable_surveys)
      return e2([]);
    null == this._surveyEventReceiver && (this._surveyEventReceiver = new $r(this.instance));
    var i2 = this.instance.get_property(Ce);
    if (i2 && !t2)
      return e2(i2);
    this.instance._send_request({ url: this.instance.requestRouter.endpointFor("api", "/api/surveys/?token=".concat(this.instance.config.token)), method: "GET", transport: "XHR", callback: (t3) => {
      var i3;
      if (200 !== t3.statusCode || !t3.json)
        return e2([]);
      var n2, r2 = t3.json.surveys || [], s2 = r2.filter((e3) => {
        var t4, i4, n3, r3, s3, o2, a2, l2, u2, c2, d2, h2;
        return (null === (t4 = e3.conditions) || void 0 === t4 ? void 0 : t4.events) && (null === (i4 = e3.conditions) || void 0 === i4 || null === (n3 = i4.events) || void 0 === n3 ? void 0 : n3.values) && (null === (r3 = e3.conditions) || void 0 === r3 || null === (s3 = r3.events) || void 0 === s3 || null === (o2 = s3.values) || void 0 === o2 ? void 0 : o2.length) > 0 || (null === (a2 = e3.conditions) || void 0 === a2 ? void 0 : a2.actions) && (null === (l2 = e3.conditions) || void 0 === l2 || null === (u2 = l2.actions) || void 0 === u2 ? void 0 : u2.values) && (null === (c2 = e3.conditions) || void 0 === c2 || null === (d2 = c2.actions) || void 0 === d2 || null === (h2 = d2.values) || void 0 === h2 ? void 0 : h2.length) > 0;
      });
      s2.length > 0 && (null === (n2 = this._surveyEventReceiver) || void 0 === n2 || n2.register(s2));
      return null === (i3 = this.instance.persistence) || void 0 === i3 || i3.register({ [Ce]: r2 }), e2(r2);
    } });
  }
  getActiveMatchingSurveys(e2) {
    var t2 = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
    this.getSurveys((t3) => {
      var i2, n2 = t3.filter((e3) => !(!e3.start_date || e3.end_date)).filter((e3) => {
        var t4, i3, n3, r3;
        if (!e3.conditions)
          return true;
        var s3 = null === (t4 = e3.conditions) || void 0 === t4 || !t4.url || vs[null !== (i3 = null === (n3 = e3.conditions) || void 0 === n3 ? void 0 : n3.urlMatchType) && void 0 !== i3 ? i3 : "icontains"](e3.conditions.url), o2 = null === (r3 = e3.conditions) || void 0 === r3 || !r3.selector || (null == h$2 ? void 0 : h$2.querySelector(e3.conditions.selector));
        return s3 && o2;
      }), r2 = null === (i2 = this._surveyEventReceiver) || void 0 === i2 ? void 0 : i2.getSurveys(), s2 = n2.filter((e3) => {
        var t4, i3, n3, s3, o2, a2, l2, u2, c2, d2, h2;
        if (!(e3.linked_flag_key || e3.targeting_flag_key || e3.internal_targeting_flag_key || null !== (t4 = e3.feature_flag_keys) && void 0 !== t4 && t4.length))
          return true;
        var _2 = !e3.linked_flag_key || this.instance.featureFlags.isFeatureEnabled(e3.linked_flag_key), p2 = !e3.targeting_flag_key || this.instance.featureFlags.isFeatureEnabled(e3.targeting_flag_key), v2 = (null === (i3 = e3.conditions) || void 0 === i3 ? void 0 : i3.events) && (null === (n3 = e3.conditions) || void 0 === n3 || null === (s3 = n3.events) || void 0 === s3 ? void 0 : s3.values) && (null === (o2 = e3.conditions) || void 0 === o2 || null === (a2 = o2.events) || void 0 === a2 ? void 0 : a2.values.length) > 0, g2 = (null === (l2 = e3.conditions) || void 0 === l2 ? void 0 : l2.actions) && (null === (u2 = e3.conditions) || void 0 === u2 || null === (c2 = u2.actions) || void 0 === c2 ? void 0 : c2.values) && (null === (d2 = e3.conditions) || void 0 === d2 || null === (h2 = d2.actions) || void 0 === h2 ? void 0 : h2.values.length) > 0, f2 = !v2 && !g2 || (null == r2 ? void 0 : r2.includes(e3.id)), m2 = this._canActivateRepeatedly(e3), b2 = !(e3.internal_targeting_flag_key && !m2) || this.instance.featureFlags.isFeatureEnabled(e3.internal_targeting_flag_key), y2 = this.checkFlags(e3);
        return _2 && p2 && b2 && f2 && y2;
      });
      return e2(s2);
    }, t2);
  }
  checkFlags(e2) {
    var t2;
    return null === (t2 = e2.feature_flag_keys) || void 0 === t2 || !t2.length || e2.feature_flag_keys.every((e3) => {
      var { key: t3, value: i2 } = e3;
      return !t3 || !i2 || this.instance.featureFlags.isFeatureEnabled(i2);
    });
  }
  getNextSurveyStep(e2, t2, i2) {
    var n2, r2 = e2.questions[t2], s2 = t2 + 1;
    if (null === (n2 = r2.branching) || void 0 === n2 || !n2.type)
      return t2 === e2.questions.length - 1 ? Ir.End : s2;
    if (r2.branching.type === Ir.End)
      return Ir.End;
    if (r2.branching.type === Ir.SpecificQuestion) {
      if (Number.isInteger(r2.branching.index))
        return r2.branching.index;
    } else if (r2.branching.type === Ir.ResponseBased) {
      if (r2.type === xr.SingleChoice) {
        var o2, a2, l2 = r2.choices.indexOf("".concat(i2));
        if (null !== (o2 = r2.branching) && void 0 !== o2 && null !== (a2 = o2.responseValues) && void 0 !== a2 && a2.hasOwnProperty(l2)) {
          var u2 = r2.branching.responseValues[l2];
          return Number.isInteger(u2) ? u2 : u2 === Ir.End ? Ir.End : s2;
        }
      } else if (r2.type === xr.Rating) {
        var c2, d2;
        if ("number" != typeof i2 || !Number.isInteger(i2))
          throw new Error("The response type must be an integer");
        var h2 = function(e3, t3) {
          if (3 === t3) {
            if (e3 < 1 || e3 > 3)
              throw new Error("The response must be in range 1-3");
            return 1 === e3 ? "negative" : 2 === e3 ? "neutral" : "positive";
          }
          if (5 === t3) {
            if (e3 < 1 || e3 > 5)
              throw new Error("The response must be in range 1-5");
            return e3 <= 2 ? "negative" : 3 === e3 ? "neutral" : "positive";
          }
          if (7 === t3) {
            if (e3 < 1 || e3 > 7)
              throw new Error("The response must be in range 1-7");
            return e3 <= 3 ? "negative" : 4 === e3 ? "neutral" : "positive";
          }
          if (10 === t3) {
            if (e3 < 0 || e3 > 10)
              throw new Error("The response must be in range 0-10");
            return e3 <= 6 ? "detractors" : e3 <= 8 ? "passives" : "promoters";
          }
          throw new Error("The scale must be one of: 3, 5, 7, 10");
        }(i2, r2.scale);
        if (null !== (c2 = r2.branching) && void 0 !== c2 && null !== (d2 = c2.responseValues) && void 0 !== d2 && d2.hasOwnProperty(h2)) {
          var _2 = r2.branching.responseValues[h2];
          return Number.isInteger(_2) ? _2 : _2 === Ir.End ? Ir.End : s2;
        }
      }
      return s2;
    }
    return ps.warn("Falling back to next question index due to unexpected branching type"), s2;
  }
  _canActivateRepeatedly(e2) {
    var t2;
    return L(null === (t2 = m$2.__PosthogExtensions__) || void 0 === t2 ? void 0 : t2.canActivateRepeatedly) ? (ps.warn("init was not called"), false) : m$2.__PosthogExtensions__.canActivateRepeatedly(e2);
  }
  canRenderSurvey(e2) {
    L(this._surveyManager) ? ps.warn("init was not called") : this.getSurveys((t2) => {
      var i2 = t2.filter((t3) => t3.id === e2)[0];
      this._surveyManager.canRenderSurvey(i2);
    });
  }
  renderSurvey(e2, t2) {
    L(this._surveyManager) ? ps.warn("init was not called") : this.getSurveys((i2) => {
      var n2 = i2.filter((t3) => t3.id === e2)[0];
      this._surveyManager.renderSurvey(n2, null == h$2 ? void 0 : h$2.querySelector(t2));
    });
  }
}
var fs = H$1("[RateLimiter]");
class ms {
  constructor(e2) {
    var t2, n2;
    i$1(this, "serverLimits", {}), i$1(this, "lastEventRateLimited", false), i$1(this, "checkForLimiting", (e3) => {
      var t3 = e3.text;
      if (t3 && t3.length)
        try {
          (JSON.parse(t3).quota_limited || []).forEach((e4) => {
            fs.info("".concat(e4 || "events", " is quota limited.")), this.serverLimits[e4] = (/* @__PURE__ */ new Date()).getTime() + 6e4;
          });
        } catch (e4) {
          return void fs.warn('could not rate limit - continuing. Error: "'.concat(null == e4 ? void 0 : e4.message, '"'), { text: t3 });
        }
    }), this.instance = e2, this.captureEventsPerSecond = (null === (t2 = e2.config.rate_limiting) || void 0 === t2 ? void 0 : t2.events_per_second) || 10, this.captureEventsBurstLimit = Math.max((null === (n2 = e2.config.rate_limiting) || void 0 === n2 ? void 0 : n2.events_burst_limit) || 10 * this.captureEventsPerSecond, this.captureEventsPerSecond), this.lastEventRateLimited = this.clientRateLimitContext(true).isRateLimited;
  }
  clientRateLimitContext() {
    var e2, t2, i2, n2 = arguments.length > 0 && void 0 !== arguments[0] && arguments[0], r2 = (/* @__PURE__ */ new Date()).getTime(), s2 = null !== (e2 = null === (t2 = this.instance.persistence) || void 0 === t2 ? void 0 : t2.get_property($e)) && void 0 !== e2 ? e2 : { tokens: this.captureEventsBurstLimit, last: r2 };
    s2.tokens += (r2 - s2.last) / 1e3 * this.captureEventsPerSecond, s2.last = r2, s2.tokens > this.captureEventsBurstLimit && (s2.tokens = this.captureEventsBurstLimit);
    var o2 = s2.tokens < 1;
    return o2 || n2 || (s2.tokens = Math.max(0, s2.tokens - 1)), !o2 || this.lastEventRateLimited || n2 || this.instance.capture("$$client_ingestion_warning", { $$client_ingestion_warning_message: "posthog-js client rate limited. Config is set to ".concat(this.captureEventsPerSecond, " events per second and ").concat(this.captureEventsBurstLimit, " events burst limit.") }, { skip_client_rate_limiting: true }), this.lastEventRateLimited = o2, null === (i2 = this.instance.persistence) || void 0 === i2 || i2.set_property($e, s2), { isRateLimited: o2, remainingTokens: s2.tokens };
  }
  isServerRateLimited(e2) {
    var t2 = this.serverLimits[e2 || "events"] || false;
    return false !== t2 && (/* @__PURE__ */ new Date()).getTime() < t2;
  }
}
var bs = () => t$1({ initialPathName: (null == _ ? void 0 : _.pathname) || "", referringDomain: vi.referringDomain() }, vi.campaignParams());
class ys {
  constructor(e2, t2, n2) {
    i$1(this, "_onSessionIdCallback", (e3) => {
      var t3 = this._getStoredProps();
      if (!t3 || t3.sessionId !== e3) {
        var i2 = { sessionId: e3, props: this._sessionSourceParamGenerator() };
        this._persistence.register({ [Te]: i2 });
      }
    }), this._sessionIdManager = e2, this._persistence = t2, this._sessionSourceParamGenerator = n2 || bs, this._sessionIdManager.onSessionId(this._onSessionIdCallback);
  }
  _getStoredProps() {
    return this._persistence.props[Te];
  }
  getSessionProps() {
    var e2, t2 = null === (e2 = this._getStoredProps()) || void 0 === e2 ? void 0 : e2.props;
    return t2 ? { $client_session_initial_referring_host: t2.referringDomain, $client_session_initial_pathname: t2.initialPathName, $client_session_initial_utm_source: t2.utm_source, $client_session_initial_utm_campaign: t2.utm_campaign, $client_session_initial_utm_medium: t2.utm_medium, $client_session_initial_utm_content: t2.utm_content, $client_session_initial_utm_term: t2.utm_term } : {};
  }
}
var ws = ["ahrefsbot", "ahrefssiteaudit", "applebot", "baiduspider", "bingbot", "bingpreview", "bot.htm", "bot.php", "crawler", "deepscan", "duckduckbot", "facebookexternal", "facebookcatalog", "gptbot", "http://yandex.com/bots", "hubspot", "ia_archiver", "linkedinbot", "mj12bot", "msnbot", "nessus", "petalbot", "pinterest", "prerender", "rogerbot", "screaming frog", "semrushbot", "sitebulb", "slurp", "turnitin", "twitterbot", "vercelbot", "yahoo! slurp", "yandexbot", "headlesschrome", "cypress", "Google-HotelAdsVerifier", "adsbot-google", "apis-google", "duplexweb-google", "feedfetcher-google", "google favicon", "google web preview", "google-read-aloud", "googlebot", "googleweblight", "mediapartners-google", "storebot-google", "Bytespider;"], Ss = function(e2, t2) {
  if (!e2)
    return false;
  var i2 = e2.toLowerCase();
  return ws.concat(t2 || []).some((e3) => {
    var t3 = e3.toLowerCase();
    return -1 !== i2.indexOf(t3);
  });
}, Es = function(e2, t2) {
  if (!e2)
    return false;
  var i2 = e2.userAgent;
  if (i2 && Ss(i2, t2))
    return true;
  try {
    var n2 = null == e2 ? void 0 : e2.userAgentData;
    if (null != n2 && n2.brands && n2.brands.some((e3) => Ss(null == e3 ? void 0 : e3.brand, t2)))
      return true;
  } catch (e3) {
  }
  return !!e2.webdriver;
};
class ks {
  constructor() {
    this.clicks = [];
  }
  isRageClick(e2, t2, i2) {
    var n2 = this.clicks[this.clicks.length - 1];
    if (n2 && Math.abs(e2 - n2.x) + Math.abs(t2 - n2.y) < 30 && i2 - n2.timestamp < 1e3) {
      if (this.clicks.push({ x: e2, y: t2, timestamp: i2 }), 3 === this.clicks.length)
        return true;
    } else
      this.clicks = [{ x: e2, y: t2, timestamp: i2 }];
    return false;
  }
}
var xs = H$1("[Dead Clicks]"), Is = () => true, Cs = (e2) => {
  var t2, i2 = !(null === (t2 = e2.instance.persistence) || void 0 === t2 || !t2.get_property(ce)), n2 = e2.instance.config.capture_dead_clicks;
  return A$2(n2) ? n2 : i2;
};
class Ps {
  get lazyLoadedDeadClicksAutocapture() {
    return this._lazyLoadedDeadClicksAutocapture;
  }
  constructor(e2, t2, i2) {
    this.instance = e2, this.isEnabled = t2, this.onCapture = i2, this.startIfEnabled();
  }
  onRemoteConfig(e2) {
    this.instance.persistence && this.instance.persistence.register({ [ce]: null == e2 ? void 0 : e2.captureDeadClicks }), this.startIfEnabled();
  }
  startIfEnabled() {
    this.isEnabled(this) && this.loadScript(() => {
      this.start();
    });
  }
  loadScript(e2) {
    var t2, i2, n2;
    null !== (t2 = m$2.__PosthogExtensions__) && void 0 !== t2 && t2.initDeadClicksAutocapture && e2(), null === (i2 = m$2.__PosthogExtensions__) || void 0 === i2 || null === (n2 = i2.loadExternalDependency) || void 0 === n2 || n2.call(i2, this.instance, "dead-clicks-autocapture", (t3) => {
      t3 ? xs.error("failed to load script", t3) : e2();
    });
  }
  start() {
    var e2;
    if (h$2) {
      if (!this._lazyLoadedDeadClicksAutocapture && null !== (e2 = m$2.__PosthogExtensions__) && void 0 !== e2 && e2.initDeadClicksAutocapture) {
        var t2 = P(this.instance.config.capture_dead_clicks) ? this.instance.config.capture_dead_clicks : {};
        t2.__onCapture = this.onCapture, this._lazyLoadedDeadClicksAutocapture = m$2.__PosthogExtensions__.initDeadClicksAutocapture(this.instance, t2), this._lazyLoadedDeadClicksAutocapture.start(h$2), xs.info("starting...");
      }
    } else
      xs.error("`document` not found. Cannot start.");
  }
  stop() {
    this._lazyLoadedDeadClicksAutocapture && (this._lazyLoadedDeadClicksAutocapture.stop(), this._lazyLoadedDeadClicksAutocapture = void 0, xs.info("stopping..."));
  }
}
var Rs = H$1("[Heatmaps]");
class Fs {
  constructor(e2) {
    var t2;
    i$1(this, "rageclicks", new ks()), i$1(this, "_enabledServerSide", false), i$1(this, "_initialized", false), i$1(this, "_flushInterval", null), this.instance = e2, this._enabledServerSide = !(null === (t2 = this.instance.persistence) || void 0 === t2 || !t2.props[ae]), null == o$1 || o$1.addEventListener("beforeunload", () => {
      this.flush();
    });
  }
  get flushIntervalMilliseconds() {
    var e2 = 5e3;
    return P(this.instance.config.capture_heatmaps) && this.instance.config.capture_heatmaps.flush_interval_milliseconds && (e2 = this.instance.config.capture_heatmaps.flush_interval_milliseconds), e2;
  }
  get isEnabled() {
    return F$1(this.instance.config.capture_heatmaps) ? F$1(this.instance.config.enable_heatmaps) ? this._enabledServerSide : this.instance.config.enable_heatmaps : false !== this.instance.config.capture_heatmaps;
  }
  startIfEnabled() {
    if (this.isEnabled) {
      if (this._initialized)
        return;
      Rs.info("starting..."), this._setupListeners(), this._flushInterval = setInterval(this.flush.bind(this), this.flushIntervalMilliseconds);
    } else {
      var e2, t2;
      clearInterval(null !== (e2 = this._flushInterval) && void 0 !== e2 ? e2 : void 0), null === (t2 = this.deadClicksCapture) || void 0 === t2 || t2.stop(), this.getAndClearBuffer();
    }
  }
  onRemoteConfig(e2) {
    var t2 = !!e2.heatmaps;
    this.instance.persistence && this.instance.persistence.register({ [ae]: t2 }), this._enabledServerSide = t2, this.startIfEnabled();
  }
  getAndClearBuffer() {
    var e2 = this.buffer;
    return this.buffer = void 0, e2;
  }
  _onDeadClick(e2) {
    this._onClick(e2.originalEvent, "deadclick");
  }
  _setupListeners() {
    o$1 && h$2 && (te(h$2, "click", (e2) => this._onClick(e2 || (null == o$1 ? void 0 : o$1.event)), false, true), te(h$2, "mousemove", (e2) => this._onMouseMove(e2 || (null == o$1 ? void 0 : o$1.event)), false, true), this.deadClicksCapture = new Ps(this.instance, Is, this._onDeadClick.bind(this)), this.deadClicksCapture.startIfEnabled(), this._initialized = true);
  }
  _getProperties(e2, t2) {
    var i2 = this.instance.scrollManager.scrollY(), n2 = this.instance.scrollManager.scrollX(), r2 = this.instance.scrollManager.scrollElement(), s2 = function(e3, t3, i3) {
      for (var n3 = e3; n3 && Ei(n3) && !ki(n3, "body"); ) {
        if (n3 === i3)
          return false;
        if (V(t3, null == o$1 ? void 0 : o$1.getComputedStyle(n3).position))
          return true;
        n3 = Li(n3);
      }
      return false;
    }($i(e2), ["fixed", "sticky"], r2);
    return { x: e2.clientX + (s2 ? 0 : n2), y: e2.clientY + (s2 ? 0 : i2), target_fixed: s2, type: t2 };
  }
  _onClick(e2) {
    var i2, n2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "click";
    if (!Si(e2.target)) {
      var r2 = this._getProperties(e2, n2);
      null !== (i2 = this.rageclicks) && void 0 !== i2 && i2.isRageClick(e2.clientX, e2.clientY, (/* @__PURE__ */ new Date()).getTime()) && this._capture(t$1(t$1({}, r2), {}, { type: "rageclick" })), this._capture(r2);
    }
  }
  _onMouseMove(e2) {
    Si(e2.target) || (clearTimeout(this._mouseMoveTimeout), this._mouseMoveTimeout = setTimeout(() => {
      this._capture(this._getProperties(e2, "mousemove"));
    }, 500));
  }
  _capture(e2) {
    if (o$1) {
      var t2 = o$1.location.href;
      this.buffer = this.buffer || {}, this.buffer[t2] || (this.buffer[t2] = []), this.buffer[t2].push(e2);
    }
  }
  flush() {
    this.buffer && !R(this.buffer) && this.instance.capture("$$heatmap", { $heatmap_data: this.getAndClearBuffer() });
  }
}
class Ts {
  constructor(e2) {
    i$1(this, "_updateScrollData", () => {
      var e3, t2, i2, n2;
      this.context || (this.context = {});
      var r2 = this.scrollElement(), s2 = this.scrollY(), o2 = r2 ? Math.max(0, r2.scrollHeight - r2.clientHeight) : 0, a2 = s2 + ((null == r2 ? void 0 : r2.clientHeight) || 0), l2 = (null == r2 ? void 0 : r2.scrollHeight) || 0;
      this.context.lastScrollY = Math.ceil(s2), this.context.maxScrollY = Math.max(s2, null !== (e3 = this.context.maxScrollY) && void 0 !== e3 ? e3 : 0), this.context.maxScrollHeight = Math.max(o2, null !== (t2 = this.context.maxScrollHeight) && void 0 !== t2 ? t2 : 0), this.context.lastContentY = a2, this.context.maxContentY = Math.max(a2, null !== (i2 = this.context.maxContentY) && void 0 !== i2 ? i2 : 0), this.context.maxContentHeight = Math.max(l2, null !== (n2 = this.context.maxContentHeight) && void 0 !== n2 ? n2 : 0);
    }), this.instance = e2;
  }
  getContext() {
    return this.context;
  }
  resetContext() {
    var e2 = this.context;
    return setTimeout(this._updateScrollData, 0), e2;
  }
  startMeasuringScrollPosition() {
    null == o$1 || o$1.addEventListener("scroll", this._updateScrollData, true), null == o$1 || o$1.addEventListener("scrollend", this._updateScrollData, true), null == o$1 || o$1.addEventListener("resize", this._updateScrollData);
  }
  scrollElement() {
    if (!this.instance.config.scroll_root_selector)
      return null == o$1 ? void 0 : o$1.document.documentElement;
    var e2 = I$1(this.instance.config.scroll_root_selector) ? this.instance.config.scroll_root_selector : [this.instance.config.scroll_root_selector];
    for (var t2 of e2) {
      var i2 = null == o$1 ? void 0 : o$1.document.querySelector(t2);
      if (i2)
        return i2;
    }
  }
  scrollY() {
    if (this.instance.config.scroll_root_selector) {
      var e2 = this.scrollElement();
      return e2 && e2.scrollTop || 0;
    }
    return o$1 && (o$1.scrollY || o$1.pageYOffset || o$1.document.documentElement.scrollTop) || 0;
  }
  scrollX() {
    if (this.instance.config.scroll_root_selector) {
      var e2 = this.scrollElement();
      return e2 && e2.scrollLeft || 0;
    }
    return o$1 && (o$1.scrollX || o$1.pageXOffset || o$1.document.documentElement.scrollLeft) || 0;
  }
}
var $s = H$1("[AutoCapture]");
function Os(e2, t2) {
  return t2.length > e2 ? t2.slice(0, e2) + "..." : t2;
}
function Ls(e2) {
  if (e2.previousElementSibling)
    return e2.previousElementSibling;
  var t2 = e2;
  do {
    t2 = t2.previousSibling;
  } while (t2 && !Ei(t2));
  return t2;
}
function Ms(e2, t2, i2, n2) {
  var r2 = e2.tagName.toLowerCase(), s2 = { tag_name: r2 };
  Oi.indexOf(r2) > -1 && !i2 && ("a" === r2.toLowerCase() || "button" === r2.toLowerCase() ? s2.$el_text = Os(1024, Wi(e2)) : s2.$el_text = Os(1024, Ti(e2)));
  var o2 = Ri(e2);
  o2.length > 0 && (s2.classes = o2.filter(function(e3) {
    return "" !== e3;
  })), W(e2.attributes, function(i3) {
    var r3;
    if ((!Di(e2) || -1 !== ["name", "id", "class", "aria-label"].indexOf(i3.name)) && ((null == n2 || !n2.includes(i3.name)) && !t2 && ji(i3.value) && (r3 = i3.name, !T(r3) || "_ngcontent" !== r3.substring(0, 10) && "_nghost" !== r3.substring(0, 7)))) {
      var o3 = i3.value;
      "class" === i3.name && (o3 = Ci(o3).join(" ")), s2["attr__" + i3.name] = Os(1024, o3);
    }
  });
  for (var a2 = 1, l2 = 1, u2 = e2; u2 = Ls(u2); )
    a2++, u2.tagName === e2.tagName && l2++;
  return s2.nth_child = a2, s2.nth_of_type = l2, s2;
}
function As(e2, t2) {
  for (var i2, n2, { e: r2, maskAllElementAttributes: s2, maskAllText: a2, elementAttributeIgnoreList: l2, elementsChainAsString: u2 } = t2, c2 = [e2], d2 = e2; d2.parentNode && !ki(d2, "body"); )
    Ii(d2.parentNode) ? (c2.push(d2.parentNode.host), d2 = d2.parentNode.host) : (c2.push(d2.parentNode), d2 = d2.parentNode);
  var h2, _2 = [], p2 = {}, v2 = false, g2 = false;
  if (W(c2, (e3) => {
    var t3 = Ai(e3);
    "a" === e3.tagName.toLowerCase() && (v2 = e3.getAttribute("href"), v2 = t3 && v2 && ji(v2) && v2), V(Ri(e3), "ph-no-capture") && (g2 = true), _2.push(Ms(e3, s2, a2, l2));
    var i3 = function(e4) {
      if (!Ai(e4))
        return {};
      var t4 = {};
      return W(e4.attributes, function(e5) {
        if (e5.name && 0 === e5.name.indexOf("data-ph-capture-attribute")) {
          var i4 = e5.name.replace("data-ph-capture-attribute-", ""), n3 = e5.value;
          i4 && n3 && ji(n3) && (t4[i4] = n3);
        }
      }), t4;
    }(e3);
    G$1(p2, i3);
  }), g2)
    return { props: {}, explicitNoCapture: g2 };
  if (a2 || ("a" === e2.tagName.toLowerCase() || "button" === e2.tagName.toLowerCase() ? _2[0].$el_text = Wi(e2) : _2[0].$el_text = Ti(e2)), v2) {
    var f2, m2;
    _2[0].attr__href = v2;
    var b2 = null === (f2 = _t(v2)) || void 0 === f2 ? void 0 : f2.host, y2 = null == o$1 || null === (m2 = o$1.location) || void 0 === m2 ? void 0 : m2.host;
    b2 && y2 && b2 !== y2 && (h2 = v2);
  }
  return { props: G$1({ $event_type: r2.type, $ce_version: 1 }, u2 ? {} : { $elements: _2 }, { $elements_chain: Vi(_2) }, null !== (i2 = _2[0]) && void 0 !== i2 && i2.$el_text ? { $el_text: null === (n2 = _2[0]) || void 0 === n2 ? void 0 : n2.$el_text } : {}, h2 && "click" === r2.type ? { $external_click_url: h2 } : {}, p2) };
}
class Ds {
  constructor(e2) {
    i$1(this, "_initialized", false), i$1(this, "_isDisabledServerSide", null), i$1(this, "rageclicks", new ks()), i$1(this, "_elementsChainAsString", false), this.instance = e2, this._elementSelectors = null;
  }
  get config() {
    var e2, t2, i2 = P(this.instance.config.autocapture) ? this.instance.config.autocapture : {};
    return i2.url_allowlist = null === (e2 = i2.url_allowlist) || void 0 === e2 ? void 0 : e2.map((e3) => new RegExp(e3)), i2.url_ignorelist = null === (t2 = i2.url_ignorelist) || void 0 === t2 ? void 0 : t2.map((e3) => new RegExp(e3)), i2;
  }
  _addDomEventHandlers() {
    if (this.isBrowserSupported()) {
      if (o$1 && h$2) {
        var e2 = (e3) => {
          e3 = e3 || (null == o$1 ? void 0 : o$1.event);
          try {
            this._captureEvent(e3);
          } catch (e4) {
            $s.error("Failed to capture event", e4);
          }
        }, t2 = (e3) => {
          e3 = e3 || (null == o$1 ? void 0 : o$1.event), this._captureEvent(e3, b$2);
        };
        te(h$2, "submit", e2, false, true), te(h$2, "change", e2, false, true), te(h$2, "click", e2, false, true), this.config.capture_copied_text && (te(h$2, "copy", t2, false, true), te(h$2, "cut", t2, false, true));
      }
    } else
      $s.info("Disabling Automatic Event Collection because this browser is not supported");
  }
  startIfEnabled() {
    this.isEnabled && !this._initialized && (this._addDomEventHandlers(), this._initialized = true);
  }
  onRemoteConfig(e2) {
    e2.elementsChainAsString && (this._elementsChainAsString = e2.elementsChainAsString), this.instance.persistence && this.instance.persistence.register({ [oe]: !!e2.autocapture_opt_out }), this._isDisabledServerSide = !!e2.autocapture_opt_out, this.startIfEnabled();
  }
  setElementSelectors(e2) {
    this._elementSelectors = e2;
  }
  getElementSelectors(e2) {
    var t2, i2 = [];
    return null === (t2 = this._elementSelectors) || void 0 === t2 || t2.forEach((t3) => {
      var n2 = null == h$2 ? void 0 : h$2.querySelectorAll(t3);
      null == n2 || n2.forEach((n3) => {
        e2 === n3 && i2.push(t3);
      });
    }), i2;
  }
  get isEnabled() {
    var e2, t2, i2 = null === (e2 = this.instance.persistence) || void 0 === e2 ? void 0 : e2.props[oe], n2 = this._isDisabledServerSide;
    if (O(n2) && !A$2(i2) && !this.instance.config.advanced_disable_decide)
      return false;
    var r2 = null !== (t2 = this._isDisabledServerSide) && void 0 !== t2 ? t2 : !!i2;
    return !!this.instance.config.autocapture && !r2;
  }
  _captureEvent(e2) {
    var t2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "$autocapture";
    if (this.isEnabled) {
      var i2, n2 = $i(e2);
      if (xi(n2) && (n2 = n2.parentNode || null), "$autocapture" === t2 && "click" === e2.type && e2 instanceof MouseEvent)
        this.instance.config.rageclick && null !== (i2 = this.rageclicks) && void 0 !== i2 && i2.isRageClick(e2.clientX, e2.clientY, (/* @__PURE__ */ new Date()).getTime()) && this._captureEvent(e2, "$rageclick");
      var r2 = t2 === b$2;
      if (n2 && Mi(n2, e2, this.config, r2, r2 ? ["copy", "cut"] : void 0)) {
        var { props: s2, explicitNoCapture: a2 } = As(n2, { e: e2, maskAllElementAttributes: this.instance.config.mask_all_element_attributes, maskAllText: this.instance.config.mask_all_text, elementAttributeIgnoreList: this.config.element_attribute_ignorelist, elementsChainAsString: this._elementsChainAsString });
        if (a2)
          return false;
        var l2 = this.getElementSelectors(n2);
        if (l2 && l2.length > 0 && (s2.$element_selectors = l2), t2 === b$2) {
          var u2, c2 = Fi(null == o$1 || null === (u2 = o$1.getSelection()) || void 0 === u2 ? void 0 : u2.toString()), d2 = e2.type || "clipboard";
          if (!c2)
            return false;
          s2.$selected_content = c2, s2.$copy_type = d2;
        }
        return this.instance.capture(t2, s2), true;
      }
    }
  }
  isBrowserSupported() {
    return C$1(null == h$2 ? void 0 : h$2.querySelectorAll);
  }
}
var Ns = H$1("[TracingHeaders]");
class qs {
  constructor(e2) {
    i$1(this, "_restoreXHRPatch", void 0), i$1(this, "_restoreFetchPatch", void 0), i$1(this, "_startCapturing", () => {
      var e3, t2, i2, n2;
      F$1(this._restoreXHRPatch) && (null === (e3 = m$2.__PosthogExtensions__) || void 0 === e3 || null === (t2 = e3.tracingHeadersPatchFns) || void 0 === t2 || t2._patchXHR(this.instance.sessionManager));
      F$1(this._restoreFetchPatch) && (null === (i2 = m$2.__PosthogExtensions__) || void 0 === i2 || null === (n2 = i2.tracingHeadersPatchFns) || void 0 === n2 || n2._patchFetch(this.instance.sessionManager));
    }), this.instance = e2;
  }
  _loadScript(e2) {
    var t2, i2, n2;
    null !== (t2 = m$2.__PosthogExtensions__) && void 0 !== t2 && t2.tracingHeadersPatchFns && e2(), null === (i2 = m$2.__PosthogExtensions__) || void 0 === i2 || null === (n2 = i2.loadExternalDependency) || void 0 === n2 || n2.call(i2, this.instance, "tracing-headers", (t3) => {
      if (t3)
        return Ns.error("failed to load script", t3);
      e2();
    });
  }
  startIfEnabledOrStop() {
    var e2, t2;
    this.instance.config.__add_tracing_headers ? this._loadScript(this._startCapturing) : (null === (e2 = this._restoreXHRPatch) || void 0 === e2 || e2.call(this), null === (t2 = this._restoreFetchPatch) || void 0 === t2 || t2.call(this), this._restoreXHRPatch = void 0, this._restoreFetchPatch = void 0);
  }
}
var Bs;
!function(e2) {
  e2[e2.PENDING = -1] = "PENDING", e2[e2.DENIED = 0] = "DENIED", e2[e2.GRANTED = 1] = "GRANTED";
}(Bs || (Bs = {}));
class Hs {
  constructor(e2) {
    this.instance = e2;
  }
  get config() {
    return this.instance.config;
  }
  get consent() {
    return this.getDnt() ? Bs.DENIED : this.storedConsent;
  }
  isOptedOut() {
    return this.consent === Bs.DENIED || this.consent === Bs.PENDING && this.config.opt_out_capturing_by_default;
  }
  isOptedIn() {
    return !this.isOptedOut();
  }
  optInOut(e2) {
    this.storage.set(this.storageKey, e2 ? 1 : 0, this.config.cookie_expiration, this.config.cross_subdomain_cookie, this.config.secure_cookie);
  }
  reset() {
    this.storage.remove(this.storageKey, this.config.cross_subdomain_cookie);
  }
  get storageKey() {
    var { token: e2, opt_out_capturing_cookie_prefix: t2 } = this.instance.config;
    return (t2 || "__ph_opt_in_out_") + e2;
  }
  get storedConsent() {
    var e2 = this.storage.get(this.storageKey);
    return "1" === e2 ? Bs.GRANTED : "0" === e2 ? Bs.DENIED : Bs.PENDING;
  }
  get storage() {
    if (!this._storage) {
      var e2 = this.config.opt_out_capturing_persistence_type;
      this._storage = "localStorage" === e2 ? st : nt;
      var t2 = "localStorage" === e2 ? nt : st;
      t2.get(this.storageKey) && (this._storage.get(this.storageKey) || this.optInOut("1" === t2.get(this.storageKey)), t2.remove(this.storageKey, this.config.cross_subdomain_cookie));
    }
    return this._storage;
  }
  getDnt() {
    return !!this.config.respect_dnt && !!ie([null == d$2 ? void 0 : d$2.doNotTrack, null == d$2 ? void 0 : d$2.msDoNotTrack, m$2.doNotTrack], (e2) => V([true, 1, "1", "yes"], e2));
  }
}
var Us = H$1("[ExceptionAutocapture]");
class zs {
  constructor(e2) {
    var t2;
    i$1(this, "originalOnUnhandledRejectionHandler", void 0), i$1(this, "startCapturing", () => {
      var e3, t3, i2, n2;
      if (o$1 && this.isEnabled && !this.hasHandlers && !this.isCapturing) {
        var r2 = null === (e3 = m$2.__PosthogExtensions__) || void 0 === e3 || null === (t3 = e3.errorWrappingFunctions) || void 0 === t3 ? void 0 : t3.wrapOnError, s2 = null === (i2 = m$2.__PosthogExtensions__) || void 0 === i2 || null === (n2 = i2.errorWrappingFunctions) || void 0 === n2 ? void 0 : n2.wrapUnhandledRejection;
        if (r2 && s2)
          try {
            this.unwrapOnError = r2(this.captureException.bind(this)), this.unwrapUnhandledRejection = s2(this.captureException.bind(this));
          } catch (e4) {
            Us.error("failed to start", e4), this.stopCapturing();
          }
        else
          Us.error("failed to load error wrapping functions - cannot start");
      }
    }), this.instance = e2, this.remoteEnabled = !(null === (t2 = this.instance.persistence) || void 0 === t2 || !t2.props[le]), this.startIfEnabled();
  }
  get isEnabled() {
    var e2;
    return null !== (e2 = this.remoteEnabled) && void 0 !== e2 && e2;
  }
  get isCapturing() {
    var e2;
    return !(null == o$1 || null === (e2 = o$1.onerror) || void 0 === e2 || !e2.__POSTHOG_INSTRUMENTED__);
  }
  get hasHandlers() {
    return this.originalOnUnhandledRejectionHandler || this.unwrapOnError;
  }
  startIfEnabled() {
    this.isEnabled && !this.isCapturing && (Us.info("enabled, starting..."), this.loadScript(this.startCapturing));
  }
  loadScript(e2) {
    var t2, i2;
    this.hasHandlers && e2(), null === (t2 = m$2.__PosthogExtensions__) || void 0 === t2 || null === (i2 = t2.loadExternalDependency) || void 0 === i2 || i2.call(t2, this.instance, "exception-autocapture", (t3) => {
      if (t3)
        return Us.error("failed to load script", t3);
      e2();
    });
  }
  stopCapturing() {
    var e2, t2;
    null === (e2 = this.unwrapOnError) || void 0 === e2 || e2.call(this), null === (t2 = this.unwrapUnhandledRejection) || void 0 === t2 || t2.call(this);
  }
  onRemoteConfig(e2) {
    var t2 = e2.autocaptureExceptions;
    this.remoteEnabled = !!t2 || false, this.instance.persistence && this.instance.persistence.register({ [le]: this.remoteEnabled }), this.startIfEnabled();
  }
  captureException(e2) {
    var t2 = this.instance.requestRouter.endpointFor("ui");
    e2.$exception_personURL = "".concat(t2, "/project/").concat(this.instance.config.token, "/person/").concat(this.instance.get_distinct_id()), this.instance.exceptions.sendExceptionEvent(e2);
  }
}
var js = H$1("[Web Vitals]"), Ws = 9e5;
class Gs {
  constructor(e2) {
    var n2;
    i$1(this, "_enabledServerSide", false), i$1(this, "_initialized", false), i$1(this, "buffer", { url: void 0, metrics: [], firstMetricTimestamp: void 0 }), i$1(this, "_flushToCapture", () => {
      clearTimeout(this._delayedFlushTimer), 0 !== this.buffer.metrics.length && (this.instance.capture("$web_vitals", this.buffer.metrics.reduce((e3, i2) => t$1(t$1({}, e3), {}, { ["$web_vitals_".concat(i2.name, "_event")]: t$1({}, i2), ["$web_vitals_".concat(i2.name, "_value")]: i2.value }), {})), this.buffer = { url: void 0, metrics: [], firstMetricTimestamp: void 0 });
    }), i$1(this, "_addToBuffer", (e3) => {
      var i2, n3 = null === (i2 = this.instance.sessionManager) || void 0 === i2 ? void 0 : i2.checkAndGetSessionAndWindowId(true);
      if (F$1(n3))
        js.error("Could not read session ID. Dropping metrics!");
      else {
        this.buffer = this.buffer || { url: void 0, metrics: [], firstMetricTimestamp: void 0 };
        var r2 = this._currentURL();
        if (!F$1(r2))
          if (L(null == e3 ? void 0 : e3.name) || L(null == e3 ? void 0 : e3.value))
            js.error("Invalid metric received", e3);
          else if (this._maxAllowedValue && e3.value >= this._maxAllowedValue)
            js.error("Ignoring metric with value >= " + this._maxAllowedValue, e3);
          else
            this.buffer.url !== r2 && (this._flushToCapture(), this._delayedFlushTimer = setTimeout(this._flushToCapture, this.flushToCaptureTimeoutMs)), F$1(this.buffer.url) && (this.buffer.url = r2), this.buffer.firstMetricTimestamp = F$1(this.buffer.firstMetricTimestamp) ? Date.now() : this.buffer.firstMetricTimestamp, e3.attribution && e3.attribution.interactionTargetElement && (e3.attribution.interactionTargetElement = void 0), this.buffer.metrics.push(t$1(t$1({}, e3), {}, { $current_url: r2, $session_id: n3.sessionId, $window_id: n3.windowId, timestamp: Date.now() })), this.buffer.metrics.length === this.allowedMetrics.length && this._flushToCapture();
      }
    }), i$1(this, "_startCapturing", () => {
      var e3, t2, i2, n3, r2 = m$2.__PosthogExtensions__;
      F$1(r2) || F$1(r2.postHogWebVitalsCallbacks) || ({ onLCP: e3, onCLS: t2, onFCP: i2, onINP: n3 } = r2.postHogWebVitalsCallbacks), e3 && t2 && i2 && n3 ? (this.allowedMetrics.indexOf("LCP") > -1 && e3(this._addToBuffer.bind(this)), this.allowedMetrics.indexOf("CLS") > -1 && t2(this._addToBuffer.bind(this)), this.allowedMetrics.indexOf("FCP") > -1 && i2(this._addToBuffer.bind(this)), this.allowedMetrics.indexOf("INP") > -1 && n3(this._addToBuffer.bind(this)), this._initialized = true) : js.error("web vitals callbacks not loaded - not starting");
    }), this.instance = e2, this._enabledServerSide = !(null === (n2 = this.instance.persistence) || void 0 === n2 || !n2.props[ue]), this.startIfEnabled();
  }
  get allowedMetrics() {
    var e2, t2, i2 = P(this.instance.config.capture_performance) ? null === (e2 = this.instance.config.capture_performance) || void 0 === e2 ? void 0 : e2.web_vitals_allowed_metrics : void 0;
    return F$1(i2) ? (null === (t2 = this.instance.persistence) || void 0 === t2 ? void 0 : t2.props[de]) || ["CLS", "FCP", "INP", "LCP"] : i2;
  }
  get flushToCaptureTimeoutMs() {
    return (P(this.instance.config.capture_performance) ? this.instance.config.capture_performance.web_vitals_delayed_flush_ms : void 0) || 5e3;
  }
  get _maxAllowedValue() {
    var e2 = P(this.instance.config.capture_performance) && M(this.instance.config.capture_performance.__web_vitals_max_value) ? this.instance.config.capture_performance.__web_vitals_max_value : Ws;
    return 0 < e2 && e2 <= 6e4 ? Ws : e2;
  }
  get isEnabled() {
    var e2 = P(this.instance.config.capture_performance) ? this.instance.config.capture_performance.web_vitals : void 0;
    return A$2(e2) ? e2 : this._enabledServerSide;
  }
  startIfEnabled() {
    this.isEnabled && !this._initialized && (js.info("enabled, starting..."), this.loadScript(this._startCapturing));
  }
  onRemoteConfig(e2) {
    var t2 = P(e2.capturePerformance) && !!e2.capturePerformance.web_vitals, i2 = P(e2.capturePerformance) ? e2.capturePerformance.web_vitals_allowed_metrics : void 0;
    this.instance.persistence && (this.instance.persistence.register({ [ue]: t2 }), this.instance.persistence.register({ [de]: i2 })), this._enabledServerSide = t2, this.startIfEnabled();
  }
  loadScript(e2) {
    var t2, i2, n2;
    null !== (t2 = m$2.__PosthogExtensions__) && void 0 !== t2 && t2.postHogWebVitalsCallbacks && e2(), null === (i2 = m$2.__PosthogExtensions__) || void 0 === i2 || null === (n2 = i2.loadExternalDependency) || void 0 === n2 || n2.call(i2, this.instance, "web-vitals", (t3) => {
      t3 ? js.error("failed to load script", t3) : e2();
    });
  }
  _currentURL() {
    var e2 = o$1 ? o$1.location.href : void 0;
    return e2 || js.error("Could not determine current URL"), e2;
  }
}
var Vs = { icontains: (e2, t2) => !!o$1 && t2.href.toLowerCase().indexOf(e2.toLowerCase()) > -1, not_icontains: (e2, t2) => !!o$1 && -1 === t2.href.toLowerCase().indexOf(e2.toLowerCase()), regex: (e2, t2) => !!o$1 && pt(t2.href, e2), not_regex: (e2, t2) => !!o$1 && !pt(t2.href, e2), exact: (e2, t2) => t2.href === e2, is_not: (e2, t2) => t2.href !== e2 };
class Js {
  constructor(e2) {
    var t2 = this;
    i$1(this, "getWebExperimentsAndEvaluateDisplayLogic", function() {
      var e3 = arguments.length > 0 && void 0 !== arguments[0] && arguments[0];
      t2.getWebExperiments((e4) => {
        Js.logInfo("retrieved web experiments from the server"), t2._flagToExperiments = /* @__PURE__ */ new Map(), e4.forEach((e5) => {
          if (e5.feature_flag_key) {
            var i2;
            if (t2._flagToExperiments)
              Js.logInfo("setting flag key ", e5.feature_flag_key, " to web experiment ", e5), null === (i2 = t2._flagToExperiments) || void 0 === i2 || i2.set(e5.feature_flag_key, e5);
            var n2 = t2.instance.getFeatureFlag(e5.feature_flag_key);
            T(n2) && e5.variants[n2] && t2.applyTransforms(e5.name, n2, e5.variants[n2].transforms);
          } else if (e5.variants)
            for (var r2 in e5.variants) {
              var s2 = e5.variants[r2];
              Js.matchesTestVariant(s2) && t2.applyTransforms(e5.name, r2, s2.transforms);
            }
        });
      }, e3);
    }), this.instance = e2, this.instance.onFeatureFlags((e3) => {
      this.onFeatureFlags(e3);
    });
  }
  onFeatureFlags(e2) {
    if (this._is_bot())
      Js.logInfo("Refusing to render web experiment since the viewer is a likely bot");
    else if (!this.instance.config.disable_web_experiments) {
      if (L(this._flagToExperiments))
        return this._flagToExperiments = /* @__PURE__ */ new Map(), this.loadIfEnabled(), void this.previewWebExperiment();
      Js.logInfo("applying feature flags", e2), e2.forEach((e3) => {
        var t2;
        if (this._flagToExperiments && null !== (t2 = this._flagToExperiments) && void 0 !== t2 && t2.has(e3)) {
          var i2, n2 = this.instance.getFeatureFlag(e3), r2 = null === (i2 = this._flagToExperiments) || void 0 === i2 ? void 0 : i2.get(e3);
          n2 && null != r2 && r2.variants[n2] && this.applyTransforms(r2.name, n2, r2.variants[n2].transforms);
        }
      });
    }
  }
  previewWebExperiment() {
    var e2 = Js.getWindowLocation();
    if (null != e2 && e2.search) {
      var t2 = gt(null == e2 ? void 0 : e2.search, "__experiment_id"), i2 = gt(null == e2 ? void 0 : e2.search, "__experiment_variant");
      t2 && i2 && (Js.logInfo("previewing web experiments ".concat(t2, " && ").concat(i2)), this.getWebExperiments((e3) => {
        this.showPreviewWebExperiment(parseInt(t2), i2, e3);
      }, false, true));
    }
  }
  loadIfEnabled() {
    this.instance.config.disable_web_experiments || this.getWebExperimentsAndEvaluateDisplayLogic();
  }
  getWebExperiments(e2, t2, i2) {
    if (this.instance.config.disable_web_experiments && !i2)
      return e2([]);
    var n2 = this.instance.get_property("$web_experiments");
    if (n2 && !t2)
      return e2(n2);
    this.instance._send_request({ url: this.instance.requestRouter.endpointFor("api", "/api/web_experiments/?token=".concat(this.instance.config.token)), method: "GET", transport: "XHR", callback: (t3) => {
      if (200 !== t3.statusCode || !t3.json)
        return e2([]);
      var i3 = t3.json.experiments || [];
      return e2(i3);
    } });
  }
  showPreviewWebExperiment(e2, t2, i2) {
    var n2 = i2.filter((t3) => t3.id === e2);
    n2 && n2.length > 0 && (Js.logInfo("Previewing web experiment [".concat(n2[0].name, "] with variant [").concat(t2, "]")), this.applyTransforms(n2[0].name, t2, n2[0].variants[t2].transforms, true));
  }
  static matchesTestVariant(e2) {
    return !L(e2.conditions) && (Js.matchUrlConditions(e2) && Js.matchUTMConditions(e2));
  }
  static matchUrlConditions(e2) {
    var t2;
    if (L(e2.conditions) || L(null === (t2 = e2.conditions) || void 0 === t2 ? void 0 : t2.url))
      return true;
    var i2, n2, r2, s2 = Js.getWindowLocation();
    return !!s2 && (null === (i2 = e2.conditions) || void 0 === i2 || !i2.url || Vs[null !== (n2 = null === (r2 = e2.conditions) || void 0 === r2 ? void 0 : r2.urlMatchType) && void 0 !== n2 ? n2 : "icontains"](e2.conditions.url, s2));
  }
  static getWindowLocation() {
    return null == o$1 ? void 0 : o$1.location;
  }
  static matchUTMConditions(e2) {
    var t2;
    if (L(e2.conditions) || L(null === (t2 = e2.conditions) || void 0 === t2 ? void 0 : t2.utm))
      return true;
    var i2 = vi.campaignParams();
    if (i2.utm_source) {
      var n2, r2, s2, o2, a2, l2, u2, c2, d2, h2, _2, p2, v2, g2, f2, m2, b2 = null === (n2 = e2.conditions) || void 0 === n2 || null === (r2 = n2.utm) || void 0 === r2 || !r2.utm_campaign || (null === (s2 = e2.conditions) || void 0 === s2 || null === (o2 = s2.utm) || void 0 === o2 ? void 0 : o2.utm_campaign) == i2.utm_campaign, y2 = null === (a2 = e2.conditions) || void 0 === a2 || null === (l2 = a2.utm) || void 0 === l2 || !l2.utm_source || (null === (u2 = e2.conditions) || void 0 === u2 || null === (c2 = u2.utm) || void 0 === c2 ? void 0 : c2.utm_source) == i2.utm_source, w2 = null === (d2 = e2.conditions) || void 0 === d2 || null === (h2 = d2.utm) || void 0 === h2 || !h2.utm_medium || (null === (_2 = e2.conditions) || void 0 === _2 || null === (p2 = _2.utm) || void 0 === p2 ? void 0 : p2.utm_medium) == i2.utm_medium, S2 = null === (v2 = e2.conditions) || void 0 === v2 || null === (g2 = v2.utm) || void 0 === g2 || !g2.utm_term || (null === (f2 = e2.conditions) || void 0 === f2 || null === (m2 = f2.utm) || void 0 === m2 ? void 0 : m2.utm_term) == i2.utm_term;
      return b2 && w2 && S2 && y2;
    }
    return false;
  }
  static logInfo(e2) {
    for (var t2 = arguments.length, i2 = new Array(t2 > 1 ? t2 - 1 : 0), n2 = 1; n2 < t2; n2++)
      i2[n2 - 1] = arguments[n2];
    B$1.info("[WebExperiments] ".concat(e2), i2);
  }
  applyTransforms(e2, t2, i2, n2) {
    var r2;
    this._is_bot() ? Js.logInfo("Refusing to render web experiment since the viewer is a likely bot") : "control" !== t2 ? i2.forEach((i3) => {
      if (i3.selector) {
        var r3;
        Js.logInfo("applying transform of variant ".concat(t2, " for experiment ").concat(e2, " "), i3);
        var s2, o2 = 0, a2 = null === (r3 = document) || void 0 === r3 ? void 0 : r3.querySelectorAll(i3.selector);
        if (null == a2 || a2.forEach((e3) => {
          var t3 = e3;
          o2 += 1, i3.attributes && i3.attributes.forEach((e4) => {
            switch (e4.name) {
              case "text":
                t3.innerText = e4.value;
                break;
              case "html":
                t3.innerHTML = e4.value;
                break;
              case "cssClass":
                t3.className = e4.value;
                break;
              default:
                t3.setAttribute(e4.name, e4.value);
            }
          }), i3.text && (t3.innerText = i3.text), i3.html && (t3.parentElement ? t3.parentElement.innerHTML = i3.html : t3.innerHTML = i3.html), i3.css && t3.setAttribute("style", i3.css);
        }), this.instance && this.instance.capture)
          this.instance.capture("$web_experiment_applied", { $web_experiment_name: e2, $web_experiment_variant: t2, $web_experiment_preview: n2, $web_experiment_document_url: null === (s2 = Js.getWindowLocation()) || void 0 === s2 ? void 0 : s2.href, $web_experiment_elements_modified: o2 });
      }
    }) : (Js.logInfo("Control variants leave the page unmodified."), this.instance && this.instance.capture && this.instance.capture("$web_experiment_applied", { $web_experiment_name: e2, $web_experiment_preview: n2, $web_experiment_variant: t2, $web_experiment_document_url: null === (r2 = Js.getWindowLocation()) || void 0 === r2 ? void 0 : r2.href, $web_experiment_elements_modified: 0 }));
  }
  _is_bot() {
    return d$2 && this.instance ? Es(d$2, this.instance.config.custom_blocked_useragents) : void 0;
  }
}
class Ys {
  constructor(e2) {
    this.instance = e2;
  }
  sendExceptionEvent(e2) {
    this.instance.capture("$exception", e2, { _noTruncate: true, _batchKey: "exceptionEvent" });
  }
}
var Xs = ["$set_once", "$set"], Ks = H$1("[SiteApps]");
class Qs {
  constructor(e2) {
    this.instance = e2, this.bufferedInvocations = [], this.apps = {};
  }
  get isEnabled() {
    return !!this.instance.config.opt_in_site_apps;
  }
  eventCollector(e2, t2) {
    if (t2) {
      var i2 = this.globalsForEvent(t2);
      this.bufferedInvocations.push(i2), this.bufferedInvocations.length > 1e3 && (this.bufferedInvocations = this.bufferedInvocations.slice(10));
    }
  }
  init() {
    if (this.isEnabled) {
      var e2 = this.instance._addCaptureHook(this.eventCollector.bind(this));
      this.stopBuffering = () => {
        e2(), this.bufferedInvocations = [], this.stopBuffering = void 0;
      };
    }
  }
  globalsForEvent(e2) {
    var i2, r2, s2, o2, a2, l2, u2;
    if (!e2)
      throw new Error("Event payload is required");
    var c2 = {}, d2 = this.instance.get_property("$groups") || [], h2 = this.instance.get_property("$stored_group_properties") || {};
    for (var [_2, p2] of Object.entries(h2))
      c2[_2] = { id: d2[_2], type: _2, properties: p2 };
    var { $set_once: v2, $set: g2 } = e2;
    return { event: t$1(t$1({}, n$3(e2, Xs)), {}, { properties: t$1(t$1(t$1({}, e2.properties), g2 ? { $set: t$1(t$1({}, null !== (i2 = null === (r2 = e2.properties) || void 0 === r2 ? void 0 : r2.$set) && void 0 !== i2 ? i2 : {}), g2) } : {}), v2 ? { $set_once: t$1(t$1({}, null !== (s2 = null === (o2 = e2.properties) || void 0 === o2 ? void 0 : o2.$set_once) && void 0 !== s2 ? s2 : {}), v2) } : {}), elements_chain: null !== (a2 = null === (l2 = e2.properties) || void 0 === l2 ? void 0 : l2.$elements_chain) && void 0 !== a2 ? a2 : "", distinct_id: null === (u2 = e2.properties) || void 0 === u2 ? void 0 : u2.distinct_id }), person: { properties: this.instance.get_property("$stored_person_properties") }, groups: c2 };
  }
  setupSiteApp(e2) {
    var t2 = { id: e2.id, loaded: false, errored: false };
    this.apps[e2.id] = t2;
    var i2 = (i3) => {
      var n3;
      for (var r2 of (this.apps[e2.id].errored = !i3, this.apps[e2.id].loaded = true, Ks.info("Site app with id ".concat(e2.id, " ").concat(i3 ? "loaded" : "errored")), i3 && this.bufferedInvocations.length && (Ks.info("Processing ".concat(this.bufferedInvocations.length, " events for site app with id ").concat(e2.id)), this.bufferedInvocations.forEach((e3) => {
        var i4;
        return null === (i4 = t2.processEvent) || void 0 === i4 ? void 0 : i4.call(t2, e3);
      })), Object.values(this.apps)))
        if (!r2.loaded)
          return;
      null === (n3 = this.stopBuffering) || void 0 === n3 || n3.call(this);
    };
    try {
      var { processEvent: n2 } = e2.init({ posthog: this.instance, callback: (e3) => {
        i2(e3);
      } });
      n2 && (t2.processEvent = n2);
    } catch (t3) {
      Ks.error("Error while initializing PostHog app with config id ".concat(e2.id), t3), i2(false);
    }
  }
  onCapturedEvent(e2) {
    if (0 !== Object.keys(this.apps).length) {
      var t2 = this.globalsForEvent(e2);
      for (var i2 of Object.values(this.apps))
        try {
          var n2;
          null === (n2 = i2.processEvent) || void 0 === n2 || n2.call(i2, t2);
        } catch (t3) {
          Ks.error("Error while processing event ".concat(e2.event, " for site app ").concat(i2.id), t3);
        }
    }
  }
  onRemoteConfig(e2) {
    var t2, i2, n2 = this;
    if (I$1(m$2._POSTHOG_JS_APPS)) {
      if (!this.isEnabled)
        return void Ks.error('PostHog site apps are disabled. Enable the "opt_in_site_apps" config to proceed.');
      for (var r2 of m$2._POSTHOG_JS_APPS)
        this.setupSiteApp(r2);
      var s2;
      m$2._POSTHOG_JS_APPS.length ? this.instance.on("eventCaptured", (e3) => this.onCapturedEvent(e3)) : null === (s2 = this.stopBuffering) || void 0 === s2 || s2.call(this);
    } else if (null === (t2 = this.stopBuffering) || void 0 === t2 || t2.call(this), null !== (i2 = e2.siteApps) && void 0 !== i2 && i2.length)
      if (this.isEnabled) {
        var o2 = function(e3, t3) {
          var i3, r3;
          m$2["__$$ph_site_app_".concat(e3)] = n2.instance, null === (i3 = m$2.__PosthogExtensions__) || void 0 === i3 || null === (r3 = i3.loadSiteApp) || void 0 === r3 || r3.call(i3, n2.instance, t3, (t4) => {
            if (t4)
              return Ks.error("Error while initializing PostHog app with config id ".concat(e3), t4);
          });
        };
        for (var { id: a2, url: l2 } of e2.siteApps)
          o2(a2, l2);
      } else
        Ks.error('PostHog site apps are disabled. Enable the "opt_in_site_apps" config to proceed.');
  }
}
var Zs = {}, eo = () => {
}, to = "posthog", io = !lr && -1 === (null == f$2 ? void 0 : f$2.indexOf("MSIE")) && -1 === (null == f$2 ? void 0 : f$2.indexOf("Mozilla")), no = () => {
  var e2, t2, i2;
  return { api_host: "https://us.i.posthog.com", ui_host: null, token: "", autocapture: true, rageclick: true, cross_subdomain_cookie: (t2 = null == h$2 ? void 0 : h$2.location, i2 = null == t2 ? void 0 : t2.hostname, !!T(i2) && "herokuapp.com" !== i2.split(".").slice(-2).join(".")), persistence: "localStorage+cookie", persistence_name: "", loaded: eo, store_google: true, custom_campaign_params: [], custom_blocked_useragents: [], save_referrer: true, capture_pageview: true, capture_pageleave: "if_capture_pageview", debug: _ && T(null == _ ? void 0 : _.search) && -1 !== _.search.indexOf("__posthog_debug=true") || false, verbose: false, cookie_expiration: 365, upgrade: false, disable_session_recording: false, disable_persistence: false, disable_web_experiments: true, disable_surveys: false, enable_recording_console_log: void 0, secure_cookie: "https:" === (null == o$1 || null === (e2 = o$1.location) || void 0 === e2 ? void 0 : e2.protocol), ip: true, opt_out_capturing_by_default: false, opt_out_persistence_by_default: false, opt_out_useragent_filter: false, opt_out_capturing_persistence_type: "localStorage", opt_out_capturing_cookie_prefix: null, opt_in_site_apps: false, property_denylist: [], respect_dnt: false, sanitize_properties: null, request_headers: {}, inapp_protocol: "//", inapp_link_new_window: false, request_batching: true, properties_string_max_length: 65535, session_recording: {}, mask_all_element_attributes: false, mask_all_text: false, advanced_disable_decide: false, advanced_disable_feature_flags: false, advanced_disable_feature_flags_on_first_load: false, advanced_disable_toolbar_metrics: false, feature_flag_request_timeout_ms: 3e3, on_request_error: (e3) => {
    var t3 = "Bad HTTP status: " + e3.statusCode + " " + e3.text;
    B$1.error(t3);
  }, get_device_id: (e3) => e3, _onCapture: eo, capture_performance: void 0, name: "posthog", bootstrap: {}, disable_compression: false, session_idle_timeout_seconds: 1800, person_profiles: "identified_only", __add_tracing_headers: false, before_send: void 0 };
}, ro = (e2) => {
  var t2 = {};
  F$1(e2.process_person) || (t2.person_profiles = e2.process_person), F$1(e2.xhr_headers) || (t2.request_headers = e2.xhr_headers), F$1(e2.cookie_name) || (t2.persistence_name = e2.cookie_name), F$1(e2.disable_cookie) || (t2.disable_persistence = e2.disable_cookie);
  var i2 = G$1({}, t2, e2);
  return I$1(e2.property_blacklist) && (F$1(e2.property_denylist) ? i2.property_denylist = e2.property_blacklist : I$1(e2.property_denylist) ? i2.property_denylist = [...e2.property_blacklist, ...e2.property_denylist] : B$1.error("Invalid value for property_denylist config: " + e2.property_denylist)), i2;
};
class so {
  constructor() {
    i$1(this, "__forceAllowLocalhost", false);
  }
  get _forceAllowLocalhost() {
    return this.__forceAllowLocalhost;
  }
  set _forceAllowLocalhost(e2) {
    B$1.error("WebPerformanceObserver is deprecated and has no impact on network capture. Use `_forceAllowLocalhostNetworkCapture` on `posthog.sessionRecording`"), this.__forceAllowLocalhost = e2;
  }
}
class oo {
  get decideEndpointWasHit() {
    var e2, t2;
    return null !== (e2 = null === (t2 = this.featureFlags) || void 0 === t2 ? void 0 : t2.hasLoadedFlags) && void 0 !== e2 && e2;
  }
  constructor() {
    i$1(this, "webPerformance", new so()), i$1(this, "version", s$1.LIB_VERSION), i$1(this, "_internalEventEmitter", new Fr()), this.config = no(), this.SentryIntegration = Er, this.sentryIntegration = (e2) => function(e3, t2) {
      var i2 = Sr(e3, t2);
      return { name: wr, processEvent: (e4) => i2(e4) };
    }(this, e2), this.__request_queue = [], this.__loaded = false, this.analyticsDefaultEndpoint = "/e/", this._initialPageviewCaptured = false, this._initialPersonProfilesConfig = null, this.featureFlags = new je(this), this.toolbar = new or(this), this.scrollManager = new Ts(this), this.pageViewManager = new Rr(this), this.surveys = new gs(this), this.experiments = new Js(this), this.exceptions = new Ys(this), this.rateLimiter = new ms(this), this.requestRouter = new yr(this), this.consent = new Hs(this), this.people = { set: (e2, t2, i2) => {
      var n2 = T(e2) ? { [e2]: t2 } : e2;
      this.setPersonProperties(n2), null == i2 || i2({});
    }, set_once: (e2, t2, i2) => {
      var n2 = T(e2) ? { [e2]: t2 } : e2;
      this.setPersonProperties(void 0, n2), null == i2 || i2({});
    } }, this.on("eventCaptured", (e2) => B$1.info('send "'.concat(null == e2 ? void 0 : e2.event, '"'), e2));
  }
  init(e2, t2, i2) {
    if (i2 && i2 !== to) {
      var n2, r2 = null !== (n2 = Zs[i2]) && void 0 !== n2 ? n2 : new oo();
      return r2._init(e2, t2, i2), Zs[i2] = r2, Zs[to][i2] = r2, r2;
    }
    return this._init(e2, t2, i2);
  }
  _init(e2) {
    var i2, n2, a2, l2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}, u2 = arguments.length > 2 ? arguments[2] : void 0;
    if (F$1(e2) || $(e2))
      return B$1.critical("PostHog was initialized without a token. This likely indicates a misconfiguration. Please check the first argument passed to posthog.init()"), this;
    if (this.__loaded)
      return B$1.warn("You have already initialized PostHog! Re-initializing is a no-op"), this;
    this.__loaded = true, this.config = {}, this._triggered_notifs = [], l2.person_profiles && (this._initialPersonProfilesConfig = l2.person_profiles), this.set_config(G$1({}, no(), ro(l2), { name: u2, token: e2 })), this.config.on_xhr_error && B$1.error("on_xhr_error is deprecated. Use on_request_error instead"), this.compression = l2.disable_compression ? void 0 : r$3.GZipJS, this.persistence = new fi(this.config), this.sessionPersistence = "sessionStorage" === this.config.persistence || "memory" === this.config.persistence ? this.persistence : new fi(t$1(t$1({}, this.config), {}, { persistence: "sessionStorage" }));
    var c2 = t$1({}, this.persistence.props), d2 = t$1({}, this.sessionPersistence.props);
    if (this._requestQueue = new ar((e3) => this._send_retriable_request(e3)), this._retryQueue = new vr(this), this.__request_queue = [], this.sessionManager = new mr(this), this.sessionPropsManager = new ys(this.sessionManager, this.persistence), new qs(this).startIfEnabledOrStop(), this.siteApps = new Qs(this), null === (i2 = this.siteApps) || void 0 === i2 || i2.init(), this.sessionRecording = new er(this), this.sessionRecording.startIfEnabledOrStop(), this.config.disable_scroll_properties || this.scrollManager.startMeasuringScrollPosition(), this.autocapture = new Ds(this), this.autocapture.startIfEnabled(), this.surveys.loadIfEnabled(), this.heatmaps = new Fs(this), this.heatmaps.startIfEnabled(), this.webVitalsAutocapture = new Gs(this), this.exceptionObserver = new zs(this), this.exceptionObserver.startIfEnabled(), this.deadClicksAutocapture = new Ps(this, Cs), this.deadClicksAutocapture.startIfEnabled(), s$1.DEBUG = s$1.DEBUG || this.config.debug, s$1.DEBUG && B$1.info("Starting in debug mode", { this: this, config: l2, thisC: t$1({}, this.config), p: c2, s: d2 }), this._sync_opt_out_with_persistence(), void 0 !== (null === (n2 = l2.bootstrap) || void 0 === n2 ? void 0 : n2.distinctID)) {
      var h2, _2, p2 = this.config.get_device_id(Ke()), v2 = null !== (h2 = l2.bootstrap) && void 0 !== h2 && h2.isIdentifiedID ? p2 : l2.bootstrap.distinctID;
      this.persistence.set_property(Fe, null !== (_2 = l2.bootstrap) && void 0 !== _2 && _2.isIdentifiedID ? "identified" : "anonymous"), this.register({ distinct_id: l2.bootstrap.distinctID, $device_id: v2 });
    }
    if (this._hasBootstrappedFeatureFlags()) {
      var g2, f2, m2 = Object.keys((null === (g2 = l2.bootstrap) || void 0 === g2 ? void 0 : g2.featureFlags) || {}).filter((e3) => {
        var t2, i3;
        return !(null === (t2 = l2.bootstrap) || void 0 === t2 || null === (i3 = t2.featureFlags) || void 0 === i3 || !i3[e3]);
      }).reduce((e3, t2) => {
        var i3, n3;
        return e3[t2] = (null === (i3 = l2.bootstrap) || void 0 === i3 || null === (n3 = i3.featureFlags) || void 0 === n3 ? void 0 : n3[t2]) || false, e3;
      }, {}), b2 = Object.keys((null === (f2 = l2.bootstrap) || void 0 === f2 ? void 0 : f2.featureFlagPayloads) || {}).filter((e3) => m2[e3]).reduce((e3, t2) => {
        var i3, n3, r2, s2;
        null !== (i3 = l2.bootstrap) && void 0 !== i3 && null !== (n3 = i3.featureFlagPayloads) && void 0 !== n3 && n3[t2] && (e3[t2] = null === (r2 = l2.bootstrap) || void 0 === r2 || null === (s2 = r2.featureFlagPayloads) || void 0 === s2 ? void 0 : s2[t2]);
        return e3;
      }, {});
      this.featureFlags.receivedFeatureFlags({ featureFlags: m2, featureFlagPayloads: b2 });
    }
    if (!this.get_distinct_id()) {
      var y2 = this.config.get_device_id(Ke());
      this.register_once({ distinct_id: y2, $device_id: y2 }, ""), this.persistence.set_property(Fe, "anonymous");
    }
    return null == o$1 || null === (a2 = o$1.addEventListener) || void 0 === a2 || a2.call(o$1, "onpagehide" in self ? "pagehide" : "unload", this._handle_unload.bind(this)), this.toolbar.maybeLoadToolbar(), l2.segment ? Pr(this, () => this._loaded()) : this._loaded(), C$1(this.config._onCapture) && this.config._onCapture !== eo && (B$1.warn("onCapture is deprecated. Please use `before_send` instead"), this.on("eventCaptured", (e3) => this.config._onCapture(e3.event, e3))), this;
  }
  _onRemoteConfig(e2) {
    var t2, i2, n2, s2, o2, a2, l2, u2, c2;
    if (!h$2 || !h$2.body)
      return B$1.info("document not ready yet, trying again in 500 milliseconds..."), void setTimeout(() => {
        this._onRemoteConfig(e2);
      }, 500);
    this.compression = void 0, e2.supportedCompression && !this.config.disable_compression && (this.compression = V(e2.supportedCompression, r$3.GZipJS) ? r$3.GZipJS : V(e2.supportedCompression, r$3.Base64) ? r$3.Base64 : void 0), null !== (t2 = e2.analytics) && void 0 !== t2 && t2.endpoint && (this.analyticsDefaultEndpoint = e2.analytics.endpoint), this.set_config({ person_profiles: this._initialPersonProfilesConfig ? this._initialPersonProfilesConfig : e2.defaultIdentifiedOnly ? "identified_only" : "always" }), null === (i2 = this.siteApps) || void 0 === i2 || i2.onRemoteConfig(e2), null === (n2 = this.sessionRecording) || void 0 === n2 || n2.onRemoteConfig(e2), null === (s2 = this.autocapture) || void 0 === s2 || s2.onRemoteConfig(e2), null === (o2 = this.heatmaps) || void 0 === o2 || o2.onRemoteConfig(e2), null === (a2 = this.surveys) || void 0 === a2 || a2.onRemoteConfig(e2), null === (l2 = this.webVitalsAutocapture) || void 0 === l2 || l2.onRemoteConfig(e2), null === (u2 = this.exceptionObserver) || void 0 === u2 || u2.onRemoteConfig(e2), null === (c2 = this.deadClicksAutocapture) || void 0 === c2 || c2.onRemoteConfig(e2);
  }
  _loaded() {
    try {
      this.config.loaded(this);
    } catch (e2) {
      B$1.critical("`loaded` function failed", e2);
    }
    this._start_queue_if_opted_in(), this.config.capture_pageview && setTimeout(() => {
      this.consent.isOptedIn() && this._captureInitialPageview();
    }, 1), new ir(this).load(), this.featureFlags.decide();
  }
  _start_queue_if_opted_in() {
    var e2;
    this.has_opted_out_capturing() || this.config.request_batching && (null === (e2 = this._requestQueue) || void 0 === e2 || e2.enable());
  }
  _dom_loaded() {
    this.has_opted_out_capturing() || j(this.__request_queue, (e2) => this._send_retriable_request(e2)), this.__request_queue = [], this._start_queue_if_opted_in();
  }
  _handle_unload() {
    var e2, t2;
    this.config.request_batching ? (this._shouldCapturePageleave() && this.capture("$pageleave"), null === (e2 = this._requestQueue) || void 0 === e2 || e2.unload(), null === (t2 = this._retryQueue) || void 0 === t2 || t2.unload()) : this._shouldCapturePageleave() && this.capture("$pageleave", null, { transport: "sendBeacon" });
  }
  _send_request(e2) {
    this.__loaded && (io ? this.__request_queue.push(e2) : this.rateLimiter.isServerRateLimited(e2.batchKey) || (e2.transport = e2.transport || this.config.api_transport, e2.url = cr(e2.url, { ip: this.config.ip ? 1 : 0 }), e2.headers = t$1({}, this.config.request_headers), e2.compression = "best-available" === e2.compression ? this.compression : e2.compression, e2.fetchOptions = e2.fetchOptions || this.config.fetch_options, ((e3) => {
      var i2, n2, r2, o2 = t$1({}, e3);
      o2.timeout = o2.timeout || 6e4, o2.url = cr(o2.url, { _: (/* @__PURE__ */ new Date()).getTime().toString(), ver: s$1.LIB_VERSION, compression: o2.compression });
      var a2 = null !== (i2 = o2.transport) && void 0 !== i2 ? i2 : "XHR", l2 = null !== (n2 = null === (r2 = ie(_r, (e4) => e4.transport === a2)) || void 0 === r2 ? void 0 : r2.method) && void 0 !== n2 ? n2 : _r[0].method;
      if (!l2)
        throw new Error("No available transport method");
      l2(o2);
    })(t$1(t$1({}, e2), {}, { callback: (t2) => {
      var i2, n2, r2;
      (this.rateLimiter.checkForLimiting(t2), t2.statusCode >= 400) && (null === (n2 = (r2 = this.config).on_request_error) || void 0 === n2 || n2.call(r2, t2));
      null === (i2 = e2.callback) || void 0 === i2 || i2.call(e2, t2);
    } }))));
  }
  _send_retriable_request(e2) {
    this._retryQueue ? this._retryQueue.retriableRequest(e2) : this._send_request(e2);
  }
  _execute_array(e2) {
    var t2, i2 = [], n2 = [], r2 = [];
    j(e2, (e3) => {
      e3 && (t2 = e3[0], I$1(t2) ? r2.push(e3) : C$1(e3) ? e3.call(this) : I$1(e3) && "alias" === t2 ? i2.push(e3) : I$1(e3) && -1 !== t2.indexOf("capture") && C$1(this[t2]) ? r2.push(e3) : n2.push(e3));
    });
    var s2 = function(e3, t3) {
      j(e3, function(e4) {
        if (I$1(e4[0])) {
          var i3 = t3;
          W(e4, function(e5) {
            i3 = i3[e5[0]].apply(i3, e5.slice(1));
          });
        } else
          this[e4[0]].apply(this, e4.slice(1));
      }, t3);
    };
    s2(i2, this), s2(n2, this), s2(r2, this);
  }
  _hasBootstrappedFeatureFlags() {
    var e2, t2;
    return (null === (e2 = this.config.bootstrap) || void 0 === e2 ? void 0 : e2.featureFlags) && Object.keys(null === (t2 = this.config.bootstrap) || void 0 === t2 ? void 0 : t2.featureFlags).length > 0 || false;
  }
  push(e2) {
    this._execute_array([e2]);
  }
  capture(e2, i2, n2) {
    var r2;
    if (this.__loaded && this.persistence && this.sessionPersistence && this._requestQueue) {
      if (!this.consent.isOptedOut())
        if (!F$1(e2) && T(e2)) {
          if (this.config.opt_out_useragent_filter || !this._is_bot()) {
            var s2 = null != n2 && n2.skip_client_rate_limiting ? void 0 : this.rateLimiter.clientRateLimitContext();
            if (null == s2 || !s2.isRateLimited) {
              this.sessionPersistence.update_search_keyword(), this.config.store_google && this.sessionPersistence.update_campaign_params(), this.config.save_referrer && this.sessionPersistence.update_referrer_info(), (this.config.store_google || this.config.save_referrer) && this.persistence.set_initial_person_info();
              var o2 = /* @__PURE__ */ new Date(), a2 = (null == n2 ? void 0 : n2.timestamp) || o2, l2 = { uuid: Ke(), event: e2, properties: this._calculate_event_properties(e2, i2 || {}, a2) };
              s2 && (l2.properties.$lib_rate_limit_remaining_tokens = s2.remainingTokens), (null == n2 ? void 0 : n2.$set) && (l2.$set = null == n2 ? void 0 : n2.$set);
              var u2 = this._calculate_set_once_properties(null == n2 ? void 0 : n2.$set_once);
              u2 && (l2.$set_once = u2), (l2 = Z(l2, null != n2 && n2._noTruncate ? null : this.config.properties_string_max_length)).timestamp = a2, F$1(null == n2 ? void 0 : n2.timestamp) || (l2.properties.$event_time_override_provided = true, l2.properties.$event_time_override_system_time = o2);
              var c2 = t$1(t$1({}, l2.properties.$set), l2.$set);
              if (R(c2) || this.setPersonPropertiesForFlags(c2), !L(this.config.before_send)) {
                var d2 = this._runBeforeSend(l2);
                if (!d2)
                  return;
                l2 = d2;
              }
              this._internalEventEmitter.emit("eventCaptured", l2);
              var h2 = { method: "POST", url: null !== (r2 = null == n2 ? void 0 : n2._url) && void 0 !== r2 ? r2 : this.requestRouter.endpointFor("api", this.analyticsDefaultEndpoint), data: l2, compression: "best-available", batchKey: null == n2 ? void 0 : n2._batchKey };
              return !this.config.request_batching || n2 && (null == n2 || !n2._batchKey) || null != n2 && n2.send_instantly ? this._send_retriable_request(h2) : this._requestQueue.enqueue(h2), l2;
            }
            B$1.critical("This capture call is ignored due to client rate limiting.");
          }
        } else
          B$1.error("No event name provided to posthog.capture");
    } else
      B$1.uninitializedWarning("posthog.capture");
  }
  _addCaptureHook(e2) {
    return this.on("eventCaptured", (t2) => e2(t2.event, t2));
  }
  _calculate_event_properties(e2, i2, n2) {
    if (n2 = n2 || /* @__PURE__ */ new Date(), !this.persistence || !this.sessionPersistence)
      return i2;
    var r2 = this.persistence.remove_event_timer(e2), s2 = t$1({}, i2);
    if (s2.token = this.config.token, "$snapshot" === e2) {
      var o2 = t$1(t$1({}, this.persistence.properties()), this.sessionPersistence.properties());
      return s2.distinct_id = o2.distinct_id, (!T(s2.distinct_id) && !M(s2.distinct_id) || $(s2.distinct_id)) && B$1.error("Invalid distinct_id for replay event. This indicates a bug in your implementation"), s2;
    }
    var a2 = vi.properties();
    if (this.sessionManager) {
      var { sessionId: l2, windowId: u2 } = this.sessionManager.checkAndGetSessionAndWindowId();
      s2.$session_id = l2, s2.$window_id = u2;
    }
    if (this.sessionRecording && (s2.$recording_status = this.sessionRecording.status), this.requestRouter.region === gr.CUSTOM && (s2.$lib_custom_api_host = this.config.api_host), this.sessionPropsManager && this.config.__preview_send_client_session_params && ("$pageview" === e2 || "$pageleave" === e2 || "$autocapture" === e2)) {
      var c2 = this.sessionPropsManager.getSessionProps();
      s2 = G$1(s2, c2);
    }
    if (!this.config.disable_scroll_properties) {
      var d2 = {};
      "$pageview" === e2 ? d2 = this.pageViewManager.doPageView(n2) : "$pageleave" === e2 && (d2 = this.pageViewManager.doPageLeave(n2)), s2 = G$1(s2, d2);
    }
    if ("$pageview" === e2 && h$2 && (s2.title = h$2.title), !F$1(r2)) {
      var _2 = n2.getTime() - r2;
      s2.$duration = parseFloat((_2 / 1e3).toFixed(3));
    }
    f$2 && this.config.opt_out_useragent_filter && (s2.$browser_type = this._is_bot() ? "bot" : "browser"), (s2 = G$1({}, a2, this.persistence.properties(), this.sessionPersistence.properties(), s2)).$is_identified = this._isIdentified(), I$1(this.config.property_denylist) ? W(this.config.property_denylist, function(e3) {
      delete s2[e3];
    }) : B$1.error("Invalid value for property_denylist config: " + this.config.property_denylist + " or property_blacklist config: " + this.config.property_blacklist);
    var p2 = this.config.sanitize_properties;
    p2 && (s2 = p2(s2, e2));
    var v2 = this._hasPersonProcessing();
    return s2.$process_person_profile = v2, v2 && this._requirePersonProcessing("_calculate_event_properties"), s2;
  }
  _calculate_set_once_properties(e2) {
    if (!this.persistence || !this._hasPersonProcessing())
      return e2;
    var t2 = G$1({}, this.persistence.get_initial_props(), e2 || {}), i2 = this.config.sanitize_properties;
    return i2 && (t2 = i2(t2, "$set_once")), R(t2) ? void 0 : t2;
  }
  register(e2, t2) {
    var i2;
    null === (i2 = this.persistence) || void 0 === i2 || i2.register(e2, t2);
  }
  register_once(e2, t2, i2) {
    var n2;
    null === (n2 = this.persistence) || void 0 === n2 || n2.register_once(e2, t2, i2);
  }
  register_for_session(e2) {
    var t2;
    null === (t2 = this.sessionPersistence) || void 0 === t2 || t2.register(e2);
  }
  unregister(e2) {
    var t2;
    null === (t2 = this.persistence) || void 0 === t2 || t2.unregister(e2);
  }
  unregister_for_session(e2) {
    var t2;
    null === (t2 = this.sessionPersistence) || void 0 === t2 || t2.unregister(e2);
  }
  _register_single(e2, t2) {
    this.register({ [e2]: t2 });
  }
  getFeatureFlag(e2, t2) {
    return this.featureFlags.getFeatureFlag(e2, t2);
  }
  getFeatureFlagPayload(e2) {
    var t2 = this.featureFlags.getFeatureFlagPayload(e2);
    try {
      return JSON.parse(t2);
    } catch (e3) {
      return t2;
    }
  }
  isFeatureEnabled(e2, t2) {
    return this.featureFlags.isFeatureEnabled(e2, t2);
  }
  reloadFeatureFlags() {
    this.featureFlags.reloadFeatureFlags();
  }
  updateEarlyAccessFeatureEnrollment(e2, t2) {
    this.featureFlags.updateEarlyAccessFeatureEnrollment(e2, t2);
  }
  getEarlyAccessFeatures(e2) {
    var t2 = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
    return this.featureFlags.getEarlyAccessFeatures(e2, t2);
  }
  on(e2, t2) {
    return this._internalEventEmitter.on(e2, t2);
  }
  onFeatureFlags(e2) {
    return this.featureFlags.onFeatureFlags(e2);
  }
  onSessionId(e2) {
    var t2, i2;
    return null !== (t2 = null === (i2 = this.sessionManager) || void 0 === i2 ? void 0 : i2.onSessionId(e2)) && void 0 !== t2 ? t2 : () => {
    };
  }
  getSurveys(e2) {
    var t2 = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
    this.surveys.getSurveys(e2, t2);
  }
  getActiveMatchingSurveys(e2) {
    var t2 = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
    this.surveys.getActiveMatchingSurveys(e2, t2);
  }
  renderSurvey(e2, t2) {
    this.surveys.renderSurvey(e2, t2);
  }
  canRenderSurvey(e2) {
    this.surveys.canRenderSurvey(e2);
  }
  getNextSurveyStep(e2, t2, i2) {
    return this.surveys.getNextSurveyStep(e2, t2, i2);
  }
  identify(e2, t2, i2) {
    if (!this.__loaded || !this.persistence)
      return B$1.uninitializedWarning("posthog.identify");
    if (M(e2) && (e2 = e2.toString(), B$1.warn("The first argument to posthog.identify was a number, but it should be a string. It has been converted to a string.")), e2) {
      if (["distinct_id", "distinctid"].includes(e2.toLowerCase()))
        B$1.critical('The string "'.concat(e2, '" was set in posthog.identify which indicates an error. This ID should be unique to the user and not a hardcoded string.'));
      else if (this._requirePersonProcessing("posthog.identify")) {
        var n2 = this.get_distinct_id();
        if (this.register({ $user_id: e2 }), !this.get_property("$device_id")) {
          var r2 = n2;
          this.register_once({ $had_persisted_distinct_id: true, $device_id: r2 }, "");
        }
        e2 !== n2 && e2 !== this.get_property(re) && (this.unregister(re), this.register({ distinct_id: e2 }));
        var s2 = "anonymous" === (this.persistence.get_property(Fe) || "anonymous");
        e2 !== n2 && s2 ? (this.persistence.set_property(Fe, "identified"), this.setPersonPropertiesForFlags(t2 || {}, false), this.capture("$identify", { distinct_id: e2, $anon_distinct_id: n2 }, { $set: t2 || {}, $set_once: i2 || {} }), this.featureFlags.setAnonymousDistinctId(n2)) : (t2 || i2) && this.setPersonProperties(t2, i2), e2 !== n2 && (this.reloadFeatureFlags(), this.unregister(Re));
      }
    } else
      B$1.error("Unique user id has not been set in posthog.identify");
  }
  setPersonProperties(e2, t2) {
    (e2 || t2) && this._requirePersonProcessing("posthog.setPersonProperties") && (this.setPersonPropertiesForFlags(e2 || {}), this.capture("$set", { $set: e2 || {}, $set_once: t2 || {} }));
  }
  group(e2, i2, n2) {
    if (e2 && i2) {
      if (this._requirePersonProcessing("posthog.group")) {
        var r2 = this.getGroups();
        r2[e2] !== i2 && this.resetGroupPropertiesForFlags(e2), this.register({ $groups: t$1(t$1({}, r2), {}, { [e2]: i2 }) }), n2 && (this.capture("$groupidentify", { $group_type: e2, $group_key: i2, $group_set: n2 }), this.setGroupPropertiesForFlags({ [e2]: n2 })), r2[e2] === i2 || n2 || this.reloadFeatureFlags();
      }
    } else
      B$1.error("posthog.group requires a group type and group key");
  }
  resetGroups() {
    this.register({ $groups: {} }), this.resetGroupPropertiesForFlags(), this.reloadFeatureFlags();
  }
  setPersonPropertiesForFlags(e2) {
    var t2 = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1];
    this.featureFlags.setPersonPropertiesForFlags(e2, t2);
  }
  resetPersonPropertiesForFlags() {
    this.featureFlags.resetPersonPropertiesForFlags();
  }
  setGroupPropertiesForFlags(e2) {
    var t2 = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1];
    this._requirePersonProcessing("posthog.setGroupPropertiesForFlags") && this.featureFlags.setGroupPropertiesForFlags(e2, t2);
  }
  resetGroupPropertiesForFlags(e2) {
    this.featureFlags.resetGroupPropertiesForFlags(e2);
  }
  reset(e2) {
    var t2, i2, n2, r2, s2;
    if (B$1.info("reset"), !this.__loaded)
      return B$1.uninitializedWarning("posthog.reset");
    var o2 = this.get_property("$device_id");
    this.consent.reset(), null === (t2 = this.persistence) || void 0 === t2 || t2.clear(), null === (i2 = this.sessionPersistence) || void 0 === i2 || i2.clear(), null === (n2 = this.surveys) || void 0 === n2 || n2.reset(), null === (r2 = this.persistence) || void 0 === r2 || r2.set_property(Fe, "anonymous"), null === (s2 = this.sessionManager) || void 0 === s2 || s2.resetSessionId();
    var a2 = this.config.get_device_id(Ke());
    this.register_once({ distinct_id: a2, $device_id: e2 ? a2 : o2 }, "");
  }
  get_distinct_id() {
    return this.get_property("distinct_id");
  }
  getGroups() {
    return this.get_property("$groups") || {};
  }
  get_session_id() {
    var e2, t2;
    return null !== (e2 = null === (t2 = this.sessionManager) || void 0 === t2 ? void 0 : t2.checkAndGetSessionAndWindowId(true).sessionId) && void 0 !== e2 ? e2 : "";
  }
  get_session_replay_url(e2) {
    if (!this.sessionManager)
      return "";
    var { sessionId: t2, sessionStartTimestamp: i2 } = this.sessionManager.checkAndGetSessionAndWindowId(true), n2 = this.requestRouter.endpointFor("ui", "/project/".concat(this.config.token, "/replay/").concat(t2));
    if (null != e2 && e2.withTimestamp && i2) {
      var r2, s2 = null !== (r2 = e2.timestampLookBack) && void 0 !== r2 ? r2 : 10;
      if (!i2)
        return n2;
      var o2 = Math.max(Math.floor(((/* @__PURE__ */ new Date()).getTime() - i2) / 1e3) - s2, 0);
      n2 += "?t=".concat(o2);
    }
    return n2;
  }
  alias(e2, t2) {
    return e2 === this.get_property(ne) ? (B$1.critical("Attempting to create alias for existing People user - aborting."), -2) : this._requirePersonProcessing("posthog.alias") ? (F$1(t2) && (t2 = this.get_distinct_id()), e2 !== t2 ? (this._register_single(re, e2), this.capture("$create_alias", { alias: e2, distinct_id: t2 })) : (B$1.warn("alias matches current distinct_id - skipping api call."), this.identify(e2), -1)) : void 0;
  }
  set_config(e2) {
    var i2, n2, r2, o2, a2 = t$1({}, this.config);
    P(e2) && (G$1(this.config, ro(e2)), null === (i2 = this.persistence) || void 0 === i2 || i2.update_config(this.config, a2), this.sessionPersistence = "sessionStorage" === this.config.persistence || "memory" === this.config.persistence ? this.persistence : new fi(t$1(t$1({}, this.config), {}, { persistence: "sessionStorage" })), st.is_supported() && "true" === st.get("ph_debug") && (this.config.debug = true), this.config.debug && (s$1.DEBUG = true, B$1.info("set_config", { config: e2, oldConfig: a2, newConfig: t$1({}, this.config) })), null === (n2 = this.sessionRecording) || void 0 === n2 || n2.startIfEnabledOrStop(), null === (r2 = this.autocapture) || void 0 === r2 || r2.startIfEnabled(), null === (o2 = this.heatmaps) || void 0 === o2 || o2.startIfEnabled(), this.surveys.loadIfEnabled(), this._sync_opt_out_with_persistence());
  }
  startSessionRecording(e2) {
    var t2 = true === e2, i2 = { sampling: t2 || !(null == e2 || !e2.sampling), linked_flag: t2 || !(null == e2 || !e2.linked_flag), url_trigger: t2 || !(null == e2 || !e2.url_trigger), event_trigger: t2 || !(null == e2 || !e2.event_trigger) };
    if (Object.values(i2).some(Boolean)) {
      var n2, r2, s2, o2, a2;
      if (null === (n2 = this.sessionManager) || void 0 === n2 || n2.checkAndGetSessionAndWindowId(), i2.sampling)
        null === (r2 = this.sessionRecording) || void 0 === r2 || r2.overrideSampling();
      if (i2.linked_flag)
        null === (s2 = this.sessionRecording) || void 0 === s2 || s2.overrideLinkedFlag();
      if (i2.url_trigger)
        null === (o2 = this.sessionRecording) || void 0 === o2 || o2.overrideTrigger("url");
      if (i2.event_trigger)
        null === (a2 = this.sessionRecording) || void 0 === a2 || a2.overrideTrigger("event");
    }
    this.set_config({ disable_session_recording: false });
  }
  stopSessionRecording() {
    this.set_config({ disable_session_recording: true });
  }
  sessionRecordingStarted() {
    var e2;
    return !(null === (e2 = this.sessionRecording) || void 0 === e2 || !e2.started);
  }
  captureException(e2, i2) {
    var n2, r2 = new Error("PostHog syntheticException"), s2 = C$1(null === (n2 = m$2.__PosthogExtensions__) || void 0 === n2 ? void 0 : n2.parseErrorAsProperties) ? m$2.__PosthogExtensions__.parseErrorAsProperties([e2.message, void 0, void 0, void 0, e2], { syntheticException: r2 }) : t$1({ $exception_level: "error", $exception_list: [{ type: e2.name, value: e2.message, mechanism: { handled: true, synthetic: false } }] }, i2);
    this.exceptions.sendExceptionEvent(s2);
  }
  loadToolbar(e2) {
    return this.toolbar.loadToolbar(e2);
  }
  get_property(e2) {
    var t2;
    return null === (t2 = this.persistence) || void 0 === t2 ? void 0 : t2.props[e2];
  }
  getSessionProperty(e2) {
    var t2;
    return null === (t2 = this.sessionPersistence) || void 0 === t2 ? void 0 : t2.props[e2];
  }
  toString() {
    var e2, t2 = null !== (e2 = this.config.name) && void 0 !== e2 ? e2 : to;
    return t2 !== to && (t2 = to + "." + t2), t2;
  }
  _isIdentified() {
    var e2, t2;
    return "identified" === (null === (e2 = this.persistence) || void 0 === e2 ? void 0 : e2.get_property(Fe)) || "identified" === (null === (t2 = this.sessionPersistence) || void 0 === t2 ? void 0 : t2.get_property(Fe));
  }
  _hasPersonProcessing() {
    var e2, t2, i2, n2;
    return !("never" === this.config.person_profiles || "identified_only" === this.config.person_profiles && !this._isIdentified() && R(this.getGroups()) && (null === (e2 = this.persistence) || void 0 === e2 || null === (t2 = e2.props) || void 0 === t2 || !t2[re]) && (null === (i2 = this.persistence) || void 0 === i2 || null === (n2 = i2.props) || void 0 === n2 || !n2[Ae]));
  }
  _shouldCapturePageleave() {
    return true === this.config.capture_pageleave || "if_capture_pageview" === this.config.capture_pageleave && this.config.capture_pageview;
  }
  createPersonProfile() {
    this._hasPersonProcessing() || this._requirePersonProcessing("posthog.createPersonProfile") && this.setPersonProperties({}, {});
  }
  _requirePersonProcessing(e2) {
    return "never" === this.config.person_profiles ? (B$1.error(e2 + ' was called, but process_person is set to "never". This call will be ignored.'), false) : (this._register_single(Ae, true), true);
  }
  _sync_opt_out_with_persistence() {
    var e2, t2, i2, n2, r2 = this.consent.isOptedOut(), s2 = this.config.opt_out_persistence_by_default, o2 = this.config.disable_persistence || r2 && !!s2;
    (null === (e2 = this.persistence) || void 0 === e2 ? void 0 : e2.disabled) !== o2 && (null === (i2 = this.persistence) || void 0 === i2 || i2.set_disabled(o2));
    (null === (t2 = this.sessionPersistence) || void 0 === t2 ? void 0 : t2.disabled) !== o2 && (null === (n2 = this.sessionPersistence) || void 0 === n2 || n2.set_disabled(o2));
  }
  opt_in_capturing(e2) {
    var t2;
    (this.consent.optInOut(true), this._sync_opt_out_with_persistence(), F$1(null == e2 ? void 0 : e2.captureEventName) || null != e2 && e2.captureEventName) && this.capture(null !== (t2 = null == e2 ? void 0 : e2.captureEventName) && void 0 !== t2 ? t2 : "$opt_in", null == e2 ? void 0 : e2.captureProperties, { send_instantly: true });
    this.config.capture_pageview && this._captureInitialPageview();
  }
  opt_out_capturing() {
    this.consent.optInOut(false), this._sync_opt_out_with_persistence();
  }
  has_opted_in_capturing() {
    return this.consent.isOptedIn();
  }
  has_opted_out_capturing() {
    return this.consent.isOptedOut();
  }
  clear_opt_in_out_capturing() {
    this.consent.reset(), this._sync_opt_out_with_persistence();
  }
  _is_bot() {
    return d$2 ? Es(d$2, this.config.custom_blocked_useragents) : void 0;
  }
  _captureInitialPageview() {
    h$2 && !this._initialPageviewCaptured && (this._initialPageviewCaptured = true, this.capture("$pageview", { title: h$2.title }, { send_instantly: true }));
  }
  debug(e2) {
    false === e2 ? (null == o$1 || o$1.console.log("You've disabled debug mode."), localStorage && localStorage.removeItem("ph_debug"), this.set_config({ debug: false })) : (null == o$1 || o$1.console.log("You're now in debug mode. All calls to PostHog will be logged in your console.\nYou can disable this with `posthog.debug(false)`."), localStorage && localStorage.setItem("ph_debug", "true"), this.set_config({ debug: true }));
  }
  _runBeforeSend(e2) {
    if (L(this.config.before_send))
      return e2;
    var t2 = I$1(this.config.before_send) ? this.config.before_send : [this.config.before_send], i2 = e2;
    for (var n2 of t2) {
      if (i2 = n2(i2), L(i2)) {
        var r2 = "Event '".concat(e2.event, "' was rejected in beforeSend function");
        return N(e2.event) ? B$1.warn("".concat(r2, ". This can cause unexpected behavior.")) : B$1.info(r2), null;
      }
      i2.properties && !R(i2.properties) || B$1.warn("Event '".concat(e2.event, "' has no properties after beforeSend function, this is likely an error."));
    }
    return i2;
  }
}
!function(e2, t2) {
  for (var i2 = 0; i2 < t2.length; i2++)
    e2.prototype[t2[i2]] = X(e2.prototype[t2[i2]]);
}(oo, ["identify"]);
var ao, lo = (ao = Zs[to] = new oo(), function() {
  function e2() {
    e2.done || (e2.done = true, io = false, W(Zs, function(e3) {
      e3._dom_loaded();
    }));
  }
  null != h$2 && h$2.addEventListener && ("complete" === h$2.readyState ? e2() : h$2.addEventListener("DOMContentLoaded", e2, false)), o$1 && te(o$1, "load", e2, true);
}(), ao);
!function() {
  function e2(e3, n3) {
    var t3 = Object.keys(e3);
    if (Object.getOwnPropertySymbols) {
      var o3 = Object.getOwnPropertySymbols(e3);
      n3 && (o3 = o3.filter(function(n4) {
        return Object.getOwnPropertyDescriptor(e3, n4).enumerable;
      })), t3.push.apply(t3, o3);
    }
    return t3;
  }
  function n2(n3) {
    for (var o3 = 1; o3 < arguments.length; o3++) {
      var r3 = null != arguments[o3] ? arguments[o3] : {};
      o3 % 2 ? e2(Object(r3), true).forEach(function(e3) {
        t2(n3, e3, r3[e3]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(n3, Object.getOwnPropertyDescriptors(r3)) : e2(Object(r3)).forEach(function(e3) {
        Object.defineProperty(n3, e3, Object.getOwnPropertyDescriptor(r3, e3));
      });
    }
    return n3;
  }
  function t2(e3, n3, t3) {
    return n3 in e3 ? Object.defineProperty(e3, n3, { value: t3, enumerable: true, configurable: true, writable: true }) : e3[n3] = t3, e3;
  }
  var o2, r2, i2;
  !function(e3) {
    e3.Popover = "popover", e3.API = "api", e3.Widget = "widget";
  }(o2 || (o2 = {})), function(e3) {
    e3.Open = "open", e3.MultipleChoice = "multiple_choice", e3.SingleChoice = "single_choice", e3.Rating = "rating", e3.Link = "link";
  }(r2 || (r2 = {})), function(e3) {
    e3.NextQuestion = "next_question", e3.End = "end", e3.ResponseBased = "response_based", e3.SpecificQuestion = "specific_question";
  }(i2 || (i2 = {}));
  var a2 = "undefined" != typeof window ? window : void 0, l2 = "undefined" != typeof globalThis ? globalThis : a2, s2 = null == l2 ? void 0 : l2.navigator, c2 = null == l2 ? void 0 : l2.document;
  null == l2 || l2.location, null == l2 || l2.fetch, null != l2 && l2.XMLHttpRequest && "withCredentials" in new l2.XMLHttpRequest() && l2.XMLHttpRequest, null == l2 || l2.AbortController, null == s2 || s2.userAgent;
  var u2, d2, p2, _2, f2, v2, h2, g2, y2 = null != a2 ? a2 : {}, m2 = {}, b2 = [], C2 = /acit|ex(?:s|g|n|p|$)|rph|grid|ows|mnc|ntw|ine[ch]|zoo|^ord|itera/i, x = Array.isArray;
  function k2(e3, n3) {
    for (var t3 in n3)
      e3[t3] = n3[t3];
    return e3;
  }
  function w2(e3) {
    var n3 = e3.parentNode;
    n3 && n3.removeChild(e3);
  }
  function S2(e3, n3, t3) {
    var o3, r3, i3, a3 = {};
    for (i3 in n3)
      "key" == i3 ? o3 = n3[i3] : "ref" == i3 ? r3 = n3[i3] : a3[i3] = n3[i3];
    if (arguments.length > 2 && (a3.children = arguments.length > 3 ? u2.call(arguments, 2) : t3), "function" == typeof e3 && null != e3.defaultProps)
      for (i3 in e3.defaultProps)
        void 0 === a3[i3] && (a3[i3] = e3.defaultProps[i3]);
    return q2(e3, a3, o3, r3, null);
  }
  function q2(e3, n3, t3, o3, r3) {
    var i3 = { type: e3, props: n3, key: t3, ref: o3, __k: null, __: null, __b: 0, __e: null, __d: void 0, __c: null, constructor: void 0, __v: null == r3 ? ++p2 : r3, __i: -1, __u: 0 };
    return null == r3 && null != d2.vnode && d2.vnode(i3), i3;
  }
  function T2(e3) {
    return e3.children;
  }
  function H2(e3, n3) {
    this.props = e3, this.context = n3;
  }
  function P2(e3, n3) {
    if (null == n3)
      return e3.__ ? P2(e3.__, e3.__i + 1) : null;
    for (var t3; n3 < e3.__k.length; n3++)
      if (null != (t3 = e3.__k[n3]) && null != t3.__e)
        return t3.__e;
    return "function" == typeof e3.type ? P2(e3) : null;
  }
  function L2(e3) {
    var n3, t3;
    if (null != (e3 = e3.__) && null != e3.__c) {
      for (e3.__e = e3.__c.base = null, n3 = 0; n3 < e3.__k.length; n3++)
        if (null != (t3 = e3.__k[n3]) && null != t3.__e) {
          e3.__e = e3.__c.base = t3.__e;
          break;
        }
      return L2(e3);
    }
  }
  function M2(e3) {
    (!e3.__d && (e3.__d = true) && _2.push(e3) && !I2.__r++ || f2 !== d2.debounceRendering) && ((f2 = d2.debounceRendering) || v2)(I2);
  }
  function I2() {
    var e3, n3, t3, o3, r3, i3, a3, l3, s3;
    for (_2.sort(h2); e3 = _2.shift(); )
      e3.__d && (n3 = _2.length, o3 = void 0, i3 = (r3 = (t3 = e3).__v).__e, l3 = [], s3 = [], (a3 = t3.__P) && ((o3 = k2({}, r3)).__v = r3.__v + 1, d2.vnode && d2.vnode(o3), B2(a3, o3, r3, t3.__n, void 0 !== a3.ownerSVGElement, 32 & r3.__u ? [i3] : null, l3, null == i3 ? P2(r3) : i3, !!(32 & r3.__u), s3), o3.__.__k[o3.__i] = o3, O2(l3, o3, s3), o3.__e != i3 && L2(o3)), _2.length > n3 && _2.sort(h2));
    I2.__r = 0;
  }
  function E2(e3, n3, t3, o3, r3, i3, a3, l3, s3, c3, u3) {
    var d3, p3, _3, f3, v3, h3 = o3 && o3.__k || b2, g3 = n3.length;
    for (t3.__d = s3, function(e4, n4, t4) {
      var o4, r4, i4, a4, l4, s4 = n4.length, c4 = t4.length, u4 = c4, d4 = 0;
      for (e4.__k = [], o4 = 0; o4 < s4; o4++)
        null != (r4 = e4.__k[o4] = null == (r4 = n4[o4]) || "boolean" == typeof r4 || "function" == typeof r4 ? null : "string" == typeof r4 || "number" == typeof r4 || "bigint" == typeof r4 || r4.constructor == String ? q2(null, r4, null, null, r4) : x(r4) ? q2(T2, { children: r4 }, null, null, null) : void 0 === r4.constructor && r4.__b > 0 ? q2(r4.type, r4.props, r4.key, r4.ref ? r4.ref : null, r4.__v) : r4) ? (r4.__ = e4, r4.__b = e4.__b + 1, l4 = F2(r4, t4, a4 = o4 + d4, u4), r4.__i = l4, i4 = null, -1 !== l4 && (u4--, (i4 = t4[l4]) && (i4.__u |= 131072)), null == i4 || null === i4.__v ? (-1 == l4 && d4--, "function" != typeof r4.type && (r4.__u |= 65536)) : l4 !== a4 && (l4 === a4 + 1 ? d4++ : l4 > a4 ? u4 > s4 - a4 ? d4 += l4 - a4 : d4-- : d4 = l4 < a4 && l4 == a4 - 1 ? l4 - a4 : 0, l4 !== o4 + d4 && (r4.__u |= 65536))) : (i4 = t4[o4]) && null == i4.key && i4.__e && (i4.__e == e4.__d && (e4.__d = P2(i4)), W2(i4, i4, false), t4[o4] = null, u4--);
      if (u4)
        for (o4 = 0; o4 < c4; o4++)
          null != (i4 = t4[o4]) && 0 == (131072 & i4.__u) && (i4.__e == e4.__d && (e4.__d = P2(i4)), W2(i4, i4));
    }(t3, n3, h3), s3 = t3.__d, d3 = 0; d3 < g3; d3++)
      null != (_3 = t3.__k[d3]) && "boolean" != typeof _3 && "function" != typeof _3 && (p3 = -1 === _3.__i ? m2 : h3[_3.__i] || m2, _3.__i = d3, B2(e3, _3, p3, r3, i3, a3, l3, s3, c3, u3), f3 = _3.__e, _3.ref && p3.ref != _3.ref && (p3.ref && j2(p3.ref, null, _3), u3.push(_3.ref, _3.__c || f3, _3)), null == v3 && null != f3 && (v3 = f3), 65536 & _3.__u || p3.__k === _3.__k ? s3 = D2(_3, s3, e3) : "function" == typeof _3.type && void 0 !== _3.__d ? s3 = _3.__d : f3 && (s3 = f3.nextSibling), _3.__d = void 0, _3.__u &= -196609);
    t3.__d = s3, t3.__e = v3;
  }
  function D2(e3, n3, t3) {
    var o3, r3;
    if ("function" == typeof e3.type) {
      for (o3 = e3.__k, r3 = 0; o3 && r3 < o3.length; r3++)
        o3[r3] && (o3[r3].__ = e3, n3 = D2(o3[r3], n3, t3));
      return n3;
    }
    return e3.__e != n3 && (t3.insertBefore(e3.__e, n3 || null), n3 = e3.__e), n3 && n3.nextSibling;
  }
  function F2(e3, n3, t3, o3) {
    var r3 = e3.key, i3 = e3.type, a3 = t3 - 1, l3 = t3 + 1, s3 = n3[t3];
    if (null === s3 || s3 && r3 == s3.key && i3 === s3.type)
      return t3;
    if (o3 > (null != s3 && 0 == (131072 & s3.__u) ? 1 : 0))
      for (; a3 >= 0 || l3 < n3.length; ) {
        if (a3 >= 0) {
          if ((s3 = n3[a3]) && 0 == (131072 & s3.__u) && r3 == s3.key && i3 === s3.type)
            return a3;
          a3--;
        }
        if (l3 < n3.length) {
          if ((s3 = n3[l3]) && 0 == (131072 & s3.__u) && r3 == s3.key && i3 === s3.type)
            return l3;
          l3++;
        }
      }
    return -1;
  }
  function Z2(e3, n3, t3) {
    "-" === n3[0] ? e3.setProperty(n3, null == t3 ? "" : t3) : e3[n3] = null == t3 ? "" : "number" != typeof t3 || C2.test(n3) ? t3 : t3 + "px";
  }
  function N2(e3, n3, t3, o3, r3) {
    var i3;
    e:
      if ("style" === n3)
        if ("string" == typeof t3)
          e3.style.cssText = t3;
        else {
          if ("string" == typeof o3 && (e3.style.cssText = o3 = ""), o3)
            for (n3 in o3)
              t3 && n3 in t3 || Z2(e3.style, n3, "");
          if (t3)
            for (n3 in t3)
              o3 && t3[n3] === o3[n3] || Z2(e3.style, n3, t3[n3]);
        }
      else if ("o" === n3[0] && "n" === n3[1])
        i3 = n3 !== (n3 = n3.replace(/(PointerCapture)$|Capture$/, "$1")), n3 = n3.toLowerCase() in e3 ? n3.toLowerCase().slice(2) : n3.slice(2), e3.l || (e3.l = {}), e3.l[n3 + i3] = t3, t3 ? o3 ? t3.u = o3.u : (t3.u = Date.now(), e3.addEventListener(n3, i3 ? V2 : A2, i3)) : e3.removeEventListener(n3, i3 ? V2 : A2, i3);
      else {
        if (r3)
          n3 = n3.replace(/xlink(H|:h)/, "h").replace(/sName$/, "s");
        else if ("width" !== n3 && "height" !== n3 && "href" !== n3 && "list" !== n3 && "form" !== n3 && "tabIndex" !== n3 && "download" !== n3 && "rowSpan" !== n3 && "colSpan" !== n3 && "role" !== n3 && n3 in e3)
          try {
            e3[n3] = null == t3 ? "" : t3;
            break e;
          } catch (e4) {
          }
        "function" == typeof t3 || (null == t3 || false === t3 && "-" !== n3[4] ? e3.removeAttribute(n3) : e3.setAttribute(n3, t3));
      }
  }
  function A2(e3) {
    var n3 = this.l[e3.type + false];
    if (e3.t) {
      if (e3.t <= n3.u)
        return;
    } else
      e3.t = Date.now();
    return n3(d2.event ? d2.event(e3) : e3);
  }
  function V2(e3) {
    return this.l[e3.type + true](d2.event ? d2.event(e3) : e3);
  }
  function B2(e3, n3, t3, o3, r3, i3, a3, l3, s3, c3) {
    var u3, p3, _3, f3, v3, h3, g3, y3, m3, b3, C3, w3, S3, q3, P3, L3 = n3.type;
    if (void 0 !== n3.constructor)
      return null;
    128 & t3.__u && (s3 = !!(32 & t3.__u), i3 = [l3 = n3.__e = t3.__e]), (u3 = d2.__b) && u3(n3);
    e:
      if ("function" == typeof L3)
        try {
          if (y3 = n3.props, m3 = (u3 = L3.contextType) && o3[u3.__c], b3 = u3 ? m3 ? m3.props.value : u3.__ : o3, t3.__c ? g3 = (p3 = n3.__c = t3.__c).__ = p3.__E : ("prototype" in L3 && L3.prototype.render ? n3.__c = p3 = new L3(y3, b3) : (n3.__c = p3 = new H2(y3, b3), p3.constructor = L3, p3.render = U2), m3 && m3.sub(p3), p3.props = y3, p3.state || (p3.state = {}), p3.context = b3, p3.__n = o3, _3 = p3.__d = true, p3.__h = [], p3._sb = []), null == p3.__s && (p3.__s = p3.state), null != L3.getDerivedStateFromProps && (p3.__s == p3.state && (p3.__s = k2({}, p3.__s)), k2(p3.__s, L3.getDerivedStateFromProps(y3, p3.__s))), f3 = p3.props, v3 = p3.state, p3.__v = n3, _3)
            null == L3.getDerivedStateFromProps && null != p3.componentWillMount && p3.componentWillMount(), null != p3.componentDidMount && p3.__h.push(p3.componentDidMount);
          else {
            if (null == L3.getDerivedStateFromProps && y3 !== f3 && null != p3.componentWillReceiveProps && p3.componentWillReceiveProps(y3, b3), !p3.__e && (null != p3.shouldComponentUpdate && false === p3.shouldComponentUpdate(y3, p3.__s, b3) || n3.__v === t3.__v)) {
              for (n3.__v !== t3.__v && (p3.props = y3, p3.state = p3.__s, p3.__d = false), n3.__e = t3.__e, n3.__k = t3.__k, n3.__k.forEach(function(e4) {
                e4 && (e4.__ = n3);
              }), C3 = 0; C3 < p3._sb.length; C3++)
                p3.__h.push(p3._sb[C3]);
              p3._sb = [], p3.__h.length && a3.push(p3);
              break e;
            }
            null != p3.componentWillUpdate && p3.componentWillUpdate(y3, p3.__s, b3), null != p3.componentDidUpdate && p3.__h.push(function() {
              p3.componentDidUpdate(f3, v3, h3);
            });
          }
          if (p3.context = b3, p3.props = y3, p3.__P = e3, p3.__e = false, w3 = d2.__r, S3 = 0, "prototype" in L3 && L3.prototype.render) {
            for (p3.state = p3.__s, p3.__d = false, w3 && w3(n3), u3 = p3.render(p3.props, p3.state, p3.context), q3 = 0; q3 < p3._sb.length; q3++)
              p3.__h.push(p3._sb[q3]);
            p3._sb = [];
          } else
            do {
              p3.__d = false, w3 && w3(n3), u3 = p3.render(p3.props, p3.state, p3.context), p3.state = p3.__s;
            } while (p3.__d && ++S3 < 25);
          p3.state = p3.__s, null != p3.getChildContext && (o3 = k2(k2({}, o3), p3.getChildContext())), _3 || null == p3.getSnapshotBeforeUpdate || (h3 = p3.getSnapshotBeforeUpdate(f3, v3)), E2(e3, x(P3 = null != u3 && u3.type === T2 && null == u3.key ? u3.props.children : u3) ? P3 : [P3], n3, t3, o3, r3, i3, a3, l3, s3, c3), p3.base = n3.__e, n3.__u &= -161, p3.__h.length && a3.push(p3), g3 && (p3.__E = p3.__ = null);
        } catch (e4) {
          n3.__v = null, s3 || null != i3 ? (n3.__e = l3, n3.__u |= s3 ? 160 : 32, i3[i3.indexOf(l3)] = null) : (n3.__e = t3.__e, n3.__k = t3.__k), d2.__e(e4, n3, t3);
        }
      else
        null == i3 && n3.__v === t3.__v ? (n3.__k = t3.__k, n3.__e = t3.__e) : n3.__e = Q2(t3.__e, n3, t3, o3, r3, i3, a3, s3, c3);
    (u3 = d2.diffed) && u3(n3);
  }
  function O2(e3, n3, t3) {
    n3.__d = void 0;
    for (var o3 = 0; o3 < t3.length; o3++)
      j2(t3[o3], t3[++o3], t3[++o3]);
    d2.__c && d2.__c(n3, e3), e3.some(function(n4) {
      try {
        e3 = n4.__h, n4.__h = [], e3.some(function(e4) {
          e4.call(n4);
        });
      } catch (e4) {
        d2.__e(e4, n4.__v);
      }
    });
  }
  function Q2(e3, n3, t3, o3, r3, i3, a3, l3, s3) {
    var c3, d3, p3, _3, f3, v3, h3, g3 = t3.props, y3 = n3.props, b3 = n3.type;
    if ("svg" === b3 && (r3 = true), null != i3) {
      for (c3 = 0; c3 < i3.length; c3++)
        if ((f3 = i3[c3]) && "setAttribute" in f3 == !!b3 && (b3 ? f3.localName === b3 : 3 === f3.nodeType)) {
          e3 = f3, i3[c3] = null;
          break;
        }
    }
    if (null == e3) {
      if (null === b3)
        return document.createTextNode(y3);
      e3 = r3 ? document.createElementNS("http://www.w3.org/2000/svg", b3) : document.createElement(b3, y3.is && y3), i3 = null, l3 = false;
    }
    if (null === b3)
      g3 === y3 || l3 && e3.data === y3 || (e3.data = y3);
    else {
      if (i3 = i3 && u2.call(e3.childNodes), g3 = t3.props || m2, !l3 && null != i3)
        for (g3 = {}, c3 = 0; c3 < e3.attributes.length; c3++)
          g3[(f3 = e3.attributes[c3]).name] = f3.value;
      for (c3 in g3)
        f3 = g3[c3], "children" == c3 || ("dangerouslySetInnerHTML" == c3 ? p3 = f3 : "key" === c3 || c3 in y3 || N2(e3, c3, null, f3, r3));
      for (c3 in y3)
        f3 = y3[c3], "children" == c3 ? _3 = f3 : "dangerouslySetInnerHTML" == c3 ? d3 = f3 : "value" == c3 ? v3 = f3 : "checked" == c3 ? h3 = f3 : "key" === c3 || l3 && "function" != typeof f3 || g3[c3] === f3 || N2(e3, c3, f3, g3[c3], r3);
      if (d3)
        l3 || p3 && (d3.__html === p3.__html || d3.__html === e3.innerHTML) || (e3.innerHTML = d3.__html), n3.__k = [];
      else if (p3 && (e3.innerHTML = ""), E2(e3, x(_3) ? _3 : [_3], n3, t3, o3, r3 && "foreignObject" !== b3, i3, a3, i3 ? i3[0] : t3.__k && P2(t3, 0), l3, s3), null != i3)
        for (c3 = i3.length; c3--; )
          null != i3[c3] && w2(i3[c3]);
      l3 || (c3 = "value", void 0 !== v3 && (v3 !== e3[c3] || "progress" === b3 && !v3 || "option" === b3 && v3 !== g3[c3]) && N2(e3, c3, v3, g3[c3], false), c3 = "checked", void 0 !== h3 && h3 !== e3[c3] && N2(e3, c3, h3, g3[c3], false));
    }
    return e3;
  }
  function j2(e3, n3, t3) {
    try {
      "function" == typeof e3 ? e3(n3) : e3.current = n3;
    } catch (e4) {
      d2.__e(e4, t3);
    }
  }
  function W2(e3, n3, t3) {
    var o3, r3;
    if (d2.unmount && d2.unmount(e3), (o3 = e3.ref) && (o3.current && o3.current !== e3.__e || j2(o3, null, n3)), null != (o3 = e3.__c)) {
      if (o3.componentWillUnmount)
        try {
          o3.componentWillUnmount();
        } catch (e4) {
          d2.__e(e4, n3);
        }
      o3.base = o3.__P = null, e3.__c = void 0;
    }
    if (o3 = e3.__k)
      for (r3 = 0; r3 < o3.length; r3++)
        o3[r3] && W2(o3[r3], n3, t3 || "function" != typeof e3.type);
    t3 || null == e3.__e || w2(e3.__e), e3.__ = e3.__e = e3.__d = void 0;
  }
  function U2(e3, n3, t3) {
    return this.constructor(e3, t3);
  }
  function R2(e3, n3, t3) {
    var o3, r3, i3, a3;
    d2.__ && d2.__(e3, n3), r3 = (o3 = "function" == typeof t3) ? null : n3.__k, i3 = [], a3 = [], B2(n3, e3 = (!o3 && t3 || n3).__k = S2(T2, null, [e3]), r3 || m2, m2, void 0 !== n3.ownerSVGElement, !o3 && t3 ? [t3] : r3 ? null : n3.firstChild ? u2.call(n3.childNodes) : null, i3, !o3 && t3 ? t3 : r3 ? r3.__e : n3.firstChild, o3, a3), O2(i3, e3, a3);
  }
  function $2(e3, n3, t3) {
    var o3, r3, i3, a3, l3 = k2({}, e3.props);
    for (i3 in e3.type && e3.type.defaultProps && (a3 = e3.type.defaultProps), n3)
      "key" == i3 ? o3 = n3[i3] : "ref" == i3 ? r3 = n3[i3] : l3[i3] = void 0 === n3[i3] && void 0 !== a3 ? a3[i3] : n3[i3];
    return arguments.length > 2 && (l3.children = arguments.length > 3 ? u2.call(arguments, 2) : t3), q2(e3.type, l3, o3 || e3.key, r3 || e3.ref, null);
  }
  u2 = b2.slice, d2 = { __e: function(e3, n3, t3, o3) {
    for (var r3, i3, a3; n3 = n3.__; )
      if ((r3 = n3.__c) && !r3.__)
        try {
          if ((i3 = r3.constructor) && null != i3.getDerivedStateFromError && (r3.setState(i3.getDerivedStateFromError(e3)), a3 = r3.__d), null != r3.componentDidCatch && (r3.componentDidCatch(e3, o3 || {}), a3 = r3.__d), a3)
            return r3.__E = r3;
        } catch (n4) {
          e3 = n4;
        }
    throw e3;
  } }, p2 = 0, H2.prototype.setState = function(e3, n3) {
    var t3;
    t3 = null != this.__s && this.__s !== this.state ? this.__s : this.__s = k2({}, this.state), "function" == typeof e3 && (e3 = e3(k2({}, t3), this.props)), e3 && k2(t3, e3), null != e3 && this.__v && (n3 && this._sb.push(n3), M2(this));
  }, H2.prototype.forceUpdate = function(e3) {
    this.__v && (this.__e = true, e3 && this.__h.push(e3), M2(this));
  }, H2.prototype.render = T2, _2 = [], v2 = "function" == typeof Promise ? Promise.prototype.then.bind(Promise.resolve()) : setTimeout, h2 = function(e3, n3) {
    return e3.__v.__b - n3.__v.__b;
  }, I2.__r = 0, g2 = 0;
  var z2 = a2, Y2 = c2, G2 = "seenSurvey_", X2 = (e3) => '\n          .survey-form, .thank-you-message {\n              position: fixed;\n              margin: 0px;\n              bottom: 0px;\n              color: black;\n              font-weight: normal;\n              font-family: -apple-system, BlinkMacSystemFont, "Inter", "Segoe UI", "Roboto", Helvetica, Arial, sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol";\n              text-align: left;\n              max-width: '.concat(parseInt((null == e3 ? void 0 : e3.maxWidth) || "300"), "px;\n              width: 100%;\n              z-index: ").concat(parseInt((null == e3 ? void 0 : e3.zIndex) || "99999"), ";\n              border: 1.5px solid ").concat((null == e3 ? void 0 : e3.borderColor) || "#c9c6c6", ";\n              border-bottom: 0px;\n              ").concat({ left: "left: 30px;", right: "right: 30px;", center: "\n            left: 50%;\n            transform: translateX(-50%);\n          " }[(null == e3 ? void 0 : e3.position) || "right"] || "right: 30px;", "\n              flex-direction: column;\n              background: ").concat((null == e3 ? void 0 : e3.backgroundColor) || "#eeeded", ';\n              border-top-left-radius: 10px;\n              border-top-right-radius: 10px;\n              box-shadow: -6px 0 16px -8px rgb(0 0 0 / 8%), -9px 0 28px 0 rgb(0 0 0 / 5%), -12px 0 48px 16px rgb(0 0 0 / 3%);\n          }\n          \n          .survey-box, .thank-you-message-container {\n              padding: 20px 25px 10px;\n              display: flex;\n              flex-direction: column;\n              border-radius: 10px;\n          }\n\n          .thank-you-message {\n              text-align: center;\n          }\n\n          .form-submit[disabled] {\n              opacity: 0.6;\n              filter: grayscale(50%);\n              cursor: not-allowed;\n          }\n          .survey-form textarea {\n              color: #2d2d2d;\n              font-size: 14px;\n              font-family: -apple-system, BlinkMacSystemFont, "Inter", "Segoe UI", "Roboto", Helvetica, Arial, sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol";\n              background: white;\n              color: black;\n              outline: none;\n              padding-left: 10px;\n              padding-right: 10px;\n              padding-top: 10px;\n              border-radius: 6px;\n              border-color: ').concat((null == e3 ? void 0 : e3.borderColor) || "#c9c6c6", ";\n              margin-top: 14px;\n              width: 100%;\n              box-sizing: border-box;\n          }\n          .survey-box:has(.survey-question:empty):not(:has(.survey-question-description)) textarea {\n              margin-top: 0;\n          }\n          .form-submit {\n              box-sizing: border-box;\n              margin: 0;\n              font-family: inherit;\n              overflow: visible;\n              text-transform: none;\n              position: relative;\n              display: inline-block;\n              font-weight: 700;\n              white-space: nowrap;\n              text-align: center;\n              border: 1.5px solid transparent;\n              cursor: pointer;\n              user-select: none;\n              touch-action: manipulation;\n              padding: 12px;\n              font-size: 14px;\n              border-radius: 6px;\n              outline: 0;\n              background: ").concat((null == e3 ? void 0 : e3.submitButtonColor) || "black", " !important;\n              text-shadow: 0 -1px 0 rgba(0, 0, 0, 0.12);\n              box-shadow: 0 2px 0 rgba(0, 0, 0, 0.045);\n              width: 100%;\n          }\n          .form-cancel {\n              display: flex;\n              float: right;\n              border: none;\n              background: none;\n              cursor: pointer;\n          }\n          .cancel-btn-wrapper {\n              position: absolute;\n              width: 35px;\n              height: 35px;\n              border-radius: 100%;\n              top: 0;\n              right: 0;\n              transform: translate(50%, -50%);\n              background: white;\n              border: 1.5px solid ").concat((null == e3 ? void 0 : e3.borderColor) || "#c9c6c6", ";\n              display: flex;\n              justify-content: center;\n              align-items: center;\n          }\n          .bolded { font-weight: 600; }\n          .buttons {\n              display: flex;\n              justify-content: center;\n          }\n          .footer-branding {\n              font-size: 11px;\n              margin-top: 10px;\n              text-align: center;\n              display: flex;\n              justify-content: center;\n              gap: 4px;\n              align-items: center;\n              font-weight: 500;\n              background: ").concat((null == e3 ? void 0 : e3.backgroundColor) || "#eeeded", ";\n              text-decoration: none;\n              backgroundColor: ").concat((null == e3 ? void 0 : e3.backgroundColor) || "#eeeded", ";\n              color: ").concat(K2((null == e3 ? void 0 : e3.backgroundColor) || "#eeeded"), ";\n          }\n          .survey-question {\n              font-weight: 500;\n              font-size: 14px;\n              background: ").concat((null == e3 ? void 0 : e3.backgroundColor) || "#eeeded", ";\n          }\n          .question-textarea-wrapper {\n              display: flex;\n              flex-direction: column;\n          }\n          .survey-question-description {\n              font-size: 13px;\n              padding-top: 5px;\n              background: ").concat((null == e3 ? void 0 : e3.backgroundColor) || "#eeeded", ";\n          }\n          .ratings-number {\n              font-size: 16px;\n              font-weight: 600;\n              padding: 8px 0px;\n              border: none;\n          }\n          .ratings-number:hover {\n              cursor: pointer;\n          }\n          .rating-options {\n              margin-top: 14px;\n          }\n          .rating-options-number {\n              display: grid;\n              border-radius: 6px;\n              overflow: hidden;\n              border: 1.5px solid ").concat((null == e3 ? void 0 : e3.borderColor) || "#c9c6c6", ";\n          }\n          .rating-options-number > .ratings-number {\n              border-right: 1px solid ").concat((null == e3 ? void 0 : e3.borderColor) || "#c9c6c6", ";\n          }\n          .rating-options-number > .ratings-number:last-of-type {\n              border-right: 0px;\n          }\n          .rating-options-number .rating-active {\n              background: ").concat((null == e3 ? void 0 : e3.ratingButtonActiveColor) || "black", ";\n          }\n          .rating-options-emoji {\n              display: flex;\n              justify-content: space-between;\n          }\n          .ratings-emoji {\n              font-size: 16px;\n              background-color: transparent;\n              border: none;\n              padding: 0px;\n          }\n          .ratings-emoji:hover {\n              cursor: pointer;\n          }\n          .ratings-emoji.rating-active svg {\n              fill: ").concat((null == e3 ? void 0 : e3.ratingButtonActiveColor) || "black", ";\n          }\n          .emoji-svg {\n              fill: '#939393';\n          }\n          .rating-text {\n              display: flex;\n              flex-direction: row;\n              font-size: 11px;\n              justify-content: space-between;\n              margin-top: 6px;\n              background: ").concat((null == e3 ? void 0 : e3.backgroundColor) || "#eeeded", ";\n              opacity: .60;\n          }\n          .multiple-choice-options {\n              margin-top: 13px;\n              font-size: 14px;\n          }\n          .survey-box:has(.survey-question:empty):not(:has(.survey-question-description)) .multiple-choice-options {\n              margin-top: 0;\n          }\n          .multiple-choice-options .choice-option {\n              display: flex;\n              align-items: center;\n              gap: 4px;\n              font-size: 13px;\n              cursor: pointer;\n              margin-bottom: 5px;\n              position: relative;\n          }\n          .multiple-choice-options > .choice-option:last-of-type {\n              margin-bottom: 0px;\n          }\n          .multiple-choice-options input {\n              cursor: pointer;\n              position: absolute;\n              opacity: 0;\n          }\n          .choice-check {\n              position: absolute;\n              right: 10px;\n              background: white;\n          }\n          .choice-check svg {\n              display: none;\n          }\n          .multiple-choice-options .choice-option:hover .choice-check svg {\n              display: inline-block;\n              opacity: .25;\n          }\n          .multiple-choice-options input:checked + label + .choice-check svg {\n              display: inline-block;\n              opacity: 100% !important;\n          }\n          .multiple-choice-options input:checked + label {\n              font-weight: bold;\n              border: 1.5px solid rgba(0,0,0);\n          }\n          .multiple-choice-options input:checked + label input {\n              font-weight: bold;\n          }\n          .multiple-choice-options label {\n              width: 100%;\n              cursor: pointer;\n              padding: 10px;\n              border: 1.5px solid rgba(0,0,0,.25);\n              border-radius: 4px;\n              background: white;\n          }\n          .multiple-choice-options .choice-option-open label {\n              padding-right: 30px;\n              display: flex;\n              flex-wrap: wrap;\n              gap: 8px;\n              max-width: 100%;\n          }\n          .multiple-choice-options .choice-option-open label span {\n              width: 100%;\n          }\n          .multiple-choice-options .choice-option-open input:disabled + label {\n              opacity: 0.6;\n          }\n          .multiple-choice-options .choice-option-open label input {\n              position: relative;\n              opacity: 1;\n              flex-grow: 1;\n              border: 0;\n              outline: 0;\n          }\n          .thank-you-message-body {\n              margin-top: 6px;\n              font-size: 14px;\n              background: ").concat((null == e3 ? void 0 : e3.backgroundColor) || "#eeeded", ";\n          }\n          .thank-you-message-header {\n              margin: 10px 0px 0px;\n              background: ").concat((null == e3 ? void 0 : e3.backgroundColor) || "#eeeded", ";\n          }\n          .thank-you-message-container .form-submit {\n              margin-top: 20px;\n              margin-bottom: 10px;\n          }\n          .thank-you-message-countdown {\n              margin-left: 6px;\n          }\n          .bottom-section {\n              margin-top: 14px;\n          }\n          ");
  function J2(e3) {
    if ("#" === e3[0]) {
      var n3 = e3.replace(/^#/, "");
      return "rgb(" + parseInt(n3.slice(0, 2), 16) + "," + parseInt(n3.slice(2, 4), 16) + "," + parseInt(n3.slice(4, 6), 16) + ")";
    }
    return "rgb(255, 255, 255)";
  }
  function K2() {
    var e3, n3 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : ne2;
    "#" === n3[0] && (e3 = J2(n3)), n3.startsWith("rgb") && (e3 = n3);
    var t3 = { aliceblue: "#f0f8ff", antiquewhite: "#faebd7", aqua: "#00ffff", aquamarine: "#7fffd4", azure: "#f0ffff", beige: "#f5f5dc", bisque: "#ffe4c4", black: "#000000", blanchedalmond: "#ffebcd", blue: "#0000ff", blueviolet: "#8a2be2", brown: "#a52a2a", burlywood: "#deb887", cadetblue: "#5f9ea0", chartreuse: "#7fff00", chocolate: "#d2691e", coral: "#ff7f50", cornflowerblue: "#6495ed", cornsilk: "#fff8dc", crimson: "#dc143c", cyan: "#00ffff", darkblue: "#00008b", darkcyan: "#008b8b", darkgoldenrod: "#b8860b", darkgray: "#a9a9a9", darkgreen: "#006400", darkkhaki: "#bdb76b", darkmagenta: "#8b008b", darkolivegreen: "#556b2f", darkorange: "#ff8c00", darkorchid: "#9932cc", darkred: "#8b0000", darksalmon: "#e9967a", darkseagreen: "#8fbc8f", darkslateblue: "#483d8b", darkslategray: "#2f4f4f", darkturquoise: "#00ced1", darkviolet: "#9400d3", deeppink: "#ff1493", deepskyblue: "#00bfff", dimgray: "#696969", dodgerblue: "#1e90ff", firebrick: "#b22222", floralwhite: "#fffaf0", forestgreen: "#228b22", fuchsia: "#ff00ff", gainsboro: "#dcdcdc", ghostwhite: "#f8f8ff", gold: "#ffd700", goldenrod: "#daa520", gray: "#808080", green: "#008000", greenyellow: "#adff2f", honeydew: "#f0fff0", hotpink: "#ff69b4", "indianred ": "#cd5c5c", indigo: "#4b0082", ivory: "#fffff0", khaki: "#f0e68c", lavender: "#e6e6fa", lavenderblush: "#fff0f5", lawngreen: "#7cfc00", lemonchiffon: "#fffacd", lightblue: "#add8e6", lightcoral: "#f08080", lightcyan: "#e0ffff", lightgoldenrodyellow: "#fafad2", lightgrey: "#d3d3d3", lightgreen: "#90ee90", lightpink: "#ffb6c1", lightsalmon: "#ffa07a", lightseagreen: "#20b2aa", lightskyblue: "#87cefa", lightslategray: "#778899", lightsteelblue: "#b0c4de", lightyellow: "#ffffe0", lime: "#00ff00", limegreen: "#32cd32", linen: "#faf0e6", magenta: "#ff00ff", maroon: "#800000", mediumaquamarine: "#66cdaa", mediumblue: "#0000cd", mediumorchid: "#ba55d3", mediumpurple: "#9370d8", mediumseagreen: "#3cb371", mediumslateblue: "#7b68ee", mediumspringgreen: "#00fa9a", mediumturquoise: "#48d1cc", mediumvioletred: "#c71585", midnightblue: "#191970", mintcream: "#f5fffa", mistyrose: "#ffe4e1", moccasin: "#ffe4b5", navajowhite: "#ffdead", navy: "#000080", oldlace: "#fdf5e6", olive: "#808000", olivedrab: "#6b8e23", orange: "#ffa500", orangered: "#ff4500", orchid: "#da70d6", palegoldenrod: "#eee8aa", palegreen: "#98fb98", paleturquoise: "#afeeee", palevioletred: "#d87093", papayawhip: "#ffefd5", peachpuff: "#ffdab9", peru: "#cd853f", pink: "#ffc0cb", plum: "#dda0dd", powderblue: "#b0e0e6", purple: "#800080", red: "#ff0000", rosybrown: "#bc8f8f", royalblue: "#4169e1", saddlebrown: "#8b4513", salmon: "#fa8072", sandybrown: "#f4a460", seagreen: "#2e8b57", seashell: "#fff5ee", sienna: "#a0522d", silver: "#c0c0c0", skyblue: "#87ceeb", slateblue: "#6a5acd", slategray: "#708090", snow: "#fffafa", springgreen: "#00ff7f", steelblue: "#4682b4", tan: "#d2b48c", teal: "#008080", thistle: "#d8bfd8", tomato: "#ff6347", turquoise: "#40e0d0", violet: "#ee82ee", wheat: "#f5deb3", white: "#ffffff", whitesmoke: "#f5f5f5", yellow: "#ffff00", yellowgreen: "#9acd32" }[n3.toLowerCase()];
    if (t3 && (e3 = J2(t3)), !e3)
      return "black";
    var o3 = e3.match(/^rgba?\((\d+),\s*(\d+),\s*(\d+)(?:,\s*(\d+(?:\.\d+)?))?\)$/);
    if (o3) {
      var r3 = parseInt(o3[1]), i3 = parseInt(o3[2]), a3 = parseInt(o3[3]);
      return Math.sqrt(r3 * r3 * 0.299 + i3 * i3 * 0.587 + a3 * a3 * 0.114) > 127.5 ? "black" : "white";
    }
    return "black";
  }
  var ee2 = { backgroundColor: "#eeeded", submitButtonColor: "black", submitButtonTextColor: "white", ratingButtonColor: "white", ratingButtonActiveColor: "black", borderColor: "#c9c6c6", placeholder: "Start typing...", whiteLabel: false, displayThankYouMessage: true, thankYouMessageHeader: "Thank you for your feedback!", position: "right" }, ne2 = "#eeeded", te2 = function() {
    var e3, t3 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}, o3 = arguments.length > 1 ? arguments[1] : void 0, r3 = arguments.length > 2 ? arguments[2] : void 0;
    r3 && (localStorage.setItem(se2(o3), "true"), r3.capture("survey sent", n2(n2({ $survey_name: o3.name, $survey_id: o3.id, $survey_iteration: o3.current_iteration, $survey_iteration_start_date: o3.current_iteration_start_date, $survey_questions: o3.questions.map((e4) => e4.question), sessionRecordingUrl: null === (e3 = r3.get_session_replay_url) || void 0 === e3 ? void 0 : e3.call(r3) }, t3), {}, { $set: { [ce2(o3, "responded")]: true } })), z2.dispatchEvent(new Event("PHSurveySent")));
  }, oe2 = (e3, n3, t3) => {
    var o3;
    !t3 && n3 && (n3.capture("survey dismissed", { $survey_name: e3.name, $survey_id: e3.id, $survey_iteration: e3.current_iteration, $survey_iteration_start_date: e3.current_iteration_start_date, sessionRecordingUrl: null === (o3 = n3.get_session_replay_url) || void 0 === o3 ? void 0 : o3.call(n3), $set: { [ce2(e3, "dismissed")]: true } }), localStorage.setItem(se2(e3), "true"), z2.dispatchEvent(new Event("PHSurveyClosed")));
  }, re2 = (e3) => e3.map((e4) => ({ sort: Math.floor(10 * Math.random()), value: e4 })).sort((e4, n3) => e4.sort - n3.sort).map((e4) => e4.value), ie2 = (e3, n3) => e3.length === n3.length && e3.every((e4, t3) => e4 === n3[t3]) ? n3.reverse() : n3, ae2 = (e3) => (e3.questions.forEach((e4, n3) => {
    e4.originalQuestionIndex = n3;
  }), e3.appearance && e3.appearance.shuffleQuestions ? ie2(e3.questions, re2(e3.questions)) : e3.questions), le2 = (e3) => {
    var n3, t3;
    return !(null === (n3 = e3.conditions) || void 0 === n3 || null === (t3 = n3.events) || void 0 === t3 || !t3.repeatedActivation || !((e4) => {
      var n4, t4, o3, r3, i3, a3;
      return null != (null === (n4 = e4.conditions) || void 0 === n4 || null === (t4 = n4.events) || void 0 === t4 || null === (o3 = t4.values) || void 0 === o3 ? void 0 : o3.length) && (null === (r3 = e4.conditions) || void 0 === r3 || null === (i3 = r3.events) || void 0 === i3 || null === (a3 = i3.values) || void 0 === a3 ? void 0 : a3.length) > 0;
    })(e3));
  }, se2 = (e3) => {
    var n3 = "".concat(G2).concat(e3.id);
    return e3.current_iteration && e3.current_iteration > 0 && (n3 = "".concat(G2).concat(e3.id, "_").concat(e3.current_iteration)), n3;
  }, ce2 = (e3, n3) => {
    var t3 = "$survey_".concat(n3, "/").concat(e3.id);
    return e3.current_iteration && e3.current_iteration > 0 && (t3 = "$survey_".concat(n3, "/").concat(e3.id, "/").concat(e3.current_iteration)), t3;
  }, ue2 = function(e3, n3) {
    var t3 = { __c: n3 = "__cC" + g2++, __: e3, Consumer: function(e4, n4) {
      return e4.children(n4);
    }, Provider: function(e4) {
      var t4, o3;
      return this.getChildContext || (t4 = [], (o3 = {})[n3] = this, this.getChildContext = function() {
        return o3;
      }, this.shouldComponentUpdate = function(e5) {
        this.props.value !== e5.value && t4.some(function(e6) {
          e6.__e = true, M2(e6);
        });
      }, this.sub = function(e5) {
        t4.push(e5);
        var n4 = e5.componentWillUnmount;
        e5.componentWillUnmount = function() {
          t4.splice(t4.indexOf(e5), 1), n4 && n4.call(e5);
        };
      }), e4.children;
    } };
    return t3.Provider.__ = t3.Consumer.contextType = t3;
  }({ isPreviewMode: false, previewPageIndex: 0, handleCloseSurveyPopup: () => {
  }, isPopup: true }), de2 = (e3) => {
    var { component: n3, children: t3, renderAsHtml: o3, style: r3 } = e3;
    return $2(n3, o3 ? { dangerouslySetInnerHTML: { __html: t3 }, style: r3 } : { children: t3, style: r3 });
  }, pe2 = c2;
  var _e2, fe2, ve2, he2, ge2 = 0, ye2 = [], me2 = [], be2 = d2.__b, Ce2 = d2.__r, xe2 = d2.diffed, ke2 = d2.__c, we2 = d2.unmount;
  function Se2(e3, n3) {
    d2.__h && d2.__h(fe2, e3, ge2 || n3), ge2 = 0;
    var t3 = fe2.__H || (fe2.__H = { __: [], __h: [] });
    return e3 >= t3.__.length && t3.__.push({ __V: me2 }), t3.__[e3];
  }
  function qe2(e3) {
    return ge2 = 1, function(e4, n3, t3) {
      var o3 = Se2(_e2++, 2);
      if (o3.t = e4, !o3.__c && (o3.__ = [Ne2(void 0, n3), function(e5) {
        var n4 = o3.__N ? o3.__N[0] : o3.__[0], t4 = o3.t(n4, e5);
        n4 !== t4 && (o3.__N = [t4, o3.__[1]], o3.__c.setState({}));
      }], o3.__c = fe2, !fe2.u)) {
        var r3 = function(e5, n4, t4) {
          if (!o3.__c.__H)
            return true;
          var r4 = o3.__c.__H.__.filter(function(e6) {
            return e6.__c;
          });
          if (r4.every(function(e6) {
            return !e6.__N;
          }))
            return !i3 || i3.call(this, e5, n4, t4);
          var a4 = false;
          return r4.forEach(function(e6) {
            if (e6.__N) {
              var n5 = e6.__[0];
              e6.__ = e6.__N, e6.__N = void 0, n5 !== e6.__[0] && (a4 = true);
            }
          }), !(!a4 && o3.__c.props === e5) && (!i3 || i3.call(this, e5, n4, t4));
        };
        fe2.u = true;
        var i3 = fe2.shouldComponentUpdate, a3 = fe2.componentWillUpdate;
        fe2.componentWillUpdate = function(e5, n4, t4) {
          if (this.__e) {
            var o4 = i3;
            i3 = void 0, r3(e5, n4, t4), i3 = o4;
          }
          a3 && a3.call(this, e5, n4, t4);
        }, fe2.shouldComponentUpdate = r3;
      }
      return o3.__N || o3.__;
    }(Ne2, e3);
  }
  function Te2(e3, n3) {
    var t3 = Se2(_e2++, 3);
    !d2.__s && Ze2(t3.__H, n3) && (t3.__ = e3, t3.i = n3, fe2.__H.__h.push(t3));
  }
  function He2(e3) {
    return ge2 = 5, Pe2(function() {
      return { current: e3 };
    }, []);
  }
  function Pe2(e3, n3) {
    var t3 = Se2(_e2++, 7);
    return Ze2(t3.__H, n3) ? (t3.__V = e3(), t3.i = n3, t3.__h = e3, t3.__V) : t3.__;
  }
  function Le2(e3) {
    var n3 = fe2.context[e3.__c], t3 = Se2(_e2++, 9);
    return t3.c = e3, n3 ? (null == t3.__ && (t3.__ = true, n3.sub(fe2)), n3.props.value) : e3.__;
  }
  function Me2() {
    for (var e3; e3 = ye2.shift(); )
      if (e3.__P && e3.__H)
        try {
          e3.__H.__h.forEach(De2), e3.__H.__h.forEach(Fe2), e3.__H.__h = [];
        } catch (n3) {
          e3.__H.__h = [], d2.__e(n3, e3.__v);
        }
  }
  d2.__b = function(e3) {
    fe2 = null, be2 && be2(e3);
  }, d2.__r = function(e3) {
    Ce2 && Ce2(e3), _e2 = 0;
    var n3 = (fe2 = e3.__c).__H;
    n3 && (ve2 === fe2 ? (n3.__h = [], fe2.__h = [], n3.__.forEach(function(e4) {
      e4.__N && (e4.__ = e4.__N), e4.__V = me2, e4.__N = e4.i = void 0;
    })) : (n3.__h.forEach(De2), n3.__h.forEach(Fe2), n3.__h = [], _e2 = 0)), ve2 = fe2;
  }, d2.diffed = function(e3) {
    xe2 && xe2(e3);
    var n3 = e3.__c;
    n3 && n3.__H && (n3.__H.__h.length && (1 !== ye2.push(n3) && he2 === d2.requestAnimationFrame || ((he2 = d2.requestAnimationFrame) || Ee2)(Me2)), n3.__H.__.forEach(function(e4) {
      e4.i && (e4.__H = e4.i), e4.__V !== me2 && (e4.__ = e4.__V), e4.i = void 0, e4.__V = me2;
    })), ve2 = fe2 = null;
  }, d2.__c = function(e3, n3) {
    n3.some(function(e4) {
      try {
        e4.__h.forEach(De2), e4.__h = e4.__h.filter(function(e5) {
          return !e5.__ || Fe2(e5);
        });
      } catch (t3) {
        n3.some(function(e5) {
          e5.__h && (e5.__h = []);
        }), n3 = [], d2.__e(t3, e4.__v);
      }
    }), ke2 && ke2(e3, n3);
  }, d2.unmount = function(e3) {
    we2 && we2(e3);
    var n3, t3 = e3.__c;
    t3 && t3.__H && (t3.__H.__.forEach(function(e4) {
      try {
        De2(e4);
      } catch (e5) {
        n3 = e5;
      }
    }), t3.__H = void 0, n3 && d2.__e(n3, t3.__v));
  };
  var Ie2 = "function" == typeof requestAnimationFrame;
  function Ee2(e3) {
    var n3, t3 = function() {
      clearTimeout(o3), Ie2 && cancelAnimationFrame(n3), setTimeout(e3);
    }, o3 = setTimeout(t3, 100);
    Ie2 && (n3 = requestAnimationFrame(t3));
  }
  function De2(e3) {
    var n3 = fe2, t3 = e3.__c;
    "function" == typeof t3 && (e3.__c = void 0, t3()), fe2 = n3;
  }
  function Fe2(e3) {
    var n3 = fe2;
    e3.__c = e3.__(), fe2 = n3;
  }
  function Ze2(e3, n3) {
    return !e3 || e3.length !== n3.length || n3.some(function(n4, t3) {
      return n4 !== e3[t3];
    });
  }
  function Ne2(e3, n3) {
    return "function" == typeof n3 ? n3(e3) : n3;
  }
  var Ae2, Ve2 = (e3) => {
    var n3 = { _log: function(n4) {
      if (a2 && y2.POSTHOG_DEBUG && !We2(a2.console) && a2.console) {
        for (var t3 = ("__rrweb_original__" in a2.console[n4]) ? a2.console[n4].__rrweb_original__ : a2.console[n4], o3 = arguments.length, r3 = new Array(o3 > 1 ? o3 - 1 : 0), i3 = 1; i3 < o3; i3++)
          r3[i3 - 1] = arguments[i3];
        t3(e3, ...r3);
      }
    }, info: function() {
      for (var e4 = arguments.length, t3 = new Array(e4), o3 = 0; o3 < e4; o3++)
        t3[o3] = arguments[o3];
      n3._log("log", ...t3);
    }, warn: function() {
      for (var e4 = arguments.length, t3 = new Array(e4), o3 = 0; o3 < e4; o3++)
        t3[o3] = arguments[o3];
      n3._log("warn", ...t3);
    }, error: function() {
      for (var e4 = arguments.length, t3 = new Array(e4), o3 = 0; o3 < e4; o3++)
        t3[o3] = arguments[o3];
      n3._log("error", ...t3);
    }, critical: function() {
      for (var n4 = arguments.length, t3 = new Array(n4), o3 = 0; o3 < n4; o3++)
        t3[o3] = arguments[o3];
      console.error(e3, ...t3);
    }, uninitializedWarning: (e4) => {
      n3.error("You must initialize PostHog before calling ".concat(e4));
    }, createLogger: (n4) => Ve2("".concat(e3, " ").concat(n4)) };
    return n3;
  }, Be2 = Ve2("[PostHog.js]").createLogger;
  !function(e3) {
    e3.GZipJS = "gzip-js", e3.Base64 = "base64";
  }(Ae2 || (Ae2 = {}));
  var Oe2 = Array.isArray, Qe2 = Object.prototype.toString, je2 = Oe2 || function(e3) {
    return "[object Array]" === Qe2.call(e3);
  }, We2 = (e3) => void 0 === e3, Ue2 = (e3) => null === e3, Re2 = (e3) => "[object Number]" == Qe2.call(e3), $e2 = 0;
  function ze2(e3, n3, t3, o3, r3, i3) {
    var a3, l3, s3 = {};
    for (l3 in n3)
      "ref" == l3 ? a3 = n3[l3] : s3[l3] = n3[l3];
    var c3 = { type: e3, props: s3, key: t3, ref: a3, __k: null, __: null, __b: 0, __e: null, __d: void 0, __c: null, constructor: void 0, __v: --$e2, __i: -1, __u: 0, __source: r3, __self: i3 };
    if ("function" == typeof e3 && (a3 = e3.defaultProps))
      for (l3 in a3)
        void 0 === s3[l3] && (s3[l3] = a3[l3]);
    return d2.vnode && d2.vnode(c3), c3;
  }
  var Ye2 = ze2("svg", { className: "emoji-svg", xmlns: "http://www.w3.org/2000/svg", height: "48", viewBox: "0 -960 960 960", width: "48", children: ze2("path", { d: "M626-533q22.5 0 38.25-15.75T680-587q0-22.5-15.75-38.25T626-641q-22.5 0-38.25 15.75T572-587q0 22.5 15.75 38.25T626-533Zm-292 0q22.5 0 38.25-15.75T388-587q0-22.5-15.75-38.25T334-641q-22.5 0-38.25 15.75T280-587q0 22.5 15.75 38.25T334-533Zm146 272q66 0 121.5-35.5T682-393h-52q-23 40-63 61.5T480.5-310q-46.5 0-87-21T331-393h-53q26 61 81 96.5T480-261Zm0 181q-83 0-156-31.5T197-197q-54-54-85.5-127T80-480q0-83 31.5-156T197-763q54-54 127-85.5T480-880q83 0 156 31.5T763-763q54 54 85.5 127T880-480q0 83-31.5 156T763-197q-54 54-127 85.5T480-80Zm0-400Zm0 340q142.375 0 241.188-98.812Q820-337.625 820-480t-98.812-241.188Q622.375-820 480-820t-241.188 98.812Q140-622.375 140-480t98.812 241.188Q337.625-140 480-140Z" }) }), Ge2 = ze2("svg", { className: "emoji-svg", xmlns: "http://www.w3.org/2000/svg", height: "48", viewBox: "0 -960 960 960", width: "48", children: ze2("path", { d: "M626-533q22.5 0 38.25-15.75T680-587q0-22.5-15.75-38.25T626-641q-22.5 0-38.25 15.75T572-587q0 22.5 15.75 38.25T626-533Zm-292 0q22.5 0 38.25-15.75T388-587q0-22.5-15.75-38.25T334-641q-22.5 0-38.25 15.75T280-587q0 22.5 15.75 38.25T334-533Zm20 194h253v-49H354v49ZM480-80q-83 0-156-31.5T197-197q-54-54-85.5-127T80-480q0-83 31.5-156T197-763q54-54 127-85.5T480-880q83 0 156 31.5T763-763q54 54 85.5 127T880-480q0 83-31.5 156T763-197q-54 54-127 85.5T480-80Zm0-400Zm0 340q142.375 0 241.188-98.812Q820-337.625 820-480t-98.812-241.188Q622.375-820 480-820t-241.188 98.812Q140-622.375 140-480t98.812 241.188Q337.625-140 480-140Z" }) }), Xe2 = ze2("svg", { className: "emoji-svg", xmlns: "http://www.w3.org/2000/svg", height: "48", viewBox: "0 -960 960 960", width: "48", children: ze2("path", { d: "M626-533q22.5 0 38.25-15.75T680-587q0-22.5-15.75-38.25T626-641q-22.5 0-38.25 15.75T572-587q0 22.5 15.75 38.25T626-533Zm-292 0q22.5 0 38.25-15.75T388-587q0-22.5-15.75-38.25T334-641q-22.5 0-38.25 15.75T280-587q0 22.5 15.75 38.25T334-533Zm146.174 116Q413-417 358.5-379.5T278-280h53q22-42 62.173-65t87.5-23Q528-368 567.5-344.5T630-280h52q-25-63-79.826-100-54.826-37-122-37ZM480-80q-83 0-156-31.5T197-197q-54-54-85.5-127T80-480q0-83 31.5-156T197-763q54-54 127-85.5T480-880q83 0 156 31.5T763-763q54 54 85.5 127T880-480q0 83-31.5 156T763-197q-54 54-127 85.5T480-80Zm0-400Zm0 340q142.375 0 241.188-98.812Q820-337.625 820-480t-98.812-241.188Q622.375-820 480-820t-241.188 98.812Q140-622.375 140-480t98.812 241.188Q337.625-140 480-140Z" }) }), Je2 = ze2("svg", { className: "emoji-svg", xmlns: "http://www.w3.org/2000/svg", height: "48", viewBox: "0 -960 960 960", width: "48", children: ze2("path", { d: "M480-417q-67 0-121.5 37.5T278-280h404q-25-63-80-100t-122-37Zm-183-72 50-45 45 45 31-36-45-45 45-45-31-36-45 45-50-45-31 36 45 45-45 45 31 36Zm272 0 44-45 51 45 31-36-45-45 45-45-31-36-51 45-44-45-31 36 44 45-44 45 31 36ZM480-80q-83 0-156-31.5T197-197q-54-54-85.5-127T80-480q0-83 31.5-156T197-763q54-54 127-85.5T480-880q83 0 156 31.5T763-763q54 54 85.5 127T880-480q0 83-31.5 156T763-197q-54 54-127 85.5T480-80Zm0-400Zm0 340q142 0 241-99t99-241q0-142-99-241t-241-99q-142 0-241 99t-99 241q0 142 99 241t241 99Z" }) }), Ke2 = ze2("svg", { className: "emoji-svg", xmlns: "http://www.w3.org/2000/svg", height: "48", viewBox: "0 -960 960 960", width: "48", children: ze2("path", { d: "M479.504-261Q537-261 585.5-287q48.5-26 78.5-72.4 6-11.6-.75-22.6-6.75-11-20.25-11H316.918Q303-393 296.5-382t-.5 22.6q30 46.4 78.5 72.4 48.5 26 105.004 26ZM347-578l27 27q7.636 8 17.818 8Q402-543 410-551q8-8 8-18t-8-18l-42-42q-8.8-9-20.9-9-12.1 0-21.1 9l-42 42q-8 7.636-8 17.818Q276-559 284-551q8 8 18 8t18-8l27-27Zm267 0 27 27q7.714 8 18 8t18-8q8-7.636 8-17.818Q685-579 677-587l-42-42q-8.8-9-20.9-9-12.1 0-21.1 9l-42 42q-8 7.714-8 18t8 18q7.636 8 17.818 8Q579-543 587-551l27-27ZM480-80q-83 0-156-31.5T197-197q-54-54-85.5-127T80-480q0-83 31.5-156T197-763q54-54 127-85.5T480-880q83 0 156 31.5T763-763q54 54 85.5 127T880-480q0 83-31.5 156T763-197q-54 54-127 85.5T480-80Zm0-400Zm0 340q142.375 0 241.188-98.812Q820-337.625 820-480t-98.812-241.188Q622.375-820 480-820t-241.188 98.812Q140-622.375 140-480t98.812 241.188Q337.625-140 480-140Z" }) }), en2 = ze2("svg", { width: "12", height: "12", viewBox: "0 0 12 12", fill: "none", xmlns: "http://www.w3.org/2000/svg", children: ze2("path", { "fill-rule": "evenodd", "clip-rule": "evenodd", d: "M0.164752 0.164752C0.384422 -0.0549175 0.740578 -0.0549175 0.960248 0.164752L6 5.20451L11.0398 0.164752C11.2594 -0.0549175 11.6156 -0.0549175 11.8352 0.164752C12.0549 0.384422 12.0549 0.740578 11.8352 0.960248L6.79549 6L11.8352 11.0398C12.0549 11.2594 12.0549 11.6156 11.8352 11.8352C11.6156 12.0549 11.2594 12.0549 11.0398 11.8352L6 6.79549L0.960248 11.8352C0.740578 12.0549 0.384422 12.0549 0.164752 11.8352C-0.0549175 11.6156 -0.0549175 11.2594 0.164752 11.0398L5.20451 6L0.164752 0.960248C-0.0549175 0.740578 -0.0549175 0.384422 0.164752 0.164752Z", fill: "black" }) }), nn2 = ze2("svg", { width: "77", height: "14", viewBox: "0 0 77 14", fill: "none", xmlns: "http://www.w3.org/2000/svg", children: [ze2("g", { "clip-path": "url(#clip0_2415_6911)", children: [ze2("mask", { id: "mask0_2415_6911", style: { maskType: "luminance" }, maskUnits: "userSpaceOnUse", x: "0", y: "0", width: "77", height: "14", children: ze2("path", { d: "M0.5 0H76.5V14H0.5V0Z", fill: "white" }) }), ze2("g", { mask: "url(#mask0_2415_6911)", children: [ze2("path", { d: "M5.77226 8.02931C5.59388 8.37329 5.08474 8.37329 4.90634 8.02931L4.4797 7.20672C4.41155 7.07535 4.41155 6.9207 4.4797 6.78933L4.90634 5.96669C5.08474 5.62276 5.59388 5.62276 5.77226 5.96669L6.19893 6.78933C6.26709 6.9207 6.26709 7.07535 6.19893 7.20672L5.77226 8.02931ZM5.77226 12.6946C5.59388 13.0386 5.08474 13.0386 4.90634 12.6946L4.4797 11.872C4.41155 11.7406 4.41155 11.586 4.4797 11.4546L4.90634 10.632C5.08474 10.288 5.59388 10.288 5.77226 10.632L6.19893 11.4546C6.26709 11.586 6.26709 11.7406 6.19893 11.872L5.77226 12.6946Z", fill: "#1D4AFF" }), ze2("path", { d: "M0.5 10.9238C0.5 10.508 1.02142 10.2998 1.32637 10.5938L3.54508 12.7327C3.85003 13.0267 3.63405 13.5294 3.20279 13.5294H0.984076C0.716728 13.5294 0.5 13.3205 0.5 13.0627V10.9238ZM0.5 8.67083C0.5 8.79459 0.551001 8.91331 0.641783 9.00081L5.19753 13.3927C5.28831 13.4802 5.41144 13.5294 5.53982 13.5294H8.0421C8.47337 13.5294 8.68936 13.0267 8.3844 12.7327L1.32637 5.92856C1.02142 5.63456 0.5 5.84278 0.5 6.25854V8.67083ZM0.5 4.00556C0.5 4.12932 0.551001 4.24802 0.641783 4.33554L10.0368 13.3927C10.1276 13.4802 10.2508 13.5294 10.3791 13.5294H12.8814C13.3127 13.5294 13.5287 13.0267 13.2237 12.7327L1.32637 1.26329C1.02142 0.969312 0.5 1.17752 0.5 1.59327V4.00556ZM5.33931 4.00556C5.33931 4.12932 5.39033 4.24802 5.4811 4.33554L14.1916 12.7327C14.4965 13.0267 15.0179 12.8185 15.0179 12.4028V9.99047C15.0179 9.86671 14.9669 9.74799 14.8762 9.66049L6.16568 1.26329C5.86071 0.969307 5.33931 1.17752 5.33931 1.59327V4.00556ZM11.005 1.26329C10.7 0.969307 10.1786 1.17752 10.1786 1.59327V4.00556C10.1786 4.12932 10.2296 4.24802 10.3204 4.33554L14.1916 8.06748C14.4965 8.36148 15.0179 8.15325 15.0179 7.7375V5.3252C15.0179 5.20144 14.9669 5.08272 14.8762 4.99522L11.005 1.26329Z", fill: "#F9BD2B" }), ze2("path", { d: "M21.0852 10.981L16.5288 6.58843C16.2238 6.29443 15.7024 6.50266 15.7024 6.91841V13.0627C15.7024 13.3205 15.9191 13.5294 16.1865 13.5294H23.2446C23.5119 13.5294 23.7287 13.3205 23.7287 13.0627V12.5032C23.7287 12.2455 23.511 12.0396 23.2459 12.0063C22.4323 11.9042 21.6713 11.546 21.0852 10.981ZM18.0252 12.0365C17.5978 12.0365 17.251 11.7021 17.251 11.2901C17.251 10.878 17.5978 10.5436 18.0252 10.5436C18.4527 10.5436 18.7996 10.878 18.7996 11.2901C18.7996 11.7021 18.4527 12.0365 18.0252 12.0365Z", fill: "currentColor" }), ze2("path", { d: "M0.5 13.0627C0.5 13.3205 0.716728 13.5294 0.984076 13.5294H3.20279C3.63405 13.5294 3.85003 13.0267 3.54508 12.7327L1.32637 10.5938C1.02142 10.2998 0.5 10.508 0.5 10.9238V13.0627ZM5.33931 5.13191L1.32637 1.26329C1.02142 0.969306 0.5 1.17752 0.5 1.59327V4.00556C0.5 4.12932 0.551001 4.24802 0.641783 4.33554L5.33931 8.86412V5.13191ZM1.32637 5.92855C1.02142 5.63455 0.5 5.84278 0.5 6.25853V8.67083C0.5 8.79459 0.551001 8.91331 0.641783 9.00081L5.33931 13.5294V9.79717L1.32637 5.92855Z", fill: "#1D4AFF" }), ze2("path", { d: "M10.1787 5.3252C10.1787 5.20144 10.1277 5.08272 10.0369 4.99522L6.16572 1.26329C5.8608 0.969306 5.33936 1.17752 5.33936 1.59327V4.00556C5.33936 4.12932 5.39037 4.24802 5.48114 4.33554L10.1787 8.86412V5.3252ZM5.33936 13.5294H8.04214C8.47341 13.5294 8.6894 13.0267 8.38443 12.7327L5.33936 9.79717V13.5294ZM5.33936 5.13191V8.67083C5.33936 8.79459 5.39037 8.91331 5.48114 9.00081L10.1787 13.5294V9.99047C10.1787 9.86671 10.1277 9.74803 10.0369 9.66049L5.33936 5.13191Z", fill: "#F54E00" }), ze2("path", { d: "M29.375 11.6667H31.3636V8.48772H33.0249C34.8499 8.48772 36.0204 7.4443 36.0204 5.83052C36.0204 4.21681 34.8499 3.17334 33.0249 3.17334H29.375V11.6667ZM31.3636 6.84972V4.81136H32.8236C33.5787 4.81136 34.0318 5.19958 34.0318 5.83052C34.0318 6.4615 33.5787 6.84972 32.8236 6.84972H31.3636ZM39.618 11.7637C41.5563 11.7637 42.9659 10.429 42.9659 8.60905C42.9659 6.78905 41.5563 5.45438 39.618 5.45438C37.6546 5.45438 36.2701 6.78905 36.2701 8.60905C36.2701 10.429 37.6546 11.7637 39.618 11.7637ZM38.1077 8.60905C38.1077 7.63838 38.7118 6.97105 39.618 6.97105C40.5116 6.97105 41.1157 7.63838 41.1157 8.60905C41.1157 9.57972 40.5116 10.2471 39.618 10.2471C38.7118 10.2471 38.1077 9.57972 38.1077 8.60905ZM46.1482 11.7637C47.6333 11.7637 48.6402 10.8658 48.6402 9.81025C48.6402 7.33505 45.2294 8.13585 45.2294 7.16518C45.2294 6.8983 45.5189 6.72843 45.9342 6.72843C46.3622 6.72843 46.8782 6.98318 47.0418 7.54132L48.527 6.94678C48.2375 6.06105 47.1677 5.45438 45.8713 5.45438C44.4743 5.45438 43.6058 6.25518 43.6058 7.21372C43.6058 9.53118 46.9663 8.88812 46.9663 9.84665C46.9663 10.1864 46.6391 10.417 46.1482 10.417C45.4434 10.417 44.9525 9.94376 44.8015 9.3735L43.3164 9.93158C43.6436 10.8537 44.6001 11.7637 46.1482 11.7637ZM53.4241 11.606L53.2982 10.0651C53.0843 10.1743 52.8074 10.2106 52.5808 10.2106C52.1278 10.2106 51.8257 9.89523 51.8257 9.34918V7.03172H53.3612V5.55145H51.8257V3.78001H49.9755V5.55145H48.9687V7.03172H49.9755V9.57972C49.9755 11.06 51.0202 11.7637 52.3921 11.7637C52.7696 11.7637 53.122 11.7031 53.4241 11.606ZM59.8749 3.17334V6.47358H56.376V3.17334H54.3874V11.6667H56.376V8.11158H59.8749V11.6667H61.8761V3.17334H59.8749ZM66.2899 11.7637C68.2281 11.7637 69.6378 10.429 69.6378 8.60905C69.6378 6.78905 68.2281 5.45438 66.2899 5.45438C64.3265 5.45438 62.942 6.78905 62.942 8.60905C62.942 10.429 64.3265 11.7637 66.2899 11.7637ZM64.7796 8.60905C64.7796 7.63838 65.3837 6.97105 66.2899 6.97105C67.1835 6.97105 67.7876 7.63838 67.7876 8.60905C67.7876 9.57972 67.1835 10.2471 66.2899 10.2471C65.3837 10.2471 64.7796 9.57972 64.7796 8.60905ZM73.2088 11.4725C73.901 11.4725 74.5177 11.242 74.845 10.8416V11.424C74.845 12.1034 74.2786 12.5767 73.4102 12.5767C72.7935 12.5767 72.2523 12.2854 72.1642 11.788L70.4776 12.0428C70.7042 13.1955 71.925 13.972 73.4102 13.972C75.361 13.972 76.6574 12.8679 76.6574 11.2298V5.55145H74.8324V6.07318C74.4926 5.69705 73.9136 5.45438 73.171 5.45438C71.409 5.45438 70.3014 6.61918 70.3014 8.46345C70.3014 10.3077 71.409 11.4725 73.2088 11.4725ZM72.1012 8.46345C72.1012 7.55345 72.655 6.97105 73.5109 6.97105C74.3793 6.97105 74.9331 7.55345 74.9331 8.46345C74.9331 9.37345 74.3793 9.95585 73.5109 9.95585C72.655 9.95585 72.1012 9.37345 72.1012 8.46345Z", fill: "currentColor" })] })] }), ze2("defs", { children: ze2("clipPath", { id: "clip0_2415_6911", children: ze2("rect", { width: "76", height: "14", fill: "white", transform: "translate(0.5)" }) }) })] }), tn2 = ze2("svg", { width: "16", height: "12", viewBox: "0 0 16 12", fill: "none", xmlns: "http://www.w3.org/2000/svg", children: ze2("path", { d: "M5.30769 10.6923L4.77736 11.2226C4.91801 11.3633 5.10878 11.4423 5.30769 11.4423C5.5066 11.4423 5.69737 11.3633 5.83802 11.2226L5.30769 10.6923ZM15.5303 1.53033C15.8232 1.23744 15.8232 0.762563 15.5303 0.46967C15.2374 0.176777 14.7626 0.176777 14.4697 0.46967L15.5303 1.53033ZM1.53033 5.85429C1.23744 5.56139 0.762563 5.56139 0.46967 5.85429C0.176777 6.14718 0.176777 6.62205 0.46967 6.91495L1.53033 5.85429ZM5.83802 11.2226L15.5303 1.53033L14.4697 0.46967L4.77736 10.162L5.83802 11.2226ZM0.46967 6.91495L4.77736 11.2226L5.83802 10.162L1.53033 5.85429L0.46967 6.91495Z", fill: "currentColor" }) });
  function on2() {
    return ze2("a", { href: "https://posthog.com", target: "_blank", rel: "noopener", className: "footer-branding", children: ["Survey by ", nn2] });
  }
  function rn2(e3) {
    var { text: n3, submitDisabled: t3, appearance: o3, onSubmit: r3, link: i3 } = e3, { isPreviewMode: l3, isPopup: s3 } = Le2(ue2), c3 = o3.submitButtonTextColor || K2(o3.submitButtonColor || ee2.submitButtonColor);
    return ze2("div", { className: "bottom-section", children: [ze2("div", { className: "buttons", children: ze2("button", { className: "form-submit", disabled: t3 && !l3, type: "button", style: s3 ? { color: c3 } : {}, onClick: () => {
      l3 || (i3 && (null == a2 || a2.open(i3)), r3());
    }, children: n3 }) }), !o3.whiteLabel && ze2(on2, {})] });
  }
  function an2(e3) {
    var { question: n3, description: t3, descriptionContentType: o3, backgroundColor: r3, forceDisableHtml: i3 } = e3, { isPopup: a3 } = Le2(ue2);
    return ze2("div", { style: a3 ? { backgroundColor: r3 || ee2.backgroundColor } : {}, children: [ze2("div", { className: "survey-question", children: n3 }), t3 && de2({ component: S2("div", { className: "survey-question-description" }), children: t3, renderAsHtml: !i3 && "text" !== o3 })] });
  }
  function ln2(e3) {
    var { onClick: n3 } = e3, { isPreviewMode: t3 } = Le2(ue2);
    return ze2("div", { className: "cancel-btn-wrapper", onClick: n3, disabled: t3, children: ze2("button", { className: "form-cancel", onClick: n3, disabled: t3, children: en2 }) });
  }
  function sn2(e3) {
    var { header: t3, description: o3, contentType: r3, forceDisableHtml: i3, appearance: a3, onClose: l3, styleOverrides: s3 } = e3, c3 = K2(a3.backgroundColor || ee2.backgroundColor), { isPopup: u3 } = Le2(ue2);
    return ze2(T2, { children: ze2("div", { className: "thank-you-message", style: n2({}, s3), children: ze2("div", { className: "thank-you-message-container", children: [u3 && ze2(ln2, { onClick: () => l3() }), ze2("h3", { className: "thank-you-message-header", style: { color: c3 }, children: t3 }), o3 && de2({ component: S2("div", { className: "thank-you-message-body" }), children: o3, renderAsHtml: !i3 && "text" !== r3, style: { color: c3 } }), u3 && ze2(rn2, { text: a3.thankYouMessageCloseButtonText || "Close", submitDisabled: false, appearance: a3, onSubmit: () => l3() })] }) }) });
  }
  function cn2(e3) {
    var n3, t3 = He2(null), [o3, r3] = qe2(null !== (n3 = e3.defaultTextColor) && void 0 !== n3 ? n3 : "black");
    return Te2(() => {
      if (t3.current) {
        var e4 = function(e5) {
          var n4 = z2.getComputedStyle(e5).backgroundColor;
          if ("rgba(0, 0, 0, 0)" === n4)
            return "black";
          var t4 = n4.match(/^rgba?\((\d+),\s*(\d+),\s*(\d+)(?:,\s*(\d+(?:\.\d+)?))?\)$/);
          if (!t4)
            return "black";
          var o4 = parseInt(t4[1]), r4 = parseInt(t4[2]), i3 = parseInt(t4[3]);
          return Math.sqrt(o4 * o4 * 0.299 + r4 * r4 * 0.587 + i3 * i3 * 0.114) > 127.5 ? "black" : "white";
        }(t3.current);
        r3(e4);
      }
    }, [e3.appearance, e3.forceUpdate]), { ref: t3, textColor: o3 };
  }
  function un2(e3) {
    var { question: n3, forceDisableHtml: t3, appearance: o3, onSubmit: r3 } = e3, i3 = He2(null), [a3, l3] = qe2("");
    return ze2("div", { ref: i3, children: [ze2(an2, { question: n3.question, description: n3.description, descriptionContentType: n3.descriptionContentType, backgroundColor: o3.backgroundColor, forceDisableHtml: t3 }), ze2("textarea", { rows: 4, placeholder: null == o3 ? void 0 : o3.placeholder, onInput: (e4) => l3(e4.currentTarget.value) }), ze2(rn2, { text: n3.buttonText || "Submit", submitDisabled: !a3 && !n3.optional, appearance: o3, onSubmit: () => r3(a3) })] });
  }
  function dn2(e3) {
    var { question: n3, forceDisableHtml: t3, appearance: o3, onSubmit: r3 } = e3;
    return ze2(T2, { children: [ze2(an2, { question: n3.question, description: n3.description, descriptionContentType: n3.descriptionContentType, forceDisableHtml: t3 }), ze2(rn2, { text: n3.buttonText || "Submit", submitDisabled: false, link: n3.link, appearance: o3, onSubmit: () => r3("link clicked") })] });
  }
  function pn2(e3) {
    var { question: n3, forceDisableHtml: t3, displayQuestionIndex: o3, appearance: r3, onSubmit: i3 } = e3, a3 = n3.scale, l3 = 10 === n3.scale ? 0 : 1, [s3, c3] = qe2(null);
    return ze2(T2, { children: [ze2(an2, { question: n3.question, description: n3.description, descriptionContentType: n3.descriptionContentType, forceDisableHtml: t3, backgroundColor: r3.backgroundColor }), ze2("div", { className: "rating-section", children: [ze2("div", { className: "rating-options", children: ["emoji" === n3.display && ze2("div", { className: "rating-options-emoji", children: (3 === n3.scale ? vn2 : hn2).map((e4, n4) => {
      var t4 = n4 + 1 === s3;
      return ze2("button", { className: "ratings-emoji question-".concat(o3, "-rating-").concat(n4, " ").concat(t4 ? "rating-active" : null), value: n4 + 1, type: "button", onClick: () => {
        c3(n4 + 1);
      }, style: { fill: t4 ? r3.ratingButtonActiveColor : r3.ratingButtonColor, borderColor: r3.borderColor }, children: e4 }, n4);
    }) }), "number" === n3.display && ze2("div", { className: "rating-options-number", style: { gridTemplateColumns: "repeat(".concat(a3 - l3 + 1, ", minmax(0, 1fr))") }, children: bn(n3.scale).map((e4, n4) => ze2(_n2, { displayQuestionIndex: o3, active: s3 === e4, appearance: r3, num: e4, setActiveNumber: (e5) => {
      c3(e5);
    } }, n4)) })] }), ze2("div", { className: "rating-text", children: [ze2("div", { children: n3.lowerBoundLabel }), ze2("div", { children: n3.upperBoundLabel })] })] }), ze2(rn2, { text: n3.buttonText || (null == r3 ? void 0 : r3.submitButtonText) || "Submit", submitDisabled: Ue2(s3) && !n3.optional, appearance: r3, onSubmit: () => i3(s3) })] });
  }
  function _n2(e3) {
    var { num: n3, active: t3, displayQuestionIndex: o3, appearance: r3, setActiveNumber: i3 } = e3, { textColor: a3, ref: l3 } = cn2({ appearance: r3, defaultTextColor: "black", forceUpdate: t3 });
    return ze2("button", { ref: l3, className: "ratings-number question-".concat(o3, "-rating-").concat(n3, " ").concat(t3 ? "rating-active" : null), type: "button", onClick: () => {
      i3(n3);
    }, style: { color: a3, backgroundColor: t3 ? r3.ratingButtonActiveColor : r3.ratingButtonColor, borderColor: r3.borderColor }, children: n3 });
  }
  function fn2(e3) {
    var { question: n3, forceDisableHtml: t3, displayQuestionIndex: o3, appearance: i3, onSubmit: a3 } = e3, l3 = He2(null), s3 = Pe2(() => ((e4) => {
      if (!e4.shuffleOptions)
        return e4.choices;
      var n4 = e4.choices, t4 = "";
      e4.hasOpenChoice && (t4 = n4.pop());
      var o4 = ie2(n4, re2(n4));
      return e4.hasOpenChoice && (e4.choices.push(t4), o4.push(t4)), o4;
    })(n3), [n3]), [c3, u3] = qe2(n3.type === r2.MultipleChoice ? [] : null), [d3, p3] = qe2(false), [_3, f3] = qe2(""), v3 = n3.type === r2.SingleChoice ? "radio" : "checkbox";
    return ze2("div", { ref: l3, children: [ze2(an2, { question: n3.question, description: n3.description, descriptionContentType: n3.descriptionContentType, forceDisableHtml: t3, backgroundColor: i3.backgroundColor }), ze2("div", { className: "multiple-choice-options", children: s3.map((e4, t4) => {
      var i4 = "choice-option", a4 = e4, l4 = e4;
      return n3.hasOpenChoice && t4 === n3.choices.length - 1 && (i4 += " choice-option-open"), ze2("div", { className: i4, children: [ze2("input", { type: v3, id: "surveyQuestion".concat(o3, "Choice").concat(t4), name: "question".concat(o3), value: a4, disabled: !a4, onInput: () => n3.hasOpenChoice && t4 === n3.choices.length - 1 ? p3(!d3) : n3.type === r2.SingleChoice ? u3(a4) : n3.type === r2.MultipleChoice && je2(c3) ? c3.includes(a4) ? u3(c3.filter((e5) => e5 !== a4)) : u3([...c3, a4]) : void 0 }), ze2("label", { htmlFor: "surveyQuestion".concat(o3, "Choice").concat(t4), style: { color: "black" }, children: n3.hasOpenChoice && t4 === n3.choices.length - 1 ? ze2(T2, { children: [ze2("span", { children: [l4, ":"] }), ze2("input", { type: "text", id: "surveyQuestion".concat(o3, "Choice").concat(t4, "Open"), name: "question".concat(o3), onInput: (e5) => {
        var t5 = e5.currentTarget.value;
        return n3.type === r2.SingleChoice ? u3(t5) : n3.type === r2.MultipleChoice && je2(c3) ? f3(t5) : void 0;
      } })] }) : l4 }), ze2("span", { className: "choice-check", style: { color: "black" }, children: tn2 })] });
    }) }), ze2(rn2, { text: n3.buttonText || "Submit", submitDisabled: (Ue2(c3) || je2(c3) && !d3 && 0 === c3.length || je2(c3) && d3 && !_3 && 0 === c3.length && !n3.optional) && !n3.optional, appearance: i3, onSubmit: () => {
      d3 && n3.type === r2.MultipleChoice ? je2(c3) && a3([...c3, _3]) : a3(c3);
    } })] });
  }
  var vn2 = [Xe2, Ge2, Ye2], hn2 = [Je2, Xe2, Ge2, Ye2, Ke2], gn2 = [1, 2, 3, 4, 5], yn = [1, 2, 3, 4, 5, 6, 7], mn = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
  function bn(e3) {
    switch (e3) {
      case 5:
      default:
        return gn2;
      case 7:
        return yn;
      case 10:
        return mn;
    }
  }
  var Cn2 = Be2("[Surveys]"), xn2 = a2, kn2 = c2;
  class wn {
    constructor(e3) {
      var n3 = this;
      t2(this, "canShowNextEventBasedSurvey", () => {
        var e4, n4 = kn2.querySelectorAll("div[class^=PostHogSurvey]");
        return !(n4.length > 0) || 1 === (null === (e4 = n4[n4.length - 1].shadowRoot) || void 0 === e4 ? void 0 : e4.childElementCount);
      }), t2(this, "handlePopoverSurvey", (e4) => {
        var n4, t3 = null === (n4 = e4.conditions) || void 0 === n4 ? void 0 : n4.seenSurveyWaitPeriodInDays, o3 = localStorage.getItem("lastSeenSurveyDate");
        if (t3 && o3) {
          var r3 = /* @__PURE__ */ new Date(), i3 = Math.abs(r3.getTime() - new Date(o3).getTime());
          if (Math.ceil(i3 / 864e5) < t3)
            return;
        }
        var a3 = ((e5) => !!localStorage.getItem(se2(e5)) && !le2(e5))(e4);
        if (!a3) {
          this.addSurveyToFocus(e4.id);
          var l3 = ((e5, n5, t4) => {
            var o4 = Y2.createElement("div");
            o4.className = "PostHogSurvey".concat(n5);
            var r4 = o4.attachShadow({ mode: "open" });
            if (e5) {
              var i4 = Object.assign(Y2.createElement("style"), { innerText: e5 });
              r4.appendChild(i4);
            }
            return Y2.body.appendChild(o4), r4;
          })(X2(null == e4 ? void 0 : e4.appearance), e4.id);
          R2(ze2(qn2, { posthog: this.posthog, survey: e4, removeSurveyFromFocus: this.removeSurveyFromFocus, isPopup: true }, "popover-survey"), l3);
        }
      }), t2(this, "handleWidget", (e4) => {
        var n4 = function(e5) {
          var n5, t4 = pe2.createElement("div");
          t4.className = "PostHogWidget".concat(e5.id);
          var o3, r3 = t4.attachShadow({ mode: "open" }), i3 = (o3 = null === (n5 = e5.appearance) || void 0 === n5 ? void 0 : n5.widgetColor, "\n        .ph-survey-widget-tab {\n            position: fixed;\n            top: 50%;\n            right: 0;\n            background: ".concat(o3 || "#e0a045", ";\n            color: white;\n            transform: rotate(-90deg) translate(0, -100%);\n            transform-origin: right top;\n            min-width: 40px;\n            padding: 8px 12px;\n            font-weight: 500;\n            border-radius: 3px 3px 0 0;\n            text-align: center;\n            cursor: pointer;\n            z-index: 9999999;\n        }\n        .ph-survey-widget-tab:hover {\n            padding-bottom: 13px;\n        }\n        .ph-survey-widget-button {\n            position: fixed;\n        }\n    "));
          return r3.append(Object.assign(pe2.createElement("style"), { innerText: i3 })), pe2.body.appendChild(t4), r3;
        }(e4), t3 = X2(e4.appearance);
        n4.appendChild(Object.assign(kn2.createElement("style"), { innerText: t3 })), R2(ze2(Hn2, { posthog: this.posthog, survey: e4, removeSurveyFromFocus: this.removeSurveyFromFocus }, "feedback-survey"), n4);
      }), t2(this, "handleWidgetSelector", (e4) => {
        var n4, t3 = (null === (n4 = e4.appearance) || void 0 === n4 ? void 0 : n4.widgetSelector) && kn2.querySelector(e4.appearance.widgetSelector);
        if (t3) {
          if (0 === kn2.querySelectorAll(".PostHogWidget".concat(e4.id)).length)
            this.handleWidget(e4);
          else if (1 === kn2.querySelectorAll(".PostHogWidget".concat(e4.id)).length && !t3.getAttribute("PHWidgetSurveyClickListener")) {
            var o3, r3, i3 = null === (o3 = kn2.querySelector(".PostHogWidget".concat(e4.id))) || void 0 === o3 || null === (r3 = o3.shadowRoot) || void 0 === r3 ? void 0 : r3.querySelector(".survey-form");
            t3.addEventListener("click", () => {
              i3 && (i3.style.display = "none" === i3.style.display ? "block" : "none", i3.addEventListener("PHSurveyClosed", () => {
                this.removeSurveyFromFocus(e4.id), i3.style.display = "none";
              }));
            }), t3.setAttribute("PHWidgetSurveyClickListener", "true");
          }
        }
      }), t2(this, "canRenderSurvey", (e4) => {
        var n4 = { visible: false };
        return e4.end_date ? (n4.disabledReason = "survey was completed on ".concat(e4.end_date), n4) : e4.type != o2.Popover ? (n4.disabledReason = "Only Popover survey types can be rendered", n4) : !e4.linked_flag_key || this.posthog.featureFlags.isFeatureEnabled(e4.linked_flag_key) ? !e4.targeting_flag_key || this.posthog.featureFlags.isFeatureEnabled(e4.targeting_flag_key) ? !e4.internal_targeting_flag_key || this.posthog.featureFlags.isFeatureEnabled(e4.internal_targeting_flag_key) ? (n4.visible = true, n4) : (n4.disabledReason = "internal targeting feature flag ".concat(e4.internal_targeting_flag_key, " is false"), n4) : (n4.disabledReason = "targeting feature flag ".concat(e4.targeting_flag_key, " is false"), n4) : (n4.disabledReason = "linked feature flag ".concat(e4.linked_flag_key, " is false"), n4);
      }), t2(this, "renderSurvey", (e4, n4) => {
        R2(ze2(qn2, { posthog: this.posthog, survey: e4, removeSurveyFromFocus: this.removeSurveyFromFocus, isPopup: false }, "popover-survey"), n4);
      }), t2(this, "callSurveysAndEvaluateDisplayLogic", function() {
        var e4, t3 = arguments.length > 0 && void 0 !== arguments[0] && arguments[0];
        null === (e4 = n3.posthog) || void 0 === e4 || e4.getActiveMatchingSurveys((e5) => {
          var t4 = e5.filter((e6) => "api" !== e6.type);
          n3.sortSurveysByAppearanceDelay(t4).forEach((e6) => {
            if (Ue2(n3.surveyInFocus)) {
              var t5, r3, i3;
              if (e6.type === o2.Widget)
                "tab" === (null === (t5 = e6.appearance) || void 0 === t5 ? void 0 : t5.widgetType) && 0 === kn2.querySelectorAll(".PostHogWidget".concat(e6.id)).length && n3.handleWidget(e6), "selector" === (null === (r3 = e6.appearance) || void 0 === r3 ? void 0 : r3.widgetType) && null !== (i3 = e6.appearance) && void 0 !== i3 && i3.widgetSelector && n3.handleWidgetSelector(e6);
              e6.type === o2.Popover && n3.canShowNextEventBasedSurvey() && n3.handlePopoverSurvey(e6);
            }
          });
        }, t3);
      }), t2(this, "addSurveyToFocus", (e4) => {
        Ue2(this.surveyInFocus) || Cn2.error("Survey ".concat([...this.surveyInFocus], " already in focus. Cannot add survey ").concat(e4, ".")), this.surveyInFocus = e4;
      }), t2(this, "removeSurveyFromFocus", (e4) => {
        this.surveyInFocus !== e4 && Cn2.error("Survey ".concat(e4, " is not in focus. Cannot remove survey ").concat(e4, ".")), this.surveyInFocus = null;
      }), this.posthog = e3, this.surveyInFocus = null;
    }
    sortSurveysByAppearanceDelay(e3) {
      return e3.sort((e4, n3) => {
        var t3, o3;
        return ((null === (t3 = e4.appearance) || void 0 === t3 ? void 0 : t3.surveyPopupDelaySeconds) || 0) - ((null === (o3 = n3.appearance) || void 0 === o3 ? void 0 : o3.surveyPopupDelaySeconds) || 0);
      });
    }
    getTestAPI() {
      return { addSurveyToFocus: this.addSurveyToFocus, removeSurveyFromFocus: this.removeSurveyFromFocus, surveyInFocus: this.surveyInFocus, canShowNextEventBasedSurvey: this.canShowNextEventBasedSurvey, handleWidget: this.handleWidget, handlePopoverSurvey: this.handlePopoverSurvey, handleWidgetSelector: this.handleWidgetSelector, sortSurveysByAppearanceDelay: this.sortSurveysByAppearanceDelay };
    }
  }
  function Sn2(e3) {
    if (kn2 && xn2) {
      var n3 = new wn(e3);
      return n3.callSurveysAndEvaluateDisplayLogic(true), setInterval(() => {
        n3.callSurveysAndEvaluateDisplayLogic(false);
      }, 1e3), n3;
    }
  }
  function qn2(e3) {
    var t3, o3, r3, i3, a3, l3, { survey: s3, forceDisableHtml: c3, posthog: u3, style: d3, previewPageIndex: p3, removeSurveyFromFocus: _3, isPopup: f3 } = e3, v3 = Number.isInteger(p3), h3 = null !== (t3 = s3.appearance) && void 0 !== t3 && t3.surveyPopupDelaySeconds ? 1e3 * s3.appearance.surveyPopupDelaySeconds : 0, { isPopupVisible: g3, isSurveySent: y3, setIsPopupVisible: m3 } = function(e4, n3, t4, o4, r4) {
      var [i4, a4] = qe2(o4 || 0 === t4), [l4, s4] = qe2(false);
      return Te2(() => {
        if (!o4 && n3) {
          var i5, l5 = () => {
            r4(e4.id), a4(false);
          }, c4 = () => {
            var n4, t5;
            null !== (n4 = e4.appearance) && void 0 !== n4 && n4.displayThankYouMessage ? (s4(true), r4(e4.id), null !== (t5 = e4.appearance) && void 0 !== t5 && t5.autoDisappear && setTimeout(() => {
              a4(false);
            }, 5e3)) : (r4(e4.id), a4(false));
          }, u4 = () => {
            var t5;
            a4(true), xn2.dispatchEvent(new Event("PHSurveyShown")), n3.capture("survey shown", { $survey_name: e4.name, $survey_id: e4.id, $survey_iteration: e4.current_iteration, $survey_iteration_start_date: e4.current_iteration_start_date, sessionRecordingUrl: null === (t5 = n3.get_session_replay_url) || void 0 === t5 ? void 0 : t5.call(n3) }), localStorage.setItem("lastSeenSurveyDate", (/* @__PURE__ */ new Date()).toISOString());
          };
          return xn2.addEventListener("PHSurveyClosed", l5), xn2.addEventListener("PHSurveySent", c4), t4 > 0 ? (i5 = setTimeout(() => {
            u4();
          }, t4), () => {
            clearTimeout(i5), xn2.removeEventListener("PHSurveyClosed", l5), xn2.removeEventListener("PHSurveySent", c4);
          }) : (u4(), () => {
            xn2.removeEventListener("PHSurveyClosed", l5), xn2.removeEventListener("PHSurveySent", c4);
          });
        }
      }, []), { isPopupVisible: i4, isSurveySent: l4, setIsPopupVisible: a4 };
    }(s3, u3, h3, v3, _3), b3 = y3 || p3 === s3.questions.length, C3 = null !== (o3 = d3) && void 0 !== o3 && o3.left && Re2(null === (r3 = d3) || void 0 === r3 ? void 0 : r3.left) ? { left: d3.left - 40 } : {};
    return v3 && ((d3 = d3 || {}).left = "unset", d3.right = "unset", d3.transform = "unset"), g3 ? ze2(ue2.Provider, { value: { isPreviewMode: v3, previewPageIndex: p3, handleCloseSurveyPopup: () => oe2(s3, u3, v3), isPopup: f3 || false }, children: b3 ? ze2(sn2, { header: (null === (i3 = s3.appearance) || void 0 === i3 ? void 0 : i3.thankYouMessageHeader) || "Thank you!", description: (null === (a3 = s3.appearance) || void 0 === a3 ? void 0 : a3.thankYouMessageDescription) || "", forceDisableHtml: !!c3, contentType: null === (l3 = s3.appearance) || void 0 === l3 ? void 0 : l3.thankYouMessageDescriptionContentType, appearance: s3.appearance || ee2, styleOverrides: n2(n2({}, d3), C3), onClose: () => m3(false) }) : ze2(Tn2, { survey: s3, forceDisableHtml: !!c3, posthog: u3, styleOverrides: d3 }) }) : ze2(T2, {});
  }
  function Tn2(e3) {
    var t3, o3, { survey: r3, forceDisableHtml: a3, posthog: l3, styleOverrides: s3 } = e3, c3 = K2((null === (t3 = r3.appearance) || void 0 === t3 ? void 0 : t3.backgroundColor) || ee2.backgroundColor), [u3, d3] = qe2({}), { isPreviewMode: p3, previewPageIndex: _3, handleCloseSurveyPopup: f3, isPopup: v3 } = Le2(ue2), [h3, g3] = qe2(_3 || 0), y3 = Pe2(() => ae2(r3), [r3]);
    Te2(() => {
      g3(null != _3 ? _3 : 0);
    }, [_3]);
    return ze2("form", { className: "survey-form", style: v3 ? n2({ color: c3, borderColor: null === (o3 = r3.appearance) || void 0 === o3 ? void 0 : o3.borderColor }, s3) : {}, children: y3.map((e4, t4) => {
      var o4, { originalQuestionIndex: s4 } = e4;
      return (p3 ? h3 === s4 : h3 === t4) && ze2("div", { className: "survey-box", style: v3 ? { backgroundColor: (null === (o4 = r3.appearance) || void 0 === o4 ? void 0 : o4.backgroundColor) || ee2.backgroundColor } : {}, children: [v3 && ze2(ln2, { onClick: () => f3() }), Pn2({ question: e4, forceDisableHtml: a3, displayQuestionIndex: t4, appearance: r3.appearance || ee2, onSubmit: (e5) => ((e6) => {
        var { res: t5, originalQuestionIndex: o5, displayQuestionIndex: a4 } = e6;
        if (l3) {
          var s5 = 0 === o5 ? "$survey_response" : "$survey_response_".concat(o5);
          if (d3(n2(n2({}, u3), {}, { [s5]: t5 })), l3.getNextSurveyStep) {
            var c4 = l3.getNextSurveyStep(r3, a4, t5);
            c4 === i2.End ? te2(n2(n2({}, u3), {}, { [s5]: t5 }), r3, l3) : g3(c4);
          } else
            a4 === r3.questions.length - 1 ? te2(n2(n2({}, u3), {}, { [s5]: t5 }), r3, l3) : g3(a4 + 1);
        }
      })({ res: e5, originalQuestionIndex: s4, displayQuestionIndex: t4 }) })] });
    }) });
  }
  function Hn2(e3) {
    var n3, t3, { survey: o3, forceDisableHtml: r3, posthog: i3, readOnly: a3, removeSurveyFromFocus: l3 } = e3, [s3, c3] = qe2(false), [u3, d3] = qe2({}), p3 = He2(null);
    return Te2(() => {
      var e4, n4;
      if (!a3 && i3) {
        if ("tab" === (null === (e4 = o3.appearance) || void 0 === e4 ? void 0 : e4.widgetType) && p3.current) {
          var t4, r4 = p3.current.getBoundingClientRect(), l4 = { top: "50%", left: parseInt("".concat(r4.right - 360)), bottom: "auto", borderRadius: 10, borderBottom: "1.5px solid ".concat((null === (t4 = o3.appearance) || void 0 === t4 ? void 0 : t4.borderColor) || "#c9c6c6") };
          d3(l4);
        }
        if ("selector" === (null === (n4 = o3.appearance) || void 0 === n4 ? void 0 : n4.widgetType)) {
          var u4 = kn2.querySelector(o3.appearance.widgetSelector || "");
          null == u4 || u4.addEventListener("click", () => {
            c3(!s3);
          }), null == u4 || u4.setAttribute("PHWidgetSurveyClickListener", "true");
        }
      }
    }, []), ze2(T2, { children: ["tab" === (null === (n3 = o3.appearance) || void 0 === n3 ? void 0 : n3.widgetType) && ze2("div", { className: "ph-survey-widget-tab", ref: p3, onClick: () => !a3 && c3(!s3), style: { color: K2(o3.appearance.widgetColor) }, children: [ze2("div", { className: "ph-survey-widget-tab-icon" }), (null === (t3 = o3.appearance) || void 0 === t3 ? void 0 : t3.widgetLabel) || ""] }), s3 && ze2(qn2, { posthog: i3, survey: o3, forceDisableHtml: r3, style: u3, removeSurveyFromFocus: l3, isPopup: true }, "feedback-widget-survey")] });
  }
  var Pn2 = (e3) => {
    var { question: t3, forceDisableHtml: o3, displayQuestionIndex: i3, appearance: a3, onSubmit: l3 } = e3, s3 = { [r2.Open]: un2, [r2.Link]: dn2, [r2.Rating]: pn2, [r2.SingleChoice]: fn2, [r2.MultipleChoice]: fn2 }, c3 = { question: t3, forceDisableHtml: o3, appearance: a3, onSubmit: l3 }, u3 = { [r2.Open]: {}, [r2.Link]: {}, [r2.Rating]: { displayQuestionIndex: i3 }, [r2.SingleChoice]: { displayQuestionIndex: i3 }, [r2.MultipleChoice]: { displayQuestionIndex: i3 } }, d3 = s3[t3.type], p3 = n2(n2({}, c3), u3[t3.type]);
    return ze2(d3, n2({}, p3));
  };
  y2.__PosthogExtensions__ = y2.__PosthogExtensions__ || {}, y2.__PosthogExtensions__.canActivateRepeatedly = le2, y2.__PosthogExtensions__.generateSurveys = Sn2, y2.extendPostHogWithSurveys = Sn2;
}();
const _AnalyticsService = class _AnalyticsService {
  constructor(environment = "prod", posthogInstance = null) {
    this.currentEnvironment = environment;
    this.isEnabled = environment === "prod";
    this.isInitialized = false;
    this.posthog = posthogInstance;
    if (this.isEnabled && this.posthog) {
      console.log(
        `[AnalyticsService] Created with environment: ${environment}, Analytics enabled: ${this.isEnabled}`
      );
      this.initializePostHog();
    } else {
      console.log(`[AnalyticsService] Analytics disabled for environment: ${environment}`);
    }
  }
  static getInstance(environment = "prod", posthogInstance = null) {
    if (!_AnalyticsService.instance) {
      _AnalyticsService.instance = new _AnalyticsService(environment, posthogInstance);
    } else if (_AnalyticsService.instance.currentEnvironment !== environment) {
      _AnalyticsService.instance.updateEnvironment(environment);
    }
    return _AnalyticsService.instance;
  }
  updateEnvironment(newEnvironment) {
    if (this.currentEnvironment === newEnvironment)
      return;
    console.log(
      `[AnalyticsService] Updating environment from ${this.currentEnvironment} to ${newEnvironment}`
    );
    this.currentEnvironment = newEnvironment;
    this.isEnabled = newEnvironment === "prod";
    if (this.isEnabled && !this.isInitialized && this.posthog) {
      this.initializePostHog();
    } else if (!this.isEnabled && this.isInitialized) {
      console.log(`[AnalyticsService] Analytics disabled for environment: ${newEnvironment}`);
    }
  }
  initializePostHog() {
    if (this.isInitialized || !this.posthog)
      return;
    try {
      this.posthog.init("phc_6XNMlD21CzZTPHMbG3JXdwbxXAjGoNwVON8uyT4aHSz", {
        api_host: "https://us.i.posthog.com",
        persistence: "localStorage",
        autocapture: true,
        disable_session_recording: true,
        capture_pageview: true,
        capture_pageleave: true,
        capture_heatmaps: true,
        loaded: (posthog) => {
          posthog.register({
            full_url: window.location.href,
            domain: window.location.hostname,
            environment: this.currentEnvironment
          });
        },
        session_recording: {
          maskAllInputs: false,
          maskInputOptions: {
            password: true
          }
        }
      });
      this.isInitialized = true;
      console.log("[AnalyticsService] PostHog initialized successfully");
    } catch (error) {
      console.error("[AnalyticsService] Failed to initialize PostHog:", error);
    }
  }
  capture(eventName, properties = {}) {
    if (!this.isEnabled) {
      console.log(
        `[AnalyticsService] Event captured but not sent (disabled): ${eventName}`,
        properties
      );
      return;
    }
    if (!this.isInitialized || !this.posthog) {
      console.warn("[AnalyticsService] PostHog not initialized, cannot capture event");
      return;
    }
    try {
      const enrichedProperties = {
        ...properties,
        environment: this.currentEnvironment,
        timestamp: (/* @__PURE__ */ new Date()).toISOString()
      };
      console.log(`[AnalyticsService] Capturing event: ${eventName}`, enrichedProperties);
      this.posthog.capture(eventName, enrichedProperties);
    } catch (error) {
      console.error("[AnalyticsService] Failed to capture event:", error);
    }
  }
  getCurrentEnvironment() {
    return this.currentEnvironment;
  }
  getIsEnabled() {
    return this.isEnabled;
  }
};
__publicField(_AnalyticsService, "instance", null);
let AnalyticsService = _AnalyticsService;
const useAnalytics = () => {
  const environment = Recoil_index_20(environmentAtom);
  const analyticsService = reactExports.useMemo(() => {
    return AnalyticsService.getInstance(environment, lo);
  }, [environment]);
  const capture = reactExports.useCallback(
    (eventName, properties = {}) => {
      analyticsService.capture(eventName, properties);
    },
    [analyticsService]
  );
  const trackTabChange = reactExports.useCallback(
    (tabName, additionalProperties = {}) => {
      const properties = {
        tab_name: tabName,
        timestamp: Date.now(),
        ...additionalProperties
      };
      capture("tab_change", properties);
    },
    [capture]
  );
  return {
    capture,
    trackTabChange
  };
};
const tabStateAtom = Recoil_index_8({
  key: "tabStateAtom",
  default: {
    activeTab: "home",
    payload: null
  }
});
const activeTabSelector = Recoil_index_9({
  key: "activeTabSelector",
  get: ({ get: get2 }) => {
    const tabState = get2(tabStateAtom);
    return typeof tabState === "string" ? tabState : tabState.activeTab;
  }
});
const tabPayloadSelector = Recoil_index_9({
  key: "tabPayloadSelector",
  get: ({ get: get2 }) => {
    const tabState = get2(tabStateAtom);
    return typeof tabState === "object" ? tabState.payload : null;
  }
});
const useTabNavigation = () => {
  const activeTab = Recoil_index_20(activeTabSelector);
  const payload = Recoil_index_20(tabPayloadSelector);
  const setTabState = Recoil_index_24(tabStateAtom);
  const setActiveTab = (tabName, payload2 = null) => {
    setTabState({
      activeTab: tabName,
      payload: payload2
    });
  };
  return {
    activeTab,
    payload,
    setActiveTab
  };
};
const ConfirmModal = ({
  isOpen,
  title = "Confirm Action",
  message,
  confirmText = "Confirm",
  cancelText = "Cancel",
  confirmButtonClass = "bg-red-500 hover:bg-red-600",
  onConfirm,
  onCancel,
  disabled = false
}) => {
  if (!isOpen)
    return null;
  return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "bg-black fixed inset-0 z-50 flex items-center justify-center bg-opacity-50", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "bg-white mx-4 w-full max-w-md rounded-lg p-6 shadow-xl", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: "mb-4 text-lg font-semibold", children: title }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "mb-6 text-left text-gray-600", children: message }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex justify-end space-x-4", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        "button",
        {
          onClick: onCancel,
          className: "rounded px-4 py-2 text-gray-600 hover:bg-gray-100 hover:text-gray-800",
          disabled,
          children: cancelText
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        "button",
        {
          onClick: onConfirm,
          disabled,
          className: `text-white rounded px-4 py-2 ${confirmButtonClass} ${disabled ? "cursor-not-allowed opacity-50" : ""}`,
          children: confirmText
        }
      )
    ] })
  ] }) });
};
const baseTabs = [
  // { id: 'messages', label: 'Messages', icon: '🌐' },
  // { id: 'apiPlayground', label: 'API Playground', icon: '🧪' },
  { id: "home", label: "Home", icon: "🏠" },
  { id: "chatLabels", label: "Chat labels", icon: "💰" },
  { id: "followExpiredFans", label: "Follow expired fans", icon: "✅" },
  { id: "messageOnlineFans", label: "Message online fans", icon: "💬" },
  { id: "createRewards", label: "Create rewards", icon: "⭐️" },
  { id: "shortcuts", label: "Customize shortcut bar", icon: "💕" },
  { id: "settings", label: "Account", icon: "⚙️" }
  // { id: 'debug', label: 'Debug console', icon: '🐞' },
];
const aiRepliesTab = { id: "aiReplySuggestions", label: "AI Reply Suggestions (Beta)", icon: "✨" };
const TabNavigation = () => {
  const { activeTab, setActiveTab } = useTabNavigation();
  const [hasUnsavedChanges, setHasUnsavedChanges] = Recoil_index_22(hasUnsavedChangesAtom);
  const [showConfirmDialog, setShowConfirmDialog] = reactExports.useState(false);
  const [pendingTab, setPendingTab] = reactExports.useState(null);
  const [isClosingModal, setIsClosingModal] = reactExports.useState(false);
  Recoil_index_20(planTypeSelector);
  const [tabs, setTabs] = reactExports.useState([...baseTabs]);
  const { trackTabChange } = useAnalytics();
  const effectiveFeatureFlags = Recoil_index_20(effectiveFeatureFlagsSelector);
  reactExports.useEffect(() => {
    const handleMessage = (event) => {
      if (event.data.type === "TAB_CHANGE") {
        setActiveTab(event.data.tab);
      }
    };
    window.addEventListener("message", handleMessage);
    return () => {
      window.removeEventListener("message", handleMessage);
    };
  }, [setActiveTab]);
  reactExports.useEffect(() => {
    if (activeTab !== "home") {
      trackTabChange(activeTab);
    }
  }, [activeTab, trackTabChange]);
  reactExports.useEffect(() => {
    let updatedTabs = [...baseTabs];
    if (effectiveFeatureFlags == null ? void 0 : effectiveFeatureFlags.enableAIReplies) {
      const settingsIndex = updatedTabs.findIndex((tab2) => tab2.id === "settings");
      if (settingsIndex !== -1) {
        updatedTabs.splice(settingsIndex, 0, aiRepliesTab);
      } else {
        updatedTabs.push(aiRepliesTab);
      }
    }
    setTabs(updatedTabs);
  }, [setActiveTab, activeTab, effectiveFeatureFlags]);
  const gradientStyle = {
    background: "linear-gradient(to bottom, rgba(171, 209, 255, 0.6), rgba(219, 183, 255, 0.6))"
  };
  const handleTabClick = (tabId) => {
    if (hasUnsavedChanges) {
      setShowConfirmDialog(true);
      setPendingTab(tabId);
      return;
    }
    setActiveTab(tabId);
  };
  reactExports.useEffect(() => {
    const handleMessage = (event) => {
      if (event.data.type === "CHECK_UNSAVED_CHANGES") {
        if (hasUnsavedChanges) {
          setShowConfirmDialog(true);
          setIsClosingModal(true);
        } else {
          window.parent.postMessage({ type: "CONFIRM_CLOSE" }, "*");
        }
      }
    };
    window.addEventListener("message", handleMessage);
    return () => window.removeEventListener("message", handleMessage);
  }, [hasUnsavedChanges]);
  const handleConfirmNavigation = () => {
    setShowConfirmDialog(false);
    if (isClosingModal) {
      window.parent.postMessage({ type: "CONFIRM_CLOSE" }, "*");
      setHasUnsavedChanges(false);
      setIsClosingModal(false);
    } else if (pendingTab) {
      setActiveTab(pendingTab);
      setHasUnsavedChanges(false);
    }
    setPendingTab(null);
  };
  const handleCancelNavigation = () => {
    setShowConfirmDialog(false);
    if (isClosingModal) {
      window.parent.postMessage({ type: "CANCEL_CLOSE" }, "*");
      setIsClosingModal(false);
    }
    setPendingTab(null);
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex h-full flex-col justify-between p-6", style: gradientStyle, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex h-full flex-col", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "mb-12 flex cursor-default items-center justify-center text-left text-xl font-bold text-gray-900 md:justify-start", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: "group relative hidden md:flex", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "relative z-10 flex flex-col items-center md:items-start", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: "flex items-center", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "mr-0 text-2xl md:mr-3 md:text-xl", children: "🌶️" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: "Spicy Toolbox" })
          ] }) }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "absolute inset-0 bg-gradient-to-r from-pink-400 via-purple-400 to-indigo-400 opacity-0 blur-xl transition-all duration-500 group-hover:opacity-70" })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: "group relative flex md:hidden", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "relative z-10", children: /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "mr-0 text-2xl md:mr-3 md:text-xl", children: "🌶️" }) }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "absolute inset-0 bg-gradient-to-r from-pink-400 via-purple-400 to-indigo-400 opacity-0 blur-xl transition-all duration-500 group-hover:opacity-80" })
        ] })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("nav", { className: "flex flex-col space-y-5 text-base", children: tabs.map((tab2) => /* @__PURE__ */ jsxRuntimeExports.jsxs(
        "button",
        {
          className: `hover:bg-white flex flex-shrink items-center justify-center rounded-full border-0 p-3 text-black-spicy transition-all duration-300 hover:bg-opacity-50 md:justify-start ${activeTab === tab2.id ? "bg-white bg-opacity-50" : ""}`,
          onClick: () => handleTabClick(tab2.id),
          children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "mr-0 md:mr-2", children: tab2.icon }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "hidden whitespace-nowrap text-sm md:flex", children: tab2.label })
          ]
        },
        tab2.id
      )) })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex flex-col", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "hidden w-full flex-col items-center text-sm font-normal text-darkPurple-spicy md:flex", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "overflow-x-auto whitespace-nowrap", children: "💝 need help or have a request?" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("a", { href: "mailto:raquel@spicytoolbox.com", className: "font-bold hover:underline", children: "raquel@spicytoolbox.com" })
    ] }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      ConfirmModal,
      {
        isOpen: showConfirmDialog,
        title: "Unsaved changes",
        message: "You're about to leave this page with unsaved changes. If you leave now, any changes you've made will be permanently lost.",
        confirmText: "Leave without saving",
        cancelText: "Go back",
        onConfirm: handleConfirmNavigation,
        onCancel: handleCancelNavigation
      }
    )
  ] });
};
const aiRepliesFeatureSelector = Recoil_index_9({
  key: "aiRepliesFeatureSelector",
  get: ({ get: get2 }) => {
    const featureFlags = get2(effectiveFeatureFlagsSelector);
    const isFeatureFlagEnabled = featureFlags.enableAIReplies === true;
    if (!isFeatureFlagEnabled) {
      console.log("[aiRepliesFeatureSelector] AI Replies feature flag is disabled");
    }
    return isFeatureFlagEnabled;
  }
});
const FreeTrialDisabledFeatureWrapper = ({ children }) => {
  const planType = Recoil_index_20(planTypeSelector);
  const { activeTab, setActiveTab } = useTabNavigation();
  const [showModal, setShowModal] = reactExports.useState(false);
  const restrictedTabs = [
    "chatLabels",
    "followExpiredFans",
    "messageOnlineFans",
    "shortcuts",
    "aiReplySuggestions",
    "createRewards"
  ];
  reactExports.useEffect(() => {
    if (planType === "free" && restrictedTabs.includes(activeTab)) {
      setShowModal(true);
    }
  }, [activeTab, planType]);
  const handleUpgrade = reactExports.useCallback(() => {
    setActiveTab("upgradeToPaid", {
      is_upgrade: true,
      back_button_tab: activeTab
    });
    setShowModal(false);
  }, [activeTab, setActiveTab, setShowModal]);
  const handleCancel = () => {
    setShowModal(false);
  };
  if (planType === "free") {
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        "div",
        {
          className: "pointer-events-none cursor-not-allowed opacity-50",
          onClick: () => setShowModal(true),
          children
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        ConfirmModal,
        {
          isOpen: showModal,
          onConfirm: handleUpgrade,
          onCancel: handleCancel,
          title: "Upgrade to unlock this feature 💕",
          message: `You're currently on the free plan! To access this feature, subscribe to the paid plan ☺️`,
          confirmText: "Learn more ✨",
          cancelText: "Maybe later 💔",
          confirmButtonClass: "bg-indigo-500 hover:bg-indigo-600"
        }
      )
    ] });
  }
  return children;
};
let lastShowComponent$1 = null;
let lastErrorShowComponent = null;
const useInAppBanner = () => {
  const setBannerState = Recoil_index_24(inAppBannerAtom);
  const showBanner = (message, componentId2) => {
    console.log("[useInAppBanner] Showing banner", { message, componentId: componentId2 });
    lastShowComponent$1 = componentId2;
    setBannerState({
      isVisible: true,
      message,
      componentId: componentId2
    });
    window.parent.postMessage({ type: "SPICY_BANNER_SHOW" }, "*");
    console.log("[useInAppBanner] Banner shown");
  };
  const showErrorBanner = (message, componentId2) => {
    console.log("[useInAppBanner] Showing error banner", {
      message,
      componentId: componentId2
    });
    lastErrorShowComponent = componentId2;
    setBannerState({
      isVisible: true,
      message,
      componentId: componentId2,
      isError: true
    });
    window.parent.postMessage({ type: "SPICY_ERROR_BANNER_SHOW" }, "*");
    console.log("[useInAppBanner] Error banner shown");
  };
  const hideBanner = (componentId2) => {
    console.log("[useInAppBanner] Attempting to hide banner", {
      componentId: componentId2,
      lastShowComponent: lastShowComponent$1
    });
    if (!componentId2 || componentId2 === lastShowComponent$1) {
      setBannerState({
        isVisible: false,
        message: "",
        componentId: null
      });
      window.parent.postMessage({ type: "SPICY_BANNER_HIDE" }, "*");
      window.parent.postMessage({ type: "SPICY_ERROR_BANNER_HIDE" }, "*");
      lastShowComponent$1 = null;
      console.log("[useInAppBanner] Banner hidden");
    } else {
      console.log(
        "[useInAppBanner] Skip hiding banner - component ID mismatch"
      );
    }
  };
  const hideErrorBanner = (componentId2) => {
    console.log("[useInAppBanner] Attempting to hide error banner", {
      componentId: componentId2,
      lastErrorShowComponent
    });
    if (!componentId2 || componentId2 === lastErrorShowComponent) {
      setBannerState({
        isVisible: false,
        message: "",
        componentId: null,
        isError: false
      });
      window.parent.postMessage({ type: "SPICY_ERROR_BANNER_HIDE" }, "*");
      lastErrorShowComponent = null;
      console.log("[useInAppBanner] Error banner hidden");
    } else {
      console.log(
        "[useInAppBanner] Skip hiding error banner - component ID mismatch"
      );
    }
  };
  return { showBanner, hideBanner, showErrorBanner, hideErrorBanner };
};
const APP_TOKEN = "33d57ade8c02dbc5a333db99ff9ae26a";
const useOnlyFansAPI = () => {
  const { showErrorBanner } = useInAppBanner();
  async function makeRequest(endpoint, method = "GET", body = null, customHeaders = null) {
    try {
      const headers = await LocalStorageManager.getOnlyFansHeaders();
      console.log("[OnlyFansAPI] Got headers for current tab:", headers);
      if (!headers) {
        console.warn("[OnlyFansAPI] No headers found for current tab");
        throw new Error("No OnlyFans headers found for current tab");
      }
      delete headers["time"];
      const updatedHeaders = {
        ...headers,
        ...customHeaders,
        "app-token": APP_TOKEN
      };
      console.log("[OnlyFansAPI] Making request with headers:", {
        endpoint,
        method,
        hasBody: !!body,
        headers: updatedHeaders
      });
      return new Promise((resolve, reject) => {
        chrome.runtime.sendMessage(
          {
            type: "onlyFansApiRequest",
            data: {
              endpoint,
              method,
              body,
              headers: updatedHeaders
            }
          },
          (response) => {
            var _a, _b, _c, _d, _e2;
            if (chrome.runtime.lastError) {
              console.error("[OnlyFansAPI] Runtime error:", chrome.runtime.lastError);
              reject(chrome.runtime.lastError);
            } else if (response.error) {
              if (response.error.includes("401") || response.error.includes("403")) {
                showErrorBanner(
                  `You're logged out of OnlyFans! Refresh the page and log back in to continue using Spicy Toolbox - [${response.error}: ${method}/${(_a = endpoint == null ? void 0 : endpoint.split("?")) == null ? void 0 : _a[0]}] `,
                  "onlyFansApi"
                );
              } else if (response.error.includes("400")) {
                showErrorBanner(
                  `Bad request - there was an error in the request format - [${response.error}: ${method}/${(_b = endpoint == null ? void 0 : endpoint.split("?")) == null ? void 0 : _b[0]}]`,
                  "onlyFansApi"
                );
              } else if (response.error.includes("429")) {
                showErrorBanner(
                  `Rate limit exceeded - please wait a few minutes and try again - [${response.error}: ${method}/${(_c = endpoint == null ? void 0 : endpoint.split("?")) == null ? void 0 : _c[0]}]`,
                  "onlyFansApi"
                );
              } else if (response.error.includes("500")) {
                showErrorBanner(
                  `OnlyFans server error - please try again later - [${response.error}: ${method}/${(_d = endpoint == null ? void 0 : endpoint.split("?")) == null ? void 0 : _d[0]}]`,
                  "onlyFansApi"
                );
              } else if (response.error.includes("503")) {
                showErrorBanner(
                  `OnlyFans is temporarily unavailable - please try again later - [${response.error}: ${method}/${(_e2 = endpoint == null ? void 0 : endpoint.split("?")) == null ? void 0 : _e2[0]}]`,
                  "onlyFansApi"
                );
              }
              console.error("[OnlyFansAPI] Request error:", response.error);
              reject(new Error(response.error));
            } else {
              console.log("[OnlyFansAPI] Request successful:", {
                endpoint,
                method,
                hasResponse: !!response.data
              });
              resolve(response.data);
            }
          }
        );
      });
    } catch (error) {
      console.error("[OnlyFansAPI] Error in makeRequest:", error);
      throw error;
    }
  }
  async function getChats(limit = 10, offset3 = 0, skipUsers = null, filter = null, order = null, query = null) {
    const endpoint = `chats?limit=${limit}&offset=${offset3}${skipUsers ? `&skip_users=${skipUsers}` : ""}${order ? `&order=${order}` : ""}${filter ? `&filter=${filter}` : ""}${query ? `&query=${query}` : ""}`;
    return makeRequest(endpoint);
  }
  async function getTransactions(startDate = null, marker = null, limit = 100) {
    let endpoint = `payouts/transactions?limit=${limit}`;
    if (startDate) {
      endpoint += `&startDate=${encodeURIComponent(startDate)}`;
    }
    if (marker) {
      endpoint += `&marker=${marker}`;
    }
    return makeRequest(endpoint);
  }
  async function getMediaWithPurchaseStatus(userId, limit = 100, offset3 = 0, list = "all", nextLastId = null) {
    console.log(
      `[getMediaWithPurchaseStatus] Fetching media for user ${userId} with limit ${limit} and offset ${offset3}`
    );
    const promises = [getMediaPurchases(userId, limit, nextLastId)];
    if (!nextLastId) {
      console.log("[getMediaWithPurchaseStatus] Fetching message media");
      promises.push(getMessagesWithMedia(
        userId,
        50
        /* limit */
      ));
    }
    const [vaultResponse, messageMedia = []] = await Promise.all(promises);
    const allMedia = [...vaultResponse.list, ...messageMedia];
    const uniqueMedia = allMedia.filter((media, index2, self2) => {
      const isDuplicate = index2 !== self2.findIndex((m2) => m2.id === media.id);
      return !isDuplicate;
    });
    const categorizedMedia = uniqueMedia.map((item) => {
      let status = "";
      if (item.canPurchase || item.price > 0 && item.canPurchaseReason === "not_available") {
        status = "locked";
      } else if (item.isFree || item.price === 0) {
        status = "free";
      } else if (item.price > 0 && !item.canPurchase && item.canPurchaseReason !== "not_available") {
        status = "unlocked";
      } else {
        status = "message";
        console.log(
          `[getMediaWithPurchaseStatus] Item is a message: id: ${item.id}, type: ${item.type}, price: ${item.price}, isFree: ${item.isFree}, canPurchase: ${item.canPurchase}, canPurchaseReason: ${item.canPurchaseReason}, fromUser:`,
          item.fromUser
        );
      }
      return { ...item, status };
    });
    console.log(
      `[getMediaWithPurchaseStatus] Combined ${allMedia.length} media items into ${uniqueMedia.length} unique items, and categorized into ${categorizedMedia.length} items`
    );
    return {
      list: categorizedMedia,
      hasMore: vaultResponse.hasMore,
      nextLastId: vaultResponse.nextLastId
    };
  }
  async function getChargebacks(limit = 10, offset3 = 0, startDate = null, endDate = null) {
    var _a;
    let endpoint = `payouts/chargebacks?limit=${limit}`;
    if (offset3 > 0) {
      endpoint += `&offset=${offset3}`;
    }
    if (startDate) {
      endpoint += `&startDate=${encodeURIComponent(startDate)}`;
    }
    if (endDate) {
      endpoint += `&endDate=${encodeURIComponent(endDate)}`;
    }
    console.log(`[getChargebacks] API request: ${endpoint}`);
    const result = await makeRequest(endpoint);
    console.log(
      `[getChargebacks] Response: list length=${(_a = result.list) == null ? void 0 : _a.length}, marker=${result.marker}`
    );
    return result;
  }
  const chatMessagesCache = /* @__PURE__ */ new Map();
  const firstPageCache = /* @__PURE__ */ new Map();
  const FIRST_PAGE_CACHE_TTL = 1e4;
  async function getChatMessages(fanId, limit = 100, offset3 = 0, lastMessageId = null) {
    let endpoint = `chats/${fanId}/messages?limit=${limit}&order=desc&skip_users=all`;
    if (lastMessageId) {
      endpoint += `&id=${lastMessageId}`;
    } else if (offset3 > 0) {
      endpoint += `&offset=${offset3}`;
    }
    return makeRequest(endpoint);
  }
  async function getChatMessagesMultiPage(fanId, minCount = 10, forceRefresh = false) {
    let allMessages = [];
    let hasMore = true;
    let lastMessageId = null;
    const pageSize = 10;
    const firstPageKey = `chat-${fanId}-first-page`;
    let firstPageResponse;
    const now = Date.now();
    const cachedFirstPage = firstPageCache.get(firstPageKey);
    if (!forceRefresh && cachedFirstPage && now - cachedFirstPage.timestamp < FIRST_PAGE_CACHE_TTL) {
      console.log(
        `[getChatMessagesMultiPage] Using cached first page for ${fanId} (age: ${now - cachedFirstPage.timestamp}ms)`
      );
      firstPageResponse = cachedFirstPage.data;
    } else {
      console.log(`[getChatMessagesMultiPage] Fetching fresh first page for ${fanId}`);
      firstPageResponse = await getChatMessages(fanId, pageSize, 0, null);
      firstPageCache.set(firstPageKey, {
        data: firstPageResponse,
        timestamp: now
      });
    }
    if (firstPageResponse.list && firstPageResponse.list.length > 0) {
      allMessages = [...allMessages, ...firstPageResponse.list];
      const lastMessage = firstPageResponse.list[firstPageResponse.list.length - 1];
      lastMessageId = lastMessage.id;
    }
    hasMore = firstPageResponse.hasMore && firstPageResponse.list && firstPageResponse.list.length > 0;
    if (allMessages.length >= minCount) {
      console.log(
        `[getChatMessagesMultiPage] Already have ${allMessages.length} messages, which is >= ${minCount} required`
      );
      return {
        list: allMessages,
        hasMore
      };
    }
    let pageCount = 1;
    const MAX_PAGES = 5;
    while (hasMore && allMessages.length < minCount && pageCount < MAX_PAGES) {
      const cacheKey = `chat-${fanId}-page-${lastMessageId}`;
      let pageResponse;
      if (chatMessagesCache.has(cacheKey)) {
        console.log(
          `[getChatMessagesMultiPage] Using cached page ${pageCount + 1} for ${cacheKey}`
        );
        pageResponse = chatMessagesCache.get(cacheKey);
      } else {
        console.log(
          `[getChatMessagesMultiPage] Fetching new page ${pageCount + 1} with lastMessageId=${lastMessageId}`
        );
        pageResponse = await getChatMessages(fanId, pageSize, 0, lastMessageId);
        chatMessagesCache.set(cacheKey, pageResponse);
      }
      if (pageResponse.list && pageResponse.list.length > 0) {
        allMessages = [...allMessages, ...pageResponse.list];
        const lastMessage = pageResponse.list[pageResponse.list.length - 1];
        lastMessageId = lastMessage.id;
      } else {
        hasMore = false;
      }
      hasMore = pageResponse.hasMore && pageResponse.list && pageResponse.list.length > 0;
      pageCount++;
    }
    console.log(
      `[getChatMessagesMultiPage] Retrieved ${allMessages.length} messages for chat ${fanId} in ${pageCount} pages`
    );
    return {
      list: allMessages,
      hasMore
    };
  }
  function clearFirstPageCache(fanId) {
    if (fanId) {
      const firstPageKey = `chat-${fanId}-first-page`;
      const hadCache = firstPageCache.delete(firstPageKey);
      console.log(
        `[clearFirstPageCache] Cleared first page cache for fan ${fanId} (had cache: ${hadCache})`
      );
    }
  }
  async function getConversation(conversationId) {
    const endpoint = `chats/${conversationId}`;
    return makeRequest(endpoint);
  }
  async function sendMessage(userId, message, price = 0, mediaIds = []) {
    const endpoint = `chats/${userId}/messages`;
    const headers = {
      "Content-Type": "application/json",
      Origin: "https://onlyfans.com",
      Referer: `https://onlyfans.com/my/chats/chat/${userId}/`
    };
    return makeRequest(
      endpoint,
      "POST",
      { text: message, price, mediaFiles: mediaIds },
      headers
    );
  }
  async function sendMassMessage(conversationIds, message, price = 0, mediaIds = [], excludedUsers = []) {
    const promises = conversationIds.filter((id2) => !excludedUsers.includes(id2)).map((id2) => sendMessage(id2, message, price, mediaIds));
    return Promise.all(promises);
  }
  async function getLikeNotifications(limit = 10, fromId = null, skip_users = "all", format = "infinite") {
    let endpoint = `users/notifications?limit=${limit}&type=favorited&skip_users=${skip_users}&format=${format}`;
    if (fromId) {
      endpoint += `&fromId=${fromId}`;
    }
    return makeRequest(endpoint);
  }
  async function getVaultLists(limit = 10, offset3 = 0) {
    const endpoint = `vault/lists?view=main&offset=${offset3}&limit=${limit}`;
    const result = await makeRequest(endpoint);
    if (result.error) {
      console.error("[only-fans-api][getVaultLists] Error loading vault lists:", result.error);
      throw new Error(result.error);
    }
    return result;
  }
  async function getVaultMedia(limit = 24, offset3 = 0, field = "recent", sort = "desc", list = "all") {
    console.log(
      `[getVaultMedia] Fetching media with limit ${limit}, offset ${offset3}, field ${field}, sort ${sort}, list ${list}`
    );
    let endpoint = "vault/media";
    const params = new URLSearchParams();
    if (limit !== null)
      params.append("limit", limit);
    if (offset3 !== null)
      params.append("offset", offset3);
    if (field !== null)
      params.append("field", field);
    if (sort !== null)
      params.append("sort", sort);
    if (list !== null)
      params.append("list", list);
    endpoint = `${endpoint}?${params.toString()}`;
    const result = await makeRequest(endpoint);
    if (result.error) {
      console.error("[only-fans-api][getVaultMedia] Error loading vault media:", result.error);
      throw new Error(result.error);
    }
    return result;
  }
  async function getSubscribers(limit = 100, offset3 = 0) {
    const endpoint = `subscriptions/subscribers?limit=${limit}&offset=${offset3}`;
    return makeRequest(endpoint);
  }
  async function getOnlineSubscribers(limit = 20, offset3 = 0) {
    const endpoint = `subscriptions/subscribers?limit=${limit}&offset=${offset3}&format=infinite&type=all&filter[online]=1&more=false`;
    return makeRequest(endpoint);
  }
  async function getActiveSubscribersCount() {
    const endpoint = `subscriptions/subscribers/count?type=active&filter[online]=1`;
    return makeRequest(endpoint);
  }
  async function followUser(userId) {
    const endpoint = `users/${userId}/subscribe`;
    return makeRequest(endpoint, "POST", { reason: 0 });
  }
  async function unfollowUser(userId) {
    const endpoint = `users/${userId}/subscribe`;
    return makeRequest(endpoint, "DELETE", { reason: 0 });
  }
  async function getUserProfile() {
    const endpoint = "users/me";
    return makeRequest(endpoint);
  }
  async function getMediaPurchases(userId, limit = 20, lastId = null) {
    console.log(
      `[getMediaPurchases] Fetching media purchases for user ${userId} with limit ${limit}, lastId ${lastId}`
    );
    let endpoint = `chats/${userId}/media?limit=${limit}`;
    if (lastId) {
      endpoint += `&last_id=${lastId}`;
    }
    endpoint += "&skip_users=all";
    return makeRequest(endpoint);
  }
  async function getMessagesByMediaId(mediaId) {
    const endpoint = `messages/search?mediaId=${mediaId}`;
    return makeRequest(endpoint);
  }
  async function updateUserNote(userId, note) {
    const endpoint = `subscriptions/${userId}`;
    return makeRequest(endpoint, "PUT", { notice: note });
  }
  async function getRecentlyActiveSubscribers(limit = 100, offset3 = 0) {
    const endpoint = `subscriptions/subscribers/recent?limit=${limit}&offset=${offset3}`;
    return makeRequest(endpoint);
  }
  async function getExpiredSubscribers(limit = 100, offset3 = 0) {
    const endpoint = `subscriptions/subscribers?limit=${limit}&offset=${offset3}&format=infinite&type=expired&more=true`;
    const response = await makeRequest(endpoint);
    const originalLength = response.list.length;
    response.list = response.list.filter(
      (user) => user.subscribedOnData !== null && user.subscribePrice === 0
    );
    response.originalLength = originalLength;
    return response;
  }
  async function getLatestExpiredSubscribers(offset3 = 0) {
    var _a, _b;
    const creatorStartInfo = await getCreatorStartDate();
    const startDate = creatorStartInfo.startDate;
    if (!startDate) {
      throw new Error("Creator start date not found");
    }
    const endDate = /* @__PURE__ */ new Date();
    const formatDate = (date) => date.toISOString().slice(0, 19).replace("T", " ");
    const formattedEndDate = formatDate(endDate);
    const encodedStartDate = encodeURIComponent(startDate);
    const encodedEndDate = encodeURIComponent(formattedEndDate);
    const endpoint = `subscriptions/subscribers/latest?startDate=${encodedStartDate}&endDate=${encodedEndDate}&by=total&offset=${offset3}`;
    console.log(`[getLatestExpiredSubscribers] API request: ${endpoint}`);
    const response = await makeRequest(endpoint);
    console.log(
      `[getLatestExpiredSubscribers] Response: users length=${(_a = response.users) == null ? void 0 : _a.length}, hasMore=${response.hasMore}`
    );
    const originalLength = ((_b = response.users) == null ? void 0 : _b.length) || 0;
    if (response.users) {
      response.users = response.users.filter((user) => {
        const isExpired = user.subscribedOnData && user.subscribedOnData.expiredAt && new Date(user.subscribedOnData.expiredAt) < /* @__PURE__ */ new Date();
        return user.subscribedOnData !== null && user.subscribePrice === 0 && isExpired;
      });
      response.list = response.users.map((user) => ({
        id: user.id.toString(),
        name: user.name,
        username: user.username,
        avatar: user.avatar,
        isPerformer: user.isPerformer,
        subscribedOn: user.subscribedOn,
        subscribedOnData: user.subscribedOnData,
        subscribedBy: user.subscribedBy,
        subscribedByData: user.subscribedByData,
        canReceiveChatMessage: user.canReceiveChatMessage,
        subscribePrice: user.subscribePrice
      }));
      delete response.users;
    } else {
      response.list = [];
    }
    response.originalLength = originalLength;
    return response;
  }
  async function getUserData(userIdOrUsername) {
    const endpoint = `users/${userIdOrUsername.replace(/^@/, "")}`;
    return makeRequest(endpoint);
  }
  async function getUnlockedMedia(userId, limit = 20) {
    const endpoint = `chats/${userId}/media/?limit=${limit}&skip_users=all`;
    const response = await makeRequest(endpoint);
    const sentMedia = response.list.filter((item) => {
      var _a;
      return ((_a = item.fromUser) == null ? void 0 : _a.id) != userId;
    });
    const categorizedMedia = sentMedia.map((item) => {
      let status = "";
      if (!item.isFree && item.price > 0 && item.canPurchase) {
        status = "locked";
      } else if (item.isFree || item.price === 0 || item.canPurchaseReason === "free") {
        status = "free";
      } else if (item.price > 0 && item.canPurchaseReason === "opened") {
        status = "unlocked";
      } else {
        status = "message";
        console.log("[getUnlockedMedia] Item is a message:", {
          id: item.id,
          type: item.type,
          price: item.price,
          isFree: item.isFree,
          canPurchase: item.canPurchase,
          canPurchaseReason: item.canPurchaseReason,
          fromUser: item.fromUser
        });
      }
      item.status = status;
      return item;
    });
    response.list = categorizedMedia;
    return response;
  }
  async function getOnlineSubscribersCount() {
    const endpoint = "subscriptions/subscribers/count?type=active&filter[online]=1";
    return makeRequest(endpoint);
  }
  async function getSubscriptionInfo() {
    const endpoint = "subscriptions/count/all";
    return makeRequest(endpoint);
  }
  async function getUsers(userIds) {
    const endpoint = `users/list?b[]=${userIds.join("&b[]=")}`;
    return makeRequest(endpoint);
  }
  async function getAutoFollowFansEnabled() {
    const endpoint = "users/me/settings";
    const response = await makeRequest(endpoint);
    return (response == null ? void 0 : response.isAutoFollowBack) ?? false;
  }
  async function getCreatorStartDate() {
    const endpoint = "users/me/start-date-model";
    const response = await makeRequest(endpoint);
    return {
      startDate: (response == null ? void 0 : response.startDate) ?? null
    };
  }
  async function getLists(limit = 10, offset3 = 0) {
    const endpoint = `lists?offset=${offset3}&skip_users=all&limit=${limit}&format=infinite`;
    const response = await makeRequest(endpoint);
    return response;
  }
  async function getListUsers(listId, limit = 50) {
    let allUsers = [];
    let offset3 = 0;
    let hasMore = true;
    while (hasMore) {
      const endpoint = `lists/${listId}/users?offset=${offset3}&limit=${limit}&format=infinite`;
      const response = await makeRequest(endpoint);
      if (response.list && response.list.length > 0) {
        allUsers = allUsers.concat(response.list);
      }
      hasMore = response.hasMore;
      offset3 = response.nextOffset || offset3 + limit;
    }
    return { list: allUsers };
  }
  async function queueMessageToList(listId, excludedLists = [], excludeUserIds = [], message, price = 0, mediaIds = []) {
    const endpoint = "messages/queue";
    const headers = {
      "Content-Type": "application/json",
      Origin: "https://onlyfans.com",
      Referer: "https://onlyfans.com/"
    };
    const payload = {
      text: message,
      userLists: [listId],
      excludedLists,
      excludeUserIds,
      mediaFiles: mediaIds,
      price,
      lockedText: false,
      previews: [],
      rfTag: [],
      rfPartner: [],
      rfGuest: [],
      userLists: [],
      isForward: false
    };
    return makeRequest(endpoint, "POST", payload, headers);
  }
  async function queueMessage(userIds, message, price = 0, mediaIds = []) {
    const endpoint = "messages/queue";
    const headers = {
      "Content-Type": "application/json",
      Origin: "https://onlyfans.com",
      Referer: "https://onlyfans.com/"
    };
    const payload = {
      text: message,
      userIds,
      mediaFiles: mediaIds,
      price,
      lockedText: false,
      previews: [],
      rfTag: [],
      rfPartner: [],
      rfGuest: [],
      userLists: [],
      isForward: false
    };
    return makeRequest(endpoint, "POST", payload, headers);
  }
  async function getMessagesWithMedia(userId, limit = 10) {
    console.log(
      `[getMessagesWithMedia] Getting messages with media for user ${userId} with limit ${limit}`
    );
    const response = await makeRequest(
      `chats/${userId}/messages?limit=${limit}&order=desc&skip_users=all`
    );
    console.log(`[getMessagesWithMedia] Got response:`, response);
    const messagesWithMedia = response.list.filter((msg) => msg.media && msg.media.length > 0);
    console.log(`[getMessagesWithMedia] Found ${messagesWithMedia.length} messages with media`);
    return messagesWithMedia;
  }
  async function createList(name) {
    const endpoint = "lists";
    const headers = {
      "Content-Type": "application/json",
      Origin: "https://onlyfans.com",
      Referer: "https://onlyfans.com/"
    };
    return makeRequest(endpoint, "POST", { name }, headers);
  }
  async function addUsersToList(listId, userIds) {
    const endpoint = "lists/users";
    const headers = {
      "Content-Type": "application/json",
      Origin: "https://onlyfans.com",
      Referer: "https://onlyfans.com/"
    };
    const payload = {
      [listId]: Array.isArray(userIds) ? userIds : [userIds]
    };
    const response = await makeRequest(endpoint, "POST", payload, headers);
    return response;
  }
  return {
    getChats,
    getTransactions,
    getChargebacks,
    getChatMessages,
    getChatMessagesMultiPage,
    clearFirstPageCache,
    getConversation,
    sendMessage,
    sendMassMessage,
    getLikeNotifications,
    getVaultMedia,
    getSubscribers,
    getOnlineSubscribers,
    getActiveSubscribersCount,
    followUser,
    unfollowUser,
    getCreatorStartDate,
    getUserProfile,
    getMessagesByMediaId,
    getMediaWithPurchaseStatus,
    updateUserNote,
    getRecentlyActiveSubscribers,
    getExpiredSubscribers,
    getLatestExpiredSubscribers,
    getUserData,
    getUnlockedMedia,
    getOnlineSubscribersCount,
    getSubscriptionInfo,
    getUsers,
    getAutoFollowFansEnabled,
    getLists,
    getListUsers,
    getVaultLists,
    queueMessage,
    queueMessageToList,
    getMessagesWithMedia,
    createList,
    addUsersToList
  };
};
const FloatingButtonContext = reactExports.createContext();
const FloatingButtonProvider = ({ children }) => {
  const [tabNavigationWidth, setTabNavigationWidth] = reactExports.useState(0);
  const [tabNavigationRef, setTabNavigationRef] = reactExports.useState(null);
  reactExports.useEffect(() => {
    if (!tabNavigationRef)
      return;
    const updateTabWidth = () => {
      const width = tabNavigationRef.getBoundingClientRect().width;
      setTabNavigationWidth(width);
    };
    updateTabWidth();
    const resizeObserver = new ResizeObserver(updateTabWidth);
    resizeObserver.observe(tabNavigationRef);
    return () => {
      resizeObserver.disconnect();
    };
  }, [tabNavigationRef]);
  const value = {
    tabNavigationWidth,
    setTabNavigationRef
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsx(FloatingButtonContext.Provider, { value, children });
};
const useFloatingButton = () => {
  const context = reactExports.useContext(FloatingButtonContext);
  if (!context) {
    throw new Error("useFloatingButton must be used within a FloatingButtonProvider");
  }
  return context;
};
const FloatingStatusBanner = ({
  message,
  type = "success",
  // 'success' or 'error'
  show = false,
  onHide,
  autoHideDelay = 5e3
  // Auto-hide after 5 seconds by default
}) => {
  const { tabNavigationWidth } = useFloatingButton();
  const [mounted, setMounted] = reactExports.useState(false);
  const [windowWidth, setWindowWidth] = reactExports.useState(window.innerWidth);
  const [isVisible3, setIsVisible] = reactExports.useState(false);
  reactExports.useEffect(() => {
    setMounted(true);
    const handleResize = () => {
      setWindowWidth(window.innerWidth);
    };
    window.addEventListener("resize", handleResize);
    return () => {
      window.removeEventListener("resize", handleResize);
      setMounted(false);
    };
  }, []);
  reactExports.useEffect(() => {
    if (show) {
      setIsVisible(true);
      if (autoHideDelay > 0) {
        const timer = setTimeout(() => {
          setIsVisible(false);
          setTimeout(() => {
            if (onHide)
              onHide();
          }, 300);
        }, autoHideDelay);
        return () => clearTimeout(timer);
      }
    } else {
      setIsVisible(false);
    }
  }, [show, autoHideDelay, onHide]);
  const getBannerColor = () => {
    if (type === "error")
      return "bg-red-200 text-black";
    return "bg-green-300 text-black";
  };
  const contentWidth = windowWidth - tabNavigationWidth;
  const bannerWidth = contentWidth * 0.9;
  const wrapperStyle = {
    position: "fixed",
    top: "1.5rem",
    left: "50%",
    transform: "translateX(-50%)",
    zIndex: 50,
    width: `${bannerWidth}px`,
    marginLeft: `${tabNavigationWidth / 2}px`
    // Offset to account for tab navigation
  };
  const bannerStyle = {
    width: "100%"
  };
  const banner = /* @__PURE__ */ jsxRuntimeExports.jsx(
    "div",
    {
      style: bannerStyle,
      className: `rounded-lg px-4 py-3 font-medium shadow-lg transition-all duration-300 ${isVisible3 ? "translate-y-0 opacity-100" : "-translate-y-4 opacity-0"} ${getBannerColor()}`,
      children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center justify-between", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "text-sm", children: message }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          "button",
          {
            onClick: () => {
              setIsVisible(false);
              setTimeout(() => {
                if (onHide)
                  onHide();
              }, 300);
            },
            className: "ml-4 transition-colors hover:text-gray-800",
            children: "×"
          }
        )
      ] })
    }
  );
  const renderBanner = () => {
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      "div",
      {
        style: wrapperStyle,
        className: `transition-all duration-300 ${show ? "pointer-events-auto" : "pointer-events-none"}`,
        children: banner
      }
    );
  };
  if (mounted && show) {
    return reactDomExports.createPortal(renderBanner(), document.body);
  }
  return null;
};
const buttonArrow = "" + new URL("button-arrow-a96d8b93.svg", import.meta.url).href;
const SubmitButton = ({ title, onSubmit, hasChanges, disabled = false, showArrow = false }) => /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex justify-end", children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
  "button",
  {
    onClick: onSubmit,
    className: `flex items-center space-x-2 rounded-full px-4 py-2 ${hasChanges && !disabled ? "text-white bg-indigo-500 hover:bg-indigo-600" : "cursor-not-allowed bg-gray-300 text-gray-500"}`,
    disabled: !hasChanges || disabled,
    children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: title }),
      showArrow && !disabled && /* @__PURE__ */ jsxRuntimeExports.jsx("img", { src: buttonArrow, alt: "arrow", className: "h-2.5 w-3" })
    ]
  }
) });
const TabHeader = ({ title, subtitle }) => {
  const titleContent = /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text-3xl font-semibold mb-5 flex items-center", children: typeof title === "string" ? title : /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex items-center", children: title }) });
  const subtitleContent = subtitle && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text-base mb-5 text-gray-700", children: typeof subtitle === "string" ? subtitle : /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex flex-col text-gray-700", children: subtitle }) });
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "mb-9 text-left", children: [
    titleContent,
    subtitleContent,
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "w-full h-px bg-gray-200" })
  ] });
};
const LoadingSpinner = ({ inline = false, size = 6 }) => {
  if (inline) {
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(
      "svg",
      {
        "aria-hidden": "true",
        className: `inline w-${size} h-${size} text-gray-200 animate-spin fill-indigo-500`,
        viewBox: "0 0 100 101",
        fill: "none",
        xmlns: "http://www.w3.org/2000/svg",
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "path",
            {
              d: "M100 50.5908C100 78.2051 77.6142 100.591 50 100.591C22.3858 100.591 0 78.2051 0 50.5908C0 22.9766 22.3858 0.59082 50 0.59082C77.6142 0.59082 100 22.9766 100 50.5908ZM9.08144 50.5908C9.08144 73.1895 27.4013 91.5094 50 91.5094C72.5987 91.5094 90.9186 73.1895 90.9186 50.5908C90.9186 27.9921 72.5987 9.67226 50 9.67226C27.4013 9.67226 9.08144 27.9921 9.08144 50.5908Z",
              fill: "currentColor"
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "path",
            {
              d: "M93.9676 39.0409C96.393 38.4038 97.8624 35.9116 97.0079 33.5539C95.2932 28.8227 92.871 24.3692 89.8167 20.348C85.8452 15.1192 80.8826 10.7238 75.2124 7.41289C69.5422 4.10194 63.2754 1.94025 56.7698 1.05124C51.7666 0.367541 46.6976 0.446843 41.7345 1.27873C39.2613 1.69328 37.813 4.19778 38.4501 6.62326C39.0873 9.04874 41.5694 10.4717 44.0505 10.1071C47.8511 9.54855 51.7191 9.52689 55.5402 10.0491C60.8642 10.7766 65.9928 12.5457 70.6331 15.2552C75.2735 17.9648 79.3347 21.5619 82.5849 25.841C84.9175 28.9121 86.7997 32.2913 88.1811 35.8758C89.083 38.2158 91.5421 39.6781 93.9676 39.0409Z",
              fill: "currentFill"
            }
          )
        ]
      }
    );
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex items-center justify-start p-4", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { role: "status", className: "flex items-center", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs(
      "svg",
      {
        "aria-hidden": "true",
        className: `w-${size} h-${size} text-gray-200 animate-spin fill-indigo-500`,
        viewBox: "0 0 100 101",
        fill: "none",
        xmlns: "http://www.w3.org/2000/svg",
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "path",
            {
              d: "M100 50.5908C100 78.2051 77.6142 100.591 50 100.591C22.3858 100.591 0 78.2051 0 50.5908C0 22.9766 22.3858 0.59082 50 0.59082C77.6142 0.59082 100 22.9766 100 50.5908ZM9.08144 50.5908C9.08144 73.1895 27.4013 91.5094 50 91.5094C72.5987 91.5094 90.9186 73.1895 90.9186 50.5908C90.9186 27.9921 72.5987 9.67226 50 9.67226C27.4013 9.67226 9.08144 27.9921 9.08144 50.5908Z",
              fill: "currentColor"
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "path",
            {
              d: "M93.9676 39.0409C96.393 38.4038 97.8624 35.9116 97.0079 33.5539C95.2932 28.8227 92.871 24.3692 89.8167 20.348C85.8452 15.1192 80.8826 10.7238 75.2124 7.41289C69.5422 4.10194 63.2754 1.94025 56.7698 1.05124C51.7666 0.367541 46.6976 0.446843 41.7345 1.27873C39.2613 1.69328 37.813 4.19778 38.4501 6.62326C39.0873 9.04874 41.5694 10.4717 44.0505 10.1071C47.8511 9.54855 51.7191 9.52689 55.5402 10.0491C60.8642 10.7766 65.9928 12.5457 70.6331 15.2552C75.2735 17.9648 79.3347 21.5619 82.5849 25.841C84.9175 28.9121 86.7997 32.2913 88.1811 35.8758C89.083 38.2158 91.5421 39.6781 93.9676 39.0409Z",
              fill: "currentFill"
            }
          )
        ]
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "ml-2 text-gray-500", children: "Loading..." })
  ] }) });
};
const AccountTab = () => {
  var _a, _b, _c;
  const subscriptionSettings = Recoil_index_20(subscriptionSettingsAtom);
  const subscriptionSettingsId = Recoil_index_20(subscriptionSettingsIdSelector);
  const serverFeatureFlags = Recoil_index_20(featureFlagsSelector);
  const effectiveFeatureFlags = Recoil_index_20(effectiveFeatureFlagsSelector);
  const hasOverrides = Recoil_index_20(hasFeatureFlagOverridesSelector);
  const [featureFlagOverrides, setFeatureFlagOverrides] = Recoil_index_22(featureFlagOverridesAtom);
  const setSubscriptionSettings = Recoil_index_24(subscriptionSettingsAtom);
  const setIsLoggedIn = Recoil_index_24(isLoggedInAtom);
  const { setActiveTab } = useTabNavigation();
  const ofUserId = Recoil_index_20(ofUserIdAtom);
  const [currentEnvironment, setCurrentEnvironment] = Recoil_index_22(environmentAtom);
  const {
    updateSubscriptionSettings,
    getPortalSession,
    getTeam,
    getCurrentUserIsOwner,
    getCurrentUserId
  } = useNetworkManager();
  const { getUserData } = useOnlyFansAPI();
  const [newEmail, setNewEmail] = reactExports.useState("");
  const [hasChanges, setHasChanges] = reactExports.useState(false);
  const [updateMessage, setUpdateMessage] = reactExports.useState("");
  const [updateStatus, setUpdateStatus] = reactExports.useState("");
  const [portalUrl, setPortalUrl] = reactExports.useState("");
  const [planName, setPlanName] = reactExports.useState("Loading...");
  const planType = Recoil_index_20(planTypeSelector);
  const [planQuantity, setPlanQuantity] = reactExports.useState(1);
  const [team, setTeam] = reactExports.useState([]);
  const [usernames, setUsernames] = reactExports.useState(/* @__PURE__ */ new Map());
  const [confirmDialog, setConfirmDialog] = reactExports.useState({
    isOpen: false,
    memberToRemove: null
  });
  const [isLoadingTeam, setIsLoadingTeam] = reactExports.useState(true);
  const [isLoadingPortal, setIsLoadingPortal] = reactExports.useState(true);
  const [loadError, setLoadError] = reactExports.useState("");
  const [isSubmitting, setIsSubmitting] = reactExports.useState(false);
  const [usernameLoadStates, setUsernameLoadStates] = reactExports.useState(/* @__PURE__ */ new Map());
  const [isOwner, setIsOwner] = reactExports.useState(false);
  const [currentUserId, setCurrentUserId] = reactExports.useState(null);
  const [currentUser, setCurrentUser] = reactExports.useState(null);
  const [environmentSwitchModal, setEnvironmentSwitchModal] = reactExports.useState({
    isOpen: false,
    targetEnv: ""
  });
  const handleFeatureFlagToggle = (flagName) => {
    try {
      const newOverrides = {
        ...featureFlagOverrides || {},
        [flagName]: !effectiveFeatureFlags[flagName]
      };
      if (newOverrides[flagName] === serverFeatureFlags[flagName]) {
        delete newOverrides[flagName];
      }
      if (Object.keys(newOverrides).length === 0) {
        setFeatureFlagOverrides(null);
      } else {
        setFeatureFlagOverrides(newOverrides);
      }
      setUpdateMessage(
        `Feature flag "${flagName}" ${!effectiveFeatureFlags[flagName] ? "enabled" : "disabled"}`
      );
      setUpdateStatus("success");
      setTimeout(() => {
        setUpdateMessage("");
        setUpdateStatus("");
      }, 3e3);
    } catch (error) {
      console.error("Error updating feature flag:", error);
      setUpdateMessage("Failed to update feature flag");
      setUpdateStatus("error");
    }
  };
  const resetFeatureFlags = () => {
    try {
      setFeatureFlagOverrides(null);
      setUpdateMessage("Feature flags reset to server values");
      setUpdateStatus("success");
      setTimeout(() => {
        setUpdateMessage("");
        setUpdateStatus("");
      }, 3e3);
    } catch (error) {
      console.error("Error resetting feature flags:", error);
      setUpdateMessage("Failed to reset feature flags");
      setUpdateStatus("error");
    }
  };
  reactExports.useEffect(() => {
    const checkCurrentUser = async () => {
      const userId = await getCurrentUserId();
      setCurrentUserId(userId);
    };
    checkCurrentUser();
  }, []);
  reactExports.useEffect(() => {
    console.log("[AccountTab] team:", team);
    if (team.length && currentUserId) {
      const foundUser = team.find((member) => !member.isOwner && member._id == currentUserId);
      setCurrentUser(foundUser);
    }
  }, [team, currentUserId]);
  const [stableCreatorIds, setStableCreatorIds] = reactExports.useState([]);
  const [retryAttempts, setRetryAttempts] = reactExports.useState(/* @__PURE__ */ new Map());
  reactExports.useEffect(() => {
    const newCreatorIds = (subscriptionSettings == null ? void 0 : subscriptionSettings.ofCreatorIds) || [];
    const currentIds = stableCreatorIds;
    const hasChanged = newCreatorIds.length !== currentIds.length || !newCreatorIds.every((id2, index2) => id2 === currentIds[index2]);
    if (hasChanged) {
      console.log("[AccountTab] Creator IDs changed, updating stable reference");
      setStableCreatorIds(newCreatorIds);
      setRetryAttempts(/* @__PURE__ */ new Map());
    }
  }, [subscriptionSettings == null ? void 0 : subscriptionSettings.ofCreatorIds, stableCreatorIds]);
  reactExports.useEffect(() => {
    const MAX_RETRIES = 3;
    const RETRY_DELAY_BASE = 1e3;
    const sleep = (ms2) => new Promise((resolve) => setTimeout(resolve, ms2));
    const fetchUsernameWithRetry = async (creatorId, attempt = 1) => {
      console.log(
        `[AccountTab] Fetching username for creator ID: ${creatorId} (attempt ${attempt})`
      );
      try {
        const userData = await getUserData(creatorId);
        console.log(
          "[AccountTab] Successfully fetched username for ID",
          creatorId,
          ":",
          userData.username
        );
        return userData.username;
      } catch (error) {
        console.error(
          `[AccountTab] Error fetching username for ID ${creatorId} (attempt ${attempt}):`,
          error
        );
        if (attempt < MAX_RETRIES) {
          const delay = RETRY_DELAY_BASE * Math.pow(2, attempt - 1);
          console.log(`[AccountTab] Retrying fetch for ID ${creatorId} in ${delay}ms`);
          setRetryAttempts((prev) => new Map(prev.set(creatorId, attempt)));
          await sleep(delay);
          return fetchUsernameWithRetry(creatorId, attempt + 1);
        } else {
          console.error(`[AccountTab] Max retries exceeded for creator ID ${creatorId}`);
          throw error;
        }
      }
    };
    const fetchUsernames = async () => {
      if (!stableCreatorIds.length) {
        console.log("[AccountTab] No creator IDs to fetch");
        return;
      }
      console.log("[AccountTab] Starting to fetch usernames for creators:", stableCreatorIds);
      const initialLoadStates = /* @__PURE__ */ new Map();
      stableCreatorIds.forEach((id2) => {
        initialLoadStates.set(id2, "loading");
      });
      console.log(
        "[AccountTab] Initialized loading states for",
        stableCreatorIds.length,
        "creators"
      );
      setUsernameLoadStates(initialLoadStates);
      const finalUsernames = /* @__PURE__ */ new Map();
      const finalLoadStates = new Map(initialLoadStates);
      for (const id2 of stableCreatorIds) {
        try {
          const username = await fetchUsernameWithRetry(id2);
          finalUsernames.set(id2, username);
          finalLoadStates.set(id2, "success");
          setUsernames(new Map(finalUsernames));
          setUsernameLoadStates(new Map(finalLoadStates));
          setRetryAttempts((prev) => {
            const newMap = new Map(prev);
            newMap.delete(id2);
            return newMap;
          });
        } catch (error) {
          console.error("[AccountTab] Final error fetching username for ID", id2, ":", error);
          finalLoadStates.set(id2, "error");
          setUsernameLoadStates(new Map(finalLoadStates));
          setRetryAttempts((prev) => {
            const newMap = new Map(prev);
            newMap.delete(id2);
            return newMap;
          });
        }
      }
      console.log("[AccountTab] Completed fetching usernames for all creators");
    };
    if (stableCreatorIds.length > 0) {
      console.log("[AccountTab] Stable creator IDs found, starting username fetch");
      fetchUsernames();
    }
  }, [stableCreatorIds]);
  reactExports.useEffect(() => {
    const loadPortalData = async () => {
      try {
        const response = await getPortalSession();
        if (response) {
          setPortalUrl(response.url);
          setPlanName(response.planName || "Free Plan");
          setPlanQuantity(response.quantity || 1);
        }
      } catch (error) {
        console.error("Error loading portal data:", error);
        setPlanName("Error loading plan");
        setLoadError("Failed to load subscription data");
      } finally {
        setIsLoadingPortal(false);
      }
    };
    loadPortalData();
  }, [subscriptionSettings]);
  reactExports.useEffect(() => {
    const loadTeamData = async () => {
      try {
        const teamData = await getTeam();
        setTeam(teamData);
      } catch (error) {
        console.error("Error loading team data:", error);
        setLoadError("Failed to load team data");
      } finally {
        setIsLoadingTeam(false);
      }
    };
    if (subscriptionSettingsId) {
      loadTeamData();
    }
  }, [subscriptionSettingsId]);
  reactExports.useEffect(() => {
    const checkOwnership = async () => {
      const ownerStatus = await getCurrentUserIsOwner();
      setIsOwner(ownerStatus);
    };
    checkOwnership();
  }, []);
  const isLoading = isLoadingTeam || isLoadingPortal;
  const handleAddTeamMember = async () => {
    if (!newEmail || isSubmitting)
      return;
    const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
    if (!emailRegex.test(newEmail)) {
      setUpdateMessage(
        `${newEmail} is not a valid email address. Please enter a valid email address.`
      );
      setUpdateStatus("error");
      return;
    }
    setIsSubmitting(true);
    try {
      const response = await updateSubscriptionSettings({
        addManagerEmail: newEmail
      });
      if (response.status === 200) {
        const teamData = await getTeam();
        setTeam(teamData);
        setSubscriptionSettings(response.body);
        setUpdateMessage("Team member added successfully!");
        setUpdateStatus("success");
        setNewEmail("");
        setHasChanges(false);
      } else {
        setUpdateMessage(response.body.message);
        setUpdateStatus("error");
      }
    } catch (error) {
      console.error("Error adding team member:", error);
      setUpdateMessage(`Failed to add team member. ${error.message}`);
      setUpdateStatus("error");
    } finally {
      setIsSubmitting(false);
    }
  };
  reactExports.useEffect(() => {
    setHasChanges(!!newEmail);
  }, [newEmail]);
  const handleRemoveCreator = (creatorId) => {
    const username = usernames.get(creatorId) || creatorId;
    setConfirmDialog({
      isOpen: true,
      memberToRemove: { id: creatorId, type: "creator" },
      message: `Are you sure you want to remove @${username} from your account? Removed creators cannot be added back to your account without contacting support.`
    });
  };
  const handleRemoveTeamMember = (member) => {
    setConfirmDialog({
      isOpen: true,
      memberToRemove: { ...member, type: "team" },
      message: `Are you sure you want to remove ${member.firstName || member.email} from the team? They will no longer have access to manage this account.`
    });
  };
  const confirmRemove = async () => {
    const memberToRemove = confirmDialog.memberToRemove;
    if (!memberToRemove || isSubmitting)
      return;
    setIsSubmitting(true);
    try {
      let response;
      if (memberToRemove.type === "creator") {
        response = await updateSubscriptionSettings({
          removeOfCreatorId: memberToRemove.id
        });
      } else {
        response = await updateSubscriptionSettings({
          removeManagerEmail: memberToRemove.email
        });
        const teamData = await getTeam();
        setTeam(teamData);
      }
      if (response.status === 200) {
        setSubscriptionSettings(response.body);
        setUpdateMessage(
          memberToRemove.type === "creator" ? "Creator removed successfully!" : "Team member removed successfully!"
        );
        setUpdateStatus("success");
      } else {
        setUpdateMessage(
          `Failed to remove ${memberToRemove.type === "creator" ? "creator" : "team member"}. Please try again.`
        );
        setUpdateStatus("error");
      }
    } catch (error) {
      console.error(
        `Error removing ${memberToRemove.type === "creator" ? "creator" : "team member"}:`,
        error
      );
      setUpdateMessage(
        `An error occurred while removing ${memberToRemove.type === "creator" ? "creator" : "team member"}.`
      );
      setUpdateStatus("error");
    } finally {
      setIsSubmitting(false);
      setConfirmDialog({ isOpen: false, memberToRemove: null });
      setTimeout(() => {
        setUpdateMessage("");
        setUpdateStatus("");
      }, 3e3);
    }
  };
  const handleEnvironmentChange = (e2) => {
    const targetEnv = e2.target.value;
    if (targetEnv === currentEnvironment)
      return;
    const currentIsProdOrStaging = ["prod", "staging"].includes(currentEnvironment);
    const targetIsProdOrStaging = ["prod", "staging"].includes(targetEnv);
    if (currentIsProdOrStaging !== targetIsProdOrStaging) {
      setEnvironmentSwitchModal({
        isOpen: true,
        targetEnv
      });
    } else {
      applyEnvironmentChange(targetEnv);
    }
  };
  const confirmEnvironmentSwitch = () => {
    applyEnvironmentChange(environmentSwitchModal.targetEnv);
    setEnvironmentSwitchModal({
      isOpen: false,
      targetEnv: ""
    });
  };
  const cancelEnvironmentSwitch = () => {
    setEnvironmentSwitchModal({
      isOpen: false,
      targetEnv: ""
    });
  };
  const applyEnvironmentChange = async (env2) => {
    try {
      setCurrentEnvironment(env2);
      setEnvironment(env2);
      refreshRoutes();
      const currentIsProdOrStaging = ["prod", "staging"].includes(currentEnvironment);
      const targetIsProdOrStaging = ["prod", "staging"].includes(env2);
      if (currentIsProdOrStaging !== targetIsProdOrStaging) {
        setIsLoggedIn(false);
        await LocalStorageManager.clear();
        setUpdateMessage("Environment changed. You have been logged out.");
        setUpdateStatus("success");
      } else {
        setUpdateMessage("Environment changed successfully.");
        setUpdateStatus("success");
      }
    } catch (error) {
      console.error("Error changing environment:", error);
      setUpdateMessage("Failed to change environment.");
      setUpdateStatus("error");
    }
    setTimeout(() => {
      setUpdateMessage("");
      setUpdateStatus("");
    }, 3e3);
  };
  const owner = team.find((member) => member.isOwner);
  const managers = team.filter((member) => !member.isOwner);
  const sortedCreators = ((_a = subscriptionSettings == null ? void 0 : subscriptionSettings.ofCreatorIds) == null ? void 0 : _a.sort((a2, b2) => {
    if (a2 === ofUserId)
      return -1;
    if (b2 === ofUserId)
      return 1;
    const usernameA = usernames.get(a2) || "";
    const usernameB = usernames.get(b2) || "";
    return usernameA.localeCompare(usernameB);
  })) || [];
  const handleLogout = async () => {
    setIsLoggedIn(false);
    await LocalStorageManager.clear();
  };
  const handleUpgradeClick = () => {
    setActiveTab("upgradeToPaid", {
      is_upgrade: true,
      back_button_tab: "settings"
    });
  };
  const getDisplayUsername = (creatorId) => {
    const loadState = usernameLoadStates.get(creatorId);
    const username = usernames.get(creatorId);
    if (loadState === "loading") {
      return "Loading...";
    } else if (loadState === "error" || !username) {
      return `Failed to fetch username (ID: ${creatorId})`;
    }
    return username;
  };
  const handleBannerHide = () => {
    setUpdateMessage("");
    setUpdateStatus("");
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "w-full text-left", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      TabHeader,
      {
        title: "Manage your account settings",
        subtitle: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "font-bold", children: "Add team members to your account" }),
          " and manage your subscription"
        ] })
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex flex-col space-y-14", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { className: "mb-4 border-b pb-3 text-lg font-bold", children: "Current plan" }),
        isLoadingPortal ? /* @__PURE__ */ jsxRuntimeExports.jsx(LoadingSpinner, {}) : loadError ? /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text-sm italic text-red-500", children: "Failed to load subscription data. Please exit this tab and try again." }) : /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "text-sm font-medium", children: [
            planName,
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "text-xs font-normal text-gray-600", children: planQuantity > 1 && ` (x${planQuantity} creator pages)` })
          ] }),
          isOwner && /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children: planType === "free" ? /* @__PURE__ */ jsxRuntimeExports.jsx(
            "button",
            {
              onClick: handleUpgradeClick,
              className: "text-xs font-normal text-ofBlue-spicy hover:underline",
              children: "Upgrade to paid plan"
            }
          ) : portalUrl && /* @__PURE__ */ jsxRuntimeExports.jsx(
            "a",
            {
              href: portalUrl,
              target: "_blank",
              rel: "noopener noreferrer",
              className: "text-xs font-normal text-ofBlue-spicy hover:underline",
              children: "Manage subscription"
            }
          ) })
        ] })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { className: "mb-4 border-b pb-3 text-lg font-bold", children: "Account admin" }),
        isLoadingTeam ? /* @__PURE__ */ jsxRuntimeExports.jsx(LoadingSpinner, {}) : loadError ? /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text-sm italic text-red-500", children: "Failed to load team data. Please exit this tab and try again." }) : owner && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "inline-flex items-center rounded-lg border border-black-spicy px-4 py-2", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex flex-col space-y-1", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center justify-between", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "text-sm font-semibold text-black-spicy", children: isOwner && (owner.firstName || owner.lastName) ? `${owner.firstName} ${owner.lastName}` : "Account admin" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "ml-2 rounded-full border border-indigo-500 bg-indigo-100 px-2 py-0.5 text-[10px] font-bold text-indigo-500", children: "admin" })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "text-xs font-normal text-gray-600", children: owner.email })
        ] }) })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { className: "mb-4 border-b pb-3 text-lg font-bold", children: "Your account" }),
        isLoadingTeam ? /* @__PURE__ */ jsxRuntimeExports.jsx(LoadingSpinner, {}) : loadError ? /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text-sm italic text-red-500", children: "Failed to load user data. Please exit this tab and try again." }) : /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "inline-flex items-center rounded-lg border border-black-spicy px-4 py-2", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex flex-col space-y-1", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center justify-between", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "text-sm font-semibold text-black-spicy", children: currentUser && (currentUser.firstName || currentUser.lastName) ? `${(currentUser == null ? void 0 : currentUser.firstName) || ""} ${(currentUser == null ? void 0 : currentUser.lastName) || ""}`.trim() : isOwner && (owner.firstName || owner.lastName) ? `${owner.firstName || ""} ${owner.lastName || ""}`.trim() : (currentUser == null ? void 0 : currentUser.email) || (owner == null ? void 0 : owner.email) || "Missing name" }),
            isOwner && /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "ml-2 rounded-full border border-indigo-500 bg-indigo-100 px-2 py-0.5 text-[10px] font-bold text-indigo-500", children: "admin" })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "text-xs font-normal text-gray-600", children: (currentUser == null ? void 0 : currentUser.email) || (isOwner ? owner == null ? void 0 : owner.email : "") })
        ] }) })
      ] }),
      isOwner && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { className: "mb-4 border-b pb-3 text-lg font-bold", children: "Your team" }),
        isLoadingTeam ? /* @__PURE__ */ jsxRuntimeExports.jsx(LoadingSpinner, {}) : loadError ? /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text-sm italic text-red-500", children: "Failed to load team data. Please exit this tab and try again." }) : /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "mb-10", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: "mb-2 text-base font-semibold", children: "Team members" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex flex-wrap gap-2", children: managers.map((manager, index2) => /* @__PURE__ */ jsxRuntimeExports.jsx(
              "div",
              {
                className: "inline-flex items-center rounded-lg border border-black-spicy px-4 py-2",
                children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex w-fit flex-col space-y-1", children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center justify-between", children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center space-x-2", children: [
                      (manager.firstName || manager.lastName) && /* @__PURE__ */ jsxRuntimeExports.jsx(
                        "span",
                        {
                          className: `text-sm font-semibold text-black-spicy ${!manager.firstName && !manager.lastName ? "font-normal italic text-gray-400" : ""}`,
                          children: `${manager.firstName} ${manager.lastName}`
                        }
                      ),
                      /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "rounded-full border border-green-500 bg-green-100 px-2 py-0.5 text-[10px] font-bold text-green-500", children: "team member" })
                    ] }),
                    /* @__PURE__ */ jsxRuntimeExports.jsx(
                      "button",
                      {
                        onClick: () => handleRemoveTeamMember(manager),
                        disabled: isSubmitting || isLoading,
                        className: `text-base text-gray-400 hover:text-gray-600 ${(isSubmitting || isLoading) && "cursor-not-allowed opacity-50"}`,
                        children: "×"
                      }
                    )
                  ] }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "text-xs font-normal text-gray-600", children: manager.email })
                ] })
              },
              index2
            )) })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: "mb-2 text-base font-semibold", children: "Add team member" }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex flex-col space-y-4", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                "input",
                {
                  type: "email",
                  value: newEmail,
                  onChange: (e2) => setNewEmail(e2.target.value),
                  placeholder: "jane.doe@myteam.com",
                  className: "w-full rounded border border-gray-300 p-3 text-xs focus:border-indigo-500 focus:outline-none focus:ring-0"
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                SubmitButton,
                {
                  title: "Submit",
                  onSubmit: handleAddTeamMember,
                  hasChanges,
                  disabled: !newEmail || isSubmitting
                }
              )
            ] })
          ] })
        ] })
      ] }),
      isOwner && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { className: "mb-4 border-b pb-3 text-lg font-bold", children: "Linked creators" }),
        isLoading ? /* @__PURE__ */ jsxRuntimeExports.jsx(LoadingSpinner, {}) : loadError ? /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text-sm italic text-red-500", children: "Failed to load creator data. Please exit this tab and try again." }) : /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "space-y-4", children: [
          sortedCreators.map((creatorId) => /* @__PURE__ */ jsxRuntimeExports.jsxs(
            "div",
            {
              className: "flex items-center justify-between rounded-lg border border-black-spicy px-4 py-3",
              children: [
                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center space-x-2", children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: "text-sm font-semibold text-black-spicy", children: [
                    "@",
                    getDisplayUsername(creatorId)
                  ] }),
                  creatorId === ofUserId && /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "rounded-full border border-indigo-500 bg-indigo-100 px-2 py-0.5 text-[10px] font-bold text-indigo-500", children: "current" })
                ] }),
                (isOwner || creatorId === ofUserId) && /* @__PURE__ */ jsxRuntimeExports.jsx(
                  "button",
                  {
                    onClick: () => handleRemoveCreator(creatorId),
                    disabled: isSubmitting || isLoading,
                    className: `rounded px-2 py-1 text-sm text-gray-400 hover:bg-gray-100 hover:text-gray-600 ${(isSubmitting || isLoading) && "cursor-not-allowed opacity-50"}`,
                    children: "Remove"
                  }
                )
              ]
            },
            creatorId
          )),
          (!(subscriptionSettings == null ? void 0 : subscriptionSettings.ofCreatorIds) || ((_b = subscriptionSettings.ofCreatorIds) == null ? void 0 : _b.length) === 0) && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text-sm italic text-gray-500", children: "No creators linked to this account yet." })
        ] }) })
      ] }),
      effectiveFeatureFlags.enableDevMenu && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { className: "mb-4 border-b pb-3 text-lg font-bold", children: "Developer settings" }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "space-y-8", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: "mb-2 text-base font-semibold", children: "API environment" }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex flex-col space-y-2", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsxs(
                "select",
                {
                  value: currentEnvironment,
                  onChange: handleEnvironmentChange,
                  disabled: isSubmitting,
                  className: "w-full rounded border border-gray-300 p-3 text-xs focus:border-indigo-500 focus:ring-2 focus:ring-indigo-500",
                  children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx("option", { value: "prod", children: "Production" }),
                    /* @__PURE__ */ jsxRuntimeExports.jsx("option", { value: "staging", children: "Staging" }),
                    /* @__PURE__ */ jsxRuntimeExports.jsx("option", { value: "dev", children: "Development" }),
                    /* @__PURE__ */ jsxRuntimeExports.jsx("option", { value: "localhost", children: "Localhost" })
                  ]
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { className: "text-xs text-gray-500", children: [
                "Current API URL: ",
                environments[currentEnvironment]
              ] })
            ] })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "mb-2 flex items-center justify-between", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: "text-base font-semibold", children: "Feature flags" }),
              hasOverrides && /* @__PURE__ */ jsxRuntimeExports.jsx(
                "button",
                {
                  onClick: resetFeatureFlags,
                  className: "text-xs text-indigo-600 hover:underline",
                  children: "Reset to defaults"
                }
              )
            ] }),
            hasOverrides && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "mb-4 rounded-lg bg-yellow-50 p-3", children: /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-xs text-yellow-800", children: "You have overridden the server feature flags. These values will persist until reset." }) }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "space-y-3", children: [
              Object.entries(serverFeatureFlags || {}).filter(([key]) => key !== "enableDevMenu").map(([key, serverValue]) => {
                const effectiveValue = effectiveFeatureFlags[key];
                const isOverridden = serverValue !== effectiveValue;
                return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center justify-between", children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex flex-col", children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "text-sm font-medium", children: key }),
                    isOverridden && /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: "text-xs text-gray-500", children: [
                      "Server value: ",
                      serverValue ? "enabled" : "disabled"
                    ] })
                  ] }),
                  /* @__PURE__ */ jsxRuntimeExports.jsxs("label", { className: "relative inline-flex cursor-pointer items-center", children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx(
                      "input",
                      {
                        type: "checkbox",
                        checked: effectiveValue,
                        onChange: () => handleFeatureFlagToggle(key),
                        className: "peer sr-only"
                      }
                    ),
                    /* @__PURE__ */ jsxRuntimeExports.jsx(
                      "div",
                      {
                        className: `after:bg-white peer-checked:after:border-white peer h-6 w-11 rounded-full bg-gray-200 after:absolute after:start-[2px] after:top-[2px] after:h-5 after:w-5 after:rounded-full after:border after:border-gray-300 after:transition-all after:content-[''] peer-checked:bg-indigo-600 peer-checked:after:translate-x-full peer-focus:outline-none peer-focus:ring-4 peer-focus:ring-indigo-300 rtl:peer-checked:after:-translate-x-full ${isOverridden ? "ring-2 ring-yellow-400" : ""}`
                      }
                    )
                  ] })
                ] }, key);
              }),
              (!serverFeatureFlags || Object.keys(serverFeatureFlags).filter((key) => key !== "enableDevMenu").length === 0) && /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-sm italic text-gray-500", children: "No feature flags available." })
            ] })
          ] })
        ] })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "mt-8 border-t pt-8", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
        "button",
        {
          onClick: handleLogout,
          disabled: isSubmitting || isLoading,
          className: `flex w-full items-center justify-center rounded-lg bg-red-50 px-4 py-3 text-sm font-medium text-red-600 transition-colors duration-200 hover:bg-red-100 ${(isSubmitting || isLoading) && "cursor-not-allowed opacity-50"}`,
          children: "Logout"
        }
      ) })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      ConfirmModal,
      {
        isOpen: confirmDialog.isOpen,
        title: ((_c = confirmDialog.memberToRemove) == null ? void 0 : _c.type) === "creator" ? "Remove creator" : "Remove team member",
        message: confirmDialog.message,
        confirmText: isSubmitting ? "Removing..." : "Remove",
        onConfirm: confirmRemove,
        onCancel: () => setConfirmDialog({ isOpen: false, memberToRemove: null }),
        disabled: isSubmitting
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      ConfirmModal,
      {
        isOpen: environmentSwitchModal.isOpen,
        title: "Change environment",
        message: `Switching between production/staging and development/localhost environments will log you out. Are you sure you want to change to ${environmentSwitchModal.targetEnv} environment?`,
        confirmText: isSubmitting ? "Switching..." : "Switch and log out",
        onConfirm: confirmEnvironmentSwitch,
        onCancel: cancelEnvironmentSwitch,
        disabled: isSubmitting
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      FloatingStatusBanner,
      {
        message: (updateMessage == null ? void 0 : updateMessage.includes("www.")) ? /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children: updateMessage.split(/(www\.[^\s]+)/).map(
          (part, i2) => part.startsWith("www.") ? /* @__PURE__ */ jsxRuntimeExports.jsx(
            "a",
            {
              href: `https://${part}`,
              className: "text-ofBlue-spicy hover:underline",
              target: "_blank",
              rel: "noopener noreferrer",
              children: part
            },
            i2
          ) : part
        ) }) : updateMessage,
        type: updateStatus === "success" ? "success" : "error",
        show: !!updateMessage,
        onHide: handleBannerHide,
        autoHideDelay: 3e3
      }
    )
  ] });
};
/**
 * @license lucide-react v0.474.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const toKebabCase = (string) => string.replace(/([a-z0-9])([A-Z])/g, "$1-$2").toLowerCase();
const mergeClasses = (...classes) => classes.filter((className, index2, array) => {
  return Boolean(className) && className.trim() !== "" && array.indexOf(className) === index2;
}).join(" ").trim();
/**
 * @license lucide-react v0.474.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
var defaultAttributes = {
  xmlns: "http://www.w3.org/2000/svg",
  width: 24,
  height: 24,
  viewBox: "0 0 24 24",
  fill: "none",
  stroke: "currentColor",
  strokeWidth: 2,
  strokeLinecap: "round",
  strokeLinejoin: "round"
};
/**
 * @license lucide-react v0.474.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const Icon = reactExports.forwardRef(
  ({
    color = "currentColor",
    size = 24,
    strokeWidth = 2,
    absoluteStrokeWidth,
    className = "",
    children,
    iconNode,
    ...rest
  }, ref) => {
    return reactExports.createElement(
      "svg",
      {
        ref,
        ...defaultAttributes,
        width: size,
        height: size,
        stroke: color,
        strokeWidth: absoluteStrokeWidth ? Number(strokeWidth) * 24 / Number(size) : strokeWidth,
        className: mergeClasses("lucide", className),
        ...rest
      },
      [
        ...iconNode.map(([tag, attrs]) => reactExports.createElement(tag, attrs)),
        ...Array.isArray(children) ? children : [children]
      ]
    );
  }
);
/**
 * @license lucide-react v0.474.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const createLucideIcon = (iconName, iconNode) => {
  const Component = reactExports.forwardRef(
    ({ className, ...props }, ref) => reactExports.createElement(Icon, {
      ref,
      iconNode,
      className: mergeClasses(`lucide-${toKebabCase(iconName)}`, className),
      ...props
    })
  );
  Component.displayName = `${iconName}`;
  return Component;
};
/**
 * @license lucide-react v0.474.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const __iconNode$3 = [
  ["circle", { cx: "9", cy: "12", r: "1", key: "1vctgf" }],
  ["circle", { cx: "9", cy: "5", r: "1", key: "hp0tcf" }],
  ["circle", { cx: "9", cy: "19", r: "1", key: "fkjjf6" }],
  ["circle", { cx: "15", cy: "12", r: "1", key: "1tmaij" }],
  ["circle", { cx: "15", cy: "5", r: "1", key: "19l28e" }],
  ["circle", { cx: "15", cy: "19", r: "1", key: "f4zoj3" }]
];
const GripVertical = createLucideIcon("GripVertical", __iconNode$3);
/**
 * @license lucide-react v0.474.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const __iconNode$2 = [
  [
    "path",
    {
      d: "M21.174 6.812a1 1 0 0 0-3.986-3.987L3.842 16.174a2 2 0 0 0-.5.83l-1.321 4.352a.5.5 0 0 0 .623.622l4.353-1.32a2 2 0 0 0 .83-.497z",
      key: "1a8usu"
    }
  ]
];
const Pen = createLucideIcon("Pen", __iconNode$2);
/**
 * @license lucide-react v0.474.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const __iconNode$1 = [
  ["path", { d: "M5 12h14", key: "1ays0h" }],
  ["path", { d: "M12 5v14", key: "s699le" }]
];
const Plus = createLucideIcon("Plus", __iconNode$1);
/**
 * @license lucide-react v0.474.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const __iconNode = [
  ["path", { d: "M3 6h18", key: "d0wm0j" }],
  ["path", { d: "M19 6v14c0 1-1 2-2 2H7c-1 0-2-1-2-2V6", key: "4alrt4" }],
  ["path", { d: "M8 6V4c0-1 1-2 2-2h4c1 0 2 1 2 2v2", key: "v07s0e" }],
  ["line", { x1: "10", x2: "10", y1: "11", y2: "17", key: "1uufr5" }],
  ["line", { x1: "14", x2: "14", y1: "11", y2: "17", key: "xtxkd" }]
];
const Trash2 = createLucideIcon("Trash2", __iconNode);
const currentCreatorSettingsSelector = Recoil_index_9({
  key: "currentCreatorSettingsSelector",
  get: ({ get: get2 }) => {
    const subscriptionSettings = get2(subscriptionSettingsAtom);
    const ofUserId = get2(ofUserIdAtom);
    if (!subscriptionSettings || !ofUserId) {
      return void 0;
    }
    const creatorSettings = Array.isArray(subscriptionSettings.creatorSettings) ? subscriptionSettings.creatorSettings : [];
    const currentCreatorSettings = creatorSettings.find(
      (setting) => setting.ofCreatorId === ofUserId
    );
    return currentCreatorSettings || null;
  }
});
const isCreatorSettingsLoadingSelector = Recoil_index_9({
  key: "isCreatorSettingsLoadingSelector",
  get: ({ get: get2 }) => {
    const currentCreatorSettings = get2(currentCreatorSettingsSelector);
    return currentCreatorSettings === void 0;
  }
});
const hasCreatorSettingsSelector = Recoil_index_9({
  key: "hasCreatorSettingsSelector",
  get: ({ get: get2 }) => {
    const currentCreatorSettings = get2(currentCreatorSettingsSelector);
    return currentCreatorSettings !== null && currentCreatorSettings !== void 0;
  }
});
const aiRepliesEnabledSelector = Recoil_index_9({
  key: "aiRepliesEnabledSelector",
  get: ({ get: get2 }) => {
    const currentCreatorSettings = get2(currentCreatorSettingsSelector);
    const featureFlags = get2(effectiveFeatureFlagsSelector);
    if (currentCreatorSettings === void 0) {
      return false;
    }
    if (!(featureFlags == null ? void 0 : featureFlags.enableAIReplies)) {
      return false;
    }
    if (currentCreatorSettings === null) {
      return false;
    }
    return currentCreatorSettings.aiRepliesEnabled === true;
  }
});
const aiRulesSelector = Recoil_index_9({
  key: "aiRulesSelector",
  get: ({ get: get2 }) => {
    const subscriptionSettings = get2(subscriptionSettingsAtom);
    const ofUserId = get2(ofUserIdAtom);
    if (!subscriptionSettings || !ofUserId) {
      return [];
    }
    const creatorSettings = Array.isArray(subscriptionSettings.creatorSettings) ? subscriptionSettings.creatorSettings : [];
    const currentCreatorSettings = creatorSettings.find((setting) => setting.ofCreatorId == ofUserId) || {};
    return Array.isArray(currentCreatorSettings.aiRules) ? currentCreatorSettings.aiRules : [];
  }
});
var DefaultContext = {
  color: void 0,
  size: void 0,
  className: void 0,
  style: void 0,
  attr: void 0
};
var IconContext = React.createContext && React.createContext(DefaultContext);
var __assign = globalThis && globalThis.__assign || function() {
  __assign = Object.assign || function(t2) {
    for (var s2, i2 = 1, n2 = arguments.length; i2 < n2; i2++) {
      s2 = arguments[i2];
      for (var p2 in s2)
        if (Object.prototype.hasOwnProperty.call(s2, p2))
          t2[p2] = s2[p2];
    }
    return t2;
  };
  return __assign.apply(this, arguments);
};
var __rest = globalThis && globalThis.__rest || function(s2, e2) {
  var t2 = {};
  for (var p2 in s2)
    if (Object.prototype.hasOwnProperty.call(s2, p2) && e2.indexOf(p2) < 0)
      t2[p2] = s2[p2];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s2); i2 < p2.length; i2++) {
      if (e2.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i2]))
        t2[p2[i2]] = s2[p2[i2]];
    }
  return t2;
};
function Tree2Element(tree) {
  return tree && tree.map(function(node, i2) {
    return React.createElement(node.tag, __assign({
      key: i2
    }, node.attr), Tree2Element(node.child));
  });
}
function GenIcon(data) {
  return function(props) {
    return React.createElement(IconBase, __assign({
      attr: __assign({}, data.attr)
    }, props), Tree2Element(data.child));
  };
}
function IconBase(props) {
  var elem = function(conf) {
    var attr = props.attr, size = props.size, title = props.title, svgProps = __rest(props, ["attr", "size", "title"]);
    var computedSize = size || conf.size || "1em";
    var className;
    if (conf.className)
      className = conf.className;
    if (props.className)
      className = (className ? className + " " : "") + props.className;
    return React.createElement("svg", __assign({
      stroke: "currentColor",
      fill: "currentColor",
      strokeWidth: "0"
    }, conf.attr, attr, svgProps, {
      className,
      style: __assign(__assign({
        color: props.color || conf.color
      }, conf.style), props.style),
      height: computedSize,
      width: computedSize,
      xmlns: "http://www.w3.org/2000/svg"
    }), title && React.createElement("title", null, title), props.children);
  };
  return IconContext !== void 0 ? React.createElement(IconContext.Consumer, null, function(conf) {
    return elem(conf);
  }) : elem(DefaultContext);
}
function HiChevronDown(props) {
  return GenIcon({ "tag": "svg", "attr": { "viewBox": "0 0 20 20", "fill": "currentColor", "aria-hidden": "true" }, "child": [{ "tag": "path", "attr": { "fillRule": "evenodd", "d": "M5.293 7.293a1 1 0 011.414 0L10 10.586l3.293-3.293a1 1 0 111.414 1.414l-4 4a1 1 0 01-1.414 0l-4-4a1 1 0 010-1.414z", "clipRule": "evenodd" } }] })(props);
}
function HiChevronLeft(props) {
  return GenIcon({ "tag": "svg", "attr": { "viewBox": "0 0 20 20", "fill": "currentColor", "aria-hidden": "true" }, "child": [{ "tag": "path", "attr": { "fillRule": "evenodd", "d": "M12.707 5.293a1 1 0 010 1.414L9.414 10l3.293 3.293a1 1 0 01-1.414 1.414l-4-4a1 1 0 010-1.414l4-4a1 1 0 011.414 0z", "clipRule": "evenodd" } }] })(props);
}
function HiChevronRight(props) {
  return GenIcon({ "tag": "svg", "attr": { "viewBox": "0 0 20 20", "fill": "currentColor", "aria-hidden": "true" }, "child": [{ "tag": "path", "attr": { "fillRule": "evenodd", "d": "M7.293 14.707a1 1 0 010-1.414L10.586 10 7.293 6.707a1 1 0 011.414-1.414l4 4a1 1 0 010 1.414l-4 4a1 1 0 01-1.414 0z", "clipRule": "evenodd" } }] })(props);
}
function HiStar(props) {
  return GenIcon({ "tag": "svg", "attr": { "viewBox": "0 0 20 20", "fill": "currentColor", "aria-hidden": "true" }, "child": [{ "tag": "path", "attr": { "d": "M9.049 2.927c.3-.921 1.603-.921 1.902 0l1.07 3.292a1 1 0 00.95.69h3.462c.969 0 1.371 1.24.588 1.81l-2.8 2.034a1 1 0 00-.364 1.118l1.07 3.292c.3.921-.755 1.688-1.54 1.118l-2.8-2.034a1 1 0 00-1.175 0l-2.8 2.034c-.784.57-1.838-.197-1.539-1.118l1.07-3.292a1 1 0 00-.364-1.118L2.98 8.72c-.783-.57-.38-1.81.588-1.81h3.461a1 1 0 00.951-.69l1.07-3.292z" } }] })(props);
}
function HiX(props) {
  return GenIcon({ "tag": "svg", "attr": { "viewBox": "0 0 20 20", "fill": "currentColor", "aria-hidden": "true" }, "child": [{ "tag": "path", "attr": { "fillRule": "evenodd", "d": "M4.293 4.293a1 1 0 011.414 0L10 8.586l4.293-4.293a1 1 0 111.414 1.414L11.414 10l4.293 4.293a1 1 0 01-1.414 1.414L10 11.414l-4.293 4.293a1 1 0 01-1.414-1.414L8.586 10 4.293 5.707a1 1 0 010-1.414z", "clipRule": "evenodd" } }] })(props);
}
function HiOutlineChevronDown(props) {
  return GenIcon({ "tag": "svg", "attr": { "fill": "none", "viewBox": "0 0 24 24", "strokeWidth": "2", "stroke": "currentColor", "aria-hidden": "true" }, "child": [{ "tag": "path", "attr": { "strokeLinecap": "round", "strokeLinejoin": "round", "d": "M19 9l-7 7-7-7" } }] })(props);
}
function HiOutlineChevronLeft(props) {
  return GenIcon({ "tag": "svg", "attr": { "fill": "none", "viewBox": "0 0 24 24", "strokeWidth": "2", "stroke": "currentColor", "aria-hidden": "true" }, "child": [{ "tag": "path", "attr": { "strokeLinecap": "round", "strokeLinejoin": "round", "d": "M15 19l-7-7 7-7" } }] })(props);
}
function HiOutlineChevronRight(props) {
  return GenIcon({ "tag": "svg", "attr": { "fill": "none", "viewBox": "0 0 24 24", "strokeWidth": "2", "stroke": "currentColor", "aria-hidden": "true" }, "child": [{ "tag": "path", "attr": { "strokeLinecap": "round", "strokeLinejoin": "round", "d": "M9 5l7 7-7 7" } }] })(props);
}
function HiOutlineChevronUp(props) {
  return GenIcon({ "tag": "svg", "attr": { "fill": "none", "viewBox": "0 0 24 24", "strokeWidth": "2", "stroke": "currentColor", "aria-hidden": "true" }, "child": [{ "tag": "path", "attr": { "strokeLinecap": "round", "strokeLinejoin": "round", "d": "M5 15l7-7 7 7" } }] })(props);
}
function HiOutlineX(props) {
  return GenIcon({ "tag": "svg", "attr": { "fill": "none", "viewBox": "0 0 24 24", "strokeWidth": "2", "stroke": "currentColor", "aria-hidden": "true" }, "child": [{ "tag": "path", "attr": { "strokeLinecap": "round", "strokeLinejoin": "round", "d": "M6 18L18 6M6 6l12 12" } }] })(props);
}
function twJoin() {
  var index2 = 0;
  var argument;
  var resolvedValue;
  var string = "";
  while (index2 < arguments.length) {
    if (argument = arguments[index2++]) {
      if (resolvedValue = toValue(argument)) {
        string && (string += " ");
        string += resolvedValue;
      }
    }
  }
  return string;
}
function toValue(mix) {
  if (typeof mix === "string") {
    return mix;
  }
  var resolvedValue;
  var string = "";
  for (var k2 = 0; k2 < mix.length; k2++) {
    if (mix[k2]) {
      if (resolvedValue = toValue(mix[k2])) {
        string && (string += " ");
        string += resolvedValue;
      }
    }
  }
  return string;
}
var CLASS_PART_SEPARATOR = "-";
function createClassUtils(config2) {
  var classMap = createClassMap(config2);
  var conflictingClassGroups = config2.conflictingClassGroups, _config$conflictingCl = config2.conflictingClassGroupModifiers, conflictingClassGroupModifiers = _config$conflictingCl === void 0 ? {} : _config$conflictingCl;
  function getClassGroupId(className) {
    var classParts = className.split(CLASS_PART_SEPARATOR);
    if (classParts[0] === "" && classParts.length !== 1) {
      classParts.shift();
    }
    return getGroupRecursive(classParts, classMap) || getGroupIdForArbitraryProperty(className);
  }
  function getConflictingClassGroupIds(classGroupId, hasPostfixModifier) {
    var conflicts = conflictingClassGroups[classGroupId] || [];
    if (hasPostfixModifier && conflictingClassGroupModifiers[classGroupId]) {
      return [].concat(conflicts, conflictingClassGroupModifiers[classGroupId]);
    }
    return conflicts;
  }
  return {
    getClassGroupId,
    getConflictingClassGroupIds
  };
}
function getGroupRecursive(classParts, classPartObject) {
  var _a;
  if (classParts.length === 0) {
    return classPartObject.classGroupId;
  }
  var currentClassPart = classParts[0];
  var nextClassPartObject = classPartObject.nextPart.get(currentClassPart);
  var classGroupFromNextClassPart = nextClassPartObject ? getGroupRecursive(classParts.slice(1), nextClassPartObject) : void 0;
  if (classGroupFromNextClassPart) {
    return classGroupFromNextClassPart;
  }
  if (classPartObject.validators.length === 0) {
    return void 0;
  }
  var classRest = classParts.join(CLASS_PART_SEPARATOR);
  return (_a = classPartObject.validators.find(function(_ref) {
    var validator = _ref.validator;
    return validator(classRest);
  })) == null ? void 0 : _a.classGroupId;
}
var arbitraryPropertyRegex = /^\[(.+)\]$/;
function getGroupIdForArbitraryProperty(className) {
  if (arbitraryPropertyRegex.test(className)) {
    var arbitraryPropertyClassName = arbitraryPropertyRegex.exec(className)[1];
    var property = arbitraryPropertyClassName == null ? void 0 : arbitraryPropertyClassName.substring(0, arbitraryPropertyClassName.indexOf(":"));
    if (property) {
      return "arbitrary.." + property;
    }
  }
}
function createClassMap(config2) {
  var theme2 = config2.theme, prefix2 = config2.prefix;
  var classMap = {
    nextPart: /* @__PURE__ */ new Map(),
    validators: []
  };
  var prefixedClassGroupEntries = getPrefixedClassGroupEntries(Object.entries(config2.classGroups), prefix2);
  prefixedClassGroupEntries.forEach(function(_ref2) {
    var classGroupId = _ref2[0], classGroup = _ref2[1];
    processClassesRecursively(classGroup, classMap, classGroupId, theme2);
  });
  return classMap;
}
function processClassesRecursively(classGroup, classPartObject, classGroupId, theme2) {
  classGroup.forEach(function(classDefinition) {
    if (typeof classDefinition === "string") {
      var classPartObjectToEdit = classDefinition === "" ? classPartObject : getPart(classPartObject, classDefinition);
      classPartObjectToEdit.classGroupId = classGroupId;
      return;
    }
    if (typeof classDefinition === "function") {
      if (isThemeGetter(classDefinition)) {
        processClassesRecursively(classDefinition(theme2), classPartObject, classGroupId, theme2);
        return;
      }
      classPartObject.validators.push({
        validator: classDefinition,
        classGroupId
      });
      return;
    }
    Object.entries(classDefinition).forEach(function(_ref3) {
      var key = _ref3[0], classGroup2 = _ref3[1];
      processClassesRecursively(classGroup2, getPart(classPartObject, key), classGroupId, theme2);
    });
  });
}
function getPart(classPartObject, path) {
  var currentClassPartObject = classPartObject;
  path.split(CLASS_PART_SEPARATOR).forEach(function(pathPart) {
    if (!currentClassPartObject.nextPart.has(pathPart)) {
      currentClassPartObject.nextPart.set(pathPart, {
        nextPart: /* @__PURE__ */ new Map(),
        validators: []
      });
    }
    currentClassPartObject = currentClassPartObject.nextPart.get(pathPart);
  });
  return currentClassPartObject;
}
function isThemeGetter(func) {
  return func.isThemeGetter;
}
function getPrefixedClassGroupEntries(classGroupEntries, prefix2) {
  if (!prefix2) {
    return classGroupEntries;
  }
  return classGroupEntries.map(function(_ref4) {
    var classGroupId = _ref4[0], classGroup = _ref4[1];
    var prefixedClassGroup = classGroup.map(function(classDefinition) {
      if (typeof classDefinition === "string") {
        return prefix2 + classDefinition;
      }
      if (typeof classDefinition === "object") {
        return Object.fromEntries(Object.entries(classDefinition).map(function(_ref5) {
          var key = _ref5[0], value = _ref5[1];
          return [prefix2 + key, value];
        }));
      }
      return classDefinition;
    });
    return [classGroupId, prefixedClassGroup];
  });
}
function createLruCache(maxCacheSize) {
  if (maxCacheSize < 1) {
    return {
      get: function get2() {
        return void 0;
      },
      set: function set() {
      }
    };
  }
  var cacheSize = 0;
  var cache = /* @__PURE__ */ new Map();
  var previousCache = /* @__PURE__ */ new Map();
  function update2(key, value) {
    cache.set(key, value);
    cacheSize++;
    if (cacheSize > maxCacheSize) {
      cacheSize = 0;
      previousCache = cache;
      cache = /* @__PURE__ */ new Map();
    }
  }
  return {
    get: function get2(key) {
      var value = cache.get(key);
      if (value !== void 0) {
        return value;
      }
      if ((value = previousCache.get(key)) !== void 0) {
        update2(key, value);
        return value;
      }
    },
    set: function set(key, value) {
      if (cache.has(key)) {
        cache.set(key, value);
      } else {
        update2(key, value);
      }
    }
  };
}
var IMPORTANT_MODIFIER = "!";
function createSplitModifiers(config2) {
  var separator = config2.separator || ":";
  var isSeparatorSingleCharacter = separator.length === 1;
  var firstSeparatorCharacter = separator[0];
  var separatorLength = separator.length;
  return function splitModifiers(className) {
    var modifiers = [];
    var bracketDepth = 0;
    var modifierStart = 0;
    var postfixModifierPosition;
    for (var index2 = 0; index2 < className.length; index2++) {
      var currentCharacter = className[index2];
      if (bracketDepth === 0) {
        if (currentCharacter === firstSeparatorCharacter && (isSeparatorSingleCharacter || className.slice(index2, index2 + separatorLength) === separator)) {
          modifiers.push(className.slice(modifierStart, index2));
          modifierStart = index2 + separatorLength;
          continue;
        }
        if (currentCharacter === "/") {
          postfixModifierPosition = index2;
          continue;
        }
      }
      if (currentCharacter === "[") {
        bracketDepth++;
      } else if (currentCharacter === "]") {
        bracketDepth--;
      }
    }
    var baseClassNameWithImportantModifier = modifiers.length === 0 ? className : className.substring(modifierStart);
    var hasImportantModifier = baseClassNameWithImportantModifier.startsWith(IMPORTANT_MODIFIER);
    var baseClassName = hasImportantModifier ? baseClassNameWithImportantModifier.substring(1) : baseClassNameWithImportantModifier;
    var maybePostfixModifierPosition = postfixModifierPosition && postfixModifierPosition > modifierStart ? postfixModifierPosition - modifierStart : void 0;
    return {
      modifiers,
      hasImportantModifier,
      baseClassName,
      maybePostfixModifierPosition
    };
  };
}
function sortModifiers(modifiers) {
  if (modifiers.length <= 1) {
    return modifiers;
  }
  var sortedModifiers = [];
  var unsortedModifiers = [];
  modifiers.forEach(function(modifier) {
    var isArbitraryVariant = modifier[0] === "[";
    if (isArbitraryVariant) {
      sortedModifiers.push.apply(sortedModifiers, unsortedModifiers.sort().concat([modifier]));
      unsortedModifiers = [];
    } else {
      unsortedModifiers.push(modifier);
    }
  });
  sortedModifiers.push.apply(sortedModifiers, unsortedModifiers.sort());
  return sortedModifiers;
}
function createConfigUtils(config2) {
  return {
    cache: createLruCache(config2.cacheSize),
    splitModifiers: createSplitModifiers(config2),
    ...createClassUtils(config2)
  };
}
var SPLIT_CLASSES_REGEX = /\s+/;
function mergeClassList(classList, configUtils) {
  var splitModifiers = configUtils.splitModifiers, getClassGroupId = configUtils.getClassGroupId, getConflictingClassGroupIds = configUtils.getConflictingClassGroupIds;
  var classGroupsInConflict = /* @__PURE__ */ new Set();
  return classList.trim().split(SPLIT_CLASSES_REGEX).map(function(originalClassName) {
    var _splitModifiers = splitModifiers(originalClassName), modifiers = _splitModifiers.modifiers, hasImportantModifier = _splitModifiers.hasImportantModifier, baseClassName = _splitModifiers.baseClassName, maybePostfixModifierPosition = _splitModifiers.maybePostfixModifierPosition;
    var classGroupId = getClassGroupId(maybePostfixModifierPosition ? baseClassName.substring(0, maybePostfixModifierPosition) : baseClassName);
    var hasPostfixModifier = Boolean(maybePostfixModifierPosition);
    if (!classGroupId) {
      if (!maybePostfixModifierPosition) {
        return {
          isTailwindClass: false,
          originalClassName
        };
      }
      classGroupId = getClassGroupId(baseClassName);
      if (!classGroupId) {
        return {
          isTailwindClass: false,
          originalClassName
        };
      }
      hasPostfixModifier = false;
    }
    var variantModifier = sortModifiers(modifiers).join(":");
    var modifierId = hasImportantModifier ? variantModifier + IMPORTANT_MODIFIER : variantModifier;
    return {
      isTailwindClass: true,
      modifierId,
      classGroupId,
      originalClassName,
      hasPostfixModifier
    };
  }).reverse().filter(function(parsed) {
    if (!parsed.isTailwindClass) {
      return true;
    }
    var modifierId = parsed.modifierId, classGroupId = parsed.classGroupId, hasPostfixModifier = parsed.hasPostfixModifier;
    var classId = modifierId + classGroupId;
    if (classGroupsInConflict.has(classId)) {
      return false;
    }
    classGroupsInConflict.add(classId);
    getConflictingClassGroupIds(classGroupId, hasPostfixModifier).forEach(function(group) {
      return classGroupsInConflict.add(modifierId + group);
    });
    return true;
  }).reverse().map(function(parsed) {
    return parsed.originalClassName;
  }).join(" ");
}
function createTailwindMerge() {
  for (var _len = arguments.length, createConfig = new Array(_len), _key = 0; _key < _len; _key++) {
    createConfig[_key] = arguments[_key];
  }
  var configUtils;
  var cacheGet;
  var cacheSet;
  var functionToCall = initTailwindMerge;
  function initTailwindMerge(classList) {
    var firstCreateConfig = createConfig[0], restCreateConfig = createConfig.slice(1);
    var config2 = restCreateConfig.reduce(function(previousConfig, createConfigCurrent) {
      return createConfigCurrent(previousConfig);
    }, firstCreateConfig());
    configUtils = createConfigUtils(config2);
    cacheGet = configUtils.cache.get;
    cacheSet = configUtils.cache.set;
    functionToCall = tailwindMerge;
    return tailwindMerge(classList);
  }
  function tailwindMerge(classList) {
    var cachedResult = cacheGet(classList);
    if (cachedResult) {
      return cachedResult;
    }
    var result = mergeClassList(classList, configUtils);
    cacheSet(classList, result);
    return result;
  }
  return function callTailwindMerge() {
    return functionToCall(twJoin.apply(null, arguments));
  };
}
function fromTheme(key) {
  var themeGetter = function themeGetter2(theme2) {
    return theme2[key] || [];
  };
  themeGetter.isThemeGetter = true;
  return themeGetter;
}
var arbitraryValueRegex = /^\[(?:([a-z-]+):)?(.+)\]$/i;
var fractionRegex = /^\d+\/\d+$/;
var stringLengths = /* @__PURE__ */ new Set(["px", "full", "screen"]);
var tshirtUnitRegex = /^(\d+(\.\d+)?)?(xs|sm|md|lg|xl)$/;
var lengthUnitRegex = /\d+(%|px|r?em|[sdl]?v([hwib]|min|max)|pt|pc|in|cm|mm|cap|ch|ex|r?lh|cq(w|h|i|b|min|max))|\b(calc|min|max|clamp)\(.+\)|^0$/;
var shadowRegex = /^-?((\d+)?\.?(\d+)[a-z]+|0)_-?((\d+)?\.?(\d+)[a-z]+|0)/;
function isLength(value) {
  return isNumber(value) || stringLengths.has(value) || fractionRegex.test(value) || isArbitraryLength(value);
}
function isArbitraryLength(value) {
  return getIsArbitraryValue(value, "length", isLengthOnly);
}
function isArbitrarySize(value) {
  return getIsArbitraryValue(value, "size", isNever);
}
function isArbitraryPosition(value) {
  return getIsArbitraryValue(value, "position", isNever);
}
function isArbitraryUrl(value) {
  return getIsArbitraryValue(value, "url", isUrl);
}
function isArbitraryNumber(value) {
  return getIsArbitraryValue(value, "number", isNumber);
}
function isNumber(value) {
  return !Number.isNaN(Number(value));
}
function isPercent(value) {
  return value.endsWith("%") && isNumber(value.slice(0, -1));
}
function isInteger(value) {
  return isIntegerOnly(value) || getIsArbitraryValue(value, "number", isIntegerOnly);
}
function isArbitraryValue(value) {
  return arbitraryValueRegex.test(value);
}
function isAny() {
  return true;
}
function isTshirtSize(value) {
  return tshirtUnitRegex.test(value);
}
function isArbitraryShadow(value) {
  return getIsArbitraryValue(value, "", isShadow);
}
function getIsArbitraryValue(value, label, testValue) {
  var result = arbitraryValueRegex.exec(value);
  if (result) {
    if (result[1]) {
      return result[1] === label;
    }
    return testValue(result[2]);
  }
  return false;
}
function isLengthOnly(value) {
  return lengthUnitRegex.test(value);
}
function isNever() {
  return false;
}
function isUrl(value) {
  return value.startsWith("url(");
}
function isIntegerOnly(value) {
  return Number.isInteger(Number(value));
}
function isShadow(value) {
  return shadowRegex.test(value);
}
function getDefaultConfig() {
  var colors = fromTheme("colors");
  var spacing = fromTheme("spacing");
  var blur = fromTheme("blur");
  var brightness = fromTheme("brightness");
  var borderColor = fromTheme("borderColor");
  var borderRadius = fromTheme("borderRadius");
  var borderSpacing = fromTheme("borderSpacing");
  var borderWidth = fromTheme("borderWidth");
  var contrast = fromTheme("contrast");
  var grayscale = fromTheme("grayscale");
  var hueRotate = fromTheme("hueRotate");
  var invert = fromTheme("invert");
  var gap = fromTheme("gap");
  var gradientColorStops = fromTheme("gradientColorStops");
  var gradientColorStopPositions = fromTheme("gradientColorStopPositions");
  var inset = fromTheme("inset");
  var margin = fromTheme("margin");
  var opacity = fromTheme("opacity");
  var padding = fromTheme("padding");
  var saturate = fromTheme("saturate");
  var scale = fromTheme("scale");
  var sepia = fromTheme("sepia");
  var skew = fromTheme("skew");
  var space2 = fromTheme("space");
  var translate = fromTheme("translate");
  var getOverscroll = function getOverscroll2() {
    return ["auto", "contain", "none"];
  };
  var getOverflow = function getOverflow2() {
    return ["auto", "hidden", "clip", "visible", "scroll"];
  };
  var getSpacingWithAutoAndArbitrary = function getSpacingWithAutoAndArbitrary2() {
    return ["auto", isArbitraryValue, spacing];
  };
  var getSpacingWithArbitrary = function getSpacingWithArbitrary2() {
    return [isArbitraryValue, spacing];
  };
  var getLengthWithEmpty = function getLengthWithEmpty2() {
    return ["", isLength];
  };
  var getNumberWithAutoAndArbitrary = function getNumberWithAutoAndArbitrary2() {
    return ["auto", isNumber, isArbitraryValue];
  };
  var getPositions = function getPositions2() {
    return ["bottom", "center", "left", "left-bottom", "left-top", "right", "right-bottom", "right-top", "top"];
  };
  var getLineStyles = function getLineStyles2() {
    return ["solid", "dashed", "dotted", "double", "none"];
  };
  var getBlendModes = function getBlendModes2() {
    return ["normal", "multiply", "screen", "overlay", "darken", "lighten", "color-dodge", "color-burn", "hard-light", "soft-light", "difference", "exclusion", "hue", "saturation", "color", "luminosity", "plus-lighter"];
  };
  var getAlign = function getAlign2() {
    return ["start", "end", "center", "between", "around", "evenly", "stretch"];
  };
  var getZeroAndEmpty = function getZeroAndEmpty2() {
    return ["", "0", isArbitraryValue];
  };
  var getBreaks = function getBreaks2() {
    return ["auto", "avoid", "all", "avoid-page", "page", "left", "right", "column"];
  };
  var getNumber = function getNumber2() {
    return [isNumber, isArbitraryNumber];
  };
  var getNumberAndArbitrary = function getNumberAndArbitrary2() {
    return [isNumber, isArbitraryValue];
  };
  return {
    cacheSize: 500,
    theme: {
      colors: [isAny],
      spacing: [isLength],
      blur: ["none", "", isTshirtSize, isArbitraryValue],
      brightness: getNumber(),
      borderColor: [colors],
      borderRadius: ["none", "", "full", isTshirtSize, isArbitraryValue],
      borderSpacing: getSpacingWithArbitrary(),
      borderWidth: getLengthWithEmpty(),
      contrast: getNumber(),
      grayscale: getZeroAndEmpty(),
      hueRotate: getNumberAndArbitrary(),
      invert: getZeroAndEmpty(),
      gap: getSpacingWithArbitrary(),
      gradientColorStops: [colors],
      gradientColorStopPositions: [isPercent, isArbitraryLength],
      inset: getSpacingWithAutoAndArbitrary(),
      margin: getSpacingWithAutoAndArbitrary(),
      opacity: getNumber(),
      padding: getSpacingWithArbitrary(),
      saturate: getNumber(),
      scale: getNumber(),
      sepia: getZeroAndEmpty(),
      skew: getNumberAndArbitrary(),
      space: getSpacingWithArbitrary(),
      translate: getSpacingWithArbitrary()
    },
    classGroups: {
      // Layout
      /**
       * Aspect Ratio
       * @see https://tailwindcss.com/docs/aspect-ratio
       */
      aspect: [{
        aspect: ["auto", "square", "video", isArbitraryValue]
      }],
      /**
       * Container
       * @see https://tailwindcss.com/docs/container
       */
      container: ["container"],
      /**
       * Columns
       * @see https://tailwindcss.com/docs/columns
       */
      columns: [{
        columns: [isTshirtSize]
      }],
      /**
       * Break After
       * @see https://tailwindcss.com/docs/break-after
       */
      "break-after": [{
        "break-after": getBreaks()
      }],
      /**
       * Break Before
       * @see https://tailwindcss.com/docs/break-before
       */
      "break-before": [{
        "break-before": getBreaks()
      }],
      /**
       * Break Inside
       * @see https://tailwindcss.com/docs/break-inside
       */
      "break-inside": [{
        "break-inside": ["auto", "avoid", "avoid-page", "avoid-column"]
      }],
      /**
       * Box Decoration Break
       * @see https://tailwindcss.com/docs/box-decoration-break
       */
      "box-decoration": [{
        "box-decoration": ["slice", "clone"]
      }],
      /**
       * Box Sizing
       * @see https://tailwindcss.com/docs/box-sizing
       */
      box: [{
        box: ["border", "content"]
      }],
      /**
       * Display
       * @see https://tailwindcss.com/docs/display
       */
      display: ["block", "inline-block", "inline", "flex", "inline-flex", "table", "inline-table", "table-caption", "table-cell", "table-column", "table-column-group", "table-footer-group", "table-header-group", "table-row-group", "table-row", "flow-root", "grid", "inline-grid", "contents", "list-item", "hidden"],
      /**
       * Floats
       * @see https://tailwindcss.com/docs/float
       */
      "float": [{
        "float": ["right", "left", "none"]
      }],
      /**
       * Clear
       * @see https://tailwindcss.com/docs/clear
       */
      clear: [{
        clear: ["left", "right", "both", "none"]
      }],
      /**
       * Isolation
       * @see https://tailwindcss.com/docs/isolation
       */
      isolation: ["isolate", "isolation-auto"],
      /**
       * Object Fit
       * @see https://tailwindcss.com/docs/object-fit
       */
      "object-fit": [{
        object: ["contain", "cover", "fill", "none", "scale-down"]
      }],
      /**
       * Object Position
       * @see https://tailwindcss.com/docs/object-position
       */
      "object-position": [{
        object: [].concat(getPositions(), [isArbitraryValue])
      }],
      /**
       * Overflow
       * @see https://tailwindcss.com/docs/overflow
       */
      overflow: [{
        overflow: getOverflow()
      }],
      /**
       * Overflow X
       * @see https://tailwindcss.com/docs/overflow
       */
      "overflow-x": [{
        "overflow-x": getOverflow()
      }],
      /**
       * Overflow Y
       * @see https://tailwindcss.com/docs/overflow
       */
      "overflow-y": [{
        "overflow-y": getOverflow()
      }],
      /**
       * Overscroll Behavior
       * @see https://tailwindcss.com/docs/overscroll-behavior
       */
      overscroll: [{
        overscroll: getOverscroll()
      }],
      /**
       * Overscroll Behavior X
       * @see https://tailwindcss.com/docs/overscroll-behavior
       */
      "overscroll-x": [{
        "overscroll-x": getOverscroll()
      }],
      /**
       * Overscroll Behavior Y
       * @see https://tailwindcss.com/docs/overscroll-behavior
       */
      "overscroll-y": [{
        "overscroll-y": getOverscroll()
      }],
      /**
       * Position
       * @see https://tailwindcss.com/docs/position
       */
      position: ["static", "fixed", "absolute", "relative", "sticky"],
      /**
       * Top / Right / Bottom / Left
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      inset: [{
        inset: [inset]
      }],
      /**
       * Right / Left
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      "inset-x": [{
        "inset-x": [inset]
      }],
      /**
       * Top / Bottom
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      "inset-y": [{
        "inset-y": [inset]
      }],
      /**
       * Start
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      start: [{
        start: [inset]
      }],
      /**
       * End
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      end: [{
        end: [inset]
      }],
      /**
       * Top
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      top: [{
        top: [inset]
      }],
      /**
       * Right
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      right: [{
        right: [inset]
      }],
      /**
       * Bottom
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      bottom: [{
        bottom: [inset]
      }],
      /**
       * Left
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      left: [{
        left: [inset]
      }],
      /**
       * Visibility
       * @see https://tailwindcss.com/docs/visibility
       */
      visibility: ["visible", "invisible", "collapse"],
      /**
       * Z-Index
       * @see https://tailwindcss.com/docs/z-index
       */
      z: [{
        z: ["auto", isInteger]
      }],
      // Flexbox and Grid
      /**
       * Flex Basis
       * @see https://tailwindcss.com/docs/flex-basis
       */
      basis: [{
        basis: getSpacingWithAutoAndArbitrary()
      }],
      /**
       * Flex Direction
       * @see https://tailwindcss.com/docs/flex-direction
       */
      "flex-direction": [{
        flex: ["row", "row-reverse", "col", "col-reverse"]
      }],
      /**
       * Flex Wrap
       * @see https://tailwindcss.com/docs/flex-wrap
       */
      "flex-wrap": [{
        flex: ["wrap", "wrap-reverse", "nowrap"]
      }],
      /**
       * Flex
       * @see https://tailwindcss.com/docs/flex
       */
      flex: [{
        flex: ["1", "auto", "initial", "none", isArbitraryValue]
      }],
      /**
       * Flex Grow
       * @see https://tailwindcss.com/docs/flex-grow
       */
      grow: [{
        grow: getZeroAndEmpty()
      }],
      /**
       * Flex Shrink
       * @see https://tailwindcss.com/docs/flex-shrink
       */
      shrink: [{
        shrink: getZeroAndEmpty()
      }],
      /**
       * Order
       * @see https://tailwindcss.com/docs/order
       */
      order: [{
        order: ["first", "last", "none", isInteger]
      }],
      /**
       * Grid Template Columns
       * @see https://tailwindcss.com/docs/grid-template-columns
       */
      "grid-cols": [{
        "grid-cols": [isAny]
      }],
      /**
       * Grid Column Start / End
       * @see https://tailwindcss.com/docs/grid-column
       */
      "col-start-end": [{
        col: ["auto", {
          span: ["full", isInteger]
        }, isArbitraryValue]
      }],
      /**
       * Grid Column Start
       * @see https://tailwindcss.com/docs/grid-column
       */
      "col-start": [{
        "col-start": getNumberWithAutoAndArbitrary()
      }],
      /**
       * Grid Column End
       * @see https://tailwindcss.com/docs/grid-column
       */
      "col-end": [{
        "col-end": getNumberWithAutoAndArbitrary()
      }],
      /**
       * Grid Template Rows
       * @see https://tailwindcss.com/docs/grid-template-rows
       */
      "grid-rows": [{
        "grid-rows": [isAny]
      }],
      /**
       * Grid Row Start / End
       * @see https://tailwindcss.com/docs/grid-row
       */
      "row-start-end": [{
        row: ["auto", {
          span: [isInteger]
        }, isArbitraryValue]
      }],
      /**
       * Grid Row Start
       * @see https://tailwindcss.com/docs/grid-row
       */
      "row-start": [{
        "row-start": getNumberWithAutoAndArbitrary()
      }],
      /**
       * Grid Row End
       * @see https://tailwindcss.com/docs/grid-row
       */
      "row-end": [{
        "row-end": getNumberWithAutoAndArbitrary()
      }],
      /**
       * Grid Auto Flow
       * @see https://tailwindcss.com/docs/grid-auto-flow
       */
      "grid-flow": [{
        "grid-flow": ["row", "col", "dense", "row-dense", "col-dense"]
      }],
      /**
       * Grid Auto Columns
       * @see https://tailwindcss.com/docs/grid-auto-columns
       */
      "auto-cols": [{
        "auto-cols": ["auto", "min", "max", "fr", isArbitraryValue]
      }],
      /**
       * Grid Auto Rows
       * @see https://tailwindcss.com/docs/grid-auto-rows
       */
      "auto-rows": [{
        "auto-rows": ["auto", "min", "max", "fr", isArbitraryValue]
      }],
      /**
       * Gap
       * @see https://tailwindcss.com/docs/gap
       */
      gap: [{
        gap: [gap]
      }],
      /**
       * Gap X
       * @see https://tailwindcss.com/docs/gap
       */
      "gap-x": [{
        "gap-x": [gap]
      }],
      /**
       * Gap Y
       * @see https://tailwindcss.com/docs/gap
       */
      "gap-y": [{
        "gap-y": [gap]
      }],
      /**
       * Justify Content
       * @see https://tailwindcss.com/docs/justify-content
       */
      "justify-content": [{
        justify: ["normal"].concat(getAlign())
      }],
      /**
       * Justify Items
       * @see https://tailwindcss.com/docs/justify-items
       */
      "justify-items": [{
        "justify-items": ["start", "end", "center", "stretch"]
      }],
      /**
       * Justify Self
       * @see https://tailwindcss.com/docs/justify-self
       */
      "justify-self": [{
        "justify-self": ["auto", "start", "end", "center", "stretch"]
      }],
      /**
       * Align Content
       * @see https://tailwindcss.com/docs/align-content
       */
      "align-content": [{
        content: ["normal"].concat(getAlign(), ["baseline"])
      }],
      /**
       * Align Items
       * @see https://tailwindcss.com/docs/align-items
       */
      "align-items": [{
        items: ["start", "end", "center", "baseline", "stretch"]
      }],
      /**
       * Align Self
       * @see https://tailwindcss.com/docs/align-self
       */
      "align-self": [{
        self: ["auto", "start", "end", "center", "stretch", "baseline"]
      }],
      /**
       * Place Content
       * @see https://tailwindcss.com/docs/place-content
       */
      "place-content": [{
        "place-content": [].concat(getAlign(), ["baseline"])
      }],
      /**
       * Place Items
       * @see https://tailwindcss.com/docs/place-items
       */
      "place-items": [{
        "place-items": ["start", "end", "center", "baseline", "stretch"]
      }],
      /**
       * Place Self
       * @see https://tailwindcss.com/docs/place-self
       */
      "place-self": [{
        "place-self": ["auto", "start", "end", "center", "stretch"]
      }],
      // Spacing
      /**
       * Padding
       * @see https://tailwindcss.com/docs/padding
       */
      p: [{
        p: [padding]
      }],
      /**
       * Padding X
       * @see https://tailwindcss.com/docs/padding
       */
      px: [{
        px: [padding]
      }],
      /**
       * Padding Y
       * @see https://tailwindcss.com/docs/padding
       */
      py: [{
        py: [padding]
      }],
      /**
       * Padding Start
       * @see https://tailwindcss.com/docs/padding
       */
      ps: [{
        ps: [padding]
      }],
      /**
       * Padding End
       * @see https://tailwindcss.com/docs/padding
       */
      pe: [{
        pe: [padding]
      }],
      /**
       * Padding Top
       * @see https://tailwindcss.com/docs/padding
       */
      pt: [{
        pt: [padding]
      }],
      /**
       * Padding Right
       * @see https://tailwindcss.com/docs/padding
       */
      pr: [{
        pr: [padding]
      }],
      /**
       * Padding Bottom
       * @see https://tailwindcss.com/docs/padding
       */
      pb: [{
        pb: [padding]
      }],
      /**
       * Padding Left
       * @see https://tailwindcss.com/docs/padding
       */
      pl: [{
        pl: [padding]
      }],
      /**
       * Margin
       * @see https://tailwindcss.com/docs/margin
       */
      m: [{
        m: [margin]
      }],
      /**
       * Margin X
       * @see https://tailwindcss.com/docs/margin
       */
      mx: [{
        mx: [margin]
      }],
      /**
       * Margin Y
       * @see https://tailwindcss.com/docs/margin
       */
      my: [{
        my: [margin]
      }],
      /**
       * Margin Start
       * @see https://tailwindcss.com/docs/margin
       */
      ms: [{
        ms: [margin]
      }],
      /**
       * Margin End
       * @see https://tailwindcss.com/docs/margin
       */
      me: [{
        me: [margin]
      }],
      /**
       * Margin Top
       * @see https://tailwindcss.com/docs/margin
       */
      mt: [{
        mt: [margin]
      }],
      /**
       * Margin Right
       * @see https://tailwindcss.com/docs/margin
       */
      mr: [{
        mr: [margin]
      }],
      /**
       * Margin Bottom
       * @see https://tailwindcss.com/docs/margin
       */
      mb: [{
        mb: [margin]
      }],
      /**
       * Margin Left
       * @see https://tailwindcss.com/docs/margin
       */
      ml: [{
        ml: [margin]
      }],
      /**
       * Space Between X
       * @see https://tailwindcss.com/docs/space
       */
      "space-x": [{
        "space-x": [space2]
      }],
      /**
       * Space Between X Reverse
       * @see https://tailwindcss.com/docs/space
       */
      "space-x-reverse": ["space-x-reverse"],
      /**
       * Space Between Y
       * @see https://tailwindcss.com/docs/space
       */
      "space-y": [{
        "space-y": [space2]
      }],
      /**
       * Space Between Y Reverse
       * @see https://tailwindcss.com/docs/space
       */
      "space-y-reverse": ["space-y-reverse"],
      // Sizing
      /**
       * Width
       * @see https://tailwindcss.com/docs/width
       */
      w: [{
        w: ["auto", "min", "max", "fit", isArbitraryValue, spacing]
      }],
      /**
       * Min-Width
       * @see https://tailwindcss.com/docs/min-width
       */
      "min-w": [{
        "min-w": ["min", "max", "fit", isArbitraryValue, isLength]
      }],
      /**
       * Max-Width
       * @see https://tailwindcss.com/docs/max-width
       */
      "max-w": [{
        "max-w": ["0", "none", "full", "min", "max", "fit", "prose", {
          screen: [isTshirtSize]
        }, isTshirtSize, isArbitraryValue]
      }],
      /**
       * Height
       * @see https://tailwindcss.com/docs/height
       */
      h: [{
        h: [isArbitraryValue, spacing, "auto", "min", "max", "fit"]
      }],
      /**
       * Min-Height
       * @see https://tailwindcss.com/docs/min-height
       */
      "min-h": [{
        "min-h": ["min", "max", "fit", isArbitraryValue, isLength]
      }],
      /**
       * Max-Height
       * @see https://tailwindcss.com/docs/max-height
       */
      "max-h": [{
        "max-h": [isArbitraryValue, spacing, "min", "max", "fit"]
      }],
      // Typography
      /**
       * Font Size
       * @see https://tailwindcss.com/docs/font-size
       */
      "font-size": [{
        text: ["base", isTshirtSize, isArbitraryLength]
      }],
      /**
       * Font Smoothing
       * @see https://tailwindcss.com/docs/font-smoothing
       */
      "font-smoothing": ["antialiased", "subpixel-antialiased"],
      /**
       * Font Style
       * @see https://tailwindcss.com/docs/font-style
       */
      "font-style": ["italic", "not-italic"],
      /**
       * Font Weight
       * @see https://tailwindcss.com/docs/font-weight
       */
      "font-weight": [{
        font: ["thin", "extralight", "light", "normal", "medium", "semibold", "bold", "extrabold", "black", isArbitraryNumber]
      }],
      /**
       * Font Family
       * @see https://tailwindcss.com/docs/font-family
       */
      "font-family": [{
        font: [isAny]
      }],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-normal": ["normal-nums"],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-ordinal": ["ordinal"],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-slashed-zero": ["slashed-zero"],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-figure": ["lining-nums", "oldstyle-nums"],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-spacing": ["proportional-nums", "tabular-nums"],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-fraction": ["diagonal-fractions", "stacked-fractons"],
      /**
       * Letter Spacing
       * @see https://tailwindcss.com/docs/letter-spacing
       */
      tracking: [{
        tracking: ["tighter", "tight", "normal", "wide", "wider", "widest", isArbitraryValue]
      }],
      /**
       * Line Clamp
       * @see https://tailwindcss.com/docs/line-clamp
       */
      "line-clamp": [{
        "line-clamp": ["none", isNumber, isArbitraryNumber]
      }],
      /**
       * Line Height
       * @see https://tailwindcss.com/docs/line-height
       */
      leading: [{
        leading: ["none", "tight", "snug", "normal", "relaxed", "loose", isArbitraryValue, isLength]
      }],
      /**
       * List Style Image
       * @see https://tailwindcss.com/docs/list-style-image
       */
      "list-image": [{
        "list-image": ["none", isArbitraryValue]
      }],
      /**
       * List Style Type
       * @see https://tailwindcss.com/docs/list-style-type
       */
      "list-style-type": [{
        list: ["none", "disc", "decimal", isArbitraryValue]
      }],
      /**
       * List Style Position
       * @see https://tailwindcss.com/docs/list-style-position
       */
      "list-style-position": [{
        list: ["inside", "outside"]
      }],
      /**
       * Placeholder Color
       * @deprecated since Tailwind CSS v3.0.0
       * @see https://tailwindcss.com/docs/placeholder-color
       */
      "placeholder-color": [{
        placeholder: [colors]
      }],
      /**
       * Placeholder Opacity
       * @see https://tailwindcss.com/docs/placeholder-opacity
       */
      "placeholder-opacity": [{
        "placeholder-opacity": [opacity]
      }],
      /**
       * Text Alignment
       * @see https://tailwindcss.com/docs/text-align
       */
      "text-alignment": [{
        text: ["left", "center", "right", "justify", "start", "end"]
      }],
      /**
       * Text Color
       * @see https://tailwindcss.com/docs/text-color
       */
      "text-color": [{
        text: [colors]
      }],
      /**
       * Text Opacity
       * @see https://tailwindcss.com/docs/text-opacity
       */
      "text-opacity": [{
        "text-opacity": [opacity]
      }],
      /**
       * Text Decoration
       * @see https://tailwindcss.com/docs/text-decoration
       */
      "text-decoration": ["underline", "overline", "line-through", "no-underline"],
      /**
       * Text Decoration Style
       * @see https://tailwindcss.com/docs/text-decoration-style
       */
      "text-decoration-style": [{
        decoration: [].concat(getLineStyles(), ["wavy"])
      }],
      /**
       * Text Decoration Thickness
       * @see https://tailwindcss.com/docs/text-decoration-thickness
       */
      "text-decoration-thickness": [{
        decoration: ["auto", "from-font", isLength]
      }],
      /**
       * Text Underline Offset
       * @see https://tailwindcss.com/docs/text-underline-offset
       */
      "underline-offset": [{
        "underline-offset": ["auto", isArbitraryValue, isLength]
      }],
      /**
       * Text Decoration Color
       * @see https://tailwindcss.com/docs/text-decoration-color
       */
      "text-decoration-color": [{
        decoration: [colors]
      }],
      /**
       * Text Transform
       * @see https://tailwindcss.com/docs/text-transform
       */
      "text-transform": ["uppercase", "lowercase", "capitalize", "normal-case"],
      /**
       * Text Overflow
       * @see https://tailwindcss.com/docs/text-overflow
       */
      "text-overflow": ["truncate", "text-ellipsis", "text-clip"],
      /**
       * Text Indent
       * @see https://tailwindcss.com/docs/text-indent
       */
      indent: [{
        indent: getSpacingWithArbitrary()
      }],
      /**
       * Vertical Alignment
       * @see https://tailwindcss.com/docs/vertical-align
       */
      "vertical-align": [{
        align: ["baseline", "top", "middle", "bottom", "text-top", "text-bottom", "sub", "super", isArbitraryValue]
      }],
      /**
       * Whitespace
       * @see https://tailwindcss.com/docs/whitespace
       */
      whitespace: [{
        whitespace: ["normal", "nowrap", "pre", "pre-line", "pre-wrap", "break-spaces"]
      }],
      /**
       * Word Break
       * @see https://tailwindcss.com/docs/word-break
       */
      "break": [{
        "break": ["normal", "words", "all", "keep"]
      }],
      /**
       * Hyphens
       * @see https://tailwindcss.com/docs/hyphens
       */
      hyphens: [{
        hyphens: ["none", "manual", "auto"]
      }],
      /**
       * Content
       * @see https://tailwindcss.com/docs/content
       */
      content: [{
        content: ["none", isArbitraryValue]
      }],
      // Backgrounds
      /**
       * Background Attachment
       * @see https://tailwindcss.com/docs/background-attachment
       */
      "bg-attachment": [{
        bg: ["fixed", "local", "scroll"]
      }],
      /**
       * Background Clip
       * @see https://tailwindcss.com/docs/background-clip
       */
      "bg-clip": [{
        "bg-clip": ["border", "padding", "content", "text"]
      }],
      /**
       * Background Opacity
       * @deprecated since Tailwind CSS v3.0.0
       * @see https://tailwindcss.com/docs/background-opacity
       */
      "bg-opacity": [{
        "bg-opacity": [opacity]
      }],
      /**
       * Background Origin
       * @see https://tailwindcss.com/docs/background-origin
       */
      "bg-origin": [{
        "bg-origin": ["border", "padding", "content"]
      }],
      /**
       * Background Position
       * @see https://tailwindcss.com/docs/background-position
       */
      "bg-position": [{
        bg: [].concat(getPositions(), [isArbitraryPosition])
      }],
      /**
       * Background Repeat
       * @see https://tailwindcss.com/docs/background-repeat
       */
      "bg-repeat": [{
        bg: ["no-repeat", {
          repeat: ["", "x", "y", "round", "space"]
        }]
      }],
      /**
       * Background Size
       * @see https://tailwindcss.com/docs/background-size
       */
      "bg-size": [{
        bg: ["auto", "cover", "contain", isArbitrarySize]
      }],
      /**
       * Background Image
       * @see https://tailwindcss.com/docs/background-image
       */
      "bg-image": [{
        bg: ["none", {
          "gradient-to": ["t", "tr", "r", "br", "b", "bl", "l", "tl"]
        }, isArbitraryUrl]
      }],
      /**
       * Background Color
       * @see https://tailwindcss.com/docs/background-color
       */
      "bg-color": [{
        bg: [colors]
      }],
      /**
       * Gradient Color Stops From Position
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-from-pos": [{
        from: [gradientColorStopPositions]
      }],
      /**
       * Gradient Color Stops Via Position
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-via-pos": [{
        via: [gradientColorStopPositions]
      }],
      /**
       * Gradient Color Stops To Position
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-to-pos": [{
        to: [gradientColorStopPositions]
      }],
      /**
       * Gradient Color Stops From
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-from": [{
        from: [gradientColorStops]
      }],
      /**
       * Gradient Color Stops Via
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-via": [{
        via: [gradientColorStops]
      }],
      /**
       * Gradient Color Stops To
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-to": [{
        to: [gradientColorStops]
      }],
      // Borders
      /**
       * Border Radius
       * @see https://tailwindcss.com/docs/border-radius
       */
      rounded: [{
        rounded: [borderRadius]
      }],
      /**
       * Border Radius Start
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-s": [{
        "rounded-s": [borderRadius]
      }],
      /**
       * Border Radius End
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-e": [{
        "rounded-e": [borderRadius]
      }],
      /**
       * Border Radius Top
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-t": [{
        "rounded-t": [borderRadius]
      }],
      /**
       * Border Radius Right
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-r": [{
        "rounded-r": [borderRadius]
      }],
      /**
       * Border Radius Bottom
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-b": [{
        "rounded-b": [borderRadius]
      }],
      /**
       * Border Radius Left
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-l": [{
        "rounded-l": [borderRadius]
      }],
      /**
       * Border Radius Start Start
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-ss": [{
        "rounded-ss": [borderRadius]
      }],
      /**
       * Border Radius Start End
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-se": [{
        "rounded-se": [borderRadius]
      }],
      /**
       * Border Radius End End
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-ee": [{
        "rounded-ee": [borderRadius]
      }],
      /**
       * Border Radius End Start
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-es": [{
        "rounded-es": [borderRadius]
      }],
      /**
       * Border Radius Top Left
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-tl": [{
        "rounded-tl": [borderRadius]
      }],
      /**
       * Border Radius Top Right
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-tr": [{
        "rounded-tr": [borderRadius]
      }],
      /**
       * Border Radius Bottom Right
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-br": [{
        "rounded-br": [borderRadius]
      }],
      /**
       * Border Radius Bottom Left
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-bl": [{
        "rounded-bl": [borderRadius]
      }],
      /**
       * Border Width
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w": [{
        border: [borderWidth]
      }],
      /**
       * Border Width X
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-x": [{
        "border-x": [borderWidth]
      }],
      /**
       * Border Width Y
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-y": [{
        "border-y": [borderWidth]
      }],
      /**
       * Border Width Start
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-s": [{
        "border-s": [borderWidth]
      }],
      /**
       * Border Width End
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-e": [{
        "border-e": [borderWidth]
      }],
      /**
       * Border Width Top
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-t": [{
        "border-t": [borderWidth]
      }],
      /**
       * Border Width Right
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-r": [{
        "border-r": [borderWidth]
      }],
      /**
       * Border Width Bottom
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-b": [{
        "border-b": [borderWidth]
      }],
      /**
       * Border Width Left
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-l": [{
        "border-l": [borderWidth]
      }],
      /**
       * Border Opacity
       * @see https://tailwindcss.com/docs/border-opacity
       */
      "border-opacity": [{
        "border-opacity": [opacity]
      }],
      /**
       * Border Style
       * @see https://tailwindcss.com/docs/border-style
       */
      "border-style": [{
        border: [].concat(getLineStyles(), ["hidden"])
      }],
      /**
       * Divide Width X
       * @see https://tailwindcss.com/docs/divide-width
       */
      "divide-x": [{
        "divide-x": [borderWidth]
      }],
      /**
       * Divide Width X Reverse
       * @see https://tailwindcss.com/docs/divide-width
       */
      "divide-x-reverse": ["divide-x-reverse"],
      /**
       * Divide Width Y
       * @see https://tailwindcss.com/docs/divide-width
       */
      "divide-y": [{
        "divide-y": [borderWidth]
      }],
      /**
       * Divide Width Y Reverse
       * @see https://tailwindcss.com/docs/divide-width
       */
      "divide-y-reverse": ["divide-y-reverse"],
      /**
       * Divide Opacity
       * @see https://tailwindcss.com/docs/divide-opacity
       */
      "divide-opacity": [{
        "divide-opacity": [opacity]
      }],
      /**
       * Divide Style
       * @see https://tailwindcss.com/docs/divide-style
       */
      "divide-style": [{
        divide: getLineStyles()
      }],
      /**
       * Border Color
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color": [{
        border: [borderColor]
      }],
      /**
       * Border Color X
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-x": [{
        "border-x": [borderColor]
      }],
      /**
       * Border Color Y
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-y": [{
        "border-y": [borderColor]
      }],
      /**
       * Border Color Top
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-t": [{
        "border-t": [borderColor]
      }],
      /**
       * Border Color Right
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-r": [{
        "border-r": [borderColor]
      }],
      /**
       * Border Color Bottom
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-b": [{
        "border-b": [borderColor]
      }],
      /**
       * Border Color Left
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-l": [{
        "border-l": [borderColor]
      }],
      /**
       * Divide Color
       * @see https://tailwindcss.com/docs/divide-color
       */
      "divide-color": [{
        divide: [borderColor]
      }],
      /**
       * Outline Style
       * @see https://tailwindcss.com/docs/outline-style
       */
      "outline-style": [{
        outline: [""].concat(getLineStyles())
      }],
      /**
       * Outline Offset
       * @see https://tailwindcss.com/docs/outline-offset
       */
      "outline-offset": [{
        "outline-offset": [isArbitraryValue, isLength]
      }],
      /**
       * Outline Width
       * @see https://tailwindcss.com/docs/outline-width
       */
      "outline-w": [{
        outline: [isLength]
      }],
      /**
       * Outline Color
       * @see https://tailwindcss.com/docs/outline-color
       */
      "outline-color": [{
        outline: [colors]
      }],
      /**
       * Ring Width
       * @see https://tailwindcss.com/docs/ring-width
       */
      "ring-w": [{
        ring: getLengthWithEmpty()
      }],
      /**
       * Ring Width Inset
       * @see https://tailwindcss.com/docs/ring-width
       */
      "ring-w-inset": ["ring-inset"],
      /**
       * Ring Color
       * @see https://tailwindcss.com/docs/ring-color
       */
      "ring-color": [{
        ring: [colors]
      }],
      /**
       * Ring Opacity
       * @see https://tailwindcss.com/docs/ring-opacity
       */
      "ring-opacity": [{
        "ring-opacity": [opacity]
      }],
      /**
       * Ring Offset Width
       * @see https://tailwindcss.com/docs/ring-offset-width
       */
      "ring-offset-w": [{
        "ring-offset": [isLength]
      }],
      /**
       * Ring Offset Color
       * @see https://tailwindcss.com/docs/ring-offset-color
       */
      "ring-offset-color": [{
        "ring-offset": [colors]
      }],
      // Effects
      /**
       * Box Shadow
       * @see https://tailwindcss.com/docs/box-shadow
       */
      shadow: [{
        shadow: ["", "inner", "none", isTshirtSize, isArbitraryShadow]
      }],
      /**
       * Box Shadow Color
       * @see https://tailwindcss.com/docs/box-shadow-color
       */
      "shadow-color": [{
        shadow: [isAny]
      }],
      /**
       * Opacity
       * @see https://tailwindcss.com/docs/opacity
       */
      opacity: [{
        opacity: [opacity]
      }],
      /**
       * Mix Blend Mode
       * @see https://tailwindcss.com/docs/mix-blend-mode
       */
      "mix-blend": [{
        "mix-blend": getBlendModes()
      }],
      /**
       * Background Blend Mode
       * @see https://tailwindcss.com/docs/background-blend-mode
       */
      "bg-blend": [{
        "bg-blend": getBlendModes()
      }],
      // Filters
      /**
       * Filter
       * @deprecated since Tailwind CSS v3.0.0
       * @see https://tailwindcss.com/docs/filter
       */
      filter: [{
        filter: ["", "none"]
      }],
      /**
       * Blur
       * @see https://tailwindcss.com/docs/blur
       */
      blur: [{
        blur: [blur]
      }],
      /**
       * Brightness
       * @see https://tailwindcss.com/docs/brightness
       */
      brightness: [{
        brightness: [brightness]
      }],
      /**
       * Contrast
       * @see https://tailwindcss.com/docs/contrast
       */
      contrast: [{
        contrast: [contrast]
      }],
      /**
       * Drop Shadow
       * @see https://tailwindcss.com/docs/drop-shadow
       */
      "drop-shadow": [{
        "drop-shadow": ["", "none", isTshirtSize, isArbitraryValue]
      }],
      /**
       * Grayscale
       * @see https://tailwindcss.com/docs/grayscale
       */
      grayscale: [{
        grayscale: [grayscale]
      }],
      /**
       * Hue Rotate
       * @see https://tailwindcss.com/docs/hue-rotate
       */
      "hue-rotate": [{
        "hue-rotate": [hueRotate]
      }],
      /**
       * Invert
       * @see https://tailwindcss.com/docs/invert
       */
      invert: [{
        invert: [invert]
      }],
      /**
       * Saturate
       * @see https://tailwindcss.com/docs/saturate
       */
      saturate: [{
        saturate: [saturate]
      }],
      /**
       * Sepia
       * @see https://tailwindcss.com/docs/sepia
       */
      sepia: [{
        sepia: [sepia]
      }],
      /**
       * Backdrop Filter
       * @deprecated since Tailwind CSS v3.0.0
       * @see https://tailwindcss.com/docs/backdrop-filter
       */
      "backdrop-filter": [{
        "backdrop-filter": ["", "none"]
      }],
      /**
       * Backdrop Blur
       * @see https://tailwindcss.com/docs/backdrop-blur
       */
      "backdrop-blur": [{
        "backdrop-blur": [blur]
      }],
      /**
       * Backdrop Brightness
       * @see https://tailwindcss.com/docs/backdrop-brightness
       */
      "backdrop-brightness": [{
        "backdrop-brightness": [brightness]
      }],
      /**
       * Backdrop Contrast
       * @see https://tailwindcss.com/docs/backdrop-contrast
       */
      "backdrop-contrast": [{
        "backdrop-contrast": [contrast]
      }],
      /**
       * Backdrop Grayscale
       * @see https://tailwindcss.com/docs/backdrop-grayscale
       */
      "backdrop-grayscale": [{
        "backdrop-grayscale": [grayscale]
      }],
      /**
       * Backdrop Hue Rotate
       * @see https://tailwindcss.com/docs/backdrop-hue-rotate
       */
      "backdrop-hue-rotate": [{
        "backdrop-hue-rotate": [hueRotate]
      }],
      /**
       * Backdrop Invert
       * @see https://tailwindcss.com/docs/backdrop-invert
       */
      "backdrop-invert": [{
        "backdrop-invert": [invert]
      }],
      /**
       * Backdrop Opacity
       * @see https://tailwindcss.com/docs/backdrop-opacity
       */
      "backdrop-opacity": [{
        "backdrop-opacity": [opacity]
      }],
      /**
       * Backdrop Saturate
       * @see https://tailwindcss.com/docs/backdrop-saturate
       */
      "backdrop-saturate": [{
        "backdrop-saturate": [saturate]
      }],
      /**
       * Backdrop Sepia
       * @see https://tailwindcss.com/docs/backdrop-sepia
       */
      "backdrop-sepia": [{
        "backdrop-sepia": [sepia]
      }],
      // Tables
      /**
       * Border Collapse
       * @see https://tailwindcss.com/docs/border-collapse
       */
      "border-collapse": [{
        border: ["collapse", "separate"]
      }],
      /**
       * Border Spacing
       * @see https://tailwindcss.com/docs/border-spacing
       */
      "border-spacing": [{
        "border-spacing": [borderSpacing]
      }],
      /**
       * Border Spacing X
       * @see https://tailwindcss.com/docs/border-spacing
       */
      "border-spacing-x": [{
        "border-spacing-x": [borderSpacing]
      }],
      /**
       * Border Spacing Y
       * @see https://tailwindcss.com/docs/border-spacing
       */
      "border-spacing-y": [{
        "border-spacing-y": [borderSpacing]
      }],
      /**
       * Table Layout
       * @see https://tailwindcss.com/docs/table-layout
       */
      "table-layout": [{
        table: ["auto", "fixed"]
      }],
      /**
       * Caption Side
       * @see https://tailwindcss.com/docs/caption-side
       */
      caption: [{
        caption: ["top", "bottom"]
      }],
      // Transitions and Animation
      /**
       * Tranisition Property
       * @see https://tailwindcss.com/docs/transition-property
       */
      transition: [{
        transition: ["none", "all", "", "colors", "opacity", "shadow", "transform", isArbitraryValue]
      }],
      /**
       * Transition Duration
       * @see https://tailwindcss.com/docs/transition-duration
       */
      duration: [{
        duration: getNumberAndArbitrary()
      }],
      /**
       * Transition Timing Function
       * @see https://tailwindcss.com/docs/transition-timing-function
       */
      ease: [{
        ease: ["linear", "in", "out", "in-out", isArbitraryValue]
      }],
      /**
       * Transition Delay
       * @see https://tailwindcss.com/docs/transition-delay
       */
      delay: [{
        delay: getNumberAndArbitrary()
      }],
      /**
       * Animation
       * @see https://tailwindcss.com/docs/animation
       */
      animate: [{
        animate: ["none", "spin", "ping", "pulse", "bounce", isArbitraryValue]
      }],
      // Transforms
      /**
       * Transform
       * @see https://tailwindcss.com/docs/transform
       */
      transform: [{
        transform: ["", "gpu", "none"]
      }],
      /**
       * Scale
       * @see https://tailwindcss.com/docs/scale
       */
      scale: [{
        scale: [scale]
      }],
      /**
       * Scale X
       * @see https://tailwindcss.com/docs/scale
       */
      "scale-x": [{
        "scale-x": [scale]
      }],
      /**
       * Scale Y
       * @see https://tailwindcss.com/docs/scale
       */
      "scale-y": [{
        "scale-y": [scale]
      }],
      /**
       * Rotate
       * @see https://tailwindcss.com/docs/rotate
       */
      rotate: [{
        rotate: [isInteger, isArbitraryValue]
      }],
      /**
       * Translate X
       * @see https://tailwindcss.com/docs/translate
       */
      "translate-x": [{
        "translate-x": [translate]
      }],
      /**
       * Translate Y
       * @see https://tailwindcss.com/docs/translate
       */
      "translate-y": [{
        "translate-y": [translate]
      }],
      /**
       * Skew X
       * @see https://tailwindcss.com/docs/skew
       */
      "skew-x": [{
        "skew-x": [skew]
      }],
      /**
       * Skew Y
       * @see https://tailwindcss.com/docs/skew
       */
      "skew-y": [{
        "skew-y": [skew]
      }],
      /**
       * Transform Origin
       * @see https://tailwindcss.com/docs/transform-origin
       */
      "transform-origin": [{
        origin: ["center", "top", "top-right", "right", "bottom-right", "bottom", "bottom-left", "left", "top-left", isArbitraryValue]
      }],
      // Interactivity
      /**
       * Accent Color
       * @see https://tailwindcss.com/docs/accent-color
       */
      accent: [{
        accent: ["auto", colors]
      }],
      /**
       * Appearance
       * @see https://tailwindcss.com/docs/appearance
       */
      appearance: ["appearance-none"],
      /**
       * Cursor
       * @see https://tailwindcss.com/docs/cursor
       */
      cursor: [{
        cursor: ["auto", "default", "pointer", "wait", "text", "move", "help", "not-allowed", "none", "context-menu", "progress", "cell", "crosshair", "vertical-text", "alias", "copy", "no-drop", "grab", "grabbing", "all-scroll", "col-resize", "row-resize", "n-resize", "e-resize", "s-resize", "w-resize", "ne-resize", "nw-resize", "se-resize", "sw-resize", "ew-resize", "ns-resize", "nesw-resize", "nwse-resize", "zoom-in", "zoom-out", isArbitraryValue]
      }],
      /**
       * Caret Color
       * @see https://tailwindcss.com/docs/just-in-time-mode#caret-color-utilities
       */
      "caret-color": [{
        caret: [colors]
      }],
      /**
       * Pointer Events
       * @see https://tailwindcss.com/docs/pointer-events
       */
      "pointer-events": [{
        "pointer-events": ["none", "auto"]
      }],
      /**
       * Resize
       * @see https://tailwindcss.com/docs/resize
       */
      resize: [{
        resize: ["none", "y", "x", ""]
      }],
      /**
       * Scroll Behavior
       * @see https://tailwindcss.com/docs/scroll-behavior
       */
      "scroll-behavior": [{
        scroll: ["auto", "smooth"]
      }],
      /**
       * Scroll Margin
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-m": [{
        "scroll-m": getSpacingWithArbitrary()
      }],
      /**
       * Scroll Margin X
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-mx": [{
        "scroll-mx": getSpacingWithArbitrary()
      }],
      /**
       * Scroll Margin Y
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-my": [{
        "scroll-my": getSpacingWithArbitrary()
      }],
      /**
       * Scroll Margin Start
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-ms": [{
        "scroll-ms": getSpacingWithArbitrary()
      }],
      /**
       * Scroll Margin End
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-me": [{
        "scroll-me": getSpacingWithArbitrary()
      }],
      /**
       * Scroll Margin Top
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-mt": [{
        "scroll-mt": getSpacingWithArbitrary()
      }],
      /**
       * Scroll Margin Right
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-mr": [{
        "scroll-mr": getSpacingWithArbitrary()
      }],
      /**
       * Scroll Margin Bottom
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-mb": [{
        "scroll-mb": getSpacingWithArbitrary()
      }],
      /**
       * Scroll Margin Left
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-ml": [{
        "scroll-ml": getSpacingWithArbitrary()
      }],
      /**
       * Scroll Padding
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-p": [{
        "scroll-p": getSpacingWithArbitrary()
      }],
      /**
       * Scroll Padding X
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-px": [{
        "scroll-px": getSpacingWithArbitrary()
      }],
      /**
       * Scroll Padding Y
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-py": [{
        "scroll-py": getSpacingWithArbitrary()
      }],
      /**
       * Scroll Padding Start
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-ps": [{
        "scroll-ps": getSpacingWithArbitrary()
      }],
      /**
       * Scroll Padding End
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-pe": [{
        "scroll-pe": getSpacingWithArbitrary()
      }],
      /**
       * Scroll Padding Top
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-pt": [{
        "scroll-pt": getSpacingWithArbitrary()
      }],
      /**
       * Scroll Padding Right
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-pr": [{
        "scroll-pr": getSpacingWithArbitrary()
      }],
      /**
       * Scroll Padding Bottom
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-pb": [{
        "scroll-pb": getSpacingWithArbitrary()
      }],
      /**
       * Scroll Padding Left
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-pl": [{
        "scroll-pl": getSpacingWithArbitrary()
      }],
      /**
       * Scroll Snap Align
       * @see https://tailwindcss.com/docs/scroll-snap-align
       */
      "snap-align": [{
        snap: ["start", "end", "center", "align-none"]
      }],
      /**
       * Scroll Snap Stop
       * @see https://tailwindcss.com/docs/scroll-snap-stop
       */
      "snap-stop": [{
        snap: ["normal", "always"]
      }],
      /**
       * Scroll Snap Type
       * @see https://tailwindcss.com/docs/scroll-snap-type
       */
      "snap-type": [{
        snap: ["none", "x", "y", "both"]
      }],
      /**
       * Scroll Snap Type Strictness
       * @see https://tailwindcss.com/docs/scroll-snap-type
       */
      "snap-strictness": [{
        snap: ["mandatory", "proximity"]
      }],
      /**
       * Touch Action
       * @see https://tailwindcss.com/docs/touch-action
       */
      touch: [{
        touch: ["auto", "none", "pinch-zoom", "manipulation", {
          pan: ["x", "left", "right", "y", "up", "down"]
        }]
      }],
      /**
       * User Select
       * @see https://tailwindcss.com/docs/user-select
       */
      select: [{
        select: ["none", "text", "all", "auto"]
      }],
      /**
       * Will Change
       * @see https://tailwindcss.com/docs/will-change
       */
      "will-change": [{
        "will-change": ["auto", "scroll", "contents", "transform", isArbitraryValue]
      }],
      // SVG
      /**
       * Fill
       * @see https://tailwindcss.com/docs/fill
       */
      fill: [{
        fill: [colors, "none"]
      }],
      /**
       * Stroke Width
       * @see https://tailwindcss.com/docs/stroke-width
       */
      "stroke-w": [{
        stroke: [isLength, isArbitraryNumber]
      }],
      /**
       * Stroke
       * @see https://tailwindcss.com/docs/stroke
       */
      stroke: [{
        stroke: [colors, "none"]
      }],
      // Accessibility
      /**
       * Screen Readers
       * @see https://tailwindcss.com/docs/screen-readers
       */
      sr: ["sr-only", "not-sr-only"]
    },
    conflictingClassGroups: {
      overflow: ["overflow-x", "overflow-y"],
      overscroll: ["overscroll-x", "overscroll-y"],
      inset: ["inset-x", "inset-y", "start", "end", "top", "right", "bottom", "left"],
      "inset-x": ["right", "left"],
      "inset-y": ["top", "bottom"],
      flex: ["basis", "grow", "shrink"],
      gap: ["gap-x", "gap-y"],
      p: ["px", "py", "ps", "pe", "pt", "pr", "pb", "pl"],
      px: ["pr", "pl"],
      py: ["pt", "pb"],
      m: ["mx", "my", "ms", "me", "mt", "mr", "mb", "ml"],
      mx: ["mr", "ml"],
      my: ["mt", "mb"],
      "font-size": ["leading"],
      "fvn-normal": ["fvn-ordinal", "fvn-slashed-zero", "fvn-figure", "fvn-spacing", "fvn-fraction"],
      "fvn-ordinal": ["fvn-normal"],
      "fvn-slashed-zero": ["fvn-normal"],
      "fvn-figure": ["fvn-normal"],
      "fvn-spacing": ["fvn-normal"],
      "fvn-fraction": ["fvn-normal"],
      rounded: ["rounded-s", "rounded-e", "rounded-t", "rounded-r", "rounded-b", "rounded-l", "rounded-ss", "rounded-se", "rounded-ee", "rounded-es", "rounded-tl", "rounded-tr", "rounded-br", "rounded-bl"],
      "rounded-s": ["rounded-ss", "rounded-es"],
      "rounded-e": ["rounded-se", "rounded-ee"],
      "rounded-t": ["rounded-tl", "rounded-tr"],
      "rounded-r": ["rounded-tr", "rounded-br"],
      "rounded-b": ["rounded-br", "rounded-bl"],
      "rounded-l": ["rounded-tl", "rounded-bl"],
      "border-spacing": ["border-spacing-x", "border-spacing-y"],
      "border-w": ["border-w-s", "border-w-e", "border-w-t", "border-w-r", "border-w-b", "border-w-l"],
      "border-w-x": ["border-w-r", "border-w-l"],
      "border-w-y": ["border-w-t", "border-w-b"],
      "border-color": ["border-color-t", "border-color-r", "border-color-b", "border-color-l"],
      "border-color-x": ["border-color-r", "border-color-l"],
      "border-color-y": ["border-color-t", "border-color-b"],
      "scroll-m": ["scroll-mx", "scroll-my", "scroll-ms", "scroll-me", "scroll-mt", "scroll-mr", "scroll-mb", "scroll-ml"],
      "scroll-mx": ["scroll-mr", "scroll-ml"],
      "scroll-my": ["scroll-mt", "scroll-mb"],
      "scroll-p": ["scroll-px", "scroll-py", "scroll-ps", "scroll-pe", "scroll-pt", "scroll-pr", "scroll-pb", "scroll-pl"],
      "scroll-px": ["scroll-pr", "scroll-pl"],
      "scroll-py": ["scroll-pt", "scroll-pb"]
    },
    conflictingClassGroupModifiers: {
      "font-size": ["leading"]
    }
  };
}
var twMerge = /* @__PURE__ */ createTailwindMerge(getDefaultConfig);
function isObject(item) {
  return item !== null && typeof item === "object" && item.constructor === Object;
}
function cloneDeep(source) {
  if (!isObject(source)) {
    return source;
  }
  const output = { ...source };
  Object.keys(source).forEach((key) => {
    output[key] = cloneDeep(source[key]);
  });
  return output;
}
function mergeDeep(target, source) {
  if (isObject(source) && Object.keys(source).length === 0) {
    return cloneDeep({ ...target, ...source });
  }
  const output = { ...target, ...source };
  if (isObject(source) && isObject(target)) {
    Object.keys(source).forEach((key) => {
      if (isObject(source[key]) && key in target && isObject(target[key])) {
        output[key] = mergeDeep(target[key], source[key]);
      } else {
        output[key] = isObject(source[key]) ? cloneDeep(source[key]) : source[key];
      }
    });
  }
  return output;
}
const AccordionPanelContext = reactExports.createContext(void 0);
function useAccordionContext() {
  const context = reactExports.useContext(AccordionPanelContext);
  if (!context) {
    throw new Error("useAccordionContext should be used within the AccordionPanelContext provider!");
  }
  return context;
}
const AccordionContent = ({ children, className, theme: customTheme = {}, ...props }) => {
  const { isOpen } = useAccordionContext();
  const theme2 = mergeDeep(useTheme().theme.accordion.content, customTheme);
  return jsxRuntimeExports.jsx("div", { className: twMerge(theme2.base, className), "data-testid": "flowbite-accordion-content", hidden: !isOpen, ...props, children });
};
const AccordionPanel = ({ children, ...props }) => {
  const { alwaysOpen } = props;
  const [isOpen, setOpen] = reactExports.useState(props.isOpen);
  const provider = alwaysOpen ? {
    ...props,
    isOpen,
    setOpen: () => setOpen(!isOpen)
  } : props;
  return jsxRuntimeExports.jsx(AccordionPanelContext.Provider, { value: provider, children });
};
const AccordionTitle = ({ as: Heading = "h2", children, className, theme: customTheme = {}, ...props }) => {
  const { arrowIcon: ArrowIcon, flush: flush3, isOpen, setOpen } = useAccordionContext();
  const onClick = () => typeof setOpen !== "undefined" && setOpen();
  const theme2 = mergeDeep(useTheme().theme.accordion.title, customTheme);
  return jsxRuntimeExports.jsxs("button", { className: twMerge(theme2.base, theme2.flush[flush3 ? "on" : "off"], theme2.open[isOpen ? "on" : "off"], className), onClick, type: "button", ...props, children: [jsxRuntimeExports.jsx(Heading, { className: theme2.heading, "data-testid": "flowbite-accordion-heading", children }), ArrowIcon && jsxRuntimeExports.jsx(ArrowIcon, { "aria-hidden": true, className: twMerge(theme2.arrow.base, theme2.arrow.open[isOpen ? "on" : "off"]), "data-testid": "flowbite-accordion-arrow" })] });
};
const AccordionComponent = ({ alwaysOpen = false, arrowIcon = HiChevronDown, children, flush: flush3 = false, collapseAll = false, className, theme: customTheme = {}, ...props }) => {
  const [isOpen, setOpen] = reactExports.useState(collapseAll ? -1 : 0);
  const panels = reactExports.useMemo(() => reactExports.Children.map(children, (child, i2) => reactExports.cloneElement(child, {
    alwaysOpen,
    arrowIcon,
    flush: flush3,
    isOpen: isOpen === i2,
    setOpen: () => setOpen(isOpen === i2 ? -1 : i2)
  })), [alwaysOpen, arrowIcon, children, flush3, isOpen]);
  const theme2 = mergeDeep(useTheme().theme.accordion.root, customTheme);
  return jsxRuntimeExports.jsx("div", { className: twMerge(theme2.base, theme2.flush[flush3 ? "on" : "off"], className), "data-testid": "flowbite-accordion", ...props, children: panels });
};
AccordionComponent.displayName = "Accordion";
AccordionPanel.displayName = "Accordion.Panel";
AccordionTitle.displayName = "Accordion.Title";
AccordionContent.displayName = "Accordion.Content";
Object.assign(AccordionComponent, {
  Panel: AccordionPanel,
  Title: AccordionTitle,
  Content: AccordionContent
});
const AvatarGroup = ({ children, className, theme: customTheme = {}, ...props }) => {
  const theme2 = mergeDeep(useTheme().theme.avatar.group, customTheme);
  return jsxRuntimeExports.jsx("div", { "data-testid": "avatar-group-element", className: twMerge(theme2.base, className), ...props, children });
};
AvatarGroup.displayName = "Avatar.Group";
const AvatarGroupCounter = ({ className, href, theme: customTheme = {}, total, ...props }) => {
  const theme2 = mergeDeep(useTheme().theme.avatar.groupCounter, customTheme);
  return jsxRuntimeExports.jsxs("a", { href, className: twMerge(theme2.base, className), ...props, children: ["+", total] });
};
AvatarGroupCounter.displayName = "Avatar.GroupCounter";
const AvatarComponent = ({ alt = "", bordered = false, children, className, color = "light", img, placeholderInitials = "", rounded = false, size = "md", stacked = false, status, statusPosition = "top-left", theme: customTheme = {}, ...props }) => {
  const theme2 = mergeDeep(useTheme().theme.avatar, customTheme);
  const imgClassName = twMerge(theme2.root.img.base, bordered && theme2.root.bordered, bordered && theme2.root.color[color], rounded && theme2.root.rounded, stacked && theme2.root.stacked, theme2.root.img.on, theme2.root.size[size]);
  const imgProps = {
    className: twMerge(imgClassName, theme2.root.img.on),
    "data-testid": "flowbite-avatar-img"
  };
  return jsxRuntimeExports.jsxs("div", { className: twMerge(theme2.root.base, className), "data-testid": "flowbite-avatar", ...props, children: [jsxRuntimeExports.jsxs("div", { className: "relative", children: [img ? typeof img === "string" ? jsxRuntimeExports.jsx("img", { alt, src: img, ...imgProps }) : img({ alt, ...imgProps }) : placeholderInitials ? jsxRuntimeExports.jsx("div", { className: twMerge(theme2.root.img.off, theme2.root.initials.base, stacked && theme2.root.stacked, bordered && theme2.root.bordered, bordered && theme2.root.color[color], theme2.root.size[size], rounded && theme2.root.rounded), "data-testid": "flowbite-avatar-initials-placeholder", children: jsxRuntimeExports.jsx("span", { className: twMerge(theme2.root.initials.text), "data-testid": "flowbite-avatar-initials-placeholder-text", children: placeholderInitials }) }) : jsxRuntimeExports.jsx("div", { className: twMerge(imgClassName, theme2.root.img.off), "data-testid": "flowbite-avatar-img", children: jsxRuntimeExports.jsx("svg", { className: theme2.root.img.placeholder, fill: "currentColor", viewBox: "0 0 20 20", xmlns: "http://www.w3.org/2000/svg", children: jsxRuntimeExports.jsx("path", { fillRule: "evenodd", d: "M10 9a3 3 0 100-6 3 3 0 000 6zm-7 9a7 7 0 1114 0H3z", clipRule: "evenodd" }) }) }), status && jsxRuntimeExports.jsx("span", { "data-testid": "flowbite-avatar-status", className: twMerge(theme2.root.status.base, theme2.root.status[status], theme2.root.statusPosition[statusPosition]) })] }), children && jsxRuntimeExports.jsx("div", { children })] });
};
AvatarComponent.displayName = "Avatar";
Object.assign(AvatarComponent, {
  Group: AvatarGroup,
  Counter: AvatarGroupCounter
});
const Badge = ({ children, color = "info", href, icon: Icon2, size = "xs", className, theme: customTheme = {}, ...props }) => {
  const theme2 = mergeDeep(useTheme().theme.badge, customTheme);
  const Content = () => jsxRuntimeExports.jsxs("span", { className: twMerge(theme2.root.base, theme2.root.color[color], theme2.root.size[size], theme2.icon[Icon2 ? "on" : "off"], className), "data-testid": "flowbite-badge", ...props, children: [Icon2 && jsxRuntimeExports.jsx(Icon2, { "aria-hidden": true, className: theme2.icon.size[size], "data-testid": "flowbite-badge-icon" }), children && jsxRuntimeExports.jsx("span", { children })] });
  return href ? jsxRuntimeExports.jsx("a", { className: theme2.root.href, href, children: jsxRuntimeExports.jsx(Content, {}) }) : jsxRuntimeExports.jsx(Content, {});
};
Badge.displayName = "Badge";
const genericForwardRef = reactExports.forwardRef;
const ButtonBaseComponent = ({ children, as: Component, href, type = "button", ...props }, ref) => {
  const BaseComponent = Component || (href ? "a" : "button");
  return reactExports.createElement(BaseComponent, { ref, href, type, ...props }, children);
};
const ButtonBase = genericForwardRef(ButtonBaseComponent);
const ButtonGroup = ({ children, className, outline, pill, theme: customTheme = {}, ...props }) => {
  const items = reactExports.useMemo(() => reactExports.Children.map(children, (child, index2) => reactExports.cloneElement(child, {
    outline,
    pill,
    positionInGroup: index2 === 0 ? "start" : index2 === children.length - 1 ? "end" : "middle"
  })), [children, outline, pill]);
  const theme2 = mergeDeep(useTheme().theme.buttonGroup, customTheme);
  return jsxRuntimeExports.jsx("div", { className: twMerge(theme2.base, className), role: "group", ...props, children: items });
};
ButtonGroup.displayName = "Button.Group";
const ButtonComponentFn = ({ children, className, color = "info", disabled, fullSized, isProcessing = false, processingLabel = "Loading...", processingSpinner, gradientDuoTone, gradientMonochrome, label, outline = false, pill = false, positionInGroup = "none", size = "md", theme: customTheme = {}, ...props }, ref) => {
  const { buttonGroup: groupTheme, button: buttonTheme2 } = useTheme().theme;
  const theme2 = mergeDeep(buttonTheme2, customTheme);
  const theirProps = props;
  return jsxRuntimeExports.jsx(ButtonBase, { ref, disabled, className: twMerge(theme2.base, disabled && theme2.disabled, !gradientDuoTone && !gradientMonochrome && theme2.color[color], gradientDuoTone && !gradientMonochrome && theme2.gradientDuoTone[gradientDuoTone], !gradientDuoTone && gradientMonochrome && theme2.gradient[gradientMonochrome], outline && (theme2.outline.color[color] ?? theme2.outline.color.default), theme2.pill[pill ? "on" : "off"], fullSized && theme2.fullSized, groupTheme.position[positionInGroup], className), ...theirProps, children: jsxRuntimeExports.jsx("span", { className: twMerge(theme2.inner.base, theme2.outline[outline ? "on" : "off"], theme2.outline.pill[outline && pill ? "on" : "off"], theme2.size[size], outline && !theme2.outline.color[color] && theme2.inner.outline, isProcessing && theme2.isProcessing, isProcessing && theme2.inner.isProcessingPadding[size], theme2.inner.position[positionInGroup]), children: jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [isProcessing && jsxRuntimeExports.jsx("span", { className: twMerge(theme2.spinnerSlot, theme2.spinnerLeftPosition[size]), children: processingSpinner || jsxRuntimeExports.jsx(Spinner, { size }) }), typeof children !== "undefined" ? children : jsxRuntimeExports.jsx("span", { "data-testid": "flowbite-button-label", className: twMerge(theme2.label), children: isProcessing ? processingLabel : label })] }) }) });
};
ButtonComponentFn.displayName = "Button";
const ButtonComponent = genericForwardRef(ButtonComponentFn);
const Button = Object.assign(ButtonComponent, {
  Group: ButtonGroup
});
const BannerCollapseButton = ({ children, ...props }) => {
  const onClick = (event) => {
    const collapseButton = event.target;
    const parentBanner = collapseButton.closest('[role="banner"]');
    parentBanner == null ? void 0 : parentBanner.remove();
  };
  return jsxRuntimeExports.jsx(Button, { onClick, ...props, children });
};
BannerCollapseButton.displayName = "Banner.CollapseButton";
const BannerComponent = ({ children, ...props }) => {
  return jsxRuntimeExports.jsx("div", { "data-testid": "flowbite-banner", role: "banner", tabIndex: -1, ...props, children });
};
BannerComponent.displayName = "Banner";
Object.assign(BannerComponent, {
  CollapseButton: BannerCollapseButton
});
const BreadcrumbItem = reactExports.forwardRef(({ children, className, href, icon: Icon2, theme: customTheme = {}, ...props }, ref) => {
  const isLink = typeof href !== "undefined";
  const Component = isLink ? "a" : "span";
  const theme2 = mergeDeep(useTheme().theme.breadcrumb.item, customTheme);
  return jsxRuntimeExports.jsxs("li", { className: twMerge(theme2.base, className), ...props, children: [jsxRuntimeExports.jsx(HiOutlineChevronRight, { "aria-hidden": true, className: theme2.chevron, "data-testid": "flowbite-breadcrumb-separator" }), jsxRuntimeExports.jsxs(Component, { ref, className: theme2.href[isLink ? "on" : "off"], "data-testid": "flowbite-breadcrumb-item", href, children: [Icon2 && jsxRuntimeExports.jsx(Icon2, { "aria-hidden": true, className: theme2.icon }), children] })] });
});
BreadcrumbItem.displayName = "Breadcrumb.Item";
const BreadcrumbComponent = ({ children, className, theme: customTheme = {}, ...props }) => {
  const theme2 = mergeDeep(useTheme().theme.breadcrumb.root, customTheme);
  return jsxRuntimeExports.jsx("nav", { "aria-label": "Breadcrumb", className: twMerge(theme2.base, className), ...props, children: jsxRuntimeExports.jsx("ol", { className: theme2.list, children }) });
};
BreadcrumbComponent.displayName = "Breadcrumb";
Object.assign(BreadcrumbComponent, { Item: BreadcrumbItem });
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var n$2 = function(t2, e2) {
  return (n$2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t3, e3) {
    t3.__proto__ = e3;
  } || function(t3, e3) {
    for (var n2 in e3)
      e3.hasOwnProperty(n2) && (t3[n2] = e3[n2]);
  })(t2, e2);
};
var o, r$2, i = (function(t2) {
  /*!
    Copyright (c) 2017 Jed Watson.
    Licensed under the MIT License (MIT), see
    http://jedwatson.github.io/classnames
  */
  !function() {
    var e2 = {}.hasOwnProperty;
    function n2() {
      for (var t3 = [], o2 = 0; o2 < arguments.length; o2++) {
        var r2 = arguments[o2];
        if (r2) {
          var i2 = typeof r2;
          if ("string" === i2 || "number" === i2)
            t3.push(r2);
          else if (Array.isArray(r2) && r2.length) {
            var s2 = n2.apply(null, r2);
            s2 && t3.push(s2);
          } else if ("object" === i2)
            for (var l2 in r2)
              e2.call(r2, l2) && r2[l2] && t3.push(l2);
        }
      }
      return t3.join(" ");
    }
    t2.exports ? (n2.default = n2, t2.exports = n2) : window.classNames = n2;
  }();
}(r$2 = { path: o, exports: {}, require: function(t2, e2) {
  return function() {
    throw new Error("Dynamic requires are not currently supported by @rollup/plugin-commonjs");
  }(null == e2 && r$2.path);
} }, r$2.exports), r$2.exports);
function s(t2, e2, n2) {
  var o2, r2, i2, s2, l2;
  function a2() {
    var c3 = Date.now() - s2;
    c3 < e2 && c3 >= 0 ? o2 = setTimeout(a2, e2 - c3) : (o2 = null, n2 || (l2 = t2.apply(i2, r2), i2 = r2 = null));
  }
  null == e2 && (e2 = 100);
  var c2 = function() {
    i2 = this, r2 = arguments, s2 = Date.now();
    var c3 = n2 && !o2;
    return o2 || (o2 = setTimeout(a2, e2)), c3 && (l2 = t2.apply(i2, r2), i2 = r2 = null), l2;
  };
  return c2.clear = function() {
    o2 && (clearTimeout(o2), o2 = null);
  }, c2.flush = function() {
    o2 && (l2 = t2.apply(i2, r2), i2 = r2 = null, clearTimeout(o2), o2 = null);
  }, c2;
}
s.debounce = s;
var l$2 = s;
!function(t2, e2) {
  void 0 === e2 && (e2 = {});
  var n2 = e2.insertAt;
  if (t2 && "undefined" != typeof document) {
    var o2 = document.head || document.getElementsByTagName("head")[0], r2 = document.createElement("style");
    r2.type = "text/css", "top" === n2 && o2.firstChild ? o2.insertBefore(r2, o2.firstChild) : o2.appendChild(r2), r2.styleSheet ? r2.styleSheet.cssText = t2 : r2.appendChild(document.createTextNode(t2));
  }
}(".indiana-scroll-container {\n  overflow: auto; }\n  .indiana-scroll-container--dragging {\n    scroll-behavior: auto !important; }\n    .indiana-scroll-container--dragging > * {\n      pointer-events: none;\n      cursor: -webkit-grab;\n      cursor: grab; }\n  .indiana-scroll-container--hide-scrollbars {\n    overflow: hidden;\n    overflow: -moz-scrollbars-none;\n    -ms-overflow-style: none;\n    scrollbar-width: none; }\n    .indiana-scroll-container--hide-scrollbars::-webkit-scrollbar {\n      display: none !important;\n      height: 0 !important;\n      width: 0 !important;\n      background: transparent !important;\n      -webkit-appearance: none !important; }\n  .indiana-scroll-container--native-scroll {\n    overflow: auto; }\n\n.indiana-dragging {\n  cursor: -webkit-grab;\n  cursor: grab; }\n");
var a, c$2 = (a = "indiana-scroll-container", function(t2, e2) {
  if (!t2)
    return a;
  var n2;
  "string" == typeof t2 ? n2 = t2 : e2 = t2;
  var o2 = a;
  return n2 && (o2 += "__" + n2), o2 + (e2 ? Object.keys(e2).reduce(function(t3, n3) {
    var r2 = e2[n3];
    return r2 && (t3 += " " + ("boolean" == typeof r2 ? o2 + "--" + n3 : o2 + "--" + n3 + "_" + r2)), t3;
  }, "") : "");
});
(function(e2) {
  function o2(n2) {
    var o3 = e2.call(this, n2) || this;
    return o3.onEndScroll = function() {
      o3.scrolling = false, !o3.pressed && o3.started && o3.processEnd();
    }, o3.onScroll = function(t2) {
      var e3 = o3.container.current;
      e3.scrollLeft === o3.scrollLeft && e3.scrollTop === o3.scrollTop || (o3.scrolling = true, o3.processScroll(t2), o3.onEndScroll());
    }, o3.onTouchStart = function(t2) {
      var e3 = o3.props.nativeMobileScroll;
      if (o3.isDraggable(t2.target))
        if (o3.internal = true, e3 && o3.scrolling)
          o3.pressed = true;
        else {
          var n3 = t2.touches[0];
          o3.processClick(t2, n3.clientX, n3.clientY), !e3 && o3.props.stopPropagation && t2.stopPropagation();
        }
    }, o3.onTouchEnd = function(t2) {
      var e3 = o3.props.nativeMobileScroll;
      o3.pressed && (!o3.started || o3.scrolling && e3 ? o3.pressed = false : o3.processEnd(), o3.forceUpdate());
    }, o3.onTouchMove = function(t2) {
      var e3 = o3.props.nativeMobileScroll;
      if (o3.pressed && (!e3 || !o3.isMobile)) {
        var n3 = t2.touches[0];
        n3 && o3.processMove(t2, n3.clientX, n3.clientY), t2.preventDefault(), o3.props.stopPropagation && t2.stopPropagation();
      }
    }, o3.onMouseDown = function(t2) {
      o3.isDraggable(t2.target) && o3.isScrollable() && (o3.internal = true, -1 !== o3.props.buttons.indexOf(t2.button) && (o3.processClick(t2, t2.clientX, t2.clientY), t2.preventDefault(), o3.props.stopPropagation && t2.stopPropagation()));
    }, o3.onMouseMove = function(t2) {
      o3.pressed && (o3.processMove(t2, t2.clientX, t2.clientY), t2.preventDefault(), o3.props.stopPropagation && t2.stopPropagation());
    }, o3.onMouseUp = function(t2) {
      o3.pressed && (o3.started ? o3.processEnd() : (o3.internal = false, o3.pressed = false, o3.forceUpdate(), o3.props.onClick && o3.props.onClick(t2)), t2.preventDefault(), o3.props.stopPropagation && t2.stopPropagation());
    }, o3.container = React.createRef(), o3.onEndScroll = l$2(o3.onEndScroll, 300), o3.scrolling = false, o3.started = false, o3.pressed = false, o3.internal = false, o3.getRef = o3.getRef.bind(o3), o3;
  }
  return function(t2, e3) {
    function o3() {
      this.constructor = t2;
    }
    n$2(t2, e3), t2.prototype = null === e3 ? Object.create(e3) : (o3.prototype = e3.prototype, new o3());
  }(o2, e2), o2.prototype.componentDidMount = function() {
    var t2 = this.props.nativeMobileScroll, e3 = this.container.current;
    window.addEventListener("mouseup", this.onMouseUp), window.addEventListener("mousemove", this.onMouseMove), window.addEventListener("touchmove", this.onTouchMove, { passive: false }), window.addEventListener("touchend", this.onTouchEnd), e3.addEventListener("touchstart", this.onTouchStart, { passive: false }), e3.addEventListener("mousedown", this.onMouseDown, { passive: false }), t2 && (this.isMobile = this.isMobileDevice(), this.isMobile && this.forceUpdate());
  }, o2.prototype.componentWillUnmount = function() {
    window.removeEventListener("mouseup", this.onMouseUp), window.removeEventListener("mousemove", this.onMouseMove), window.removeEventListener("touchmove", this.onTouchMove), window.removeEventListener("touchend", this.onTouchEnd);
  }, o2.prototype.getElement = function() {
    return this.container.current;
  }, o2.prototype.isMobileDevice = function() {
    return void 0 !== window.orientation || -1 !== navigator.userAgent.indexOf("IEMobile");
  }, o2.prototype.isDraggable = function(t2) {
    var e3 = this.props.ignoreElements;
    if (e3) {
      var n2 = t2.closest(e3);
      return null === n2 || n2.contains(this.getElement());
    }
    return true;
  }, o2.prototype.isScrollable = function() {
    var t2 = this.container.current;
    return t2 && (t2.scrollWidth > t2.clientWidth || t2.scrollHeight > t2.clientHeight);
  }, o2.prototype.processClick = function(t2, e3, n2) {
    var o3 = this.container.current;
    this.scrollLeft = o3.scrollLeft, this.scrollTop = o3.scrollTop, this.clientX = e3, this.clientY = n2, this.pressed = true;
  }, o2.prototype.processStart = function(t2) {
    void 0 === t2 && (t2 = true);
    var e3 = this.props.onStartScroll;
    this.started = true, t2 && document.body.classList.add("indiana-dragging"), e3 && e3({ external: !this.internal }), this.forceUpdate();
  }, o2.prototype.processScroll = function(t2) {
    if (this.started) {
      var e3 = this.props.onScroll;
      e3 && e3({ external: !this.internal });
    } else
      this.processStart(false);
  }, o2.prototype.processMove = function(t2, e3, n2) {
    var o3 = this.props, r2 = o3.horizontal, i2 = o3.vertical, s2 = o3.activationDistance, l2 = o3.onScroll, a2 = this.container.current;
    this.started ? (r2 && (a2.scrollLeft -= e3 - this.clientX), i2 && (a2.scrollTop -= n2 - this.clientY), l2 && l2({ external: !this.internal }), this.clientX = e3, this.clientY = n2, this.scrollLeft = a2.scrollLeft, this.scrollTop = a2.scrollTop) : (r2 && Math.abs(e3 - this.clientX) > s2 || i2 && Math.abs(n2 - this.clientY) > s2) && (this.clientX = e3, this.clientY = n2, this.processStart());
  }, o2.prototype.processEnd = function() {
    var t2 = this.props.onEndScroll;
    this.container.current && t2 && t2({ external: !this.internal }), this.pressed = false, this.started = false, this.scrolling = false, this.internal = false, document.body.classList.remove("indiana-dragging"), this.forceUpdate();
  }, o2.prototype.getRef = function(t2) {
    [this.container, this.props.innerRef].forEach(function(e3) {
      e3 && ("function" == typeof e3 ? e3(t2) : e3.current = t2);
    });
  }, o2.prototype.render = function() {
    var e3 = this.props, n2 = e3.children, o3 = e3.draggingClassName, r2 = e3.className, s2 = e3.style, l2 = e3.hideScrollbars, a2 = e3.component;
    return React.createElement(a2, { className: i(r2, this.pressed && o3, c$2({ dragging: this.pressed, "hide-scrollbars": l2, "native-scroll": this.isMobile })), style: s2, ref: this.getRef, onScroll: this.onScroll }, n2);
  }, o2.defaultProps = { nativeMobileScroll: true, hideScrollbars: true, activationDistance: 10, vertical: true, horizontal: true, stopPropagation: false, style: {}, component: "div", buttons: [0] }, o2;
})(reactExports.PureComponent);
const Checkbox = reactExports.forwardRef(({ className, color = "default", theme: customTheme = {}, ...props }, ref) => {
  const theme2 = mergeDeep(useTheme().theme.checkbox, customTheme);
  return jsxRuntimeExports.jsx("input", { ref, type: "checkbox", className: twMerge(theme2.root.base, theme2.root.color[color], className), ...props });
});
Checkbox.displayName = "Checkbox";
var Views;
(function(Views2) {
  Views2[Views2["Days"] = 0] = "Days";
  Views2[Views2["Months"] = 1] = "Months";
  Views2[Views2["Years"] = 2] = "Years";
  Views2[Views2["Decades"] = 3] = "Decades";
})(Views || (Views = {}));
var WeekStart;
(function(WeekStart2) {
  WeekStart2[WeekStart2["Saturday"] = 0] = "Saturday";
  WeekStart2[WeekStart2["Sunday"] = 1] = "Sunday";
  WeekStart2[WeekStart2["Monday"] = 2] = "Monday";
  WeekStart2[WeekStart2["Tuesday"] = 3] = "Tuesday";
  WeekStart2[WeekStart2["Wednesday"] = 4] = "Wednesday";
  WeekStart2[WeekStart2["Thursday"] = 5] = "Thursday";
  WeekStart2[WeekStart2["Friday"] = 6] = "Friday";
})(WeekStart || (WeekStart = {}));
reactExports.createContext(void 0);
const accordionTheme = {
  root: {
    base: "divide-y divide-gray-200 border-gray-200 dark:divide-gray-700 dark:border-gray-700",
    flush: {
      off: "rounded-lg border",
      on: "border-b"
    }
  },
  content: {
    base: "py-5 px-5 last:rounded-b-lg dark:bg-gray-900 first:rounded-t-lg"
  },
  title: {
    arrow: {
      base: "h-6 w-6 shrink-0",
      open: {
        off: "",
        on: "rotate-180"
      }
    },
    base: "flex w-full items-center justify-between first:rounded-t-lg last:rounded-b-lg py-5 px-5 text-left font-medium text-gray-500 dark:text-gray-400",
    flush: {
      off: "hover:bg-gray-100 focus:ring-4 focus:ring-gray-200 dark:hover:bg-gray-800 dark:focus:ring-gray-800",
      on: "bg-transparent dark:bg-transparent"
    },
    heading: "",
    open: {
      off: "",
      on: "text-gray-900 bg-gray-100 dark:bg-gray-800 dark:text-white"
    }
  }
};
const alertTheme = {
  base: "flex flex-col gap-2 p-4 text-sm",
  borderAccent: "border-t-4",
  closeButton: {
    base: "-mx-1.5 -my-1.5 ml-auto inline-flex h-8 w-8 rounded-lg p-1.5 focus:ring-2",
    icon: "w-5 h-5",
    color: {
      info: "bg-cyan-100 text-cyan-500 hover:bg-cyan-200 focus:ring-cyan-400 dark:bg-cyan-200 dark:text-cyan-600 dark:hover:bg-cyan-300",
      gray: "bg-gray-100 text-gray-500 hover:bg-gray-200 focus:ring-gray-400 dark:bg-gray-700 dark:text-gray-300 dark:hover:bg-gray-800 dark:hover:text-white",
      failure: "bg-red-100 text-red-500 hover:bg-red-200 focus:ring-red-400 dark:bg-red-200 dark:text-red-600 dark:hover:bg-red-300",
      success: "bg-green-100 text-green-500 hover:bg-green-200 focus:ring-green-400 dark:bg-green-200 dark:text-green-600 dark:hover:bg-green-300",
      warning: "bg-yellow-100 text-yellow-500 hover:bg-yellow-200 focus:ring-yellow-400 dark:bg-yellow-200 dark:text-yellow-600 dark:hover:bg-yellow-300",
      red: "bg-red-100 text-red-500 hover:bg-red-200 focus:ring-red-400 dark:bg-red-200 dark:text-red-600 dark:hover:bg-red-300",
      green: "bg-green-100 text-green-500 hover:bg-green-200 focus:ring-green-400 dark:bg-green-200 dark:text-green-600 dark:hover:bg-green-300",
      yellow: "bg-yellow-100 text-yellow-500 hover:bg-yellow-200 focus:ring-yellow-400 dark:bg-yellow-200 dark:text-yellow-600 dark:hover:bg-yellow-300",
      blue: "bg-cyan-100 text-cyan-500 hover:bg-cyan-200 focus:ring-cyan-400 dark:bg-cyan-200 dark:text-cyan-600 dark:hover:bg-cyan-300",
      cyan: "bg-cyan-100 text-cyan-500 hover:bg-cyan-200 focus:ring-cyan-400 dark:bg-cyan-200 dark:text-cyan-600 dark:hover:bg-cyan-300",
      pink: "bg-pink-100 text-pink-500 hover:bg-pink-200 focus:ring-pink-400 dark:bg-pink-200 dark:text-pink-600 dark:hover:bg-pink-300",
      lime: "bg-lime-100 text-lime-500 hover:bg-lime-200 focus:ring-lime-400 dark:bg-lime-200 dark:text-lime-600 dark:hover:bg-lime-300",
      dark: "bg-gray-100 text-gray-500 hover:bg-gray-200 focus:ring-gray-400 dark:bg-gray-200 dark:text-gray-600 dark:hover:bg-gray-300",
      indigo: "bg-indigo-100 text-indigo-500 hover:bg-indigo-200 focus:ring-indigo-400 dark:bg-indigo-200 dark:text-indigo-600 dark:hover:bg-indigo-300",
      purple: "bg-purple-100 text-purple-500 hover:bg-purple-200 focus:ring-purple-400 dark:bg-purple-200 dark:text-purple-600 dark:hover:bg-purple-300",
      teal: "bg-teal-100 text-teal-500 hover:bg-teal-200 focus:ring-teal-400 dark:bg-teal-200 dark:text-teal-600 dark:hover:bg-teal-300",
      light: "bg-gray-50 text-gray-500 hover:bg-gray-100 focus:ring-gray-200 dark:bg-gray-600 dark:text-gray-200 dark:hover:bg-gray-700 dark:hover:text-white"
    }
  },
  color: {
    info: "text-cyan-700 bg-cyan-100 border-cyan-500 dark:bg-cyan-200 dark:text-cyan-800",
    gray: "text-gray-700 bg-gray-100 border-gray-500 dark:bg-gray-700 dark:text-gray-300",
    failure: "text-red-700 bg-red-100 border-red-500 dark:bg-red-200 dark:text-red-800",
    success: "text-green-700 bg-green-100 border-green-500 dark:bg-green-200 dark:text-green-800",
    warning: "text-yellow-700 bg-yellow-100 border-yellow-500 dark:bg-yellow-200 dark:text-yellow-800",
    red: "text-red-700 bg-red-100 border-red-500 dark:bg-red-200 dark:text-red-800",
    green: "text-green-700 bg-green-100 border-green-500 dark:bg-green-200 dark:text-green-800",
    yellow: "text-yellow-700 bg-yellow-100 border-yellow-500 dark:bg-yellow-200 dark:text-yellow-800",
    blue: "text-cyan-700 bg-cyan-100 border-cyan-500 dark:bg-cyan-200 dark:text-cyan-800",
    cyan: "text-cyan-700 bg-cyan-100 border-cyan-500 dark:bg-cyan-200 dark:text-cyan-800",
    pink: "text-pink-700 bg-pink-100 border-pink-500 dark:bg-pink-200 dark:text-pink-800",
    lime: "text-lime-700 bg-lime-100 border-lime-500 dark:bg-lime-200 dark:text-lime-800",
    dark: "text-gray-200 bg-gray-800 border-gray-600 dark:bg-gray-900 dark:text-gray-300",
    indigo: "text-indigo-700 bg-indigo-100 border-indigo-500 dark:bg-indigo-200 dark:text-indigo-800",
    purple: "text-purple-700 bg-purple-100 border-purple-500 dark:bg-purple-200 dark:text-purple-800",
    teal: "text-teal-700 bg-teal-100 border-teal-500 dark:bg-teal-200 dark:text-teal-800",
    light: "text-gray-600 bg-gray-50 border-gray-400 dark:bg-gray-500 dark:text-gray-200"
  },
  icon: "mr-3 inline h-5 w-5 flex-shrink-0",
  rounded: "rounded-lg",
  wrapper: "flex items-center"
};
const avatarTheme = {
  root: {
    base: "flex justify-center items-center space-x-4 rounded",
    bordered: "p-1 ring-2",
    rounded: "rounded-full",
    color: {
      dark: "ring-gray-800 dark:ring-gray-800",
      failure: "ring-red-500 dark:ring-red-700",
      gray: "ring-gray-500 dark:ring-gray-400",
      info: "ring-cyan-400 dark:ring-cyan-800",
      light: "ring-gray-300 dark:ring-gray-500",
      purple: "ring-purple-500 dark:ring-purple-600",
      success: "ring-green-500 dark:ring-green-500",
      warning: "ring-yellow-300 dark:ring-yellow-500",
      pink: "ring-pink-500 dark:ring-pink-500"
    },
    img: {
      base: "rounded",
      off: "relative overflow-hidden bg-gray-100 dark:bg-gray-600",
      on: "",
      placeholder: "absolute w-auto h-auto text-gray-400 -bottom-1"
    },
    size: {
      xs: "w-6 h-6",
      sm: "w-8 h-8",
      md: "w-10 h-10",
      lg: "w-20 h-20",
      xl: "w-36 h-36"
    },
    stacked: "ring-2 ring-gray-300 dark:ring-gray-500",
    statusPosition: {
      "bottom-left": "-bottom-1 -left-1",
      "bottom-center": "-bottom-1 center",
      "bottom-right": "-bottom-1 -right-1",
      "top-left": "-top-1 -left-1",
      "top-center": "-top-1 center",
      "top-right": "-top-1 -right-1",
      "center-right": "center -right-1",
      center: "center center",
      "center-left": "center -left-1"
    },
    status: {
      away: "bg-yellow-400",
      base: "absolute h-3.5 w-3.5 rounded-full border-2 border-white dark:border-gray-800",
      busy: "bg-red-400",
      offline: "bg-gray-400",
      online: "bg-green-400"
    },
    initials: {
      text: "font-medium text-gray-600 dark:text-gray-300",
      base: "inline-flex overflow-hidden relative justify-center items-center bg-gray-100 dark:bg-gray-600"
    }
  },
  group: {
    base: "flex -space-x-4"
  },
  groupCounter: {
    base: "relative flex items-center justify-center w-10 h-10 text-xs font-medium text-white bg-gray-700 rounded-full ring-2 ring-gray-300 hover:bg-gray-600 dark:ring-gray-500"
  }
};
const badgeTheme = {
  root: {
    base: "flex h-fit items-center gap-1 font-semibold",
    color: {
      info: "bg-cyan-100 text-cyan-800 dark:bg-cyan-200 dark:text-cyan-800 group-hover:bg-cyan-200 dark:group-hover:bg-cyan-300",
      gray: "bg-gray-100 text-gray-800 dark:bg-gray-700 dark:text-gray-300 group-hover:bg-gray-200 dark:group-hover:bg-gray-600",
      failure: "bg-red-100 text-red-800 dark:bg-red-200 dark:text-red-900 group-hover:bg-red-200 dark:group-hover:bg-red-300",
      success: "bg-green-100 text-green-800 dark:bg-green-200 dark:text-green-900 group-hover:bg-green-200 dark:group-hover:bg-green-300",
      warning: "bg-yellow-100 text-yellow-800 dark:bg-yellow-200 dark:text-yellow-900 group-hover:bg-yellow-200 dark:group-hover:bg-yellow-300",
      indigo: "bg-indigo-100 text-indigo-800 dark:bg-indigo-200 dark:text-indigo-900 group-hover:bg-indigo-200 dark:group-hover:bg-indigo-300",
      purple: "bg-purple-100 text-purple-800 dark:bg-purple-200 dark:text-purple-900 group-hover:bg-purple-200 dark:group-hover:bg-purple-300",
      pink: "bg-pink-100 text-pink-800 dark:bg-pink-200 dark:text-pink-900 group-hover:bg-pink-200 dark:group-hover:bg-pink-300",
      blue: "bg-cyan-100 text-cyan-800 dark:bg-cyan-200 dark:text-cyan-900 group-hover:bg-cyan-200 dark:group-hover:bg-cyan-300",
      cyan: "bg-cyan-100 text-cyan-800 dark:bg-cyan-200 dark:text-cyan-900 group-hover:bg-cyan-200 dark:group-hover:bg-cyan-300",
      dark: "bg-gray-600 text-gray-100 dark:bg-gray-900 dark:text-gray-200 group-hover:bg-gray-500 dark:group-hover:bg-gray-700",
      light: "bg-gray-200 text-gray-800 dark:bg-gray-400 dark:text-gray-900 group-hover:bg-gray-300 dark:group-hover:bg-gray-500",
      green: "bg-green-100 text-green-800 dark:bg-green-200 dark:text-green-900 group-hover:bg-green-200 dark:group-hover:bg-green-300",
      lime: "bg-lime-100 text-lime-800 dark:bg-lime-200 dark:text-lime-900 group-hover:bg-lime-200 dark:group-hover:bg-lime-300",
      red: "bg-red-100 text-red-800 dark:bg-red-200 dark:text-red-900 group-hover:bg-red-200 dark:group-hover:bg-red-300",
      teal: "bg-teal-100 text-teal-800 dark:bg-teal-200 dark:text-teal-900 group-hover:bg-teal-200 dark:group-hover:bg-teal-300",
      yellow: "bg-yellow-100 text-yellow-800 dark:bg-yellow-200 dark:text-yellow-900 group-hover:bg-yellow-200 dark:group-hover:bg-yellow-300"
    },
    href: "group",
    size: {
      xs: "p-1 text-xs",
      sm: "p-1.5 text-sm"
    }
  },
  icon: {
    off: "rounded px-2 py-0.5",
    on: "rounded-full p-1.5",
    size: {
      xs: "w-3 h-3",
      sm: "w-3.5 h-3.5"
    }
  }
};
const blockquoteTheme = {
  root: {
    base: "text-xl italic font-semibold text-gray-900 dark:text-white"
  }
};
const breadcrumbTheme = {
  root: {
    base: "",
    list: "flex items-center"
  },
  item: {
    base: "group flex items-center",
    chevron: "mx-1 h-4 w-4 text-gray-400 group-first:hidden md:mx-2",
    href: {
      off: "flex items-center text-sm font-medium text-gray-500 dark:text-gray-400",
      on: "flex items-center text-sm font-medium text-gray-700 hover:text-gray-900 dark:text-gray-400 dark:hover:text-white"
    },
    icon: "mr-2 h-4 w-4"
  }
};
const buttonTheme = {
  base: "group flex items-stretch items-center justify-center p-0.5 text-center font-medium relative focus:z-10 focus:outline-none",
  fullSized: "w-full",
  color: {
    dark: "text-white bg-gray-800 border border-transparent enabled:hover:bg-gray-900 focus:ring-4 focus:ring-gray-300 dark:bg-gray-800 dark:enabled:hover:bg-gray-700 dark:focus:ring-gray-800 dark:border-gray-700",
    failure: "text-white bg-red-700 border border-transparent enabled:hover:bg-red-800 focus:ring-4 focus:ring-red-300 dark:bg-red-600 dark:enabled:hover:bg-red-700 dark:focus:ring-red-900",
    gray: "text-gray-900 bg-white border border-gray-200 enabled:hover:bg-gray-100 enabled:hover:text-cyan-700 :ring-cyan-700 focus:text-cyan-700 dark:bg-transparent dark:text-gray-400 dark:border-gray-600 dark:enabled:hover:text-white dark:enabled:hover:bg-gray-700 focus:ring-2",
    info: "text-white bg-cyan-700 border border-transparent enabled:hover:bg-cyan-800 focus:ring-4 focus:ring-cyan-300 dark:bg-cyan-600 dark:enabled:hover:bg-cyan-700 dark:focus:ring-cyan-800",
    light: "text-gray-900 bg-white border border-gray-300 enabled:hover:bg-gray-100 focus:ring-4 focus:ring-cyan-300 dark:bg-gray-600 dark:text-white dark:border-gray-600 dark:enabled:hover:bg-gray-700 dark:enabled:hover:border-gray-700 dark:focus:ring-gray-700",
    purple: "text-white bg-purple-700 border border-transparent enabled:hover:bg-purple-800 focus:ring-4 focus:ring-purple-300 dark:bg-purple-600 dark:enabled:hover:bg-purple-700 dark:focus:ring-purple-900",
    success: "text-white bg-green-700 border border-transparent enabled:hover:bg-green-800 focus:ring-4 focus:ring-green-300 dark:bg-green-600 dark:enabled:hover:bg-green-700 dark:focus:ring-green-800",
    warning: "text-white bg-yellow-400 border border-transparent enabled:hover:bg-yellow-500 focus:ring-4 focus:ring-yellow-300 dark:focus:ring-yellow-900",
    blue: "text-white bg-blue-700 border border-transparent enabled:hover:bg-blue-800 focus:ring-4 focus:ring-blue-300 dark:bg-blue-600 dark:hover:bg-blue-700 dark:focus:ring-blue-800",
    cyan: "text-cyan-900 bg-white border border-cyan-300 enabled:hover:bg-cyan-100 focus:ring-4 focus:ring-cyan-300 :bg-cyan-600 dark:text-white dark:border-cyan-600 dark:enabled:hover:bg-cyan-700 dark:enabled:hover:border-cyan-700 dark:focus:ring-cyan-700",
    green: "text-green-900 bg-white border border-green-300 enabled:hover:bg-green-100 focus:ring-4 focus:ring-green-300 :bg-green-600 dark:text-white dark:border-green-600 dark:enabled:hover:bg-green-700 dark:enabled:hover:border-green-700 dark:focus:ring-green-700",
    indigo: "text-indigo-900 bg-white border border-indigo-300 enabled:hover:bg-indigo-100 focus:ring-4 focus:ring-indigo-300 :bg-indigo-600 dark:text-white dark:border-indigo-600 dark:enabled:hover:bg-indigo-700 dark:enabled:hover:border-indigo-700 dark:focus:ring-indigo-700",
    lime: "text-lime-900 bg-white border border-lime-300 enabled:hover:bg-lime-100 focus:ring-4 focus:ring-lime-300 :bg-lime-600 dark:text-white dark:border-lime-600 dark:enabled:hover:bg-lime-700 dark:enabled:hover:border-lime-700 dark:focus:ring-lime-700",
    pink: "text-pink-900 bg-white border border-pink-300 enabled:hover:bg-pink-100 focus:ring-4 focus:ring-pink-300 :bg-pink-600 dark:text-white dark:border-pink-600 dark:enabled:hover:bg-pink-700 dark:enabled:hover:border-pink-700 dark:focus:ring-pink-700",
    red: "text-red-900 bg-white border border-red-300 enabled:hover:bg-red-100 focus:ring-4 focus:ring-red-300 :bg-red-600 dark:text-white dark:border-red-600 dark:enabled:hover:bg-red-700 dark:enabled:hover:border-red-700 dark:focus:ring-red-700",
    teal: "text-teal-900 bg-white border border-teal-300 enabled:hover:bg-teal-100 focus:ring-4 focus:ring-teal-300 :bg-teal-600 dark:text-white dark:border-teal-600 dark:enabled:hover:bg-teal-700 dark:enabled:hover:border-teal-700 dark:focus:ring-teal-700",
    yellow: "text-yellow-900 bg-white border border-yellow-300 enabled:hover:bg-yellow-100 focus:ring-4 focus:ring-yellow-300 :bg-yellow-600 dark:text-white dark:border-yellow-600 dark:enabled:hover:bg-yellow-700 dark:enabled:hover:border-yellow-700 dark:focus:ring-yellow-700"
  },
  disabled: "cursor-not-allowed opacity-50",
  isProcessing: "cursor-wait",
  spinnerSlot: "absolute h-full top-0 flex items-center animate-fade-in",
  spinnerLeftPosition: {
    xs: "left-2",
    sm: "left-3",
    md: "left-4",
    lg: "left-5",
    xl: "left-6"
  },
  gradient: {
    cyan: "text-white bg-gradient-to-r from-cyan-400 via-cyan-500 to-cyan-600 enabled:hover:bg-gradient-to-br focus:ring-4 focus:ring-cyan-300 dark:focus:ring-cyan-800",
    failure: "text-white bg-gradient-to-r from-red-400 via-red-500 to-red-600 enabled:hover:bg-gradient-to-br focus:ring-4 focus:ring-red-300 dark:focus:ring-red-800",
    info: "text-white bg-gradient-to-r from-cyan-500 via-cyan-600 to-cyan-700 enabled:hover:bg-gradient-to-br focus:ring-4 focus:ring-cyan-300 dark:focus:ring-cyan-800 ",
    lime: "text-gray-900 bg-gradient-to-r from-lime-200 via-lime-400 to-lime-500 enabled:hover:bg-gradient-to-br focus:ring-4 focus:ring-lime-300 dark:focus:ring-lime-800",
    pink: "text-white bg-gradient-to-r from-pink-400 via-pink-500 to-pink-600 enabled:hover:bg-gradient-to-br focus:ring-4 focus:ring-pink-300 dark:focus:ring-pink-800",
    purple: "text-white bg-gradient-to-r from-purple-500 via-purple-600 to-purple-700 enabled:hover:bg-gradient-to-br focus:ring-4 focus:ring-purple-300 dark:focus:ring-purple-800",
    success: "text-white bg-gradient-to-r from-green-400 via-green-500 to-green-600 enabled:hover:bg-gradient-to-br focus:ring-4 focus:ring-green-300 dark:focus:ring-green-800",
    teal: "text-white bg-gradient-to-r from-teal-400 via-teal-500 to-teal-600 enabled:hover:bg-gradient-to-br focus:ring-4 focus:ring-teal-300 dark:focus:ring-teal-800"
  },
  gradientDuoTone: {
    cyanToBlue: "text-white bg-gradient-to-r from-cyan-500 to-cyan-500 enabled:hover:bg-gradient-to-bl focus:ring-4 focus:ring-cyan-300 dark:focus:ring-cyan-800",
    greenToBlue: "text-white bg-gradient-to-br from-green-400 to-cyan-600 enabled:hover:bg-gradient-to-bl focus:ring-4 focus:ring-green-200 dark:focus:ring-green-800",
    pinkToOrange: "text-white bg-gradient-to-br from-pink-500 to-orange-400 enabled:hover:bg-gradient-to-bl focus:ring-4 focus:ring-pink-200 dark:focus:ring-pink-800",
    purpleToBlue: "text-white bg-gradient-to-br from-purple-600 to-cyan-500 enabled:hover:bg-gradient-to-bl focus:ring-4 focus:ring-cyan-300 dark:focus:ring-cyan-800",
    purpleToPink: "text-white bg-gradient-to-r from-purple-500 to-pink-500 enabled:hover:bg-gradient-to-l focus:ring-4 focus:ring-purple-200 dark:focus:ring-purple-800",
    redToYellow: "text-gray-900 bg-gradient-to-r from-red-200 via-red-300 to-yellow-200 enabled:hover:bg-gradient-to-bl focus:ring-4 focus:ring-red-100 dark:focus:ring-red-400",
    tealToLime: "text-gray-900 bg-gradient-to-r from-teal-200 to-lime-200 enabled:hover:bg-gradient-to-l enabled:hover:from-teal-200 enabled:hover:to-lime-200 enabled:hover:text-gray-900 focus:ring-4 focus:ring-lime-200 dark:focus:ring-teal-700"
  },
  inner: {
    base: "flex items-stretch items-center transition-all duration-200",
    position: {
      none: "",
      start: "rounded-r-none",
      middle: "rounded-none",
      end: "rounded-l-none"
    },
    outline: "border border-transparent",
    isProcessingPadding: {
      xs: "pl-8",
      sm: "pl-10",
      md: "pl-12",
      lg: "pl-16",
      xl: "pl-20"
    }
  },
  label: "ml-2 inline-flex h-4 w-4 items-center justify-center rounded-full bg-cyan-200 text-xs font-semibold text-cyan-800",
  outline: {
    color: {
      gray: "border border-gray-900 dark:border-white",
      default: "border-0",
      light: ""
    },
    off: "",
    on: "flex justify-center bg-white text-gray-900 transition-all duration-75 ease-in group-enabled:group-hover:bg-opacity-0 group-enabled:group-hover:text-inherit dark:bg-gray-900 dark:text-white w-full",
    pill: {
      off: "rounded-md",
      on: "rounded-full"
    }
  },
  pill: {
    off: "rounded-lg",
    on: "rounded-full"
  },
  size: {
    xs: "text-xs px-2 py-1",
    sm: "text-sm px-3 py-1.5",
    md: "text-sm px-4 py-2",
    lg: "text-base px-5 py-2.5",
    xl: "text-base px-6 py-3"
  }
};
const buttonGroupTheme = {
  base: "inline-flex",
  position: {
    none: "focus:ring-2",
    start: "rounded-r-none",
    middle: "rounded-none border-l-0 pl-0",
    end: "rounded-l-none border-l-0 pl-0"
  }
};
const cardTheme = {
  root: {
    base: "flex rounded-lg border border-gray-200 bg-white shadow-md dark:border-gray-700 dark:bg-gray-800",
    children: "flex h-full flex-col justify-center gap-4 p-6",
    horizontal: {
      off: "flex-col",
      on: "flex-col md:max-w-xl md:flex-row"
    },
    href: "hover:bg-gray-100 dark:hover:bg-gray-700"
  },
  img: {
    base: "",
    horizontal: {
      off: "rounded-t-lg",
      on: "h-96 w-full rounded-t-lg object-cover md:h-auto md:w-48 md:rounded-none md:rounded-l-lg"
    }
  }
};
const carouselTheme = {
  root: {
    base: "relative h-full w-full",
    leftControl: "absolute top-0 left-0 flex h-full items-center justify-center px-4 focus:outline-none",
    rightControl: "absolute top-0 right-0 flex h-full items-center justify-center px-4 focus:outline-none"
  },
  indicators: {
    active: {
      off: "bg-white/50 hover:bg-white dark:bg-gray-800/50 dark:hover:bg-gray-800",
      on: "bg-white dark:bg-gray-800"
    },
    base: "h-3 w-3 rounded-full",
    wrapper: "absolute bottom-5 left-1/2 flex -translate-x-1/2 space-x-3"
  },
  item: {
    base: "absolute top-1/2 left-1/2 block w-full -translate-x-1/2 -translate-y-1/2",
    wrapper: "w-full flex-shrink-0 transform cursor-grab snap-center"
  },
  control: {
    base: "inline-flex h-8 w-8 items-center justify-center rounded-full bg-white/30 group-hover:bg-white/50 group-focus:outline-none group-focus:ring-4 group-focus:ring-white dark:bg-gray-800/30 dark:group-hover:bg-gray-800/60 dark:group-focus:ring-gray-800/70 sm:h-10 sm:w-10",
    icon: "h-5 w-5 text-white dark:text-gray-800 sm:h-6 sm:w-6"
  },
  scrollContainer: {
    base: "flex h-full snap-mandatory overflow-y-hidden overflow-x-scroll scroll-smooth rounded-lg",
    snap: "snap-x"
  }
};
const checkboxTheme = {
  root: {
    base: "h-4 w-4 rounded focus:ring-2 border border-gray-300 dark:border-gray-600 dark:bg-gray-700 bg-gray-100",
    color: {
      default: "focus:ring-cyan-600 dark:ring-offset-cyan-600 dark:focus:ring-cyan-600 text-cyan-600",
      dark: "focus:ring-gray-800 dark:ring-offset-gray-800 dark:focus:ring-gray-800 text-gray-800",
      failure: "focus:ring-red-900 dark:ring-offset-red-900 dark:focus:ring-red-900 text-red-900",
      gray: "focus:ring-gray-900 dark:ring-offset-gray-900 dark:focus:ring-gray-900 text-gray-900",
      info: "focus:ring-cyan-800 dark:ring-offset-gray-800 dark:focus:ring-cyan-800 text-cyan-800",
      light: "focus:ring-gray-900 dark:ring-offset-gray-900 dark:focus:ring-gray-900 text-gray-900",
      purple: "focus:ring-purple-600 dark:ring-offset-purple-600 dark:focus:ring-purple-600 text-purple-600",
      success: "focus:ring-green-800 dark:ring-offset-green-800 dark:focus:ring-green-800 text-green-800",
      warning: "focus:ring-yellow-400 dark:ring-offset-yellow-400 dark:focus:ring-yellow-400 text-yellow-400",
      blue: "focus:ring-blue-600 dark:ring-offset-blue-700 dark:focus:ring-blue-700 text-blue-700",
      cyan: "focus:ring-cyan-600 dark:ring-offset-cyan-600 dark:focus:ring-cyan-600 text-cyan-600",
      green: "focus:ring-green-600 dark:ring-offset-green-600 dark:focus:ring-green-600 text-green-600",
      indigo: "focus:ring-indigo-700 dark:ring-offset-indigo-700 dark:focus:ring-indigo-700 text-indigo-700",
      lime: "focus:ring-lime-700 dark:ring-offset-lime-700 dark:focus:ring-lime-700 text-lime-700",
      pink: "focus:ring-pink-600 dark:ring-offset-pink-600 dark:focus:ring-pink-600 text-pink-600",
      red: "focus:ring-red-600 dark:ring-offset-red-600 dark:focus:ring-red-600 text-red-600",
      teal: "focus:ring-teal-600 dark:ring-offset-teal-600 dark:focus:ring-teal-600 text-teal-600",
      yellow: "focus:ring-yellow-400 dark:ring-offset-yellow-400 dark:focus:ring-yellow-400 text-yellow-400"
    }
  }
};
const darkThemeToggleTheme = {
  root: {
    base: "rounded-lg p-2.5 text-sm text-gray-500 hover:bg-gray-100 focus:outline-none focus:ring-4 focus:ring-gray-200 dark:text-gray-400 dark:hover:bg-gray-700 dark:focus:ring-gray-700",
    icon: "h-5 w-5"
  }
};
const datePickerTheme = {
  root: {
    base: "relative"
  },
  popup: {
    root: {
      base: "absolute top-10 z-50 block pt-2",
      inline: "relative top-0 z-auto",
      inner: "inline-block rounded-lg bg-white p-4 shadow-lg dark:bg-gray-700"
    },
    header: {
      base: "",
      title: "px-2 py-3 text-center font-semibold text-gray-900 dark:text-white",
      selectors: {
        base: "flex justify-between mb-2",
        button: {
          base: "text-sm rounded-lg text-gray-900 dark:text-white bg-white dark:bg-gray-700 font-semibold py-2.5 px-5 hover:bg-gray-100 dark:hover:bg-gray-600 focus:outline-none focus:ring-2 focus:ring-gray-200 view-switch",
          prev: "",
          next: "",
          view: ""
        }
      }
    },
    view: {
      base: "p-1"
    },
    footer: {
      base: "flex mt-2 space-x-2",
      button: {
        base: "w-full rounded-lg px-5 py-2 text-center text-sm font-medium focus:ring-4 focus:ring-cyan-300",
        today: "bg-cyan-700 text-white hover:bg-cyan-800 dark:bg-cyan-600 dark:hover:bg-cyan-700",
        clear: "border border-gray-300 bg-white text-gray-900 hover:bg-gray-100 dark:border-gray-600 dark:bg-gray-700 dark:text-white dark:hover:bg-gray-600"
      }
    }
  },
  views: {
    days: {
      header: {
        base: "grid grid-cols-7 mb-1",
        title: "dow h-6 text-center text-sm font-medium leading-6 text-gray-500 dark:text-gray-400"
      },
      items: {
        base: "grid w-64 grid-cols-7",
        item: {
          base: "block flex-1 cursor-pointer rounded-lg border-0 text-center text-sm font-semibold leading-9 text-gray-900 hover:bg-gray-100 dark:text-white dark:hover:bg-gray-600 ",
          selected: "bg-cyan-700 text-white hover:bg-cyan-600",
          disabled: "text-gray-500"
        }
      }
    },
    months: {
      items: {
        base: "grid w-64 grid-cols-4",
        item: {
          base: "block flex-1 cursor-pointer rounded-lg border-0 text-center text-sm font-semibold leading-9 text-gray-900 hover:bg-gray-100 dark:text-white dark:hover:bg-gray-600",
          selected: "bg-cyan-700 text-white hover:bg-cyan-600",
          disabled: "text-gray-500"
        }
      }
    },
    years: {
      items: {
        base: "grid w-64 grid-cols-4",
        item: {
          base: "block flex-1 cursor-pointer rounded-lg border-0 text-center text-sm font-semibold leading-9 hover:bg-gray-100 dark:text-white dark:hover:bg-gray-600 text-gray-900",
          selected: "bg-cyan-700 text-white hover:bg-cyan-600",
          disabled: "text-gray-500"
        }
      }
    },
    decades: {
      items: {
        base: "grid w-64 grid-cols-4",
        item: {
          base: "block flex-1 cursor-pointer rounded-lg border-0 text-center text-sm font-semibold leading-9  hover:bg-gray-100 dark:text-white dark:hover:bg-gray-600 text-gray-900",
          selected: "bg-cyan-700 text-white hover:bg-cyan-600",
          disabled: "text-gray-500"
        }
      }
    }
  }
};
const dropdownTheme = {
  arrowIcon: "ml-2 h-4 w-4",
  content: "py-1 focus:outline-none",
  floating: {
    animation: "transition-opacity",
    arrow: {
      base: "absolute z-10 h-2 w-2 rotate-45",
      style: {
        dark: "bg-gray-900 dark:bg-gray-700",
        light: "bg-white",
        auto: "bg-white dark:bg-gray-700"
      },
      placement: "-4px"
    },
    base: "z-10 w-fit rounded divide-y divide-gray-100 shadow focus:outline-none",
    content: "py-1 text-sm text-gray-700 dark:text-gray-200",
    divider: "my-1 h-px bg-gray-100 dark:bg-gray-600",
    header: "block py-2 px-4 text-sm text-gray-700 dark:text-gray-200",
    hidden: "invisible opacity-0",
    item: {
      container: "",
      base: "flex items-center justify-start py-2 px-4 text-sm text-gray-700 cursor-pointer w-full hover:bg-gray-100 focus:bg-gray-100 dark:text-gray-200 dark:hover:bg-gray-600 focus:outline-none dark:hover:text-white dark:focus:bg-gray-600 dark:focus:text-white",
      icon: "mr-2 h-4 w-4"
    },
    style: {
      dark: "bg-gray-900 text-white dark:bg-gray-700",
      light: "border border-gray-200 bg-white text-gray-900",
      auto: "border border-gray-200 bg-white text-gray-900 dark:border-none dark:bg-gray-700 dark:text-white"
    },
    target: "w-fit"
  },
  inlineWrapper: "flex items-center"
};
const fileInputTheme = {
  root: {
    base: "flex"
  },
  field: {
    base: "relative w-full",
    input: {
      base: "rounded-lg overflow-hidden block w-full border disabled:cursor-not-allowed disabled:opacity-50",
      sizes: {
        sm: "sm:text-xs",
        md: "text-sm",
        lg: "sm:text-md"
      },
      colors: {
        gray: "bg-gray-50 border-gray-300 text-gray-900 focus:border-cyan-500 focus:ring-cyan-500 dark:border-gray-600 dark:bg-gray-700 dark:text-white dark:placeholder-gray-400 dark:focus:border-cyan-500 dark:focus:ring-cyan-500",
        info: "border-cyan-500 bg-cyan-50 text-cyan-900 placeholder-cyan-700 focus:border-cyan-500 focus:ring-cyan-500 dark:border-cyan-400 dark:bg-cyan-100 dark:focus:border-cyan-500 dark:focus:ring-cyan-500",
        failure: "border-red-500 bg-red-50 text-red-900 placeholder-red-700 focus:border-red-500 focus:ring-red-500 dark:border-red-400 dark:bg-red-100 dark:focus:border-red-500 dark:focus:ring-red-500",
        warning: "border-yellow-500 bg-yellow-50 text-yellow-900 placeholder-yellow-700 focus:border-yellow-500 focus:ring-yellow-500 dark:border-yellow-400 dark:bg-yellow-100 dark:focus:border-yellow-500 dark:focus:ring-yellow-500",
        success: "border-green-500 bg-green-50 text-green-900 placeholder-green-700 focus:border-green-500 focus:ring-green-500 dark:border-green-400 dark:bg-green-100 dark:focus:border-green-500 dark:focus:ring-green-500"
      }
    }
  }
};
const floatingLabelTheme = {
  input: {
    default: {
      filled: {
        sm: "peer block w-full appearance-none rounded-t-lg border-0 border-b-2 border-gray-300 bg-gray-50 px-2.5 pb-2.5 pt-5 text-xs text-gray-900 focus:border-blue-600 focus:outline-none focus:ring-0 dark:border-gray-600 dark:bg-gray-700 dark:text-white dark:focus:border-blue-500",
        md: "peer block w-full appearance-none rounded-t-lg border-0 border-b-2 border-gray-300 bg-gray-50 px-2.5 pb-2.5 pt-5 text-sm text-gray-900 focus:border-blue-600 focus:outline-none focus:ring-0 dark:border-gray-600 dark:bg-gray-700 dark:text-white dark:focus:border-blue-500"
      },
      outlined: {
        sm: "border-1 peer block w-full appearance-none rounded-lg border-gray-300 bg-transparent px-2.5 pb-2.5 pt-4 text-xs text-gray-900 focus:border-blue-600 focus:outline-none focus:ring-0 dark:border-gray-600 dark:text-white dark:focus:border-blue-500",
        md: "border-1 peer block w-full appearance-none rounded-lg border-gray-300 bg-transparent px-2.5 pb-2.5 pt-4 text-sm text-gray-900 focus:border-blue-600 focus:outline-none focus:ring-0 dark:border-gray-600 dark:text-white dark:focus:border-blue-500"
      },
      standard: {
        sm: "block py-2.5 px-0 w-full text-xs text-gray-900 bg-transparent border-0 border-b-2 border-gray-300 appearance-none dark:text-white dark:border-gray-600 dark:focus:border-blue-500 focus:outline-none focus:ring-0 focus:border-blue-600 peer",
        md: "block py-2.5 px-0 w-full text-sm text-gray-900 bg-transparent border-0 border-b-2 border-gray-300 appearance-none dark:text-white dark:border-gray-600 dark:focus:border-blue-500 focus:outline-none focus:ring-0 focus:border-blue-600 peer"
      }
    },
    success: {
      filled: {
        sm: "block rounded-t-lg px-2.5 pb-2.5 pt-5 w-full text-xs text-gray-900 bg-gray-50 dark:bg-gray-700 border-0 border-b-2 border-green-600 dark:border-green-500 appearance-none dark:text-white dark:focus:border-green-500 focus:outline-none focus:ring-0 focus:border-green-600 peer",
        md: "block rounded-t-lg px-2.5 pb-2.5 pt-5 w-full text-sm text-gray-900 bg-gray-50 dark:bg-gray-700 border-0 border-b-2 border-green-600 dark:border-green-500 appearance-none dark:text-white dark:focus:border-green-500 focus:outline-none focus:ring-0 focus:border-green-600 peer"
      },
      outlined: {
        sm: "block px-2.5 pb-2.5 pt-4 w-full text-xs text-gray-900 bg-transparent rounded-lg border-1 border-green-600 appearance-none dark:text-white dark:border-green-500 dark:focus:border-green-500 focus:outline-none focus:ring-0 focus:border-green-600 peer",
        md: "block px-2.5 pb-2.5 pt-4 w-full text-sm text-gray-900 bg-transparent rounded-lg border-1 border-green-600 appearance-none dark:text-white dark:border-green-500 dark:focus:border-green-500 focus:outline-none focus:ring-0 focus:border-green-600 peer"
      },
      standard: {
        sm: "block py-2.5 px-0 w-full text-xs text-gray-900 bg-transparent border-0 border-b-2 border-green-600 appearance-none dark:text-white dark:border-green-500 dark:focus:border-green-500 focus:outline-none focus:ring-0 focus:border-green-600 peer",
        md: "block py-2.5 px-0 w-full text-sm text-gray-900 bg-transparent border-0 border-b-2 border-green-600 appearance-none dark:text-white dark:border-green-500 dark:focus:border-green-500 focus:outline-none focus:ring-0 focus:border-green-600 peer"
      }
    },
    error: {
      filled: {
        sm: "block rounded-t-lg px-2.5 pb-2.5 pt-5 w-full text-xs text-gray-900 bg-gray-50 dark:bg-gray-700 border-0 border-b-2 appearance-none dark:text-white dark:border-red-500 focus:outline-none focus:ring-0 border-red-600 focus:border-red-600 dark:focus-border-red-500 peer",
        md: "block rounded-t-lg px-2.5 pb-2.5 pt-5 w-full text-sm text-gray-900 bg-gray-50 dark:bg-gray-700 border-0 border-b-2 appearance-none dark:text-white dark:border-red-500 focus:outline-none focus:ring-0 border-red-600 focus:border-red-600 dark:focus-border-red-500 peer"
      },
      outlined: {
        sm: "block px-2.5 pb-2.5 pt-4 w-full text-xs text-gray-900 bg-transparent rounded-lg border-1 appearance-none dark:text-white dark:border-red-500 border-red-600 dark:focus:border-red-500 focus:outline-none focus:ring-0 focus:border-red-600 peer",
        md: "block px-2.5 pb-2.5 pt-4 w-full text-sm text-gray-900 bg-transparent rounded-lg border-1 appearance-none dark:text-white dark:border-red-500 border-red-600 dark:focus:border-red-500 focus:outline-none focus:ring-0 focus:border-red-600 peer"
      },
      standard: {
        sm: "block py-2.5 px-0 w-full text-xs text-gray-900 bg-transparent border-0 border-b-2 border-red-600 appearance-none dark:text-white dark:border-red-500 dark:focus:border-red-500 focus:outline-none focus:ring-0 focus:border-red-600 peer",
        md: "block py-2.5 px-0 w-full text-sm text-gray-900 bg-transparent border-0 border-b-2 border-red-600 appearance-none dark:text-white dark:border-red-500 dark:focus:border-red-500 focus:outline-none focus:ring-0 focus:border-red-600 peer"
      }
    }
  },
  label: {
    default: {
      filled: {
        sm: "absolute left-2.5 top-4 z-10 origin-[0] -translate-y-4 scale-75 transition-transform text-xs text-gray-500  duration-300 peer-placeholder-shown:translate-y-0 peer-placeholder-shown:scale-100 peer-focus:-translate-y-4 peer-focus:scale-75 peer-focus:text-blue-600 dark:text-gray-400 peer-focus:dark:text-blue-500",
        md: "absolute left-2.5 top-4 z-10 origin-[0] -translate-y-4 scale-75 transition-transform text-sm text-gray-500 duration-300 peer-placeholder-shown:translate-y-0 peer-placeholder-shown:scale-100 peer-focus:-translate-y-4 peer-focus:scale-75 peer-focus:text-blue-600 dark:text-gray-400 peer-focus:dark:text-blue-500"
      },
      outlined: {
        sm: "absolute left-1 top-2 z-10 origin-[0] -translate-y-4 scale-75 transition-transform bg-white px-2 text-xs text-gray-500 duration-300 peer-placeholder-shown:top-1/2 peer-placeholder-shown:-translate-y-1/2 peer-placeholder-shown:scale-100 peer-focus:top-2 peer-focus:-translate-y-4 peer-focus:scale-75 peer-focus:px-2 peer-focus:text-blue-600 dark:bg-gray-900 dark:text-gray-400 peer-focus:dark:text-blue-500",
        md: "absolute left-1 top-2 z-10 origin-[0] -translate-y-4 scale-75 transition-transform bg-white px-2 text-sm text-gray-500 duration-300 peer-placeholder-shown:top-1/2 peer-placeholder-shown:-translate-y-1/2 peer-placeholder-shown:scale-100 peer-focus:top-2 peer-focus:-translate-y-4 peer-focus:scale-75 peer-focus:px-2 peer-focus:text-blue-600 dark:bg-gray-900 dark:text-gray-400 peer-focus:dark:text-blue-500"
      },
      standard: {
        sm: "absolute text-xs text-gray-500 dark:text-gray-400  transition-transform -translate-y-6 scale-75 top-3 -z-10 origin-[0] duration-300 peer-focus:left-0 peer-focus:text-blue-600 peer-focus:dark:text-blue-500 peer-placeholder-shown:scale-100 peer-placeholder-shown:translate-y-0 peer-focus:scale-75 peer-focus:-translate-y-6",
        md: "absolute text-sm text-gray-500 dark:text-gray-400  transition-transform -translate-y-6 scale-75 top-3 -z-10 origin-[0] duration-300 peer-focus:left-0 peer-focus:text-blue-600 peer-focus:dark:text-blue-500 peer-placeholder-shown:scale-100 peer-placeholder-shown:translate-y-0 peer-focus:scale-75 peer-focus:-translate-y-6"
      }
    },
    success: {
      filled: {
        sm: "absolute left-2.5 top-4 z-10 origin-[0] -translate-y-4 scale-75 transition-transform text-sm text-green-600 duration-300 peer-placeholder-shown:translate-y-0 peer-placeholder-shown:scale-100 peer-focus:-translate-y-4 peer-focus:scale-75 dark:text-green-500",
        md: "absolute left-2.5 top-4 z-10 origin-[0] -translate-y-4 scale-75 transition-transform text-sm text-green-600 duration-300 peer-placeholder-shown:translate-y-0 peer-placeholder-shown:scale-100 peer-focus:-translate-y-4 peer-focus:scale-75 dark:text-green-500"
      },
      outlined: {
        sm: "absolute left-1 top-2 z-10 origin-[0] -translate-y-4 scale-75 transition-transform bg-white px-2 text-sm text-green-600 duration-300 peer-placeholder-shown:top-1/2 peer-placeholder-shown:-translate-y-1/2 peer-placeholder-shown:scale-100 peer-focus:top-2 peer-focus:-translate-y-4 peer-focus:scale-75 peer-focus:px-2 dark:bg-gray-900 dark:text-green-500",
        md: "absolute left-1 top-2 z-10 origin-[0] -translate-y-4 scale-75 transition-transform bg-white px-2 text-sm text-green-600 duration-300 peer-placeholder-shown:top-1/2 peer-placeholder-shown:-translate-y-1/2 peer-placeholder-shown:scale-100 peer-focus:top-2 peer-focus:-translate-y-4 peer-focus:scale-75 peer-focus:px-2 dark:bg-gray-900 dark:text-green-500"
      },
      standard: {
        sm: "absolute text-xs text-green-600 dark:text-green-500  transition-transform -translate-y-6 scale-75 top-3 -z-10 origin-[0] duration-300 peer-focus:left-0 peer-placeholder-shown:scale-100 peer-placeholder-shown:translate-y-0 peer-focus:scale-75 peer-focus:-translate-y-6",
        md: "absolute text-sm text-green-600 dark:text-green-500  transition-transform -translate-y-6 scale-75 top-3 -z-10 origin-[0] duration-300 peer-focus:left-0 peer-placeholder-shown:scale-100 peer-placeholder-shown:translate-y-0 peer-focus:scale-75 peer-focus:-translate-y-6"
      }
    },
    error: {
      filled: {
        sm: "absolute left-2.5 top-4 z-10 origin-[0] -translate-y-4 scale-75 transition-transform text-xs text-red-600 duration-300 peer-placeholder-shown:translate-y-0 peer-placeholder-shown:scale-100 peer-focus:-translate-y-4 peer-focus:scale-75 dark:text-red-500",
        md: "absolute left-2.5 top-4 z-10 origin-[0] -translate-y-4 scale-75 transition-transform text-xs text-red-600 duration-300 peer-placeholder-shown:translate-y-0 peer-placeholder-shown:scale-100 peer-focus:-translate-y-4 peer-focus:scale-75 dark:text-red-500"
      },
      outlined: {
        sm: "absolute left-1 top-2 z-10 origin-[0] -translate-y-4 scale-75 transition-transform bg-white px-2 text-xs text-red-600 duration-300 peer-placeholder-shown:top-1/2 peer-placeholder-shown:-translate-y-1/2 peer-placeholder-shown:scale-100 peer-focus:top-2 peer-focus:-translate-y-4 peer-focus:scale-75 peer-focus:px-2 dark:bg-gray-900 dark:text-red-500",
        md: "absolute left-1 top-2 z-10 origin-[0] -translate-y-4 scale-75 transition-transform bg-white px-2 text-xs text-red-600 duration-300 peer-placeholder-shown:top-1/2 peer-placeholder-shown:-translate-y-1/2 peer-placeholder-shown:scale-100 peer-focus:top-2 peer-focus:-translate-y-4 peer-focus:scale-75 peer-focus:px-2 dark:bg-gray-900 dark:text-red-500"
      },
      standard: {
        sm: "absolute text-xs text-red-600 dark:text-red-500  transition-transform -translate-y-6 scale-75 top-3 -z-10 origin-[0] duration-300 peer-focus:left-0 peer-placeholder-shown:scale-100 peer-placeholder-shown:translate-y-0 peer-focus:scale-75 peer-focus:-translate-y-6",
        md: "absolute text-sm text-red-600 dark:text-red-500  transition-transform -translate-y-6 scale-75 top-3 -z-10 origin-[0] duration-300 peer-focus:left-0 peer-placeholder-shown:scale-100 peer-placeholder-shown:translate-y-0 peer-focus:scale-75 peer-focus:-translate-y-6"
      }
    }
  },
  helperText: {
    default: "mt-2 text-xs text-gray-600 dark:text-gray-400",
    success: "mt-2 text-xs text-green-600 dark:text-green-400",
    error: "mt-2 text-xs text-red-600 dark:text-red-400"
  }
};
const footerTheme = {
  root: {
    base: "w-full rounded-lg bg-white shadow dark:bg-gray-800 md:flex md:items-center md:justify-between",
    container: "w-full p-6",
    bgDark: "bg-gray-800"
  },
  groupLink: {
    base: "flex flex-wrap text-sm text-gray-500 dark:text-white",
    link: {
      base: "last:mr-0 md:mr-6",
      href: "hover:underline"
    },
    col: "flex-col space-y-4"
  },
  icon: {
    base: "text-gray-500 dark:hover:text-white",
    size: "h-5 w-5"
  },
  title: {
    base: "mb-6 text-sm font-semibold uppercase text-gray-500 dark:text-white"
  },
  divider: {
    base: "w-full my-6 border-gray-200 sm:mx-auto dark:border-gray-700 lg:my-8"
  },
  copyright: {
    base: "text-sm text-gray-500 dark:text-gray-400 sm:text-center",
    href: "ml-1 hover:underline",
    span: "ml-1"
  },
  brand: {
    base: "mb-4 flex items-center sm:mb-0",
    img: "mr-3 h-8",
    span: "self-center whitespace-nowrap text-2xl font-semibold text-gray-800 dark:text-white"
  }
};
const helperTextTheme = {
  root: {
    base: "mt-2 text-sm",
    colors: {
      gray: "text-gray-500 dark:text-gray-400",
      info: "text-cyan-700 dark:text-cyan-800",
      success: "text-green-600 dark:text-green-500",
      failure: "text-red-600 dark:text-red-500",
      warning: "text-yellow-500 dark:text-yellow-600"
    }
  }
};
const kbdTheme = {
  root: {
    base: "px-2 py-1.5 mr-1 text-xs font-semibold text-gray-800 bg-gray-100 border border-gray-200 rounded-lg dark:bg-gray-600 dark:text-gray-100 dark:border-gray-500",
    icon: "inline-block"
  }
};
const labelTheme = {
  root: {
    base: "text-sm font-medium",
    disabled: "opacity-50",
    colors: {
      default: "text-gray-900 dark:text-white",
      info: "text-cyan-500 dark:text-cyan-600",
      failure: "text-red-700 dark:text-red-500",
      warning: "text-yellow-500 dark:text-yellow-600",
      success: "text-green-700 dark:text-green-500"
    }
  }
};
const listGroupTheme = {
  root: {
    base: "list-none rounded-lg border border-gray-200 bg-white text-sm font-medium text-gray-900 dark:border-gray-600 dark:bg-gray-700 dark:text-white text-left"
  },
  item: {
    base: "[&>*]:first:rounded-t-lg [&>*]:last:rounded-b-lg [&>*]:last:border-b-0",
    link: {
      base: "flex items-center w-full border-b border-gray-200 py-2 px-4 dark:border-gray-600",
      active: {
        off: "hover:bg-gray-100 hover:text-cyan-700 focus:text-cyan-700 focus:outline-none focus:ring-2 focus:ring-cyan-700 dark:border-gray-600 dark:hover:bg-gray-600 dark:hover:text-white dark:focus:text-white dark:focus:ring-gray-500",
        on: "bg-cyan-700 text-white dark:bg-gray-800"
      },
      href: {
        off: "",
        on: ""
      },
      icon: "mr-2 h-4 w-4 fill-current"
    }
  }
};
const modalTheme = {
  root: {
    base: "fixed top-0 right-0 left-0 z-50 h-modal h-screen overflow-y-auto overflow-x-hidden md:inset-0 md:h-full",
    show: {
      on: "flex bg-gray-900 bg-opacity-50 dark:bg-opacity-80",
      off: "hidden"
    },
    sizes: {
      sm: "max-w-sm",
      md: "max-w-md",
      lg: "max-w-lg",
      xl: "max-w-xl",
      "2xl": "max-w-2xl",
      "3xl": "max-w-3xl",
      "4xl": "max-w-4xl",
      "5xl": "max-w-5xl",
      "6xl": "max-w-6xl",
      "7xl": "max-w-7xl"
    },
    positions: {
      "top-left": "items-start justify-start",
      "top-center": "items-start justify-center",
      "top-right": "items-start justify-end",
      "center-left": "items-center justify-start",
      center: "items-center justify-center",
      "center-right": "items-center justify-end",
      "bottom-right": "items-end justify-end",
      "bottom-center": "items-end justify-center",
      "bottom-left": "items-end justify-start"
    }
  },
  content: {
    base: "relative h-full w-full p-4 md:h-auto",
    inner: "relative rounded-lg bg-white shadow dark:bg-gray-700 flex flex-col max-h-[90vh]"
  },
  body: {
    base: "p-6 flex-1 overflow-auto",
    popup: "pt-0"
  },
  header: {
    base: "flex items-start justify-between rounded-t dark:border-gray-600 border-b p-5",
    popup: "p-2 border-b-0",
    title: "text-xl font-medium text-gray-900 dark:text-white",
    close: {
      base: "ml-auto inline-flex items-center rounded-lg bg-transparent p-1.5 text-sm text-gray-400 hover:bg-gray-200 hover:text-gray-900 dark:hover:bg-gray-600 dark:hover:text-white",
      icon: "h-5 w-5"
    }
  },
  footer: {
    base: "flex items-center space-x-2 rounded-b border-gray-200 p-6 dark:border-gray-600",
    popup: "border-t"
  }
};
const navbarTheme = {
  root: {
    base: "bg-white px-2 py-2.5 dark:border-gray-700 dark:bg-gray-800 sm:px-4",
    rounded: {
      on: "rounded",
      off: ""
    },
    bordered: {
      on: "border",
      off: ""
    },
    inner: {
      base: "mx-auto flex flex-wrap items-center justify-between",
      fluid: {
        on: "",
        off: "container"
      }
    }
  },
  brand: {
    base: "flex items-center"
  },
  collapse: {
    base: "w-full md:block md:w-auto",
    list: "mt-4 flex flex-col md:mt-0 md:flex-row md:space-x-8 md:text-sm md:font-medium",
    hidden: {
      on: "hidden",
      off: ""
    }
  },
  link: {
    base: "block py-2 pr-4 pl-3 md:p-0",
    active: {
      on: "bg-cyan-700 text-white dark:text-white md:bg-transparent md:text-cyan-700",
      off: "border-b border-gray-100  text-gray-700 hover:bg-gray-50 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white md:border-0 md:hover:bg-transparent md:hover:text-cyan-700 md:dark:hover:bg-transparent md:dark:hover:text-white"
    },
    disabled: {
      on: "text-gray-400 hover:cursor-not-allowed dark:text-gray-600",
      off: ""
    }
  },
  toggle: {
    base: "inline-flex items-center rounded-lg p-2 text-sm text-gray-500 hover:bg-gray-100 focus:outline-none focus:ring-2 focus:ring-gray-200 dark:text-gray-400 dark:hover:bg-gray-700 dark:focus:ring-gray-600 md:hidden",
    icon: "h-6 w-6 shrink-0"
  }
};
const paginationTheme = {
  base: "",
  layout: {
    table: {
      base: "text-sm text-gray-700 dark:text-gray-400",
      span: "font-semibold text-gray-900 dark:text-white"
    }
  },
  pages: {
    base: "xs:mt-0 mt-2 inline-flex items-center -space-x-px",
    showIcon: "inline-flex",
    previous: {
      base: "ml-0 rounded-l-lg border border-gray-300 bg-white py-2 px-3 leading-tight text-gray-500 enabled:hover:bg-gray-100 enabled:hover:text-gray-700 dark:border-gray-700 dark:bg-gray-800 dark:text-gray-400 enabled:dark:hover:bg-gray-700 enabled:dark:hover:text-white",
      icon: "h-5 w-5"
    },
    next: {
      base: "rounded-r-lg border border-gray-300 bg-white py-2 px-3 leading-tight text-gray-500 enabled:hover:bg-gray-100 enabled:hover:text-gray-700 dark:border-gray-700 dark:bg-gray-800 dark:text-gray-400 enabled:dark:hover:bg-gray-700 enabled:dark:hover:text-white",
      icon: "h-5 w-5"
    },
    selector: {
      base: "w-12 border border-gray-300 bg-white py-2 leading-tight text-gray-500 enabled:hover:bg-gray-100 enabled:hover:text-gray-700 dark:border-gray-700 dark:bg-gray-800 dark:text-gray-400 enabled:dark:hover:bg-gray-700 enabled:dark:hover:text-white",
      active: "bg-cyan-50 text-cyan-600 hover:bg-cyan-100 hover:text-cyan-700 dark:border-gray-700 dark:bg-gray-700 dark:text-white",
      disabled: "opacity-50 cursor-normal"
    }
  }
};
const progressTheme = {
  base: "w-full overflow-hidden rounded-full bg-gray-200 dark:bg-gray-700",
  label: "mb-1 flex justify-between font-medium dark:text-white",
  bar: "rounded-full text-center font-medium leading-none text-cyan-300 dark:text-cyan-100 space-x-2",
  color: {
    dark: "bg-gray-600 dark:bg-gray-300",
    blue: "bg-cyan-600",
    red: "bg-red-600 dark:bg-red-500",
    green: "bg-green-600 dark:bg-green-500",
    yellow: "bg-yellow-400",
    indigo: "bg-indigo-600 dark:bg-indigo-500",
    purple: "bg-purple-600 dark:bg-purple-500"
  },
  size: {
    sm: "h-1.5",
    md: "h-2.5",
    lg: "h-4",
    xl: "h-6"
  }
};
const radioTheme = {
  root: {
    base: "h-4 w-4 border border-gray-300 focus:ring-2 focus:ring-cyan-500 dark:border-gray-600 dark:bg-gray-700 dark:focus:bg-cyan-600 dark:focus:ring-cyan-600 text-cyan-600"
  }
};
const rangeSliderTheme = {
  root: {
    base: "flex"
  },
  field: {
    base: "relative w-full",
    input: {
      base: "w-full bg-gray-200 rounded-lg appearance-none cursor-pointer dark:bg-gray-700",
      sizes: {
        sm: "h-1 range-sm",
        md: "h-2",
        lg: "h-3 range-lg"
      }
    }
  }
};
const ratingTheme = {
  root: {
    base: "flex items-center"
  },
  advanced: {
    base: "flex items-center",
    label: "text-sm font-medium text-cyan-600 dark:text-cyan-500",
    progress: {
      base: "mx-4 h-5 w-2/4 rounded bg-gray-200 dark:bg-gray-700",
      fill: "h-5 rounded bg-yellow-400",
      label: "text-sm font-medium text-cyan-600 dark:text-cyan-500"
    }
  },
  star: {
    empty: "text-gray-300 dark:text-gray-500",
    filled: "text-yellow-400",
    sizes: {
      sm: "w-5 h-5",
      md: "w-7 h-7",
      lg: "w-10 h-10"
    }
  }
};
const selectTheme = {
  base: "flex",
  addon: "inline-flex items-center rounded-l-md border border-r-0 border-gray-300 bg-gray-200 px-3 text-sm text-gray-900 dark:border-gray-600 dark:bg-gray-600 dark:text-gray-400",
  field: {
    base: "relative w-full",
    icon: {
      base: "pointer-events-none absolute inset-y-0 left-0 flex items-center pl-3",
      svg: "h-5 w-5 text-gray-500 dark:text-gray-400"
    },
    select: {
      base: "block w-full border disabled:cursor-not-allowed disabled:opacity-50",
      withIcon: {
        on: "pl-10",
        off: ""
      },
      withAddon: {
        on: "rounded-r-lg",
        off: "rounded-lg"
      },
      withShadow: {
        on: "shadow-sm dark:shadow-sm-light",
        off: ""
      },
      sizes: {
        sm: "p-2 sm:text-xs",
        md: "p-2.5 text-sm",
        lg: "sm:text-md p-4"
      },
      colors: {
        gray: "bg-gray-50 border-gray-300 text-gray-900 focus:border-cyan-500 focus:ring-cyan-500 dark:border-gray-600 dark:bg-gray-700 dark:text-white dark:placeholder-gray-400 dark:focus:border-cyan-500 dark:focus:ring-cyan-500",
        info: "border-cyan-500 bg-cyan-50 text-cyan-900 placeholder-cyan-700 focus:border-cyan-500 focus:ring-cyan-500 dark:border-cyan-400 dark:bg-cyan-100 dark:focus:border-cyan-500 dark:focus:ring-cyan-500",
        failure: "border-red-500 bg-red-50 text-red-900 placeholder-red-700 focus:border-red-500 focus:ring-red-500 dark:border-red-400 dark:bg-red-100 dark:focus:border-red-500 dark:focus:ring-red-500",
        warning: "border-yellow-500 bg-yellow-50 text-yellow-900 placeholder-yellow-700 focus:border-yellow-500 focus:ring-yellow-500 dark:border-yellow-400 dark:bg-yellow-100 dark:focus:border-yellow-500 dark:focus:ring-yellow-500",
        success: "border-green-500 bg-green-50 text-green-900 placeholder-green-700 focus:border-green-500 focus:ring-green-500 dark:border-green-400 dark:bg-green-100 dark:focus:border-green-500 dark:focus:ring-green-500"
      }
    }
  }
};
const sidebarTheme = {
  root: {
    base: "h-full",
    collapsed: {
      on: "w-16",
      off: "w-64"
    },
    inner: "h-full overflow-y-auto overflow-x-hidden rounded bg-gray-50 py-4 px-3 dark:bg-gray-800"
  },
  collapse: {
    button: "group flex w-full items-center rounded-lg p-2 text-base font-normal text-gray-900 transition duration-75 hover:bg-gray-100 dark:text-white dark:hover:bg-gray-700",
    icon: {
      base: "h-6 w-6 text-gray-500 transition duration-75 group-hover:text-gray-900 dark:text-gray-400 dark:group-hover:text-white",
      open: {
        off: "",
        on: "text-gray-900"
      }
    },
    label: {
      base: "ml-3 flex-1 whitespace-nowrap text-left",
      icon: {
        base: "h-6 w-6 transition ease-in-out delay-0",
        open: {
          on: "rotate-180",
          off: ""
        }
      }
    },
    list: "space-y-2 py-2"
  },
  cta: {
    base: "mt-6 rounded-lg p-4 bg-gray-100 dark:bg-gray-700",
    color: {
      blue: "bg-cyan-50 dark:bg-cyan-900",
      dark: "bg-dark-50 dark:bg-dark-900",
      failure: "bg-red-50 dark:bg-red-900",
      gray: "bg-alternative-50 dark:bg-alternative-900",
      green: "bg-green-50 dark:bg-green-900",
      light: "bg-light-50 dark:bg-light-900",
      red: "bg-red-50 dark:bg-red-900",
      purple: "bg-purple-50 dark:bg-purple-900",
      success: "bg-green-50 dark:bg-green-900",
      yellow: "bg-yellow-50 dark:bg-yellow-900",
      warning: "bg-yellow-50 dark:bg-yellow-900"
    }
  },
  item: {
    base: "flex items-center justify-center rounded-lg p-2 text-base font-normal text-gray-900 hover:bg-gray-100 dark:text-white dark:hover:bg-gray-700",
    active: "bg-gray-100 dark:bg-gray-700",
    collapsed: {
      insideCollapse: "group w-full pl-8 transition duration-75",
      noIcon: "font-bold"
    },
    content: {
      base: "px-3 flex-1 whitespace-nowrap"
    },
    icon: {
      base: "h-6 w-6 flex-shrink-0 text-gray-500 transition duration-75 group-hover:text-gray-900 dark:text-gray-400 dark:group-hover:text-white",
      active: "text-gray-700 dark:text-gray-100"
    },
    label: "",
    listItem: ""
  },
  items: "",
  itemGroup: "mt-4 space-y-2 border-t border-gray-200 pt-4 first:mt-0 first:border-t-0 first:pt-0 dark:border-gray-700",
  logo: {
    base: "mb-5 flex items-center pl-2.5",
    collapsed: {
      on: "hidden",
      off: "self-center whitespace-nowrap text-xl font-semibold dark:text-white"
    },
    img: "mr-3 h-6 sm:h-7"
  }
};
const spinnerTheme = {
  base: "inline animate-spin text-gray-200",
  color: {
    failure: "fill-red-600",
    gray: "fill-gray-600",
    info: "fill-cyan-600",
    pink: "fill-pink-600",
    purple: "fill-purple-600",
    success: "fill-green-500",
    warning: "fill-yellow-400"
  },
  light: {
    off: {
      base: "dark:text-gray-600",
      color: {
        failure: "",
        gray: "dark:fill-gray-300",
        info: "",
        pink: "",
        purple: "",
        success: "",
        warning: ""
      }
    },
    on: {
      base: "",
      color: {
        failure: "",
        gray: "",
        info: "",
        pink: "",
        purple: "",
        success: "",
        warning: ""
      }
    }
  },
  size: {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-6 h-6",
    lg: "w-8 h-8",
    xl: "w-10 h-10"
  }
};
const tabTheme = {
  base: "flex flex-col gap-2",
  tablist: {
    base: "flex text-center",
    styles: {
      default: "flex-wrap border-b border-gray-200 dark:border-gray-700",
      underline: "flex-wrap -mb-px border-b border-gray-200 dark:border-gray-700",
      pills: "flex-wrap font-medium text-sm text-gray-500 dark:text-gray-400 space-x-2",
      fullWidth: "w-full text-sm font-medium divide-x divide-gray-200 shadow grid grid-flow-col dark:divide-gray-700 dark:text-gray-400 rounded-none"
    },
    tabitem: {
      base: "flex items-center justify-center p-4 rounded-t-lg text-sm font-medium first:ml-0 disabled:cursor-not-allowed disabled:text-gray-400 disabled:dark:text-gray-500 focus:ring-4 focus:ring-cyan-300 focus:outline-none",
      styles: {
        default: {
          base: "rounded-t-lg",
          active: {
            on: "bg-gray-100 text-cyan-600 dark:bg-gray-800 dark:text-cyan-500",
            off: "text-gray-500 hover:bg-gray-50 hover:text-gray-600 dark:text-gray-400 dark:hover:bg-gray-800  dark:hover:text-gray-300"
          }
        },
        underline: {
          base: "rounded-t-lg",
          active: {
            on: "text-cyan-600 rounded-t-lg border-b-2 border-cyan-600 active dark:text-cyan-500 dark:border-cyan-500",
            off: "border-b-2 border-transparent text-gray-500 hover:border-gray-300 hover:text-gray-600 dark:text-gray-400 dark:hover:text-gray-300"
          }
        },
        pills: {
          base: "",
          active: {
            on: "rounded-lg bg-cyan-600 text-white",
            off: "rounded-lg hover:text-gray-900 hover:bg-gray-100 dark:hover:bg-gray-800 dark:hover:text-white"
          }
        },
        fullWidth: {
          base: "ml-0 first:ml-0 w-full rounded-none flex",
          active: {
            on: "p-4 text-gray-900 bg-gray-100 active dark:bg-gray-700 dark:text-white rounded-none",
            off: "bg-white hover:text-gray-700 hover:bg-gray-50 dark:hover:text-white dark:bg-gray-800 dark:hover:bg-gray-700 rounded-none"
          }
        }
      },
      icon: "mr-2 h-5 w-5"
    }
  },
  tabitemcontainer: {
    base: "",
    styles: {
      default: "",
      underline: "",
      pills: "",
      fullWidth: ""
    }
  },
  tabpanel: "py-3"
};
const tableTheme = {
  root: {
    base: "w-full text-left text-sm text-gray-500 dark:text-gray-400",
    shadow: "absolute bg-white dark:bg-black w-full h-full top-0 left-0 rounded-lg drop-shadow-md -z-10",
    wrapper: "relative"
  },
  body: {
    base: "group/body",
    cell: {
      base: "group-first/body:group-first/row:first:rounded-tl-lg group-first/body:group-first/row:last:rounded-tr-lg group-last/body:group-last/row:first:rounded-bl-lg group-last/body:group-last/row:last:rounded-br-lg px-6 py-4"
    }
  },
  head: {
    base: "group/head text-xs uppercase text-gray-700 dark:text-gray-400",
    cell: {
      base: "group-first/head:first:rounded-tl-lg group-first/head:last:rounded-tr-lg bg-gray-50 dark:bg-gray-700 px-6 py-3"
    }
  },
  row: {
    base: "group/row",
    hovered: "hover:bg-gray-50 dark:hover:bg-gray-600",
    striped: "odd:bg-white even:bg-gray-50 odd:dark:bg-gray-800 even:dark:bg-gray-700"
  }
};
const textInputTheme = {
  base: "flex",
  addon: "inline-flex items-center rounded-l-md border border-r-0 border-gray-300 bg-gray-200 px-3 text-sm text-gray-900 dark:border-gray-600 dark:bg-gray-600 dark:text-gray-400",
  field: {
    base: "relative w-full",
    icon: {
      base: "pointer-events-none absolute inset-y-0 left-0 flex items-center pl-3",
      svg: "h-5 w-5 text-gray-500 dark:text-gray-400"
    },
    rightIcon: {
      base: "pointer-events-none absolute inset-y-0 right-0 flex items-center pr-3",
      svg: "h-5 w-5 text-gray-500 dark:text-gray-400"
    },
    input: {
      base: "block w-full border disabled:cursor-not-allowed disabled:opacity-50",
      sizes: {
        sm: "p-2 sm:text-xs",
        md: "p-2.5 text-sm",
        lg: "sm:text-md p-4"
      },
      colors: {
        gray: "bg-gray-50 border-gray-300 text-gray-900 focus:border-cyan-500 focus:ring-cyan-500 dark:border-gray-600 dark:bg-gray-700 dark:text-white dark:placeholder-gray-400 dark:focus:border-cyan-500 dark:focus:ring-cyan-500",
        info: "border-cyan-500 bg-cyan-50 text-cyan-900 placeholder-cyan-700 focus:border-cyan-500 focus:ring-cyan-500 dark:border-cyan-400 dark:bg-cyan-100 dark:focus:border-cyan-500 dark:focus:ring-cyan-500",
        failure: "border-red-500 bg-red-50 text-red-900 placeholder-red-700 focus:border-red-500 focus:ring-red-500 dark:border-red-400 dark:bg-red-100 dark:focus:border-red-500 dark:focus:ring-red-500",
        warning: "border-yellow-500 bg-yellow-50 text-yellow-900 placeholder-yellow-700 focus:border-yellow-500 focus:ring-yellow-500 dark:border-yellow-400 dark:bg-yellow-100 dark:focus:border-yellow-500 dark:focus:ring-yellow-500",
        success: "border-green-500 bg-green-50 text-green-900 placeholder-green-700 focus:border-green-500 focus:ring-green-500 dark:border-green-400 dark:bg-green-100 dark:focus:border-green-500 dark:focus:ring-green-500"
      },
      withRightIcon: {
        on: "pr-10",
        off: ""
      },
      withIcon: {
        on: "pl-10",
        off: ""
      },
      withAddon: {
        on: "rounded-r-lg",
        off: "rounded-lg"
      },
      withShadow: {
        on: "shadow-sm dark:shadow-sm-light",
        off: ""
      }
    }
  }
};
const textareaTheme = {
  base: "block w-full rounded-lg border disabled:cursor-not-allowed disabled:opacity-50 text-sm",
  colors: {
    gray: "bg-gray-50 border-gray-300 text-gray-900 focus:border-cyan-500 focus:ring-cyan-500 dark:border-gray-600 dark:bg-gray-700 dark:text-white dark:placeholder-gray-400 dark:focus:border-cyan-500 dark:focus:ring-cyan-500",
    info: "border-cyan-500 bg-cyan-50 text-cyan-900 placeholder-cyan-700 focus:border-cyan-500 focus:ring-cyan-500 dark:border-cyan-400 dark:bg-cyan-100 dark:focus:border-cyan-500 dark:focus:ring-cyan-500",
    failure: "border-red-500 bg-red-50 text-red-900 placeholder-red-700 focus:border-red-500 focus:ring-red-500 dark:border-red-400 dark:bg-red-100 dark:focus:border-red-500 dark:focus:ring-red-500",
    warning: "border-yellow-500 bg-yellow-50 text-yellow-900 placeholder-yellow-700 focus:border-yellow-500 focus:ring-yellow-500 dark:border-yellow-400 dark:bg-yellow-100 dark:focus:border-yellow-500 dark:focus:ring-yellow-500",
    success: "border-green-500 bg-green-50 text-green-900 placeholder-green-700 focus:border-green-500 focus:ring-green-500 dark:border-green-400 dark:bg-green-100 dark:focus:border-green-500 dark:focus:ring-green-500"
  },
  withShadow: {
    on: "shadow-sm dark:shadow-sm-light",
    off: ""
  }
};
const timelineTheme = {
  root: {
    direction: {
      horizontal: "items-base sm:flex",
      vertical: "relative border-l border-gray-200 dark:border-gray-700"
    }
  },
  item: {
    root: {
      horizontal: "relative mb-6 sm:mb-0",
      vertical: "mb-10 ml-6"
    },
    content: {
      root: {
        base: "mt-3 sm:pr-8"
      },
      body: "mb-4 text-base font-normal text-gray-500 dark:text-gray-400",
      time: "mb-1 text-sm font-normal leading-none text-gray-400 dark:text-gray-500",
      title: "text-lg font-semibold text-gray-900 dark:text-white"
    },
    point: {
      horizontal: "flex items-center",
      line: "hidden h-0.5 w-full bg-gray-200 dark:bg-gray-700 sm:flex",
      marker: {
        base: {
          horizontal: "absolute -left-1.5 h-3 w-3 rounded-full border border-white bg-gray-200 dark:border-gray-900 dark:bg-gray-700",
          vertical: "absolute -left-1.5 mt-1.5 h-3 w-3 rounded-full border border-white bg-gray-200 dark:border-gray-900 dark:bg-gray-700"
        },
        icon: {
          base: "h-3 w-3 text-cyan-600 dark:text-cyan-300",
          wrapper: "absolute -left-3 flex h-6 w-6 items-center justify-center rounded-full bg-cyan-200 ring-8 ring-white dark:bg-cyan-900 dark:ring-gray-900"
        }
      },
      vertical: ""
    }
  }
};
const toastTheme = {
  root: {
    base: "flex w-full max-w-xs items-center rounded-lg bg-white p-4 text-gray-500 shadow dark:bg-gray-800 dark:text-gray-400",
    closed: "opacity-0 ease-out"
  },
  toggle: {
    base: "-mx-1.5 -my-1.5 ml-auto inline-flex h-8 w-8 rounded-lg bg-white p-1.5 text-gray-400 hover:bg-gray-100 hover:text-gray-900 focus:ring-2 focus:ring-gray-300 dark:bg-gray-800 dark:text-gray-500 dark:hover:bg-gray-700 dark:hover:text-white",
    icon: "h-5 w-5 shrink-0"
  }
};
const toggleSwitchTheme = {
  root: {
    base: "group relative flex items-center rounded-lg focus:outline-none",
    active: {
      on: "cursor-pointer",
      off: "cursor-not-allowed opacity-50"
    },
    label: "ml-3 text-sm font-medium text-gray-900 dark:text-gray-300"
  },
  toggle: {
    base: "toggle-bg rounded-full border group-focus:ring-4 group-focus:ring-cyan-500/25",
    checked: {
      on: "after:translate-x-full after:border-white",
      off: "border-gray-200 bg-gray-200 dark:border-gray-600 dark:bg-gray-700",
      color: {
        blue: " bg-cyan-700 border-cyan-700",
        dark: "bg-dark-700 border-dark-900",
        failure: "bg-red-700 border-red-900",
        gray: "bg-gray-500 border-gray-600",
        green: "bg-green-600 border-green-700",
        light: "bg-light-700 border-light-900",
        red: "bg-red-700 border-red-900",
        purple: "bg-purple-700 border-purple-900",
        success: "bg-green-500 border-green-500",
        yellow: "bg-yellow-400 border-yellow-400",
        warning: "bg-yellow-600 border-yellow-600",
        cyan: "bg-cyan-500 border-cyan-500",
        lime: "bg-lime-400 border-lime-400",
        indigo: "bg-indigo-400 border-indigo-400",
        teal: "bg-gradient-to-r from-teal-400 via-teal-500 to-teal-600 hover:bg-gradient-to-br focus:ring-4",
        info: "bg-cyan-600 border-cyan-600",
        pink: "bg-pink-600 border-pink-600"
      }
    },
    sizes: {
      sm: "w-9 h-5 after:absolute after:top-[2px] after:left-[2px] after:h-4 after:w-4",
      md: "w-11 h-6 after:absolute after:top-[2px] after:left-[2px] after:h-5 after:w-5",
      lg: "w-14 h-7 after:absolute after:top-0.5 after:left-[4px] after:h-6 after:w-6"
    }
  }
};
const tooltipTheme = {
  target: "w-fit",
  animation: "transition-opacity",
  arrow: {
    base: "absolute z-10 h-2 w-2 rotate-45",
    style: {
      dark: "bg-gray-900 dark:bg-gray-700",
      light: "bg-white",
      auto: "bg-white dark:bg-gray-700"
    },
    placement: "-4px"
  },
  base: "absolute inline-block z-10 rounded-lg py-2 px-3 text-sm font-medium shadow-sm",
  hidden: "invisible opacity-0",
  style: {
    dark: "bg-gray-900 text-white dark:bg-gray-700",
    light: "border border-gray-200 bg-white text-gray-900",
    auto: "border border-gray-200 bg-white text-gray-900 dark:border-none dark:bg-gray-700 dark:text-white"
  },
  content: "relative z-20"
};
const theme = {
  accordion: accordionTheme,
  alert: alertTheme,
  avatar: avatarTheme,
  badge: badgeTheme,
  blockquote: blockquoteTheme,
  breadcrumb: breadcrumbTheme,
  button: buttonTheme,
  buttonGroup: buttonGroupTheme,
  card: cardTheme,
  carousel: carouselTheme,
  checkbox: checkboxTheme,
  datepicker: datePickerTheme,
  darkThemeToggle: darkThemeToggleTheme,
  dropdown: dropdownTheme,
  fileInput: fileInputTheme,
  floatingLabel: floatingLabelTheme,
  footer: footerTheme,
  helperText: helperTextTheme,
  kbd: kbdTheme,
  label: labelTheme,
  listGroup: listGroupTheme,
  modal: modalTheme,
  navbar: navbarTheme,
  pagination: paginationTheme,
  progress: progressTheme,
  radio: radioTheme,
  rangeSlider: rangeSliderTheme,
  rating: ratingTheme,
  select: selectTheme,
  textInput: textInputTheme,
  textarea: textareaTheme,
  toggleSwitch: toggleSwitchTheme,
  sidebar: sidebarTheme,
  spinner: spinnerTheme,
  tab: tabTheme,
  table: tableTheme,
  timeline: timelineTheme,
  toast: toastTheme,
  tooltip: tooltipTheme
};
const ThemeContext = reactExports.createContext({
  theme
});
const useTheme = () => {
  const context = reactExports.useContext(ThemeContext);
  if (!context) {
    throw new Error("useTheme should be used within the ThemeContext provider!");
  }
  return context;
};
const sides = ["top", "right", "bottom", "left"];
const alignments = ["start", "end"];
const placements = /* @__PURE__ */ sides.reduce((acc, side) => acc.concat(side, side + "-" + alignments[0], side + "-" + alignments[1]), []);
const min = Math.min;
const max = Math.max;
const round = Math.round;
const floor = Math.floor;
const createCoords = (v2) => ({
  x: v2,
  y: v2
});
const oppositeSideMap = {
  left: "right",
  right: "left",
  bottom: "top",
  top: "bottom"
};
const oppositeAlignmentMap = {
  start: "end",
  end: "start"
};
function clamp(start, value, end2) {
  return max(start, min(value, end2));
}
function evaluate(value, param) {
  return typeof value === "function" ? value(param) : value;
}
function getSide(placement) {
  return placement.split("-")[0];
}
function getAlignment(placement) {
  return placement.split("-")[1];
}
function getOppositeAxis(axis) {
  return axis === "x" ? "y" : "x";
}
function getAxisLength(axis) {
  return axis === "y" ? "height" : "width";
}
function getSideAxis(placement) {
  return ["top", "bottom"].includes(getSide(placement)) ? "y" : "x";
}
function getAlignmentAxis(placement) {
  return getOppositeAxis(getSideAxis(placement));
}
function getAlignmentSides(placement, rects, rtl) {
  if (rtl === void 0) {
    rtl = false;
  }
  const alignment = getAlignment(placement);
  const alignmentAxis = getAlignmentAxis(placement);
  const length = getAxisLength(alignmentAxis);
  let mainAlignmentSide = alignmentAxis === "x" ? alignment === (rtl ? "end" : "start") ? "right" : "left" : alignment === "start" ? "bottom" : "top";
  if (rects.reference[length] > rects.floating[length]) {
    mainAlignmentSide = getOppositePlacement(mainAlignmentSide);
  }
  return [mainAlignmentSide, getOppositePlacement(mainAlignmentSide)];
}
function getExpandedPlacements(placement) {
  const oppositePlacement = getOppositePlacement(placement);
  return [getOppositeAlignmentPlacement(placement), oppositePlacement, getOppositeAlignmentPlacement(oppositePlacement)];
}
function getOppositeAlignmentPlacement(placement) {
  return placement.replace(/start|end/g, (alignment) => oppositeAlignmentMap[alignment]);
}
function getSideList(side, isStart, rtl) {
  const lr2 = ["left", "right"];
  const rl2 = ["right", "left"];
  const tb2 = ["top", "bottom"];
  const bt2 = ["bottom", "top"];
  switch (side) {
    case "top":
    case "bottom":
      if (rtl)
        return isStart ? rl2 : lr2;
      return isStart ? lr2 : rl2;
    case "left":
    case "right":
      return isStart ? tb2 : bt2;
    default:
      return [];
  }
}
function getOppositeAxisPlacements(placement, flipAlignment, direction, rtl) {
  const alignment = getAlignment(placement);
  let list = getSideList(getSide(placement), direction === "start", rtl);
  if (alignment) {
    list = list.map((side) => side + "-" + alignment);
    if (flipAlignment) {
      list = list.concat(list.map(getOppositeAlignmentPlacement));
    }
  }
  return list;
}
function getOppositePlacement(placement) {
  return placement.replace(/left|right|bottom|top/g, (side) => oppositeSideMap[side]);
}
function expandPaddingObject(padding) {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0,
    ...padding
  };
}
function getPaddingObject(padding) {
  return typeof padding !== "number" ? expandPaddingObject(padding) : {
    top: padding,
    right: padding,
    bottom: padding,
    left: padding
  };
}
function rectToClientRect(rect) {
  const {
    x,
    y: y2,
    width,
    height
  } = rect;
  return {
    width,
    height,
    top: y2,
    left: x,
    right: x + width,
    bottom: y2 + height,
    x,
    y: y2
  };
}
function computeCoordsFromPlacement(_ref, placement, rtl) {
  let {
    reference,
    floating
  } = _ref;
  const sideAxis = getSideAxis(placement);
  const alignmentAxis = getAlignmentAxis(placement);
  const alignLength = getAxisLength(alignmentAxis);
  const side = getSide(placement);
  const isVertical = sideAxis === "y";
  const commonX = reference.x + reference.width / 2 - floating.width / 2;
  const commonY = reference.y + reference.height / 2 - floating.height / 2;
  const commonAlign = reference[alignLength] / 2 - floating[alignLength] / 2;
  let coords;
  switch (side) {
    case "top":
      coords = {
        x: commonX,
        y: reference.y - floating.height
      };
      break;
    case "bottom":
      coords = {
        x: commonX,
        y: reference.y + reference.height
      };
      break;
    case "right":
      coords = {
        x: reference.x + reference.width,
        y: commonY
      };
      break;
    case "left":
      coords = {
        x: reference.x - floating.width,
        y: commonY
      };
      break;
    default:
      coords = {
        x: reference.x,
        y: reference.y
      };
  }
  switch (getAlignment(placement)) {
    case "start":
      coords[alignmentAxis] -= commonAlign * (rtl && isVertical ? -1 : 1);
      break;
    case "end":
      coords[alignmentAxis] += commonAlign * (rtl && isVertical ? -1 : 1);
      break;
  }
  return coords;
}
const computePosition$1 = async (reference, floating, config2) => {
  const {
    placement = "bottom",
    strategy = "absolute",
    middleware = [],
    platform: platform2
  } = config2;
  const validMiddleware = middleware.filter(Boolean);
  const rtl = await (platform2.isRTL == null ? void 0 : platform2.isRTL(floating));
  let rects = await platform2.getElementRects({
    reference,
    floating,
    strategy
  });
  let {
    x,
    y: y2
  } = computeCoordsFromPlacement(rects, placement, rtl);
  let statefulPlacement = placement;
  let middlewareData = {};
  let resetCount = 0;
  for (let i2 = 0; i2 < validMiddleware.length; i2++) {
    const {
      name,
      fn: fn2
    } = validMiddleware[i2];
    const {
      x: nextX,
      y: nextY,
      data,
      reset
    } = await fn2({
      x,
      y: y2,
      initialPlacement: placement,
      placement: statefulPlacement,
      strategy,
      middlewareData,
      rects,
      platform: platform2,
      elements: {
        reference,
        floating
      }
    });
    x = nextX != null ? nextX : x;
    y2 = nextY != null ? nextY : y2;
    middlewareData = {
      ...middlewareData,
      [name]: {
        ...middlewareData[name],
        ...data
      }
    };
    if (reset && resetCount <= 50) {
      resetCount++;
      if (typeof reset === "object") {
        if (reset.placement) {
          statefulPlacement = reset.placement;
        }
        if (reset.rects) {
          rects = reset.rects === true ? await platform2.getElementRects({
            reference,
            floating,
            strategy
          }) : reset.rects;
        }
        ({
          x,
          y: y2
        } = computeCoordsFromPlacement(rects, statefulPlacement, rtl));
      }
      i2 = -1;
    }
  }
  return {
    x,
    y: y2,
    placement: statefulPlacement,
    strategy,
    middlewareData
  };
};
async function detectOverflow(state, options) {
  var _await$platform$isEle;
  if (options === void 0) {
    options = {};
  }
  const {
    x,
    y: y2,
    platform: platform2,
    rects,
    elements,
    strategy
  } = state;
  const {
    boundary = "clippingAncestors",
    rootBoundary = "viewport",
    elementContext = "floating",
    altBoundary = false,
    padding = 0
  } = evaluate(options, state);
  const paddingObject = getPaddingObject(padding);
  const altContext = elementContext === "floating" ? "reference" : "floating";
  const element = elements[altBoundary ? altContext : elementContext];
  const clippingClientRect = rectToClientRect(await platform2.getClippingRect({
    element: ((_await$platform$isEle = await (platform2.isElement == null ? void 0 : platform2.isElement(element))) != null ? _await$platform$isEle : true) ? element : element.contextElement || await (platform2.getDocumentElement == null ? void 0 : platform2.getDocumentElement(elements.floating)),
    boundary,
    rootBoundary,
    strategy
  }));
  const rect = elementContext === "floating" ? {
    x,
    y: y2,
    width: rects.floating.width,
    height: rects.floating.height
  } : rects.reference;
  const offsetParent = await (platform2.getOffsetParent == null ? void 0 : platform2.getOffsetParent(elements.floating));
  const offsetScale = await (platform2.isElement == null ? void 0 : platform2.isElement(offsetParent)) ? await (platform2.getScale == null ? void 0 : platform2.getScale(offsetParent)) || {
    x: 1,
    y: 1
  } : {
    x: 1,
    y: 1
  };
  const elementClientRect = rectToClientRect(platform2.convertOffsetParentRelativeRectToViewportRelativeRect ? await platform2.convertOffsetParentRelativeRectToViewportRelativeRect({
    elements,
    rect,
    offsetParent,
    strategy
  }) : rect);
  return {
    top: (clippingClientRect.top - elementClientRect.top + paddingObject.top) / offsetScale.y,
    bottom: (elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom) / offsetScale.y,
    left: (clippingClientRect.left - elementClientRect.left + paddingObject.left) / offsetScale.x,
    right: (elementClientRect.right - clippingClientRect.right + paddingObject.right) / offsetScale.x
  };
}
const arrow$2 = (options) => ({
  name: "arrow",
  options,
  async fn(state) {
    const {
      x,
      y: y2,
      placement,
      rects,
      platform: platform2,
      elements,
      middlewareData
    } = state;
    const {
      element,
      padding = 0
    } = evaluate(options, state) || {};
    if (element == null) {
      return {};
    }
    const paddingObject = getPaddingObject(padding);
    const coords = {
      x,
      y: y2
    };
    const axis = getAlignmentAxis(placement);
    const length = getAxisLength(axis);
    const arrowDimensions = await platform2.getDimensions(element);
    const isYAxis = axis === "y";
    const minProp = isYAxis ? "top" : "left";
    const maxProp = isYAxis ? "bottom" : "right";
    const clientProp = isYAxis ? "clientHeight" : "clientWidth";
    const endDiff = rects.reference[length] + rects.reference[axis] - coords[axis] - rects.floating[length];
    const startDiff = coords[axis] - rects.reference[axis];
    const arrowOffsetParent = await (platform2.getOffsetParent == null ? void 0 : platform2.getOffsetParent(element));
    let clientSize = arrowOffsetParent ? arrowOffsetParent[clientProp] : 0;
    if (!clientSize || !await (platform2.isElement == null ? void 0 : platform2.isElement(arrowOffsetParent))) {
      clientSize = elements.floating[clientProp] || rects.floating[length];
    }
    const centerToReference = endDiff / 2 - startDiff / 2;
    const largestPossiblePadding = clientSize / 2 - arrowDimensions[length] / 2 - 1;
    const minPadding = min(paddingObject[minProp], largestPossiblePadding);
    const maxPadding = min(paddingObject[maxProp], largestPossiblePadding);
    const min$1 = minPadding;
    const max2 = clientSize - arrowDimensions[length] - maxPadding;
    const center = clientSize / 2 - arrowDimensions[length] / 2 + centerToReference;
    const offset3 = clamp(min$1, center, max2);
    const shouldAddOffset = !middlewareData.arrow && getAlignment(placement) != null && center !== offset3 && rects.reference[length] / 2 - (center < min$1 ? minPadding : maxPadding) - arrowDimensions[length] / 2 < 0;
    const alignmentOffset = shouldAddOffset ? center < min$1 ? center - min$1 : center - max2 : 0;
    return {
      [axis]: coords[axis] + alignmentOffset,
      data: {
        [axis]: offset3,
        centerOffset: center - offset3 - alignmentOffset,
        ...shouldAddOffset && {
          alignmentOffset
        }
      },
      reset: shouldAddOffset
    };
  }
});
function getPlacementList(alignment, autoAlignment, allowedPlacements) {
  const allowedPlacementsSortedByAlignment = alignment ? [...allowedPlacements.filter((placement) => getAlignment(placement) === alignment), ...allowedPlacements.filter((placement) => getAlignment(placement) !== alignment)] : allowedPlacements.filter((placement) => getSide(placement) === placement);
  return allowedPlacementsSortedByAlignment.filter((placement) => {
    if (alignment) {
      return getAlignment(placement) === alignment || (autoAlignment ? getOppositeAlignmentPlacement(placement) !== placement : false);
    }
    return true;
  });
}
const autoPlacement$1 = function(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: "autoPlacement",
    options,
    async fn(state) {
      var _middlewareData$autoP, _middlewareData$autoP2, _placementsThatFitOnE;
      const {
        rects,
        middlewareData,
        placement,
        platform: platform2,
        elements
      } = state;
      const {
        crossAxis = false,
        alignment,
        allowedPlacements = placements,
        autoAlignment = true,
        ...detectOverflowOptions
      } = evaluate(options, state);
      const placements$1 = alignment !== void 0 || allowedPlacements === placements ? getPlacementList(alignment || null, autoAlignment, allowedPlacements) : allowedPlacements;
      const overflow = await detectOverflow(state, detectOverflowOptions);
      const currentIndex = ((_middlewareData$autoP = middlewareData.autoPlacement) == null ? void 0 : _middlewareData$autoP.index) || 0;
      const currentPlacement = placements$1[currentIndex];
      if (currentPlacement == null) {
        return {};
      }
      const alignmentSides = getAlignmentSides(currentPlacement, rects, await (platform2.isRTL == null ? void 0 : platform2.isRTL(elements.floating)));
      if (placement !== currentPlacement) {
        return {
          reset: {
            placement: placements$1[0]
          }
        };
      }
      const currentOverflows = [overflow[getSide(currentPlacement)], overflow[alignmentSides[0]], overflow[alignmentSides[1]]];
      const allOverflows = [...((_middlewareData$autoP2 = middlewareData.autoPlacement) == null ? void 0 : _middlewareData$autoP2.overflows) || [], {
        placement: currentPlacement,
        overflows: currentOverflows
      }];
      const nextPlacement = placements$1[currentIndex + 1];
      if (nextPlacement) {
        return {
          data: {
            index: currentIndex + 1,
            overflows: allOverflows
          },
          reset: {
            placement: nextPlacement
          }
        };
      }
      const placementsSortedByMostSpace = allOverflows.map((d2) => {
        const alignment2 = getAlignment(d2.placement);
        return [d2.placement, alignment2 && crossAxis ? (
          // Check along the mainAxis and main crossAxis side.
          d2.overflows.slice(0, 2).reduce((acc, v2) => acc + v2, 0)
        ) : (
          // Check only the mainAxis.
          d2.overflows[0]
        ), d2.overflows];
      }).sort((a2, b2) => a2[1] - b2[1]);
      const placementsThatFitOnEachSide = placementsSortedByMostSpace.filter((d2) => d2[2].slice(
        0,
        // Aligned placements should not check their opposite crossAxis
        // side.
        getAlignment(d2[0]) ? 2 : 3
      ).every((v2) => v2 <= 0));
      const resetPlacement = ((_placementsThatFitOnE = placementsThatFitOnEachSide[0]) == null ? void 0 : _placementsThatFitOnE[0]) || placementsSortedByMostSpace[0][0];
      if (resetPlacement !== placement) {
        return {
          data: {
            index: currentIndex + 1,
            overflows: allOverflows
          },
          reset: {
            placement: resetPlacement
          }
        };
      }
      return {};
    }
  };
};
const flip$1 = function(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: "flip",
    options,
    async fn(state) {
      var _middlewareData$arrow, _middlewareData$flip;
      const {
        placement,
        middlewareData,
        rects,
        initialPlacement,
        platform: platform2,
        elements
      } = state;
      const {
        mainAxis: checkMainAxis = true,
        crossAxis: checkCrossAxis = true,
        fallbackPlacements: specifiedFallbackPlacements,
        fallbackStrategy = "bestFit",
        fallbackAxisSideDirection = "none",
        flipAlignment = true,
        ...detectOverflowOptions
      } = evaluate(options, state);
      if ((_middlewareData$arrow = middlewareData.arrow) != null && _middlewareData$arrow.alignmentOffset) {
        return {};
      }
      const side = getSide(placement);
      const initialSideAxis = getSideAxis(initialPlacement);
      const isBasePlacement = getSide(initialPlacement) === initialPlacement;
      const rtl = await (platform2.isRTL == null ? void 0 : platform2.isRTL(elements.floating));
      const fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipAlignment ? [getOppositePlacement(initialPlacement)] : getExpandedPlacements(initialPlacement));
      const hasFallbackAxisSideDirection = fallbackAxisSideDirection !== "none";
      if (!specifiedFallbackPlacements && hasFallbackAxisSideDirection) {
        fallbackPlacements.push(...getOppositeAxisPlacements(initialPlacement, flipAlignment, fallbackAxisSideDirection, rtl));
      }
      const placements2 = [initialPlacement, ...fallbackPlacements];
      const overflow = await detectOverflow(state, detectOverflowOptions);
      const overflows = [];
      let overflowsData = ((_middlewareData$flip = middlewareData.flip) == null ? void 0 : _middlewareData$flip.overflows) || [];
      if (checkMainAxis) {
        overflows.push(overflow[side]);
      }
      if (checkCrossAxis) {
        const sides2 = getAlignmentSides(placement, rects, rtl);
        overflows.push(overflow[sides2[0]], overflow[sides2[1]]);
      }
      overflowsData = [...overflowsData, {
        placement,
        overflows
      }];
      if (!overflows.every((side2) => side2 <= 0)) {
        var _middlewareData$flip2, _overflowsData$filter;
        const nextIndex2 = (((_middlewareData$flip2 = middlewareData.flip) == null ? void 0 : _middlewareData$flip2.index) || 0) + 1;
        const nextPlacement = placements2[nextIndex2];
        if (nextPlacement) {
          return {
            data: {
              index: nextIndex2,
              overflows: overflowsData
            },
            reset: {
              placement: nextPlacement
            }
          };
        }
        let resetPlacement = (_overflowsData$filter = overflowsData.filter((d2) => d2.overflows[0] <= 0).sort((a2, b2) => a2.overflows[1] - b2.overflows[1])[0]) == null ? void 0 : _overflowsData$filter.placement;
        if (!resetPlacement) {
          switch (fallbackStrategy) {
            case "bestFit": {
              var _overflowsData$filter2;
              const placement2 = (_overflowsData$filter2 = overflowsData.filter((d2) => {
                if (hasFallbackAxisSideDirection) {
                  const currentSideAxis = getSideAxis(d2.placement);
                  return currentSideAxis === initialSideAxis || // Create a bias to the `y` side axis due to horizontal
                  // reading directions favoring greater width.
                  currentSideAxis === "y";
                }
                return true;
              }).map((d2) => [d2.placement, d2.overflows.filter((overflow2) => overflow2 > 0).reduce((acc, overflow2) => acc + overflow2, 0)]).sort((a2, b2) => a2[1] - b2[1])[0]) == null ? void 0 : _overflowsData$filter2[0];
              if (placement2) {
                resetPlacement = placement2;
              }
              break;
            }
            case "initialPlacement":
              resetPlacement = initialPlacement;
              break;
          }
        }
        if (placement !== resetPlacement) {
          return {
            reset: {
              placement: resetPlacement
            }
          };
        }
      }
      return {};
    }
  };
};
async function convertValueToCoords(state, options) {
  const {
    placement,
    platform: platform2,
    elements
  } = state;
  const rtl = await (platform2.isRTL == null ? void 0 : platform2.isRTL(elements.floating));
  const side = getSide(placement);
  const alignment = getAlignment(placement);
  const isVertical = getSideAxis(placement) === "y";
  const mainAxisMulti = ["left", "top"].includes(side) ? -1 : 1;
  const crossAxisMulti = rtl && isVertical ? -1 : 1;
  const rawValue = evaluate(options, state);
  let {
    mainAxis,
    crossAxis,
    alignmentAxis
  } = typeof rawValue === "number" ? {
    mainAxis: rawValue,
    crossAxis: 0,
    alignmentAxis: null
  } : {
    mainAxis: rawValue.mainAxis || 0,
    crossAxis: rawValue.crossAxis || 0,
    alignmentAxis: rawValue.alignmentAxis
  };
  if (alignment && typeof alignmentAxis === "number") {
    crossAxis = alignment === "end" ? alignmentAxis * -1 : alignmentAxis;
  }
  return isVertical ? {
    x: crossAxis * crossAxisMulti,
    y: mainAxis * mainAxisMulti
  } : {
    x: mainAxis * mainAxisMulti,
    y: crossAxis * crossAxisMulti
  };
}
const offset$2 = function(options) {
  if (options === void 0) {
    options = 0;
  }
  return {
    name: "offset",
    options,
    async fn(state) {
      var _middlewareData$offse, _middlewareData$arrow;
      const {
        x,
        y: y2,
        placement,
        middlewareData
      } = state;
      const diffCoords = await convertValueToCoords(state, options);
      if (placement === ((_middlewareData$offse = middlewareData.offset) == null ? void 0 : _middlewareData$offse.placement) && (_middlewareData$arrow = middlewareData.arrow) != null && _middlewareData$arrow.alignmentOffset) {
        return {};
      }
      return {
        x: x + diffCoords.x,
        y: y2 + diffCoords.y,
        data: {
          ...diffCoords,
          placement
        }
      };
    }
  };
};
const shift$2 = function(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: "shift",
    options,
    async fn(state) {
      const {
        x,
        y: y2,
        placement
      } = state;
      const {
        mainAxis: checkMainAxis = true,
        crossAxis: checkCrossAxis = false,
        limiter = {
          fn: (_ref) => {
            let {
              x: x2,
              y: y3
            } = _ref;
            return {
              x: x2,
              y: y3
            };
          }
        },
        ...detectOverflowOptions
      } = evaluate(options, state);
      const coords = {
        x,
        y: y2
      };
      const overflow = await detectOverflow(state, detectOverflowOptions);
      const crossAxis = getSideAxis(getSide(placement));
      const mainAxis = getOppositeAxis(crossAxis);
      let mainAxisCoord = coords[mainAxis];
      let crossAxisCoord = coords[crossAxis];
      if (checkMainAxis) {
        const minSide = mainAxis === "y" ? "top" : "left";
        const maxSide = mainAxis === "y" ? "bottom" : "right";
        const min2 = mainAxisCoord + overflow[minSide];
        const max2 = mainAxisCoord - overflow[maxSide];
        mainAxisCoord = clamp(min2, mainAxisCoord, max2);
      }
      if (checkCrossAxis) {
        const minSide = crossAxis === "y" ? "top" : "left";
        const maxSide = crossAxis === "y" ? "bottom" : "right";
        const min2 = crossAxisCoord + overflow[minSide];
        const max2 = crossAxisCoord - overflow[maxSide];
        crossAxisCoord = clamp(min2, crossAxisCoord, max2);
      }
      const limitedCoords = limiter.fn({
        ...state,
        [mainAxis]: mainAxisCoord,
        [crossAxis]: crossAxisCoord
      });
      return {
        ...limitedCoords,
        data: {
          x: limitedCoords.x - x,
          y: limitedCoords.y - y2,
          enabled: {
            [mainAxis]: checkMainAxis,
            [crossAxis]: checkCrossAxis
          }
        }
      };
    }
  };
};
function hasWindow() {
  return typeof window !== "undefined";
}
function getNodeName(node) {
  if (isNode(node)) {
    return (node.nodeName || "").toLowerCase();
  }
  return "#document";
}
function getWindow$1(node) {
  var _node$ownerDocument;
  return (node == null || (_node$ownerDocument = node.ownerDocument) == null ? void 0 : _node$ownerDocument.defaultView) || window;
}
function getDocumentElement$1(node) {
  var _ref;
  return (_ref = (isNode(node) ? node.ownerDocument : node.document) || window.document) == null ? void 0 : _ref.documentElement;
}
function isNode(value) {
  if (!hasWindow()) {
    return false;
  }
  return value instanceof Node || value instanceof getWindow$1(value).Node;
}
function isElement$2(value) {
  if (!hasWindow()) {
    return false;
  }
  return value instanceof Element || value instanceof getWindow$1(value).Element;
}
function isHTMLElement$1(value) {
  if (!hasWindow()) {
    return false;
  }
  return value instanceof HTMLElement || value instanceof getWindow$1(value).HTMLElement;
}
function isShadowRoot$1(value) {
  if (!hasWindow() || typeof ShadowRoot === "undefined") {
    return false;
  }
  return value instanceof ShadowRoot || value instanceof getWindow$1(value).ShadowRoot;
}
function isOverflowElement(element) {
  const {
    overflow,
    overflowX,
    overflowY,
    display
  } = getComputedStyle$1(element);
  return /auto|scroll|overlay|hidden|clip/.test(overflow + overflowY + overflowX) && !["inline", "contents"].includes(display);
}
function isTableElement(element) {
  return ["table", "td", "th"].includes(getNodeName(element));
}
function isTopLayer(element) {
  return [":popover-open", ":modal"].some((selector2) => {
    try {
      return element.matches(selector2);
    } catch (e2) {
      return false;
    }
  });
}
function isContainingBlock(elementOrCss) {
  const webkit = isWebKit();
  const css = isElement$2(elementOrCss) ? getComputedStyle$1(elementOrCss) : elementOrCss;
  return css.transform !== "none" || css.perspective !== "none" || (css.containerType ? css.containerType !== "normal" : false) || !webkit && (css.backdropFilter ? css.backdropFilter !== "none" : false) || !webkit && (css.filter ? css.filter !== "none" : false) || ["transform", "perspective", "filter"].some((value) => (css.willChange || "").includes(value)) || ["paint", "layout", "strict", "content"].some((value) => (css.contain || "").includes(value));
}
function getContainingBlock(element) {
  let currentNode = getParentNode(element);
  while (isHTMLElement$1(currentNode) && !isLastTraversableNode(currentNode)) {
    if (isContainingBlock(currentNode)) {
      return currentNode;
    } else if (isTopLayer(currentNode)) {
      return null;
    }
    currentNode = getParentNode(currentNode);
  }
  return null;
}
function isWebKit() {
  if (typeof CSS === "undefined" || !CSS.supports)
    return false;
  return CSS.supports("-webkit-backdrop-filter", "none");
}
function isLastTraversableNode(node) {
  return ["html", "body", "#document"].includes(getNodeName(node));
}
function getComputedStyle$1(element) {
  return getWindow$1(element).getComputedStyle(element);
}
function getNodeScroll(element) {
  if (isElement$2(element)) {
    return {
      scrollLeft: element.scrollLeft,
      scrollTop: element.scrollTop
    };
  }
  return {
    scrollLeft: element.scrollX,
    scrollTop: element.scrollY
  };
}
function getParentNode(node) {
  if (getNodeName(node) === "html") {
    return node;
  }
  const result = (
    // Step into the shadow DOM of the parent of a slotted node.
    node.assignedSlot || // DOM Element detected.
    node.parentNode || // ShadowRoot detected.
    isShadowRoot$1(node) && node.host || // Fallback.
    getDocumentElement$1(node)
  );
  return isShadowRoot$1(result) ? result.host : result;
}
function getNearestOverflowAncestor(node) {
  const parentNode = getParentNode(node);
  if (isLastTraversableNode(parentNode)) {
    return node.ownerDocument ? node.ownerDocument.body : node.body;
  }
  if (isHTMLElement$1(parentNode) && isOverflowElement(parentNode)) {
    return parentNode;
  }
  return getNearestOverflowAncestor(parentNode);
}
function getOverflowAncestors(node, list, traverseIframes) {
  var _node$ownerDocument2;
  if (list === void 0) {
    list = [];
  }
  if (traverseIframes === void 0) {
    traverseIframes = true;
  }
  const scrollableAncestor = getNearestOverflowAncestor(node);
  const isBody = scrollableAncestor === ((_node$ownerDocument2 = node.ownerDocument) == null ? void 0 : _node$ownerDocument2.body);
  const win = getWindow$1(scrollableAncestor);
  if (isBody) {
    const frameElement = getFrameElement(win);
    return list.concat(win, win.visualViewport || [], isOverflowElement(scrollableAncestor) ? scrollableAncestor : [], frameElement && traverseIframes ? getOverflowAncestors(frameElement) : []);
  }
  return list.concat(scrollableAncestor, getOverflowAncestors(scrollableAncestor, [], traverseIframes));
}
function getFrameElement(win) {
  return win.parent && Object.getPrototypeOf(win.parent) ? win.frameElement : null;
}
function getCssDimensions(element) {
  const css = getComputedStyle$1(element);
  let width = parseFloat(css.width) || 0;
  let height = parseFloat(css.height) || 0;
  const hasOffset = isHTMLElement$1(element);
  const offsetWidth = hasOffset ? element.offsetWidth : width;
  const offsetHeight = hasOffset ? element.offsetHeight : height;
  const shouldFallback = round(width) !== offsetWidth || round(height) !== offsetHeight;
  if (shouldFallback) {
    width = offsetWidth;
    height = offsetHeight;
  }
  return {
    width,
    height,
    $: shouldFallback
  };
}
function unwrapElement(element) {
  return !isElement$2(element) ? element.contextElement : element;
}
function getScale(element) {
  const domElement = unwrapElement(element);
  if (!isHTMLElement$1(domElement)) {
    return createCoords(1);
  }
  const rect = domElement.getBoundingClientRect();
  const {
    width,
    height,
    $: $2
  } = getCssDimensions(domElement);
  let x = ($2 ? round(rect.width) : rect.width) / width;
  let y2 = ($2 ? round(rect.height) : rect.height) / height;
  if (!x || !Number.isFinite(x)) {
    x = 1;
  }
  if (!y2 || !Number.isFinite(y2)) {
    y2 = 1;
  }
  return {
    x,
    y: y2
  };
}
const noOffsets = /* @__PURE__ */ createCoords(0);
function getVisualOffsets(element) {
  const win = getWindow$1(element);
  if (!isWebKit() || !win.visualViewport) {
    return noOffsets;
  }
  return {
    x: win.visualViewport.offsetLeft,
    y: win.visualViewport.offsetTop
  };
}
function shouldAddVisualOffsets(element, isFixed, floatingOffsetParent) {
  if (isFixed === void 0) {
    isFixed = false;
  }
  if (!floatingOffsetParent || isFixed && floatingOffsetParent !== getWindow$1(element)) {
    return false;
  }
  return isFixed;
}
function getBoundingClientRect(element, includeScale, isFixedStrategy, offsetParent) {
  if (includeScale === void 0) {
    includeScale = false;
  }
  if (isFixedStrategy === void 0) {
    isFixedStrategy = false;
  }
  const clientRect = element.getBoundingClientRect();
  const domElement = unwrapElement(element);
  let scale = createCoords(1);
  if (includeScale) {
    if (offsetParent) {
      if (isElement$2(offsetParent)) {
        scale = getScale(offsetParent);
      }
    } else {
      scale = getScale(element);
    }
  }
  const visualOffsets = shouldAddVisualOffsets(domElement, isFixedStrategy, offsetParent) ? getVisualOffsets(domElement) : createCoords(0);
  let x = (clientRect.left + visualOffsets.x) / scale.x;
  let y2 = (clientRect.top + visualOffsets.y) / scale.y;
  let width = clientRect.width / scale.x;
  let height = clientRect.height / scale.y;
  if (domElement) {
    const win = getWindow$1(domElement);
    const offsetWin = offsetParent && isElement$2(offsetParent) ? getWindow$1(offsetParent) : offsetParent;
    let currentWin = win;
    let currentIFrame = getFrameElement(currentWin);
    while (currentIFrame && offsetParent && offsetWin !== currentWin) {
      const iframeScale = getScale(currentIFrame);
      const iframeRect = currentIFrame.getBoundingClientRect();
      const css = getComputedStyle$1(currentIFrame);
      const left = iframeRect.left + (currentIFrame.clientLeft + parseFloat(css.paddingLeft)) * iframeScale.x;
      const top = iframeRect.top + (currentIFrame.clientTop + parseFloat(css.paddingTop)) * iframeScale.y;
      x *= iframeScale.x;
      y2 *= iframeScale.y;
      width *= iframeScale.x;
      height *= iframeScale.y;
      x += left;
      y2 += top;
      currentWin = getWindow$1(currentIFrame);
      currentIFrame = getFrameElement(currentWin);
    }
  }
  return rectToClientRect({
    width,
    height,
    x,
    y: y2
  });
}
function convertOffsetParentRelativeRectToViewportRelativeRect(_ref) {
  let {
    elements,
    rect,
    offsetParent,
    strategy
  } = _ref;
  const isFixed = strategy === "fixed";
  const documentElement = getDocumentElement$1(offsetParent);
  const topLayer = elements ? isTopLayer(elements.floating) : false;
  if (offsetParent === documentElement || topLayer && isFixed) {
    return rect;
  }
  let scroll3 = {
    scrollLeft: 0,
    scrollTop: 0
  };
  let scale = createCoords(1);
  const offsets = createCoords(0);
  const isOffsetParentAnElement = isHTMLElement$1(offsetParent);
  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
    if (getNodeName(offsetParent) !== "body" || isOverflowElement(documentElement)) {
      scroll3 = getNodeScroll(offsetParent);
    }
    if (isHTMLElement$1(offsetParent)) {
      const offsetRect = getBoundingClientRect(offsetParent);
      scale = getScale(offsetParent);
      offsets.x = offsetRect.x + offsetParent.clientLeft;
      offsets.y = offsetRect.y + offsetParent.clientTop;
    }
  }
  return {
    width: rect.width * scale.x,
    height: rect.height * scale.y,
    x: rect.x * scale.x - scroll3.scrollLeft * scale.x + offsets.x,
    y: rect.y * scale.y - scroll3.scrollTop * scale.y + offsets.y
  };
}
function getClientRects(element) {
  return Array.from(element.getClientRects());
}
function getWindowScrollBarX(element, rect) {
  const leftScroll = getNodeScroll(element).scrollLeft;
  if (!rect) {
    return getBoundingClientRect(getDocumentElement$1(element)).left + leftScroll;
  }
  return rect.left + leftScroll;
}
function getDocumentRect(element) {
  const html = getDocumentElement$1(element);
  const scroll3 = getNodeScroll(element);
  const body = element.ownerDocument.body;
  const width = max(html.scrollWidth, html.clientWidth, body.scrollWidth, body.clientWidth);
  const height = max(html.scrollHeight, html.clientHeight, body.scrollHeight, body.clientHeight);
  let x = -scroll3.scrollLeft + getWindowScrollBarX(element);
  const y2 = -scroll3.scrollTop;
  if (getComputedStyle$1(body).direction === "rtl") {
    x += max(html.clientWidth, body.clientWidth) - width;
  }
  return {
    width,
    height,
    x,
    y: y2
  };
}
function getViewportRect(element, strategy) {
  const win = getWindow$1(element);
  const html = getDocumentElement$1(element);
  const visualViewport = win.visualViewport;
  let width = html.clientWidth;
  let height = html.clientHeight;
  let x = 0;
  let y2 = 0;
  if (visualViewport) {
    width = visualViewport.width;
    height = visualViewport.height;
    const visualViewportBased = isWebKit();
    if (!visualViewportBased || visualViewportBased && strategy === "fixed") {
      x = visualViewport.offsetLeft;
      y2 = visualViewport.offsetTop;
    }
  }
  return {
    width,
    height,
    x,
    y: y2
  };
}
function getInnerBoundingClientRect(element, strategy) {
  const clientRect = getBoundingClientRect(element, true, strategy === "fixed");
  const top = clientRect.top + element.clientTop;
  const left = clientRect.left + element.clientLeft;
  const scale = isHTMLElement$1(element) ? getScale(element) : createCoords(1);
  const width = element.clientWidth * scale.x;
  const height = element.clientHeight * scale.y;
  const x = left * scale.x;
  const y2 = top * scale.y;
  return {
    width,
    height,
    x,
    y: y2
  };
}
function getClientRectFromClippingAncestor(element, clippingAncestor, strategy) {
  let rect;
  if (clippingAncestor === "viewport") {
    rect = getViewportRect(element, strategy);
  } else if (clippingAncestor === "document") {
    rect = getDocumentRect(getDocumentElement$1(element));
  } else if (isElement$2(clippingAncestor)) {
    rect = getInnerBoundingClientRect(clippingAncestor, strategy);
  } else {
    const visualOffsets = getVisualOffsets(element);
    rect = {
      ...clippingAncestor,
      x: clippingAncestor.x - visualOffsets.x,
      y: clippingAncestor.y - visualOffsets.y
    };
  }
  return rectToClientRect(rect);
}
function hasFixedPositionAncestor(element, stopNode) {
  const parentNode = getParentNode(element);
  if (parentNode === stopNode || !isElement$2(parentNode) || isLastTraversableNode(parentNode)) {
    return false;
  }
  return getComputedStyle$1(parentNode).position === "fixed" || hasFixedPositionAncestor(parentNode, stopNode);
}
function getClippingElementAncestors(element, cache) {
  const cachedResult = cache.get(element);
  if (cachedResult) {
    return cachedResult;
  }
  let result = getOverflowAncestors(element, [], false).filter((el2) => isElement$2(el2) && getNodeName(el2) !== "body");
  let currentContainingBlockComputedStyle = null;
  const elementIsFixed = getComputedStyle$1(element).position === "fixed";
  let currentNode = elementIsFixed ? getParentNode(element) : element;
  while (isElement$2(currentNode) && !isLastTraversableNode(currentNode)) {
    const computedStyle = getComputedStyle$1(currentNode);
    const currentNodeIsContaining = isContainingBlock(currentNode);
    if (!currentNodeIsContaining && computedStyle.position === "fixed") {
      currentContainingBlockComputedStyle = null;
    }
    const shouldDropCurrentNode = elementIsFixed ? !currentNodeIsContaining && !currentContainingBlockComputedStyle : !currentNodeIsContaining && computedStyle.position === "static" && !!currentContainingBlockComputedStyle && ["absolute", "fixed"].includes(currentContainingBlockComputedStyle.position) || isOverflowElement(currentNode) && !currentNodeIsContaining && hasFixedPositionAncestor(element, currentNode);
    if (shouldDropCurrentNode) {
      result = result.filter((ancestor) => ancestor !== currentNode);
    } else {
      currentContainingBlockComputedStyle = computedStyle;
    }
    currentNode = getParentNode(currentNode);
  }
  cache.set(element, result);
  return result;
}
function getClippingRect(_ref) {
  let {
    element,
    boundary,
    rootBoundary,
    strategy
  } = _ref;
  const elementClippingAncestors = boundary === "clippingAncestors" ? isTopLayer(element) ? [] : getClippingElementAncestors(element, this._c) : [].concat(boundary);
  const clippingAncestors = [...elementClippingAncestors, rootBoundary];
  const firstClippingAncestor = clippingAncestors[0];
  const clippingRect = clippingAncestors.reduce((accRect, clippingAncestor) => {
    const rect = getClientRectFromClippingAncestor(element, clippingAncestor, strategy);
    accRect.top = max(rect.top, accRect.top);
    accRect.right = min(rect.right, accRect.right);
    accRect.bottom = min(rect.bottom, accRect.bottom);
    accRect.left = max(rect.left, accRect.left);
    return accRect;
  }, getClientRectFromClippingAncestor(element, firstClippingAncestor, strategy));
  return {
    width: clippingRect.right - clippingRect.left,
    height: clippingRect.bottom - clippingRect.top,
    x: clippingRect.left,
    y: clippingRect.top
  };
}
function getDimensions(element) {
  const {
    width,
    height
  } = getCssDimensions(element);
  return {
    width,
    height
  };
}
function getRectRelativeToOffsetParent(element, offsetParent, strategy) {
  const isOffsetParentAnElement = isHTMLElement$1(offsetParent);
  const documentElement = getDocumentElement$1(offsetParent);
  const isFixed = strategy === "fixed";
  const rect = getBoundingClientRect(element, true, isFixed, offsetParent);
  let scroll3 = {
    scrollLeft: 0,
    scrollTop: 0
  };
  const offsets = createCoords(0);
  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
    if (getNodeName(offsetParent) !== "body" || isOverflowElement(documentElement)) {
      scroll3 = getNodeScroll(offsetParent);
    }
    if (isOffsetParentAnElement) {
      const offsetRect = getBoundingClientRect(offsetParent, true, isFixed, offsetParent);
      offsets.x = offsetRect.x + offsetParent.clientLeft;
      offsets.y = offsetRect.y + offsetParent.clientTop;
    } else if (documentElement) {
      offsets.x = getWindowScrollBarX(documentElement);
    }
  }
  let htmlX = 0;
  let htmlY = 0;
  if (documentElement && !isOffsetParentAnElement && !isFixed) {
    const htmlRect = documentElement.getBoundingClientRect();
    htmlY = htmlRect.top + scroll3.scrollTop;
    htmlX = htmlRect.left + scroll3.scrollLeft - // RTL <body> scrollbar.
    getWindowScrollBarX(documentElement, htmlRect);
  }
  const x = rect.left + scroll3.scrollLeft - offsets.x - htmlX;
  const y2 = rect.top + scroll3.scrollTop - offsets.y - htmlY;
  return {
    x,
    y: y2,
    width: rect.width,
    height: rect.height
  };
}
function isStaticPositioned(element) {
  return getComputedStyle$1(element).position === "static";
}
function getTrueOffsetParent(element, polyfill2) {
  if (!isHTMLElement$1(element) || getComputedStyle$1(element).position === "fixed") {
    return null;
  }
  if (polyfill2) {
    return polyfill2(element);
  }
  let rawOffsetParent = element.offsetParent;
  if (getDocumentElement$1(element) === rawOffsetParent) {
    rawOffsetParent = rawOffsetParent.ownerDocument.body;
  }
  return rawOffsetParent;
}
function getOffsetParent(element, polyfill2) {
  const win = getWindow$1(element);
  if (isTopLayer(element)) {
    return win;
  }
  if (!isHTMLElement$1(element)) {
    let svgOffsetParent = getParentNode(element);
    while (svgOffsetParent && !isLastTraversableNode(svgOffsetParent)) {
      if (isElement$2(svgOffsetParent) && !isStaticPositioned(svgOffsetParent)) {
        return svgOffsetParent;
      }
      svgOffsetParent = getParentNode(svgOffsetParent);
    }
    return win;
  }
  let offsetParent = getTrueOffsetParent(element, polyfill2);
  while (offsetParent && isTableElement(offsetParent) && isStaticPositioned(offsetParent)) {
    offsetParent = getTrueOffsetParent(offsetParent, polyfill2);
  }
  if (offsetParent && isLastTraversableNode(offsetParent) && isStaticPositioned(offsetParent) && !isContainingBlock(offsetParent)) {
    return win;
  }
  return offsetParent || getContainingBlock(element) || win;
}
const getElementRects = async function(data) {
  const getOffsetParentFn = this.getOffsetParent || getOffsetParent;
  const getDimensionsFn = this.getDimensions;
  const floatingDimensions = await getDimensionsFn(data.floating);
  return {
    reference: getRectRelativeToOffsetParent(data.reference, await getOffsetParentFn(data.floating), data.strategy),
    floating: {
      x: 0,
      y: 0,
      width: floatingDimensions.width,
      height: floatingDimensions.height
    }
  };
};
function isRTL(element) {
  return getComputedStyle$1(element).direction === "rtl";
}
const platform = {
  convertOffsetParentRelativeRectToViewportRelativeRect,
  getDocumentElement: getDocumentElement$1,
  getClippingRect,
  getOffsetParent,
  getElementRects,
  getClientRects,
  getDimensions,
  getScale,
  isElement: isElement$2,
  isRTL
};
function observeMove(element, onMove) {
  let io2 = null;
  let timeoutId2;
  const root = getDocumentElement$1(element);
  function cleanup() {
    var _io;
    clearTimeout(timeoutId2);
    (_io = io2) == null || _io.disconnect();
    io2 = null;
  }
  function refresh(skip, threshold) {
    if (skip === void 0) {
      skip = false;
    }
    if (threshold === void 0) {
      threshold = 1;
    }
    cleanup();
    const {
      left,
      top,
      width,
      height
    } = element.getBoundingClientRect();
    if (!skip) {
      onMove();
    }
    if (!width || !height) {
      return;
    }
    const insetTop = floor(top);
    const insetRight = floor(root.clientWidth - (left + width));
    const insetBottom = floor(root.clientHeight - (top + height));
    const insetLeft = floor(left);
    const rootMargin = -insetTop + "px " + -insetRight + "px " + -insetBottom + "px " + -insetLeft + "px";
    const options = {
      rootMargin,
      threshold: max(0, min(1, threshold)) || 1
    };
    let isFirstUpdate = true;
    function handleObserve(entries) {
      const ratio = entries[0].intersectionRatio;
      if (ratio !== threshold) {
        if (!isFirstUpdate) {
          return refresh();
        }
        if (!ratio) {
          timeoutId2 = setTimeout(() => {
            refresh(false, 1e-7);
          }, 1e3);
        } else {
          refresh(false, ratio);
        }
      }
      isFirstUpdate = false;
    }
    try {
      io2 = new IntersectionObserver(handleObserve, {
        ...options,
        // Handle <iframe>s
        root: root.ownerDocument
      });
    } catch (e2) {
      io2 = new IntersectionObserver(handleObserve, options);
    }
    io2.observe(element);
  }
  refresh(true);
  return cleanup;
}
function autoUpdate(reference, floating, update2, options) {
  if (options === void 0) {
    options = {};
  }
  const {
    ancestorScroll = true,
    ancestorResize = true,
    elementResize = typeof ResizeObserver === "function",
    layoutShift = typeof IntersectionObserver === "function",
    animationFrame = false
  } = options;
  const referenceEl = unwrapElement(reference);
  const ancestors = ancestorScroll || ancestorResize ? [...referenceEl ? getOverflowAncestors(referenceEl) : [], ...getOverflowAncestors(floating)] : [];
  ancestors.forEach((ancestor) => {
    ancestorScroll && ancestor.addEventListener("scroll", update2, {
      passive: true
    });
    ancestorResize && ancestor.addEventListener("resize", update2);
  });
  const cleanupIo = referenceEl && layoutShift ? observeMove(referenceEl, update2) : null;
  let reobserveFrame = -1;
  let resizeObserver = null;
  if (elementResize) {
    resizeObserver = new ResizeObserver((_ref) => {
      let [firstEntry] = _ref;
      if (firstEntry && firstEntry.target === referenceEl && resizeObserver) {
        resizeObserver.unobserve(floating);
        cancelAnimationFrame(reobserveFrame);
        reobserveFrame = requestAnimationFrame(() => {
          var _resizeObserver;
          (_resizeObserver = resizeObserver) == null || _resizeObserver.observe(floating);
        });
      }
      update2();
    });
    if (referenceEl && !animationFrame) {
      resizeObserver.observe(referenceEl);
    }
    resizeObserver.observe(floating);
  }
  let frameId;
  let prevRefRect = animationFrame ? getBoundingClientRect(reference) : null;
  if (animationFrame) {
    frameLoop();
  }
  function frameLoop() {
    const nextRefRect = getBoundingClientRect(reference);
    if (prevRefRect && (nextRefRect.x !== prevRefRect.x || nextRefRect.y !== prevRefRect.y || nextRefRect.width !== prevRefRect.width || nextRefRect.height !== prevRefRect.height)) {
      update2();
    }
    prevRefRect = nextRefRect;
    frameId = requestAnimationFrame(frameLoop);
  }
  update2();
  return () => {
    var _resizeObserver2;
    ancestors.forEach((ancestor) => {
      ancestorScroll && ancestor.removeEventListener("scroll", update2);
      ancestorResize && ancestor.removeEventListener("resize", update2);
    });
    cleanupIo == null || cleanupIo();
    (_resizeObserver2 = resizeObserver) == null || _resizeObserver2.disconnect();
    resizeObserver = null;
    if (animationFrame) {
      cancelAnimationFrame(frameId);
    }
  };
}
const offset$1 = offset$2;
const autoPlacement = autoPlacement$1;
const shift$1 = shift$2;
const flip = flip$1;
const arrow$1 = arrow$2;
const computePosition = (reference, floating, options) => {
  const cache = /* @__PURE__ */ new Map();
  const mergedOptions = {
    platform,
    ...options
  };
  const platformWithCache = {
    ...mergedOptions.platform,
    _c: cache
  };
  return computePosition$1(reference, floating, {
    ...mergedOptions,
    platform: platformWithCache
  });
};
const arrow = (options) => {
  function isRef(value) {
    return {}.hasOwnProperty.call(value, "current");
  }
  return {
    name: "arrow",
    options,
    fn(state) {
      const {
        element,
        padding
      } = typeof options === "function" ? options(state) : options;
      if (element && isRef(element)) {
        if (element.current != null) {
          return arrow$1({
            element: element.current,
            padding
          }).fn(state);
        }
        return {};
      } else if (element) {
        return arrow$1({
          element,
          padding
        }).fn(state);
      }
      return {};
    }
  };
};
var index$2 = typeof document !== "undefined" ? reactExports.useLayoutEffect : reactExports.useEffect;
function deepEqual(a2, b2) {
  if (a2 === b2) {
    return true;
  }
  if (typeof a2 !== typeof b2) {
    return false;
  }
  if (typeof a2 === "function" && a2.toString() === b2.toString()) {
    return true;
  }
  let length, i2, keys;
  if (a2 && b2 && typeof a2 == "object") {
    if (Array.isArray(a2)) {
      length = a2.length;
      if (length != b2.length)
        return false;
      for (i2 = length; i2-- !== 0; ) {
        if (!deepEqual(a2[i2], b2[i2])) {
          return false;
        }
      }
      return true;
    }
    keys = Object.keys(a2);
    length = keys.length;
    if (length !== Object.keys(b2).length) {
      return false;
    }
    for (i2 = length; i2-- !== 0; ) {
      if (!{}.hasOwnProperty.call(b2, keys[i2])) {
        return false;
      }
    }
    for (i2 = length; i2-- !== 0; ) {
      const key = keys[i2];
      if (key === "_owner" && a2.$$typeof) {
        continue;
      }
      if (!deepEqual(a2[key], b2[key])) {
        return false;
      }
    }
    return true;
  }
  return a2 !== a2 && b2 !== b2;
}
function getDPR(element) {
  if (typeof window === "undefined") {
    return 1;
  }
  const win = element.ownerDocument.defaultView || window;
  return win.devicePixelRatio || 1;
}
function roundByDPR(element, value) {
  const dpr = getDPR(element);
  return Math.round(value * dpr) / dpr;
}
function useLatestRef$1(value) {
  const ref = reactExports.useRef(value);
  index$2(() => {
    ref.current = value;
  });
  return ref;
}
function useFloating$1(options) {
  if (options === void 0) {
    options = {};
  }
  const {
    placement = "bottom",
    strategy = "absolute",
    middleware = [],
    platform: platform2,
    elements: {
      reference: externalReference,
      floating: externalFloating
    } = {},
    transform = true,
    whileElementsMounted,
    open
  } = options;
  const [data, setData] = reactExports.useState({
    x: 0,
    y: 0,
    strategy,
    placement,
    middlewareData: {},
    isPositioned: false
  });
  const [latestMiddleware, setLatestMiddleware] = reactExports.useState(middleware);
  if (!deepEqual(latestMiddleware, middleware)) {
    setLatestMiddleware(middleware);
  }
  const [_reference, _setReference] = reactExports.useState(null);
  const [_floating, _setFloating] = reactExports.useState(null);
  const setReference = reactExports.useCallback((node) => {
    if (node != referenceRef.current) {
      referenceRef.current = node;
      _setReference(node);
    }
  }, [_setReference]);
  const setFloating = reactExports.useCallback((node) => {
    if (node !== floatingRef.current) {
      floatingRef.current = node;
      _setFloating(node);
    }
  }, [_setFloating]);
  const referenceEl = externalReference || _reference;
  const floatingEl = externalFloating || _floating;
  const referenceRef = reactExports.useRef(null);
  const floatingRef = reactExports.useRef(null);
  const dataRef = reactExports.useRef(data);
  const whileElementsMountedRef = useLatestRef$1(whileElementsMounted);
  const platformRef = useLatestRef$1(platform2);
  const update2 = reactExports.useCallback(() => {
    if (!referenceRef.current || !floatingRef.current) {
      return;
    }
    const config2 = {
      placement,
      strategy,
      middleware: latestMiddleware
    };
    if (platformRef.current) {
      config2.platform = platformRef.current;
    }
    computePosition(referenceRef.current, floatingRef.current, config2).then((data2) => {
      const fullData = {
        ...data2,
        isPositioned: true
      };
      if (isMountedRef.current && !deepEqual(dataRef.current, fullData)) {
        dataRef.current = fullData;
        reactDomExports.flushSync(() => {
          setData(fullData);
        });
      }
    });
  }, [latestMiddleware, placement, strategy, platformRef]);
  index$2(() => {
    if (open === false && dataRef.current.isPositioned) {
      dataRef.current.isPositioned = false;
      setData((data2) => ({
        ...data2,
        isPositioned: false
      }));
    }
  }, [open]);
  const isMountedRef = reactExports.useRef(false);
  index$2(() => {
    isMountedRef.current = true;
    return () => {
      isMountedRef.current = false;
    };
  }, []);
  index$2(() => {
    if (referenceEl)
      referenceRef.current = referenceEl;
    if (floatingEl)
      floatingRef.current = floatingEl;
    if (referenceEl && floatingEl) {
      if (whileElementsMountedRef.current) {
        return whileElementsMountedRef.current(referenceEl, floatingEl, update2);
      } else {
        update2();
      }
    }
  }, [referenceEl, floatingEl, update2, whileElementsMountedRef]);
  const refs = reactExports.useMemo(() => ({
    reference: referenceRef,
    floating: floatingRef,
    setReference,
    setFloating
  }), [setReference, setFloating]);
  const elements = reactExports.useMemo(() => ({
    reference: referenceEl,
    floating: floatingEl
  }), [referenceEl, floatingEl]);
  const floatingStyles = reactExports.useMemo(() => {
    const initialStyles = {
      position: strategy,
      left: 0,
      top: 0
    };
    if (!elements.floating) {
      return initialStyles;
    }
    const x = roundByDPR(elements.floating, data.x);
    const y2 = roundByDPR(elements.floating, data.y);
    if (transform) {
      return {
        ...initialStyles,
        transform: "translate(" + x + "px, " + y2 + "px)",
        ...getDPR(elements.floating) >= 1.5 && {
          willChange: "transform"
        }
      };
    }
    return {
      position: strategy,
      left: x,
      top: y2
    };
  }, [strategy, transform, elements.floating, data.x, data.y]);
  return reactExports.useMemo(() => ({
    ...data,
    update: update2,
    refs,
    elements,
    floatingStyles
  }), [data, update2, refs, elements, floatingStyles]);
}
var getDefaultParent = function(originalTarget) {
  if (typeof document === "undefined") {
    return null;
  }
  var sampleTarget = Array.isArray(originalTarget) ? originalTarget[0] : originalTarget;
  return sampleTarget.ownerDocument.body;
};
var counterMap = /* @__PURE__ */ new WeakMap();
var uncontrolledNodes = /* @__PURE__ */ new WeakMap();
var markerMap = {};
var lockCount = 0;
var unwrapHost = function(node) {
  return node && (node.host || unwrapHost(node.parentNode));
};
var correctTargets = function(parent, targets) {
  return targets.map(function(target) {
    if (parent.contains(target)) {
      return target;
    }
    var correctedTarget = unwrapHost(target);
    if (correctedTarget && parent.contains(correctedTarget)) {
      return correctedTarget;
    }
    console.error("aria-hidden", target, "in not contained inside", parent, ". Doing nothing");
    return null;
  }).filter(function(x) {
    return Boolean(x);
  });
};
var applyAttributeToOthers = function(originalTarget, parentNode, markerName, controlAttribute) {
  var targets = correctTargets(parentNode, Array.isArray(originalTarget) ? originalTarget : [originalTarget]);
  if (!markerMap[markerName]) {
    markerMap[markerName] = /* @__PURE__ */ new WeakMap();
  }
  var markerCounter = markerMap[markerName];
  var hiddenNodes = [];
  var elementsToKeep = /* @__PURE__ */ new Set();
  var elementsToStop = new Set(targets);
  var keep = function(el2) {
    if (!el2 || elementsToKeep.has(el2)) {
      return;
    }
    elementsToKeep.add(el2);
    keep(el2.parentNode);
  };
  targets.forEach(keep);
  var deep = function(parent) {
    if (!parent || elementsToStop.has(parent)) {
      return;
    }
    Array.prototype.forEach.call(parent.children, function(node) {
      if (elementsToKeep.has(node)) {
        deep(node);
      } else {
        var attr = node.getAttribute(controlAttribute);
        var alreadyHidden = attr !== null && attr !== "false";
        var counterValue = (counterMap.get(node) || 0) + 1;
        var markerValue = (markerCounter.get(node) || 0) + 1;
        counterMap.set(node, counterValue);
        markerCounter.set(node, markerValue);
        hiddenNodes.push(node);
        if (counterValue === 1 && alreadyHidden) {
          uncontrolledNodes.set(node, true);
        }
        if (markerValue === 1) {
          node.setAttribute(markerName, "true");
        }
        if (!alreadyHidden) {
          node.setAttribute(controlAttribute, "true");
        }
      }
    });
  };
  deep(parentNode);
  elementsToKeep.clear();
  lockCount++;
  return function() {
    hiddenNodes.forEach(function(node) {
      var counterValue = counterMap.get(node) - 1;
      var markerValue = markerCounter.get(node) - 1;
      counterMap.set(node, counterValue);
      markerCounter.set(node, markerValue);
      if (!counterValue) {
        if (!uncontrolledNodes.has(node)) {
          node.removeAttribute(controlAttribute);
        }
        uncontrolledNodes.delete(node);
      }
      if (!markerValue) {
        node.removeAttribute(markerName);
      }
    });
    lockCount--;
    if (!lockCount) {
      counterMap = /* @__PURE__ */ new WeakMap();
      counterMap = /* @__PURE__ */ new WeakMap();
      uncontrolledNodes = /* @__PURE__ */ new WeakMap();
      markerMap = {};
    }
  };
};
var hideOthers = function(originalTarget, parentNode, markerName) {
  if (markerName === void 0) {
    markerName = "data-aria-hidden";
  }
  var targets = Array.from(Array.isArray(originalTarget) ? originalTarget : [originalTarget]);
  var activeParentNode = parentNode || getDefaultParent(originalTarget);
  if (!activeParentNode) {
    return function() {
      return null;
    };
  }
  targets.push.apply(targets, Array.from(activeParentNode.querySelectorAll("[aria-live]")));
  return applyAttributeToOthers(targets, activeParentNode, markerName, "aria-hidden");
};
var inertOthers = function(originalTarget, parentNode, markerName) {
  if (markerName === void 0) {
    markerName = "data-inert-ed";
  }
  var activeParentNode = parentNode || getDefaultParent(originalTarget);
  if (!activeParentNode) {
    return function() {
      return null;
    };
  }
  return applyAttributeToOthers(originalTarget, activeParentNode, markerName, "inert");
};
var supportsInert = function() {
  return typeof HTMLElement !== "undefined" && HTMLElement.prototype.hasOwnProperty("inert");
};
var suppressOthers = function(originalTarget, parentNode, markerName) {
  if (markerName === void 0) {
    markerName = "data-suppressed";
  }
  return (supportsInert() ? inertOthers : hideOthers)(originalTarget, parentNode, markerName);
};
/*!
* tabbable 6.2.0
* @license MIT, https://github.com/focus-trap/tabbable/blob/master/LICENSE
*/
var candidateSelectors = ["input:not([inert])", "select:not([inert])", "textarea:not([inert])", "a[href]:not([inert])", "button:not([inert])", "[tabindex]:not(slot):not([inert])", "audio[controls]:not([inert])", "video[controls]:not([inert])", '[contenteditable]:not([contenteditable="false"]):not([inert])', "details>summary:first-of-type:not([inert])", "details:not([inert])"];
var candidateSelector = /* @__PURE__ */ candidateSelectors.join(",");
var NoElement = typeof Element === "undefined";
var matches = NoElement ? function() {
} : Element.prototype.matches || Element.prototype.msMatchesSelector || Element.prototype.webkitMatchesSelector;
var getRootNode = !NoElement && Element.prototype.getRootNode ? function(element) {
  var _element$getRootNode;
  return element === null || element === void 0 ? void 0 : (_element$getRootNode = element.getRootNode) === null || _element$getRootNode === void 0 ? void 0 : _element$getRootNode.call(element);
} : function(element) {
  return element === null || element === void 0 ? void 0 : element.ownerDocument;
};
var isInert = function isInert2(node, lookUp) {
  var _node$getAttribute;
  if (lookUp === void 0) {
    lookUp = true;
  }
  var inertAtt = node === null || node === void 0 ? void 0 : (_node$getAttribute = node.getAttribute) === null || _node$getAttribute === void 0 ? void 0 : _node$getAttribute.call(node, "inert");
  var inert = inertAtt === "" || inertAtt === "true";
  var result = inert || lookUp && node && isInert2(node.parentNode);
  return result;
};
var isContentEditable = function isContentEditable2(node) {
  var _node$getAttribute2;
  var attValue = node === null || node === void 0 ? void 0 : (_node$getAttribute2 = node.getAttribute) === null || _node$getAttribute2 === void 0 ? void 0 : _node$getAttribute2.call(node, "contenteditable");
  return attValue === "" || attValue === "true";
};
var getCandidates = function getCandidates2(el2, includeContainer, filter) {
  if (isInert(el2)) {
    return [];
  }
  var candidates = Array.prototype.slice.apply(el2.querySelectorAll(candidateSelector));
  if (includeContainer && matches.call(el2, candidateSelector)) {
    candidates.unshift(el2);
  }
  candidates = candidates.filter(filter);
  return candidates;
};
var getCandidatesIteratively = function getCandidatesIteratively2(elements, includeContainer, options) {
  var candidates = [];
  var elementsToCheck = Array.from(elements);
  while (elementsToCheck.length) {
    var element = elementsToCheck.shift();
    if (isInert(element, false)) {
      continue;
    }
    if (element.tagName === "SLOT") {
      var assigned = element.assignedElements();
      var content = assigned.length ? assigned : element.children;
      var nestedCandidates = getCandidatesIteratively2(content, true, options);
      if (options.flatten) {
        candidates.push.apply(candidates, nestedCandidates);
      } else {
        candidates.push({
          scopeParent: element,
          candidates: nestedCandidates
        });
      }
    } else {
      var validCandidate = matches.call(element, candidateSelector);
      if (validCandidate && options.filter(element) && (includeContainer || !elements.includes(element))) {
        candidates.push(element);
      }
      var shadowRoot = element.shadowRoot || // check for an undisclosed shadow
      typeof options.getShadowRoot === "function" && options.getShadowRoot(element);
      var validShadowRoot = !isInert(shadowRoot, false) && (!options.shadowRootFilter || options.shadowRootFilter(element));
      if (shadowRoot && validShadowRoot) {
        var _nestedCandidates = getCandidatesIteratively2(shadowRoot === true ? element.children : shadowRoot.children, true, options);
        if (options.flatten) {
          candidates.push.apply(candidates, _nestedCandidates);
        } else {
          candidates.push({
            scopeParent: element,
            candidates: _nestedCandidates
          });
        }
      } else {
        elementsToCheck.unshift.apply(elementsToCheck, element.children);
      }
    }
  }
  return candidates;
};
var hasTabIndex = function hasTabIndex2(node) {
  return !isNaN(parseInt(node.getAttribute("tabindex"), 10));
};
var getTabIndex = function getTabIndex2(node) {
  if (!node) {
    throw new Error("No node provided");
  }
  if (node.tabIndex < 0) {
    if ((/^(AUDIO|VIDEO|DETAILS)$/.test(node.tagName) || isContentEditable(node)) && !hasTabIndex(node)) {
      return 0;
    }
  }
  return node.tabIndex;
};
var getSortOrderTabIndex = function getSortOrderTabIndex2(node, isScope) {
  var tabIndex = getTabIndex(node);
  if (tabIndex < 0 && isScope && !hasTabIndex(node)) {
    return 0;
  }
  return tabIndex;
};
var sortOrderedTabbables = function sortOrderedTabbables2(a2, b2) {
  return a2.tabIndex === b2.tabIndex ? a2.documentOrder - b2.documentOrder : a2.tabIndex - b2.tabIndex;
};
var isInput = function isInput2(node) {
  return node.tagName === "INPUT";
};
var isHiddenInput = function isHiddenInput2(node) {
  return isInput(node) && node.type === "hidden";
};
var isDetailsWithSummary = function isDetailsWithSummary2(node) {
  var r2 = node.tagName === "DETAILS" && Array.prototype.slice.apply(node.children).some(function(child) {
    return child.tagName === "SUMMARY";
  });
  return r2;
};
var getCheckedRadio = function getCheckedRadio2(nodes2, form) {
  for (var i2 = 0; i2 < nodes2.length; i2++) {
    if (nodes2[i2].checked && nodes2[i2].form === form) {
      return nodes2[i2];
    }
  }
};
var isTabbableRadio = function isTabbableRadio2(node) {
  if (!node.name) {
    return true;
  }
  var radioScope = node.form || getRootNode(node);
  var queryRadios = function queryRadios2(name) {
    return radioScope.querySelectorAll('input[type="radio"][name="' + name + '"]');
  };
  var radioSet;
  if (typeof window !== "undefined" && typeof window.CSS !== "undefined" && typeof window.CSS.escape === "function") {
    radioSet = queryRadios(window.CSS.escape(node.name));
  } else {
    try {
      radioSet = queryRadios(node.name);
    } catch (err2) {
      console.error("Looks like you have a radio button with a name attribute containing invalid CSS selector characters and need the CSS.escape polyfill: %s", err2.message);
      return false;
    }
  }
  var checked = getCheckedRadio(radioSet, node.form);
  return !checked || checked === node;
};
var isRadio = function isRadio2(node) {
  return isInput(node) && node.type === "radio";
};
var isNonTabbableRadio = function isNonTabbableRadio2(node) {
  return isRadio(node) && !isTabbableRadio(node);
};
var isNodeAttached = function isNodeAttached2(node) {
  var _nodeRoot;
  var nodeRoot = node && getRootNode(node);
  var nodeRootHost = (_nodeRoot = nodeRoot) === null || _nodeRoot === void 0 ? void 0 : _nodeRoot.host;
  var attached = false;
  if (nodeRoot && nodeRoot !== node) {
    var _nodeRootHost, _nodeRootHost$ownerDo, _node$ownerDocument;
    attached = !!((_nodeRootHost = nodeRootHost) !== null && _nodeRootHost !== void 0 && (_nodeRootHost$ownerDo = _nodeRootHost.ownerDocument) !== null && _nodeRootHost$ownerDo !== void 0 && _nodeRootHost$ownerDo.contains(nodeRootHost) || node !== null && node !== void 0 && (_node$ownerDocument = node.ownerDocument) !== null && _node$ownerDocument !== void 0 && _node$ownerDocument.contains(node));
    while (!attached && nodeRootHost) {
      var _nodeRoot2, _nodeRootHost2, _nodeRootHost2$ownerD;
      nodeRoot = getRootNode(nodeRootHost);
      nodeRootHost = (_nodeRoot2 = nodeRoot) === null || _nodeRoot2 === void 0 ? void 0 : _nodeRoot2.host;
      attached = !!((_nodeRootHost2 = nodeRootHost) !== null && _nodeRootHost2 !== void 0 && (_nodeRootHost2$ownerD = _nodeRootHost2.ownerDocument) !== null && _nodeRootHost2$ownerD !== void 0 && _nodeRootHost2$ownerD.contains(nodeRootHost));
    }
  }
  return attached;
};
var isZeroArea = function isZeroArea2(node) {
  var _node$getBoundingClie = node.getBoundingClientRect(), width = _node$getBoundingClie.width, height = _node$getBoundingClie.height;
  return width === 0 && height === 0;
};
var isHidden = function isHidden2(node, _ref) {
  var displayCheck = _ref.displayCheck, getShadowRoot = _ref.getShadowRoot;
  if (getComputedStyle(node).visibility === "hidden") {
    return true;
  }
  var isDirectSummary = matches.call(node, "details>summary:first-of-type");
  var nodeUnderDetails = isDirectSummary ? node.parentElement : node;
  if (matches.call(nodeUnderDetails, "details:not([open]) *")) {
    return true;
  }
  if (!displayCheck || displayCheck === "full" || displayCheck === "legacy-full") {
    if (typeof getShadowRoot === "function") {
      var originalNode = node;
      while (node) {
        var parentElement = node.parentElement;
        var rootNode = getRootNode(node);
        if (parentElement && !parentElement.shadowRoot && getShadowRoot(parentElement) === true) {
          return isZeroArea(node);
        } else if (node.assignedSlot) {
          node = node.assignedSlot;
        } else if (!parentElement && rootNode !== node.ownerDocument) {
          node = rootNode.host;
        } else {
          node = parentElement;
        }
      }
      node = originalNode;
    }
    if (isNodeAttached(node)) {
      return !node.getClientRects().length;
    }
    if (displayCheck !== "legacy-full") {
      return true;
    }
  } else if (displayCheck === "non-zero-area") {
    return isZeroArea(node);
  }
  return false;
};
var isDisabledFromFieldset = function isDisabledFromFieldset2(node) {
  if (/^(INPUT|BUTTON|SELECT|TEXTAREA)$/.test(node.tagName)) {
    var parentNode = node.parentElement;
    while (parentNode) {
      if (parentNode.tagName === "FIELDSET" && parentNode.disabled) {
        for (var i2 = 0; i2 < parentNode.children.length; i2++) {
          var child = parentNode.children.item(i2);
          if (child.tagName === "LEGEND") {
            return matches.call(parentNode, "fieldset[disabled] *") ? true : !child.contains(node);
          }
        }
        return true;
      }
      parentNode = parentNode.parentElement;
    }
  }
  return false;
};
var isNodeMatchingSelectorFocusable = function isNodeMatchingSelectorFocusable2(options, node) {
  if (node.disabled || // we must do an inert look up to filter out any elements inside an inert ancestor
  //  because we're limited in the type of selectors we can use in JSDom (see related
  //  note related to `candidateSelectors`)
  isInert(node) || isHiddenInput(node) || isHidden(node, options) || // For a details element with a summary, the summary element gets the focus
  isDetailsWithSummary(node) || isDisabledFromFieldset(node)) {
    return false;
  }
  return true;
};
var isNodeMatchingSelectorTabbable = function isNodeMatchingSelectorTabbable2(options, node) {
  if (isNonTabbableRadio(node) || getTabIndex(node) < 0 || !isNodeMatchingSelectorFocusable(options, node)) {
    return false;
  }
  return true;
};
var isValidShadowRootTabbable = function isValidShadowRootTabbable2(shadowHostNode) {
  var tabIndex = parseInt(shadowHostNode.getAttribute("tabindex"), 10);
  if (isNaN(tabIndex) || tabIndex >= 0) {
    return true;
  }
  return false;
};
var sortByOrder = function sortByOrder2(candidates) {
  var regularTabbables = [];
  var orderedTabbables = [];
  candidates.forEach(function(item, i2) {
    var isScope = !!item.scopeParent;
    var element = isScope ? item.scopeParent : item;
    var candidateTabindex = getSortOrderTabIndex(element, isScope);
    var elements = isScope ? sortByOrder2(item.candidates) : element;
    if (candidateTabindex === 0) {
      isScope ? regularTabbables.push.apply(regularTabbables, elements) : regularTabbables.push(element);
    } else {
      orderedTabbables.push({
        documentOrder: i2,
        tabIndex: candidateTabindex,
        item,
        isScope,
        content: elements
      });
    }
  });
  return orderedTabbables.sort(sortOrderedTabbables).reduce(function(acc, sortable) {
    sortable.isScope ? acc.push.apply(acc, sortable.content) : acc.push(sortable.content);
    return acc;
  }, []).concat(regularTabbables);
};
var tabbable = function tabbable2(container, options) {
  options = options || {};
  var candidates;
  if (options.getShadowRoot) {
    candidates = getCandidatesIteratively([container], options.includeContainer, {
      filter: isNodeMatchingSelectorTabbable.bind(null, options),
      flatten: false,
      getShadowRoot: options.getShadowRoot,
      shadowRootFilter: isValidShadowRootTabbable
    });
  } else {
    candidates = getCandidates(container, options.includeContainer, isNodeMatchingSelectorTabbable.bind(null, options));
  }
  return sortByOrder(candidates);
};
function _extends$1() {
  _extends$1 = Object.assign ? Object.assign.bind() : function(target) {
    for (var i2 = 1; i2 < arguments.length; i2++) {
      var source = arguments[i2];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends$1.apply(this, arguments);
}
var index$1 = typeof document !== "undefined" ? reactExports.useLayoutEffect : reactExports.useEffect;
let serverHandoffComplete = false;
let count$2 = 0;
const genId = () => "floating-ui-" + count$2++;
function useFloatingId() {
  const [id2, setId] = reactExports.useState(() => serverHandoffComplete ? genId() : void 0);
  index$1(() => {
    if (id2 == null) {
      setId(genId());
    }
  }, []);
  reactExports.useEffect(() => {
    if (!serverHandoffComplete) {
      serverHandoffComplete = true;
    }
  }, []);
  return id2;
}
const useReactId = React$1[/* @__PURE__ */ "useId".toString()];
const useId = useReactId || useFloatingId;
function createPubSub() {
  const map = /* @__PURE__ */ new Map();
  return {
    emit(event, data) {
      var _map$get;
      (_map$get = map.get(event)) == null ? void 0 : _map$get.forEach((handler) => handler(data));
    },
    on(event, listener) {
      map.set(event, [...map.get(event) || [], listener]);
    },
    off(event, listener) {
      var _map$get2;
      map.set(event, ((_map$get2 = map.get(event)) == null ? void 0 : _map$get2.filter((l2) => l2 !== listener)) || []);
    }
  };
}
const FloatingNodeContext = /* @__PURE__ */ reactExports.createContext(null);
const FloatingTreeContext = /* @__PURE__ */ reactExports.createContext(null);
const useFloatingParentNodeId = () => {
  var _React$useContext;
  return ((_React$useContext = reactExports.useContext(FloatingNodeContext)) == null ? void 0 : _React$useContext.id) || null;
};
const useFloatingTree = () => reactExports.useContext(FloatingTreeContext);
function getDocument(node) {
  return (node == null ? void 0 : node.ownerDocument) || document;
}
function getPlatform() {
  const uaData = navigator.userAgentData;
  if (uaData != null && uaData.platform) {
    return uaData.platform;
  }
  return navigator.platform;
}
function getUserAgent() {
  const uaData = navigator.userAgentData;
  if (uaData && Array.isArray(uaData.brands)) {
    return uaData.brands.map((_ref) => {
      let {
        brand,
        version
      } = _ref;
      return brand + "/" + version;
    }).join(" ");
  }
  return navigator.userAgent;
}
function getWindow(value) {
  return getDocument(value).defaultView || window;
}
function isElement$1(value) {
  return value ? value instanceof Element || value instanceof getWindow(value).Element : false;
}
function isHTMLElement(value) {
  return value ? value instanceof HTMLElement || value instanceof getWindow(value).HTMLElement : false;
}
function isShadowRoot(node) {
  if (typeof ShadowRoot === "undefined") {
    return false;
  }
  const OwnElement = getWindow(node).ShadowRoot;
  return node instanceof OwnElement || node instanceof ShadowRoot;
}
function isVirtualClick(event) {
  if (event.mozInputSource === 0 && event.isTrusted) {
    return true;
  }
  const androidRe = /Android/i;
  if ((androidRe.test(getPlatform()) || androidRe.test(getUserAgent())) && event.pointerType) {
    return event.type === "click" && event.buttons === 1;
  }
  return event.detail === 0 && !event.pointerType;
}
function isVirtualPointerEvent(event) {
  return event.width === 0 && event.height === 0 || event.width === 1 && event.height === 1 && event.pressure === 0 && event.detail === 0 && event.pointerType !== "mouse" || // iOS VoiceOver returns 0.333• for width/height.
  event.width < 1 && event.height < 1 && event.pressure === 0 && event.detail === 0;
}
function isSafari() {
  return /apple/i.test(navigator.vendor);
}
function isMac() {
  return getPlatform().toLowerCase().startsWith("mac") && !navigator.maxTouchPoints;
}
function isMouseLikePointerType(pointerType, strict) {
  const values2 = ["mouse", "pen"];
  if (!strict) {
    values2.push("", void 0);
  }
  return values2.includes(pointerType);
}
function isReactEvent(event) {
  return "nativeEvent" in event;
}
function contains(parent, child) {
  if (!parent || !child) {
    return false;
  }
  const rootNode = child.getRootNode && child.getRootNode();
  if (parent.contains(child)) {
    return true;
  }
  if (rootNode && isShadowRoot(rootNode)) {
    let next = child;
    while (next) {
      if (parent === next) {
        return true;
      }
      next = next.parentNode || next.host;
    }
  }
  return false;
}
function createAttribute(name) {
  return "data-floating-ui-" + name;
}
function useLatestRef(value) {
  const ref = reactExports.useRef(value);
  index$1(() => {
    ref.current = value;
  });
  return ref;
}
const safePolygonIdentifier = /* @__PURE__ */ createAttribute("safe-polygon");
function getDelay(value, prop, pointerType) {
  if (pointerType && !isMouseLikePointerType(pointerType)) {
    return 0;
  }
  if (typeof value === "number") {
    return value;
  }
  return value == null ? void 0 : value[prop];
}
function useHover(context, props) {
  if (props === void 0) {
    props = {};
  }
  const {
    open,
    onOpenChange,
    dataRef,
    events,
    elements: {
      domReference,
      floating
    },
    refs
  } = context;
  const {
    enabled = true,
    delay = 0,
    handleClose = null,
    mouseOnly = false,
    restMs = 0,
    move: move3 = true
  } = props;
  const tree = useFloatingTree();
  const parentId = useFloatingParentNodeId();
  const handleCloseRef = useLatestRef(handleClose);
  const delayRef = useLatestRef(delay);
  const pointerTypeRef = reactExports.useRef();
  const timeoutRef = reactExports.useRef();
  const handlerRef = reactExports.useRef();
  const restTimeoutRef = reactExports.useRef();
  const blockMouseMoveRef = reactExports.useRef(true);
  const performedPointerEventsMutationRef = reactExports.useRef(false);
  const unbindMouseMoveRef = reactExports.useRef(() => {
  });
  const isHoverOpen = reactExports.useCallback(() => {
    var _dataRef$current$open;
    const type = (_dataRef$current$open = dataRef.current.openEvent) == null ? void 0 : _dataRef$current$open.type;
    return (type == null ? void 0 : type.includes("mouse")) && type !== "mousedown";
  }, [dataRef]);
  reactExports.useEffect(() => {
    if (!enabled) {
      return;
    }
    function onDismiss() {
      clearTimeout(timeoutRef.current);
      clearTimeout(restTimeoutRef.current);
      blockMouseMoveRef.current = true;
    }
    events.on("dismiss", onDismiss);
    return () => {
      events.off("dismiss", onDismiss);
    };
  }, [enabled, events]);
  reactExports.useEffect(() => {
    if (!enabled || !handleCloseRef.current || !open) {
      return;
    }
    function onLeave(event) {
      if (isHoverOpen()) {
        onOpenChange(false, event);
      }
    }
    const html = getDocument(floating).documentElement;
    html.addEventListener("mouseleave", onLeave);
    return () => {
      html.removeEventListener("mouseleave", onLeave);
    };
  }, [floating, open, onOpenChange, enabled, handleCloseRef, dataRef, isHoverOpen]);
  const closeWithDelay = reactExports.useCallback(function(event, runElseBranch) {
    if (runElseBranch === void 0) {
      runElseBranch = true;
    }
    const closeDelay = getDelay(delayRef.current, "close", pointerTypeRef.current);
    if (closeDelay && !handlerRef.current) {
      clearTimeout(timeoutRef.current);
      timeoutRef.current = setTimeout(() => onOpenChange(false, event), closeDelay);
    } else if (runElseBranch) {
      clearTimeout(timeoutRef.current);
      onOpenChange(false, event);
    }
  }, [delayRef, onOpenChange]);
  const cleanupMouseMoveHandler = reactExports.useCallback(() => {
    unbindMouseMoveRef.current();
    handlerRef.current = void 0;
  }, []);
  const clearPointerEvents = reactExports.useCallback(() => {
    if (performedPointerEventsMutationRef.current) {
      const body = getDocument(refs.floating.current).body;
      body.style.pointerEvents = "";
      body.removeAttribute(safePolygonIdentifier);
      performedPointerEventsMutationRef.current = false;
    }
  }, [refs]);
  reactExports.useEffect(() => {
    if (!enabled) {
      return;
    }
    function isClickLikeOpenEvent() {
      return dataRef.current.openEvent ? ["click", "mousedown"].includes(dataRef.current.openEvent.type) : false;
    }
    function onMouseEnter(event) {
      clearTimeout(timeoutRef.current);
      blockMouseMoveRef.current = false;
      if (mouseOnly && !isMouseLikePointerType(pointerTypeRef.current) || restMs > 0 && getDelay(delayRef.current, "open") === 0) {
        return;
      }
      const openDelay = getDelay(delayRef.current, "open", pointerTypeRef.current);
      if (openDelay) {
        timeoutRef.current = setTimeout(() => {
          onOpenChange(true, event);
        }, openDelay);
      } else {
        onOpenChange(true, event);
      }
    }
    function onMouseLeave(event) {
      if (isClickLikeOpenEvent()) {
        return;
      }
      unbindMouseMoveRef.current();
      const doc = getDocument(floating);
      clearTimeout(restTimeoutRef.current);
      if (handleCloseRef.current) {
        if (!open) {
          clearTimeout(timeoutRef.current);
        }
        handlerRef.current = handleCloseRef.current({
          ...context,
          tree,
          x: event.clientX,
          y: event.clientY,
          onClose() {
            clearPointerEvents();
            cleanupMouseMoveHandler();
            closeWithDelay(event);
          }
        });
        const handler = handlerRef.current;
        doc.addEventListener("mousemove", handler);
        unbindMouseMoveRef.current = () => {
          doc.removeEventListener("mousemove", handler);
        };
        return;
      }
      const shouldClose = pointerTypeRef.current === "touch" ? !contains(floating, event.relatedTarget) : true;
      if (shouldClose) {
        closeWithDelay(event);
      }
    }
    function onScrollMouseLeave(event) {
      if (isClickLikeOpenEvent()) {
        return;
      }
      handleCloseRef.current == null ? void 0 : handleCloseRef.current({
        ...context,
        tree,
        x: event.clientX,
        y: event.clientY,
        onClose() {
          clearPointerEvents();
          cleanupMouseMoveHandler();
          closeWithDelay(event);
        }
      })(event);
    }
    if (isElement$1(domReference)) {
      const ref = domReference;
      open && ref.addEventListener("mouseleave", onScrollMouseLeave);
      floating == null ? void 0 : floating.addEventListener("mouseleave", onScrollMouseLeave);
      move3 && ref.addEventListener("mousemove", onMouseEnter, {
        once: true
      });
      ref.addEventListener("mouseenter", onMouseEnter);
      ref.addEventListener("mouseleave", onMouseLeave);
      return () => {
        open && ref.removeEventListener("mouseleave", onScrollMouseLeave);
        floating == null ? void 0 : floating.removeEventListener("mouseleave", onScrollMouseLeave);
        move3 && ref.removeEventListener("mousemove", onMouseEnter);
        ref.removeEventListener("mouseenter", onMouseEnter);
        ref.removeEventListener("mouseleave", onMouseLeave);
      };
    }
  }, [domReference, floating, enabled, context, mouseOnly, restMs, move3, closeWithDelay, cleanupMouseMoveHandler, clearPointerEvents, onOpenChange, open, tree, delayRef, handleCloseRef, dataRef]);
  index$1(() => {
    var _handleCloseRef$curre;
    if (!enabled) {
      return;
    }
    if (open && (_handleCloseRef$curre = handleCloseRef.current) != null && _handleCloseRef$curre.__options.blockPointerEvents && isHoverOpen()) {
      const body = getDocument(floating).body;
      body.setAttribute(safePolygonIdentifier, "");
      body.style.pointerEvents = "none";
      performedPointerEventsMutationRef.current = true;
      if (isElement$1(domReference) && floating) {
        var _tree$nodesRef$curren, _tree$nodesRef$curren2;
        const ref = domReference;
        const parentFloating = tree == null ? void 0 : (_tree$nodesRef$curren = tree.nodesRef.current.find((node) => node.id === parentId)) == null ? void 0 : (_tree$nodesRef$curren2 = _tree$nodesRef$curren.context) == null ? void 0 : _tree$nodesRef$curren2.elements.floating;
        if (parentFloating) {
          parentFloating.style.pointerEvents = "";
        }
        ref.style.pointerEvents = "auto";
        floating.style.pointerEvents = "auto";
        return () => {
          ref.style.pointerEvents = "";
          floating.style.pointerEvents = "";
        };
      }
    }
  }, [enabled, open, parentId, floating, domReference, tree, handleCloseRef, dataRef, isHoverOpen]);
  index$1(() => {
    if (!open) {
      pointerTypeRef.current = void 0;
      cleanupMouseMoveHandler();
      clearPointerEvents();
    }
  }, [open, cleanupMouseMoveHandler, clearPointerEvents]);
  reactExports.useEffect(() => {
    return () => {
      cleanupMouseMoveHandler();
      clearTimeout(timeoutRef.current);
      clearTimeout(restTimeoutRef.current);
      clearPointerEvents();
    };
  }, [enabled, cleanupMouseMoveHandler, clearPointerEvents]);
  return reactExports.useMemo(() => {
    if (!enabled) {
      return {};
    }
    function setPointerRef(event) {
      pointerTypeRef.current = event.pointerType;
    }
    return {
      reference: {
        onPointerDown: setPointerRef,
        onPointerEnter: setPointerRef,
        onMouseMove(event) {
          if (open || restMs === 0) {
            return;
          }
          clearTimeout(restTimeoutRef.current);
          restTimeoutRef.current = setTimeout(() => {
            if (!blockMouseMoveRef.current) {
              onOpenChange(true, event.nativeEvent);
            }
          }, restMs);
        }
      },
      floating: {
        onMouseEnter() {
          clearTimeout(timeoutRef.current);
        },
        onMouseLeave(event) {
          events.emit("dismiss", {
            type: "mouseLeave",
            data: {
              returnFocus: false
            }
          });
          closeWithDelay(event.nativeEvent, false);
        }
      }
    };
  }, [events, enabled, restMs, open, onOpenChange, closeWithDelay]);
}
function activeElement(doc) {
  let activeElement2 = doc.activeElement;
  while (((_activeElement = activeElement2) == null ? void 0 : (_activeElement$shadow = _activeElement.shadowRoot) == null ? void 0 : _activeElement$shadow.activeElement) != null) {
    var _activeElement, _activeElement$shadow;
    activeElement2 = activeElement2.shadowRoot.activeElement;
  }
  return activeElement2;
}
let rafId = 0;
function enqueueFocus(el2, options) {
  if (options === void 0) {
    options = {};
  }
  const {
    preventScroll = false,
    cancelPrevious = true,
    sync = false
  } = options;
  cancelPrevious && cancelAnimationFrame(rafId);
  const exec = () => el2 == null ? void 0 : el2.focus({
    preventScroll
  });
  if (sync) {
    exec();
  } else {
    rafId = requestAnimationFrame(exec);
  }
}
function getAncestors(nodes2, id2) {
  var _nodes$find;
  let allAncestors = [];
  let currentParentId = (_nodes$find = nodes2.find((node) => node.id === id2)) == null ? void 0 : _nodes$find.parentId;
  while (currentParentId) {
    const currentNode = nodes2.find((node) => node.id === currentParentId);
    currentParentId = currentNode == null ? void 0 : currentNode.parentId;
    if (currentNode) {
      allAncestors = allAncestors.concat(currentNode);
    }
  }
  return allAncestors;
}
function getChildren(nodes2, id2) {
  let allChildren = nodes2.filter((node) => {
    var _node$context;
    return node.parentId === id2 && ((_node$context = node.context) == null ? void 0 : _node$context.open);
  });
  let currentChildren = allChildren;
  while (currentChildren.length) {
    currentChildren = nodes2.filter((node) => {
      var _currentChildren;
      return (_currentChildren = currentChildren) == null ? void 0 : _currentChildren.some((n2) => {
        var _node$context2;
        return node.parentId === n2.id && ((_node$context2 = node.context) == null ? void 0 : _node$context2.open);
      });
    });
    allChildren = allChildren.concat(currentChildren);
  }
  return allChildren;
}
function getTarget$1(event) {
  if ("composedPath" in event) {
    return event.composedPath()[0];
  }
  return event.target;
}
const TYPEABLE_SELECTOR = "input:not([type='hidden']):not([disabled]),[contenteditable]:not([contenteditable='false']),textarea:not([disabled])";
function isTypeableElement(element) {
  return isHTMLElement(element) && element.matches(TYPEABLE_SELECTOR);
}
function stopEvent(event) {
  event.preventDefault();
  event.stopPropagation();
}
const getTabbableOptions = () => ({
  getShadowRoot: true,
  displayCheck: (
    // JSDOM does not support the `tabbable` library. To solve this we can
    // check if `ResizeObserver` is a real function (not polyfilled), which
    // determines if the current environment is JSDOM-like.
    typeof ResizeObserver === "function" && ResizeObserver.toString().includes("[native code]") ? "full" : "none"
  )
});
function getTabbableIn(container, direction) {
  const allTabbable = tabbable(container, getTabbableOptions());
  if (direction === "prev") {
    allTabbable.reverse();
  }
  const activeIndex = allTabbable.indexOf(activeElement(getDocument(container)));
  const nextTabbableElements = allTabbable.slice(activeIndex + 1);
  return nextTabbableElements[0];
}
function getNextTabbable() {
  return getTabbableIn(document.body, "next");
}
function getPreviousTabbable() {
  return getTabbableIn(document.body, "prev");
}
function isOutsideEvent(event, container) {
  const containerElement = container || event.currentTarget;
  const relatedTarget = event.relatedTarget;
  return !relatedTarget || !contains(containerElement, relatedTarget);
}
function disableFocusInside(container) {
  const tabbableElements = tabbable(container, getTabbableOptions());
  tabbableElements.forEach((element) => {
    element.dataset.tabindex = element.getAttribute("tabindex") || "";
    element.setAttribute("tabindex", "-1");
  });
}
function enableFocusInside(container) {
  const elements = container.querySelectorAll("[data-tabindex]");
  elements.forEach((element) => {
    const tabindex = element.dataset.tabindex;
    delete element.dataset.tabindex;
    if (tabindex) {
      element.setAttribute("tabindex", tabindex);
    } else {
      element.removeAttribute("tabindex");
    }
  });
}
const HIDDEN_STYLES = {
  border: 0,
  clip: "rect(0 0 0 0)",
  height: "1px",
  margin: "-1px",
  overflow: "hidden",
  padding: 0,
  position: "fixed",
  whiteSpace: "nowrap",
  width: "1px",
  top: 0,
  left: 0
};
let timeoutId;
function setActiveElementOnTab(event) {
  if (event.key === "Tab") {
    event.target;
    clearTimeout(timeoutId);
  }
}
const FocusGuard = /* @__PURE__ */ reactExports.forwardRef(function FocusGuard2(props, ref) {
  const [role, setRole] = reactExports.useState();
  index$1(() => {
    if (isSafari()) {
      setRole("button");
    }
    document.addEventListener("keydown", setActiveElementOnTab);
    return () => {
      document.removeEventListener("keydown", setActiveElementOnTab);
    };
  }, []);
  const restProps = {
    ref,
    tabIndex: 0,
    // Role is only for VoiceOver
    role,
    "aria-hidden": role ? void 0 : true,
    [createAttribute("focus-guard")]: "",
    style: HIDDEN_STYLES
  };
  return /* @__PURE__ */ reactExports.createElement("span", _extends$1({}, props, restProps));
});
const PortalContext = /* @__PURE__ */ reactExports.createContext(null);
function useFloatingPortalNode(_temp) {
  let {
    id: id2,
    root
  } = _temp === void 0 ? {} : _temp;
  const [portalNode, setPortalNode] = reactExports.useState(null);
  const uniqueId = useId();
  const portalContext = usePortalContext();
  const data = reactExports.useMemo(() => ({
    id: id2,
    root,
    portalContext,
    uniqueId
  }), [id2, root, portalContext, uniqueId]);
  const dataRef = reactExports.useRef();
  index$1(() => {
    return () => {
      portalNode == null ? void 0 : portalNode.remove();
    };
  }, [portalNode, data]);
  index$1(() => {
    if (dataRef.current === data)
      return;
    dataRef.current = data;
    const {
      id: id3,
      root: root2,
      portalContext: portalContext2,
      uniqueId: uniqueId2
    } = data;
    const existingIdRoot = id3 ? document.getElementById(id3) : null;
    const attr = createAttribute("portal");
    if (existingIdRoot) {
      const subRoot = document.createElement("div");
      subRoot.id = uniqueId2;
      subRoot.setAttribute(attr, "");
      existingIdRoot.appendChild(subRoot);
      setPortalNode(subRoot);
    } else {
      let container = root2 || (portalContext2 == null ? void 0 : portalContext2.portalNode);
      if (container && !isElement$1(container))
        container = container.current;
      container = container || document.body;
      let idWrapper = null;
      if (id3) {
        idWrapper = document.createElement("div");
        idWrapper.id = id3;
        container.appendChild(idWrapper);
      }
      const subRoot = document.createElement("div");
      subRoot.id = uniqueId2;
      subRoot.setAttribute(attr, "");
      container = idWrapper || container;
      container.appendChild(subRoot);
      setPortalNode(subRoot);
    }
  }, [data]);
  return portalNode;
}
function FloatingPortal(_ref) {
  let {
    children,
    id: id2,
    root = null,
    preserveTabOrder = true
  } = _ref;
  const portalNode = useFloatingPortalNode({
    id: id2,
    root
  });
  const [focusManagerState, setFocusManagerState] = reactExports.useState(null);
  const beforeOutsideRef = reactExports.useRef(null);
  const afterOutsideRef = reactExports.useRef(null);
  const beforeInsideRef = reactExports.useRef(null);
  const afterInsideRef = reactExports.useRef(null);
  const shouldRenderGuards = (
    // The FocusManager and therefore floating element are currently open/
    // rendered.
    !!focusManagerState && // Guards are only for non-modal focus management.
    !focusManagerState.modal && // Don't render if unmount is transitioning.
    focusManagerState.open && preserveTabOrder && !!(root || portalNode)
  );
  reactExports.useEffect(() => {
    if (!portalNode || !preserveTabOrder || focusManagerState != null && focusManagerState.modal) {
      return;
    }
    function onFocus(event) {
      if (portalNode && isOutsideEvent(event)) {
        const focusing = event.type === "focusin";
        const manageFocus = focusing ? enableFocusInside : disableFocusInside;
        manageFocus(portalNode);
      }
    }
    portalNode.addEventListener("focusin", onFocus, true);
    portalNode.addEventListener("focusout", onFocus, true);
    return () => {
      portalNode.removeEventListener("focusin", onFocus, true);
      portalNode.removeEventListener("focusout", onFocus, true);
    };
  }, [portalNode, preserveTabOrder, focusManagerState == null ? void 0 : focusManagerState.modal]);
  return /* @__PURE__ */ reactExports.createElement(PortalContext.Provider, {
    value: reactExports.useMemo(() => ({
      preserveTabOrder,
      beforeOutsideRef,
      afterOutsideRef,
      beforeInsideRef,
      afterInsideRef,
      portalNode,
      setFocusManagerState
    }), [preserveTabOrder, portalNode])
  }, shouldRenderGuards && portalNode && /* @__PURE__ */ reactExports.createElement(FocusGuard, {
    "data-type": "outside",
    ref: beforeOutsideRef,
    onFocus: (event) => {
      if (isOutsideEvent(event, portalNode)) {
        var _beforeInsideRef$curr;
        (_beforeInsideRef$curr = beforeInsideRef.current) == null ? void 0 : _beforeInsideRef$curr.focus();
      } else {
        const prevTabbable = getPreviousTabbable() || (focusManagerState == null ? void 0 : focusManagerState.refs.domReference.current);
        prevTabbable == null ? void 0 : prevTabbable.focus();
      }
    }
  }), shouldRenderGuards && portalNode && /* @__PURE__ */ reactExports.createElement("span", {
    "aria-owns": portalNode.id,
    style: HIDDEN_STYLES
  }), portalNode && /* @__PURE__ */ reactDomExports.createPortal(children, portalNode), shouldRenderGuards && portalNode && /* @__PURE__ */ reactExports.createElement(FocusGuard, {
    "data-type": "outside",
    ref: afterOutsideRef,
    onFocus: (event) => {
      if (isOutsideEvent(event, portalNode)) {
        var _afterInsideRef$curre;
        (_afterInsideRef$curre = afterInsideRef.current) == null ? void 0 : _afterInsideRef$curre.focus();
      } else {
        const nextTabbable = getNextTabbable() || (focusManagerState == null ? void 0 : focusManagerState.refs.domReference.current);
        nextTabbable == null ? void 0 : nextTabbable.focus();
        (focusManagerState == null ? void 0 : focusManagerState.closeOnFocusOut) && (focusManagerState == null ? void 0 : focusManagerState.onOpenChange(false, event.nativeEvent));
      }
    }
  }));
}
const usePortalContext = () => reactExports.useContext(PortalContext);
const VisuallyHiddenDismiss = /* @__PURE__ */ reactExports.forwardRef(function VisuallyHiddenDismiss2(props, ref) {
  return /* @__PURE__ */ reactExports.createElement("button", _extends$1({}, props, {
    type: "button",
    ref,
    tabIndex: -1,
    style: HIDDEN_STYLES
  }));
});
function FloatingFocusManager(props) {
  const {
    context,
    children,
    disabled = false,
    order = ["content"],
    guards: _guards = true,
    initialFocus = 0,
    returnFocus = true,
    modal = true,
    visuallyHiddenDismiss = false,
    closeOnFocusOut = true
  } = props;
  const {
    open,
    refs,
    nodeId,
    onOpenChange,
    events,
    dataRef,
    elements: {
      domReference,
      floating
    }
  } = context;
  const guards = supportsInert() ? _guards : true;
  const orderRef = useLatestRef(order);
  const initialFocusRef = useLatestRef(initialFocus);
  const returnFocusRef = useLatestRef(returnFocus);
  const tree = useFloatingTree();
  const portalContext = usePortalContext();
  const ignoreInitialFocus = typeof initialFocus === "number" && initialFocus < 0;
  const startDismissButtonRef = reactExports.useRef(null);
  const endDismissButtonRef = reactExports.useRef(null);
  const preventReturnFocusRef = reactExports.useRef(false);
  const previouslyFocusedElementRef = reactExports.useRef(null);
  const isPointerDownRef = reactExports.useRef(false);
  const isInsidePortal = portalContext != null;
  const isTypeableCombobox = domReference && domReference.getAttribute("role") === "combobox" && isTypeableElement(domReference);
  const getTabbableContent = reactExports.useCallback(function(container) {
    if (container === void 0) {
      container = floating;
    }
    return container ? tabbable(container, getTabbableOptions()) : [];
  }, [floating]);
  const getTabbableElements = reactExports.useCallback((container) => {
    const content = getTabbableContent(container);
    return orderRef.current.map((type) => {
      if (domReference && type === "reference") {
        return domReference;
      }
      if (floating && type === "floating") {
        return floating;
      }
      return content;
    }).filter(Boolean).flat();
  }, [domReference, floating, orderRef, getTabbableContent]);
  reactExports.useEffect(() => {
    if (disabled || !modal)
      return;
    function onKeyDown(event) {
      if (event.key === "Tab") {
        if (contains(floating, activeElement(getDocument(floating))) && getTabbableContent().length === 0 && !isTypeableCombobox) {
          stopEvent(event);
        }
        const els = getTabbableElements();
        const target = getTarget$1(event);
        if (orderRef.current[0] === "reference" && target === domReference) {
          stopEvent(event);
          if (event.shiftKey) {
            enqueueFocus(els[els.length - 1]);
          } else {
            enqueueFocus(els[1]);
          }
        }
        if (orderRef.current[1] === "floating" && target === floating && event.shiftKey) {
          stopEvent(event);
          enqueueFocus(els[0]);
        }
      }
    }
    const doc = getDocument(floating);
    doc.addEventListener("keydown", onKeyDown);
    return () => {
      doc.removeEventListener("keydown", onKeyDown);
    };
  }, [disabled, domReference, floating, modal, orderRef, refs, isTypeableCombobox, getTabbableContent, getTabbableElements]);
  reactExports.useEffect(() => {
    if (disabled || !closeOnFocusOut)
      return;
    function handlePointerDown() {
      isPointerDownRef.current = true;
      setTimeout(() => {
        isPointerDownRef.current = false;
      });
    }
    function handleFocusOutside(event) {
      const relatedTarget = event.relatedTarget;
      queueMicrotask(() => {
        const movedToUnrelatedNode = !(contains(domReference, relatedTarget) || contains(floating, relatedTarget) || contains(relatedTarget, floating) || contains(portalContext == null ? void 0 : portalContext.portalNode, relatedTarget) || relatedTarget != null && relatedTarget.hasAttribute(createAttribute("focus-guard")) || tree && (getChildren(tree.nodesRef.current, nodeId).find((node) => {
          var _node$context, _node$context2;
          return contains((_node$context = node.context) == null ? void 0 : _node$context.elements.floating, relatedTarget) || contains((_node$context2 = node.context) == null ? void 0 : _node$context2.elements.domReference, relatedTarget);
        }) || getAncestors(tree.nodesRef.current, nodeId).find((node) => {
          var _node$context3, _node$context4;
          return ((_node$context3 = node.context) == null ? void 0 : _node$context3.elements.floating) === relatedTarget || ((_node$context4 = node.context) == null ? void 0 : _node$context4.elements.domReference) === relatedTarget;
        })));
        if (relatedTarget && movedToUnrelatedNode && !isPointerDownRef.current && // Fix React 18 Strict Mode returnFocus due to double rendering.
        relatedTarget !== previouslyFocusedElementRef.current) {
          preventReturnFocusRef.current = true;
          onOpenChange(false, event);
        }
      });
    }
    if (floating && isHTMLElement(domReference)) {
      domReference.addEventListener("focusout", handleFocusOutside);
      domReference.addEventListener("pointerdown", handlePointerDown);
      !modal && floating.addEventListener("focusout", handleFocusOutside);
      return () => {
        domReference.removeEventListener("focusout", handleFocusOutside);
        domReference.removeEventListener("pointerdown", handlePointerDown);
        !modal && floating.removeEventListener("focusout", handleFocusOutside);
      };
    }
  }, [disabled, domReference, floating, modal, nodeId, tree, portalContext, onOpenChange, closeOnFocusOut]);
  reactExports.useEffect(() => {
    var _portalContext$portal;
    if (disabled)
      return;
    const portalNodes = Array.from((portalContext == null ? void 0 : (_portalContext$portal = portalContext.portalNode) == null ? void 0 : _portalContext$portal.querySelectorAll("[" + createAttribute("portal") + "]")) || []);
    if (floating && modal) {
      const insideNodes = [floating, ...portalNodes, startDismissButtonRef.current, endDismissButtonRef.current].filter((x) => x != null);
      const suppressorFn = guards ? hideOthers : suppressOthers;
      const cleanup = suppressorFn(orderRef.current.includes("reference") || isTypeableCombobox ? insideNodes.concat(domReference || []) : insideNodes, void 0, createAttribute("inert"));
      return () => {
        cleanup();
      };
    }
  }, [disabled, domReference, floating, modal, orderRef, portalContext, isTypeableCombobox, guards]);
  index$1(() => {
    if (disabled || !floating)
      return;
    const doc = getDocument(floating);
    const previouslyFocusedElement = activeElement(doc);
    queueMicrotask(() => {
      const focusableElements = getTabbableElements(floating);
      const initialFocusValue = initialFocusRef.current;
      const elToFocus = (typeof initialFocusValue === "number" ? focusableElements[initialFocusValue] : initialFocusValue.current) || floating;
      const focusAlreadyInsideFloatingEl = contains(floating, previouslyFocusedElement);
      if (!ignoreInitialFocus && !focusAlreadyInsideFloatingEl && open) {
        enqueueFocus(elToFocus, {
          preventScroll: elToFocus === floating
        });
      }
    });
  }, [disabled, open, floating, ignoreInitialFocus, getTabbableElements, initialFocusRef]);
  index$1(() => {
    if (disabled || !floating)
      return;
    let preventReturnFocusScroll = false;
    const doc = getDocument(floating);
    const previouslyFocusedElement = activeElement(doc);
    const contextData = dataRef.current;
    previouslyFocusedElementRef.current = previouslyFocusedElement;
    function onDismiss(payload) {
      if (payload.type === "escapeKey" && refs.domReference.current) {
        previouslyFocusedElementRef.current = refs.domReference.current;
      }
      if (["referencePress", "escapeKey"].includes(payload.type)) {
        return;
      }
      const returnFocus2 = payload.data.returnFocus;
      if (typeof returnFocus2 === "object") {
        preventReturnFocusRef.current = false;
        preventReturnFocusScroll = returnFocus2.preventScroll;
      } else {
        preventReturnFocusRef.current = !returnFocus2;
      }
    }
    events.on("dismiss", onDismiss);
    return () => {
      events.off("dismiss", onDismiss);
      const activeEl = activeElement(doc);
      const shouldFocusReference = contains(floating, activeEl) || tree && getChildren(tree.nodesRef.current, nodeId).some((node) => {
        var _node$context5;
        return contains((_node$context5 = node.context) == null ? void 0 : _node$context5.elements.floating, activeEl);
      }) || contextData.openEvent && ["click", "mousedown"].includes(contextData.openEvent.type);
      if (shouldFocusReference && refs.domReference.current) {
        previouslyFocusedElementRef.current = refs.domReference.current;
      }
      if (
        // eslint-disable-next-line react-hooks/exhaustive-deps
        returnFocusRef.current && isHTMLElement(previouslyFocusedElementRef.current) && !preventReturnFocusRef.current
      ) {
        enqueueFocus(previouslyFocusedElementRef.current, {
          // When dismissing nested floating elements, by the time the rAF has
          // executed, the menus will all have been unmounted. When they try
          // to get focused, the calls get ignored — leaving the root
          // reference focused as desired.
          cancelPrevious: false,
          preventScroll: preventReturnFocusScroll
        });
      }
    };
  }, [disabled, floating, returnFocusRef, dataRef, refs, events, tree, nodeId]);
  index$1(() => {
    if (disabled || !portalContext)
      return;
    portalContext.setFocusManagerState({
      ...context,
      modal,
      closeOnFocusOut,
      open
    });
    return () => {
      portalContext.setFocusManagerState(null);
    };
  }, [disabled, portalContext, modal, open, closeOnFocusOut, context]);
  index$1(() => {
    if (disabled)
      return;
    if (floating && typeof MutationObserver === "function") {
      const handleMutation = () => {
        const tabIndex = floating.getAttribute("tabindex");
        if (orderRef.current.includes("floating") || activeElement(getDocument(floating)) !== refs.domReference.current && getTabbableContent().length === 0) {
          if (tabIndex !== "0") {
            floating.setAttribute("tabindex", "0");
          }
        } else if (tabIndex !== "-1") {
          floating.setAttribute("tabindex", "-1");
        }
      };
      handleMutation();
      const observer = new MutationObserver(handleMutation);
      observer.observe(floating, {
        childList: true,
        subtree: true,
        attributes: true
      });
      return () => {
        observer.disconnect();
      };
    }
  }, [disabled, floating, refs, orderRef, getTabbableContent]);
  function renderDismissButton(location2) {
    if (disabled || !visuallyHiddenDismiss || !modal) {
      return null;
    }
    return /* @__PURE__ */ reactExports.createElement(VisuallyHiddenDismiss, {
      ref: location2 === "start" ? startDismissButtonRef : endDismissButtonRef,
      onClick: (event) => onOpenChange(false, event.nativeEvent)
    }, typeof visuallyHiddenDismiss === "string" ? visuallyHiddenDismiss : "Dismiss");
  }
  const shouldRenderGuards = !disabled && guards && !isTypeableCombobox && (isInsidePortal || modal);
  return /* @__PURE__ */ reactExports.createElement(reactExports.Fragment, null, shouldRenderGuards && /* @__PURE__ */ reactExports.createElement(FocusGuard, {
    "data-type": "inside",
    ref: portalContext == null ? void 0 : portalContext.beforeInsideRef,
    onFocus: (event) => {
      if (modal) {
        const els = getTabbableElements();
        enqueueFocus(order[0] === "reference" ? els[0] : els[els.length - 1]);
      } else if (portalContext != null && portalContext.preserveTabOrder && portalContext.portalNode) {
        preventReturnFocusRef.current = false;
        if (isOutsideEvent(event, portalContext.portalNode)) {
          const nextTabbable = getNextTabbable() || domReference;
          nextTabbable == null ? void 0 : nextTabbable.focus();
        } else {
          var _portalContext$before;
          (_portalContext$before = portalContext.beforeOutsideRef.current) == null ? void 0 : _portalContext$before.focus();
        }
      }
    }
  }), !isTypeableCombobox && renderDismissButton("start"), children, renderDismissButton("end"), shouldRenderGuards && /* @__PURE__ */ reactExports.createElement(FocusGuard, {
    "data-type": "inside",
    ref: portalContext == null ? void 0 : portalContext.afterInsideRef,
    onFocus: (event) => {
      if (modal) {
        enqueueFocus(getTabbableElements()[0]);
      } else if (portalContext != null && portalContext.preserveTabOrder && portalContext.portalNode) {
        if (closeOnFocusOut) {
          preventReturnFocusRef.current = true;
        }
        if (isOutsideEvent(event, portalContext.portalNode)) {
          const prevTabbable = getPreviousTabbable() || domReference;
          prevTabbable == null ? void 0 : prevTabbable.focus();
        } else {
          var _portalContext$afterO;
          (_portalContext$afterO = portalContext.afterOutsideRef.current) == null ? void 0 : _portalContext$afterO.focus();
        }
      }
    }
  }));
}
function sortByDocumentPosition(a2, b2) {
  const position3 = a2.compareDocumentPosition(b2);
  if (position3 & Node.DOCUMENT_POSITION_FOLLOWING || position3 & Node.DOCUMENT_POSITION_CONTAINED_BY) {
    return -1;
  }
  if (position3 & Node.DOCUMENT_POSITION_PRECEDING || position3 & Node.DOCUMENT_POSITION_CONTAINS) {
    return 1;
  }
  return 0;
}
function areMapsEqual(map1, map2) {
  if (map1.size !== map2.size) {
    return false;
  }
  for (const [key, value] of map1.entries()) {
    if (value !== map2.get(key)) {
      return false;
    }
  }
  return true;
}
const FloatingListContext = /* @__PURE__ */ reactExports.createContext({
  register: () => {
  },
  unregister: () => {
  },
  map: /* @__PURE__ */ new Map(),
  elementsRef: {
    current: []
  }
});
function FloatingList(_ref) {
  let {
    children,
    elementsRef,
    labelsRef
  } = _ref;
  const [map, setMap] = reactExports.useState(() => /* @__PURE__ */ new Map());
  const register = reactExports.useCallback((node) => {
    setMap((prevMap) => new Map(prevMap).set(node, null));
  }, []);
  const unregister = reactExports.useCallback((node) => {
    setMap((prevMap) => {
      const map2 = new Map(prevMap);
      map2.delete(node);
      return map2;
    });
  }, []);
  index$1(() => {
    const newMap = new Map(map);
    const nodes2 = Array.from(newMap.keys()).sort(sortByDocumentPosition);
    nodes2.forEach((node, index2) => {
      newMap.set(node, index2);
    });
    if (!areMapsEqual(map, newMap)) {
      setMap(newMap);
    }
  }, [map]);
  return /* @__PURE__ */ reactExports.createElement(FloatingListContext.Provider, {
    value: reactExports.useMemo(() => ({
      register,
      unregister,
      map,
      elementsRef,
      labelsRef
    }), [register, unregister, map, elementsRef, labelsRef])
  }, children);
}
function useListItem(_temp) {
  let {
    label
  } = _temp === void 0 ? {} : _temp;
  const [index$1$1, setIndex] = reactExports.useState(null);
  const componentRef = reactExports.useRef(null);
  const {
    register,
    unregister,
    map,
    elementsRef,
    labelsRef
  } = reactExports.useContext(FloatingListContext);
  const ref = reactExports.useCallback((node) => {
    componentRef.current = node;
    if (index$1$1 !== null) {
      elementsRef.current[index$1$1] = node;
      if (labelsRef) {
        var _node$textContent;
        const isLabelDefined = label !== void 0;
        labelsRef.current[index$1$1] = isLabelDefined ? label : (_node$textContent = node == null ? void 0 : node.textContent) != null ? _node$textContent : null;
      }
    }
  }, [index$1$1, elementsRef, labelsRef, label]);
  index$1(() => {
    const node = componentRef.current;
    if (node) {
      register(node);
      return () => {
        unregister(node);
      };
    }
  }, [register, unregister]);
  index$1(() => {
    const index2 = componentRef.current ? map.get(componentRef.current) : null;
    if (index2 != null) {
      setIndex(index2);
    }
  }, [map]);
  return reactExports.useMemo(() => ({
    ref,
    index: index$1$1 == null ? -1 : index$1$1
  }), [index$1$1, ref]);
}
const identifier = /* @__PURE__ */ createAttribute("scroll-lock");
const FloatingOverlay = /* @__PURE__ */ reactExports.forwardRef(function FloatingOverlay2(_ref, ref) {
  let {
    lockScroll = false,
    ...rest
  } = _ref;
  index$1(() => {
    var _window$visualViewpor, _window$visualViewpor2;
    if (!lockScroll) {
      return;
    }
    const alreadyLocked = document.body.hasAttribute(identifier);
    if (alreadyLocked) {
      return;
    }
    document.body.setAttribute(identifier, "");
    const scrollbarX = Math.round(document.documentElement.getBoundingClientRect().left) + document.documentElement.scrollLeft;
    const paddingProp = scrollbarX ? "paddingLeft" : "paddingRight";
    const scrollbarWidth = window.innerWidth - document.documentElement.clientWidth;
    if (!/iP(hone|ad|od)|iOS/.test(getPlatform())) {
      Object.assign(document.body.style, {
        overflow: "hidden",
        [paddingProp]: scrollbarWidth + "px"
      });
      return () => {
        document.body.removeAttribute(identifier);
        Object.assign(document.body.style, {
          overflow: "",
          [paddingProp]: ""
        });
      };
    }
    const offsetLeft = ((_window$visualViewpor = window.visualViewport) == null ? void 0 : _window$visualViewpor.offsetLeft) || 0;
    const offsetTop = ((_window$visualViewpor2 = window.visualViewport) == null ? void 0 : _window$visualViewpor2.offsetTop) || 0;
    const scrollX = window.pageXOffset;
    const scrollY = window.pageYOffset;
    Object.assign(document.body.style, {
      position: "fixed",
      overflow: "hidden",
      top: -(scrollY - Math.floor(offsetTop)) + "px",
      left: -(scrollX - Math.floor(offsetLeft)) + "px",
      right: "0",
      [paddingProp]: scrollbarWidth + "px"
    });
    return () => {
      Object.assign(document.body.style, {
        position: "",
        overflow: "",
        top: "",
        left: "",
        right: "",
        [paddingProp]: ""
      });
      document.body.removeAttribute(identifier);
      window.scrollTo(scrollX, scrollY);
    };
  }, [lockScroll]);
  return /* @__PURE__ */ reactExports.createElement("div", _extends$1({
    ref
  }, rest, {
    style: {
      position: "fixed",
      overflow: "auto",
      top: 0,
      right: 0,
      bottom: 0,
      left: 0,
      ...rest.style
    }
  }));
});
function isButtonTarget(event) {
  return isHTMLElement(event.target) && event.target.tagName === "BUTTON";
}
function isSpaceIgnored(element) {
  return isTypeableElement(element);
}
function useClick(context, props) {
  if (props === void 0) {
    props = {};
  }
  const {
    open,
    onOpenChange,
    dataRef,
    elements: {
      domReference
    }
  } = context;
  const {
    enabled = true,
    event: eventOption = "click",
    toggle = true,
    ignoreMouse = false,
    keyboardHandlers = true
  } = props;
  const pointerTypeRef = reactExports.useRef();
  const didKeyDownRef = reactExports.useRef(false);
  return reactExports.useMemo(() => {
    if (!enabled)
      return {};
    return {
      reference: {
        onPointerDown(event) {
          pointerTypeRef.current = event.pointerType;
        },
        onMouseDown(event) {
          if (event.button !== 0) {
            return;
          }
          if (isMouseLikePointerType(pointerTypeRef.current, true) && ignoreMouse) {
            return;
          }
          if (eventOption === "click") {
            return;
          }
          if (open && toggle && (dataRef.current.openEvent ? dataRef.current.openEvent.type === "mousedown" : true)) {
            onOpenChange(false, event.nativeEvent);
          } else {
            event.preventDefault();
            onOpenChange(true, event.nativeEvent);
          }
        },
        onClick(event) {
          if (eventOption === "mousedown" && pointerTypeRef.current) {
            pointerTypeRef.current = void 0;
            return;
          }
          if (isMouseLikePointerType(pointerTypeRef.current, true) && ignoreMouse) {
            return;
          }
          if (open && toggle && (dataRef.current.openEvent ? dataRef.current.openEvent.type === "click" : true)) {
            onOpenChange(false, event.nativeEvent);
          } else {
            onOpenChange(true, event.nativeEvent);
          }
        },
        onKeyDown(event) {
          pointerTypeRef.current = void 0;
          if (event.defaultPrevented || !keyboardHandlers || isButtonTarget(event)) {
            return;
          }
          if (event.key === " " && !isSpaceIgnored(domReference)) {
            event.preventDefault();
            didKeyDownRef.current = true;
          }
          if (event.key === "Enter") {
            if (open && toggle) {
              onOpenChange(false, event.nativeEvent);
            } else {
              onOpenChange(true, event.nativeEvent);
            }
          }
        },
        onKeyUp(event) {
          if (event.defaultPrevented || !keyboardHandlers || isButtonTarget(event) || isSpaceIgnored(domReference)) {
            return;
          }
          if (event.key === " " && didKeyDownRef.current) {
            didKeyDownRef.current = false;
            if (open && toggle) {
              onOpenChange(false, event.nativeEvent);
            } else {
              onOpenChange(true, event.nativeEvent);
            }
          }
        }
      }
    };
  }, [enabled, dataRef, eventOption, ignoreMouse, keyboardHandlers, domReference, toggle, open, onOpenChange]);
}
const useInsertionEffect = React$1[/* @__PURE__ */ "useInsertionEffect".toString()];
const useSafeInsertionEffect = useInsertionEffect || ((fn2) => fn2());
function useEffectEvent(callback) {
  const ref = reactExports.useRef(() => {
  });
  useSafeInsertionEffect(() => {
    ref.current = callback;
  });
  return reactExports.useCallback(function() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    return ref.current == null ? void 0 : ref.current(...args);
  }, []);
}
function isEventTargetWithin(event, node) {
  if (node == null) {
    return false;
  }
  if ("composedPath" in event) {
    return event.composedPath().includes(node);
  }
  const e2 = event;
  return e2.target != null && node.contains(e2.target);
}
const bubbleHandlerKeys = {
  pointerdown: "onPointerDown",
  mousedown: "onMouseDown",
  click: "onClick"
};
const captureHandlerKeys = {
  pointerdown: "onPointerDownCapture",
  mousedown: "onMouseDownCapture",
  click: "onClickCapture"
};
const normalizeBubblesProp = (bubbles) => {
  var _bubbles$escapeKey, _bubbles$outsidePress;
  return {
    escapeKeyBubbles: typeof bubbles === "boolean" ? bubbles : (_bubbles$escapeKey = bubbles == null ? void 0 : bubbles.escapeKey) != null ? _bubbles$escapeKey : false,
    outsidePressBubbles: typeof bubbles === "boolean" ? bubbles : (_bubbles$outsidePress = bubbles == null ? void 0 : bubbles.outsidePress) != null ? _bubbles$outsidePress : true
  };
};
function useDismiss(context, props) {
  if (props === void 0) {
    props = {};
  }
  const {
    open,
    onOpenChange,
    events,
    nodeId,
    elements: {
      reference,
      domReference,
      floating
    },
    dataRef
  } = context;
  const {
    enabled = true,
    escapeKey = true,
    outsidePress: unstable_outsidePress = true,
    outsidePressEvent = "pointerdown",
    referencePress = false,
    referencePressEvent = "pointerdown",
    ancestorScroll = false,
    bubbles
  } = props;
  const tree = useFloatingTree();
  const nested = useFloatingParentNodeId() != null;
  const outsidePressFn = useEffectEvent(typeof unstable_outsidePress === "function" ? unstable_outsidePress : () => false);
  const outsidePress = typeof unstable_outsidePress === "function" ? outsidePressFn : unstable_outsidePress;
  const insideReactTreeRef = reactExports.useRef(false);
  const {
    escapeKeyBubbles,
    outsidePressBubbles
  } = normalizeBubblesProp(bubbles);
  const closeOnEscapeKeyDown = useEffectEvent((event) => {
    if (!open || !enabled || !escapeKey || event.key !== "Escape") {
      return;
    }
    const children = tree ? getChildren(tree.nodesRef.current, nodeId) : [];
    if (!escapeKeyBubbles) {
      event.stopPropagation();
      if (children.length > 0) {
        let shouldDismiss = true;
        children.forEach((child) => {
          var _child$context;
          if ((_child$context = child.context) != null && _child$context.open && !child.context.dataRef.current.__escapeKeyBubbles) {
            shouldDismiss = false;
            return;
          }
        });
        if (!shouldDismiss) {
          return;
        }
      }
    }
    events.emit("dismiss", {
      type: "escapeKey",
      data: {
        returnFocus: {
          preventScroll: false
        }
      }
    });
    onOpenChange(false, isReactEvent(event) ? event.nativeEvent : event);
  });
  const closeOnPressOutside = useEffectEvent((event) => {
    const insideReactTree = insideReactTreeRef.current;
    insideReactTreeRef.current = false;
    if (insideReactTree) {
      return;
    }
    if (typeof outsidePress === "function" && !outsidePress(event)) {
      return;
    }
    const target = getTarget$1(event);
    if (isHTMLElement(target) && floating) {
      const canScrollX = target.clientWidth > 0 && target.scrollWidth > target.clientWidth;
      const canScrollY = target.clientHeight > 0 && target.scrollHeight > target.clientHeight;
      let xCond = canScrollY && event.offsetX > target.clientWidth;
      if (canScrollY) {
        const isRTL2 = getWindow(floating).getComputedStyle(target).direction === "rtl";
        if (isRTL2) {
          xCond = event.offsetX <= target.offsetWidth - target.clientWidth;
        }
      }
      if (xCond || canScrollX && event.offsetY > target.clientHeight) {
        return;
      }
    }
    const targetIsInsideChildren = tree && getChildren(tree.nodesRef.current, nodeId).some((node) => {
      var _node$context;
      return isEventTargetWithin(event, (_node$context = node.context) == null ? void 0 : _node$context.elements.floating);
    });
    if (isEventTargetWithin(event, floating) || isEventTargetWithin(event, domReference) || targetIsInsideChildren) {
      return;
    }
    const children = tree ? getChildren(tree.nodesRef.current, nodeId) : [];
    if (children.length > 0) {
      let shouldDismiss = true;
      children.forEach((child) => {
        var _child$context2;
        if ((_child$context2 = child.context) != null && _child$context2.open && !child.context.dataRef.current.__outsidePressBubbles) {
          shouldDismiss = false;
          return;
        }
      });
      if (!shouldDismiss) {
        return;
      }
    }
    events.emit("dismiss", {
      type: "outsidePress",
      data: {
        returnFocus: nested ? {
          preventScroll: true
        } : isVirtualClick(event) || isVirtualPointerEvent(event)
      }
    });
    onOpenChange(false, event);
  });
  reactExports.useEffect(() => {
    if (!open || !enabled) {
      return;
    }
    dataRef.current.__escapeKeyBubbles = escapeKeyBubbles;
    dataRef.current.__outsidePressBubbles = outsidePressBubbles;
    function onScroll(event) {
      onOpenChange(false, event);
    }
    const doc = getDocument(floating);
    escapeKey && doc.addEventListener("keydown", closeOnEscapeKeyDown);
    outsidePress && doc.addEventListener(outsidePressEvent, closeOnPressOutside);
    let ancestors = [];
    if (ancestorScroll) {
      if (isElement$1(domReference)) {
        ancestors = getOverflowAncestors(domReference);
      }
      if (isElement$1(floating)) {
        ancestors = ancestors.concat(getOverflowAncestors(floating));
      }
      if (!isElement$1(reference) && reference && reference.contextElement) {
        ancestors = ancestors.concat(getOverflowAncestors(reference.contextElement));
      }
    }
    ancestors = ancestors.filter((ancestor) => {
      var _doc$defaultView;
      return ancestor !== ((_doc$defaultView = doc.defaultView) == null ? void 0 : _doc$defaultView.visualViewport);
    });
    ancestors.forEach((ancestor) => {
      ancestor.addEventListener("scroll", onScroll, {
        passive: true
      });
    });
    return () => {
      escapeKey && doc.removeEventListener("keydown", closeOnEscapeKeyDown);
      outsidePress && doc.removeEventListener(outsidePressEvent, closeOnPressOutside);
      ancestors.forEach((ancestor) => {
        ancestor.removeEventListener("scroll", onScroll);
      });
    };
  }, [dataRef, floating, domReference, reference, escapeKey, outsidePress, outsidePressEvent, open, onOpenChange, ancestorScroll, enabled, escapeKeyBubbles, outsidePressBubbles, closeOnEscapeKeyDown, closeOnPressOutside]);
  reactExports.useEffect(() => {
    insideReactTreeRef.current = false;
  }, [outsidePress, outsidePressEvent]);
  return reactExports.useMemo(() => {
    if (!enabled) {
      return {};
    }
    return {
      reference: {
        onKeyDown: closeOnEscapeKeyDown,
        [bubbleHandlerKeys[referencePressEvent]]: (event) => {
          if (referencePress) {
            events.emit("dismiss", {
              type: "referencePress",
              data: {
                returnFocus: false
              }
            });
            onOpenChange(false, event.nativeEvent);
          }
        }
      },
      floating: {
        onKeyDown: closeOnEscapeKeyDown,
        [captureHandlerKeys[outsidePressEvent]]: () => {
          insideReactTreeRef.current = true;
        }
      }
    };
  }, [enabled, events, referencePress, outsidePressEvent, referencePressEvent, onOpenChange, closeOnEscapeKeyDown]);
}
function useFloating(options) {
  var _options$elements;
  if (options === void 0) {
    options = {};
  }
  const {
    open = false,
    onOpenChange: unstable_onOpenChange,
    nodeId
  } = options;
  const [_domReference, setDomReference] = reactExports.useState(null);
  const domReference = ((_options$elements = options.elements) == null ? void 0 : _options$elements.reference) || _domReference;
  const position3 = useFloating$1(options);
  const tree = useFloatingTree();
  const onOpenChange = useEffectEvent((open2, event) => {
    if (open2) {
      dataRef.current.openEvent = event;
    }
    unstable_onOpenChange == null ? void 0 : unstable_onOpenChange(open2, event);
  });
  const domReferenceRef = reactExports.useRef(null);
  const dataRef = reactExports.useRef({});
  const events = reactExports.useState(() => createPubSub())[0];
  const floatingId = useId();
  const setPositionReference = reactExports.useCallback((node) => {
    const positionReference = isElement$1(node) ? {
      getBoundingClientRect: () => node.getBoundingClientRect(),
      contextElement: node
    } : node;
    position3.refs.setReference(positionReference);
  }, [position3.refs]);
  const setReference = reactExports.useCallback((node) => {
    if (isElement$1(node) || node === null) {
      domReferenceRef.current = node;
      setDomReference(node);
    }
    if (isElement$1(position3.refs.reference.current) || position3.refs.reference.current === null || // Don't allow setting virtual elements using the old technique back to
    // `null` to support `positionReference` + an unstable `reference`
    // callback ref.
    node !== null && !isElement$1(node)) {
      position3.refs.setReference(node);
    }
  }, [position3.refs]);
  const refs = reactExports.useMemo(() => ({
    ...position3.refs,
    setReference,
    setPositionReference,
    domReference: domReferenceRef
  }), [position3.refs, setReference, setPositionReference]);
  const elements = reactExports.useMemo(() => ({
    ...position3.elements,
    domReference
  }), [position3.elements, domReference]);
  const context = reactExports.useMemo(() => ({
    ...position3,
    refs,
    elements,
    dataRef,
    nodeId,
    floatingId,
    events,
    open,
    onOpenChange
  }), [position3, nodeId, floatingId, events, open, onOpenChange, refs, elements]);
  index$1(() => {
    const node = tree == null ? void 0 : tree.nodesRef.current.find((node2) => node2.id === nodeId);
    if (node) {
      node.context = context;
    }
  });
  return reactExports.useMemo(() => ({
    ...position3,
    context,
    refs,
    elements
  }), [position3, refs, elements, context]);
}
function useFocus(context, props) {
  if (props === void 0) {
    props = {};
  }
  const {
    open,
    onOpenChange,
    dataRef,
    events,
    refs,
    elements: {
      floating,
      domReference
    }
  } = context;
  const {
    enabled = true,
    keyboardOnly = true
  } = props;
  const pointerTypeRef = reactExports.useRef("");
  const blockFocusRef = reactExports.useRef(false);
  const timeoutRef = reactExports.useRef();
  reactExports.useEffect(() => {
    if (!enabled) {
      return;
    }
    const doc = getDocument(floating);
    const win = doc.defaultView || window;
    function onBlur() {
      if (!open && isHTMLElement(domReference) && domReference === activeElement(getDocument(domReference))) {
        blockFocusRef.current = true;
      }
    }
    win.addEventListener("blur", onBlur);
    return () => {
      win.removeEventListener("blur", onBlur);
    };
  }, [floating, domReference, open, enabled]);
  reactExports.useEffect(() => {
    if (!enabled) {
      return;
    }
    function onDismiss(payload) {
      if (payload.type === "referencePress" || payload.type === "escapeKey") {
        blockFocusRef.current = true;
      }
    }
    events.on("dismiss", onDismiss);
    return () => {
      events.off("dismiss", onDismiss);
    };
  }, [events, enabled]);
  reactExports.useEffect(() => {
    return () => {
      clearTimeout(timeoutRef.current);
    };
  }, []);
  return reactExports.useMemo(() => {
    if (!enabled) {
      return {};
    }
    return {
      reference: {
        onPointerDown(_ref) {
          let {
            pointerType
          } = _ref;
          pointerTypeRef.current = pointerType;
          blockFocusRef.current = !!(pointerType && keyboardOnly);
        },
        onMouseLeave() {
          blockFocusRef.current = false;
        },
        onFocus(event) {
          var _dataRef$current$open;
          if (blockFocusRef.current) {
            return;
          }
          if (event.type === "focus" && ((_dataRef$current$open = dataRef.current.openEvent) == null ? void 0 : _dataRef$current$open.type) === "mousedown" && isEventTargetWithin(dataRef.current.openEvent, domReference)) {
            return;
          }
          onOpenChange(true, event.nativeEvent);
        },
        onBlur(event) {
          blockFocusRef.current = false;
          const relatedTarget = event.relatedTarget;
          const movedToFocusGuard = isElement$1(relatedTarget) && relatedTarget.hasAttribute(createAttribute("focus-guard")) && relatedTarget.getAttribute("data-type") === "outside";
          timeoutRef.current = setTimeout(() => {
            if (contains(refs.floating.current, relatedTarget) || contains(domReference, relatedTarget) || movedToFocusGuard) {
              return;
            }
            onOpenChange(false, event.nativeEvent);
          });
        }
      }
    };
  }, [enabled, keyboardOnly, domReference, refs, dataRef, onOpenChange]);
}
function mergeProps(userProps, propsList, elementKey) {
  const map = /* @__PURE__ */ new Map();
  return {
    ...elementKey === "floating" && {
      tabIndex: -1
    },
    ...userProps,
    ...propsList.map((value) => value ? value[elementKey] : null).concat(userProps).reduce((acc, props) => {
      if (!props) {
        return acc;
      }
      Object.entries(props).forEach((_ref) => {
        let [key, value] = _ref;
        if (key.indexOf("on") === 0) {
          if (!map.has(key)) {
            map.set(key, []);
          }
          if (typeof value === "function") {
            var _map$get;
            (_map$get = map.get(key)) == null ? void 0 : _map$get.push(value);
            acc[key] = function() {
              var _map$get2;
              for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                args[_key] = arguments[_key];
              }
              return (_map$get2 = map.get(key)) == null ? void 0 : _map$get2.map((fn2) => fn2(...args)).find((val) => val !== void 0);
            };
          }
        } else {
          acc[key] = value;
        }
      });
      return acc;
    }, {})
  };
}
function useInteractions(propsList) {
  if (propsList === void 0) {
    propsList = [];
  }
  const deps = propsList;
  const getReferenceProps = reactExports.useCallback(
    (userProps) => mergeProps(userProps, propsList, "reference"),
    // eslint-disable-next-line react-hooks/exhaustive-deps
    deps
  );
  const getFloatingProps = reactExports.useCallback(
    (userProps) => mergeProps(userProps, propsList, "floating"),
    // eslint-disable-next-line react-hooks/exhaustive-deps
    deps
  );
  const getItemProps = reactExports.useCallback(
    (userProps) => mergeProps(userProps, propsList, "item"),
    // Granularly check for `item` changes, because the `getItemProps` getter
    // should be as referentially stable as possible since it may be passed as
    // a prop to many components. All `item` key values must therefore be
    // memoized.
    // eslint-disable-next-line react-hooks/exhaustive-deps
    propsList.map((key) => key == null ? void 0 : key.item)
  );
  return reactExports.useMemo(() => ({
    getReferenceProps,
    getFloatingProps,
    getItemProps
  }), [getReferenceProps, getFloatingProps, getItemProps]);
}
let isPreventScrollSupported = false;
const ARROW_UP = "ArrowUp";
const ARROW_DOWN = "ArrowDown";
const ARROW_LEFT = "ArrowLeft";
const ARROW_RIGHT = "ArrowRight";
function isDifferentRow(index2, cols, prevRow) {
  return Math.floor(index2 / cols) !== prevRow;
}
function isIndexOutOfBounds(listRef, index2) {
  return index2 < 0 || index2 >= listRef.current.length;
}
function findNonDisabledIndex(listRef, _temp) {
  let {
    startingIndex = -1,
    decrement = false,
    disabledIndices,
    amount = 1
  } = _temp === void 0 ? {} : _temp;
  const list = listRef.current;
  let index2 = startingIndex;
  do {
    var _list$index, _list$index2;
    index2 = index2 + (decrement ? -amount : amount);
  } while (index2 >= 0 && index2 <= list.length - 1 && (disabledIndices ? disabledIndices.includes(index2) : list[index2] == null || ((_list$index = list[index2]) == null ? void 0 : _list$index.hasAttribute("disabled")) || ((_list$index2 = list[index2]) == null ? void 0 : _list$index2.getAttribute("aria-disabled")) === "true"));
  return index2;
}
function doSwitch(orientation, vertical2, horizontal2) {
  switch (orientation) {
    case "vertical":
      return vertical2;
    case "horizontal":
      return horizontal2;
    default:
      return vertical2 || horizontal2;
  }
}
function isMainOrientationKey(key, orientation) {
  const vertical2 = key === ARROW_UP || key === ARROW_DOWN;
  const horizontal2 = key === ARROW_LEFT || key === ARROW_RIGHT;
  return doSwitch(orientation, vertical2, horizontal2);
}
function isMainOrientationToEndKey(key, orientation, rtl) {
  const vertical2 = key === ARROW_DOWN;
  const horizontal2 = rtl ? key === ARROW_LEFT : key === ARROW_RIGHT;
  return doSwitch(orientation, vertical2, horizontal2) || key === "Enter" || key == " " || key === "";
}
function isCrossOrientationOpenKey(key, orientation, rtl) {
  const vertical2 = rtl ? key === ARROW_LEFT : key === ARROW_RIGHT;
  const horizontal2 = key === ARROW_DOWN;
  return doSwitch(orientation, vertical2, horizontal2);
}
function isCrossOrientationCloseKey(key, orientation, rtl) {
  const vertical2 = rtl ? key === ARROW_RIGHT : key === ARROW_LEFT;
  const horizontal2 = key === ARROW_UP;
  return doSwitch(orientation, vertical2, horizontal2);
}
function getMinIndex(listRef, disabledIndices) {
  return findNonDisabledIndex(listRef, {
    disabledIndices
  });
}
function getMaxIndex(listRef, disabledIndices) {
  return findNonDisabledIndex(listRef, {
    decrement: true,
    startingIndex: listRef.current.length,
    disabledIndices
  });
}
function useListNavigation(context, props) {
  const {
    open,
    onOpenChange,
    refs,
    elements: {
      domReference,
      floating
    }
  } = context;
  const {
    listRef,
    activeIndex,
    onNavigate: unstable_onNavigate = () => {
    },
    enabled = true,
    selectedIndex = null,
    allowEscape = false,
    loop = false,
    nested = false,
    rtl = false,
    virtual = false,
    focusItemOnOpen = "auto",
    focusItemOnHover = true,
    openOnArrowKeyDown = true,
    disabledIndices = void 0,
    orientation = "vertical",
    cols = 1,
    scrollItemIntoView = true
  } = props;
  const parentId = useFloatingParentNodeId();
  const tree = useFloatingTree();
  const onNavigate = useEffectEvent(unstable_onNavigate);
  const focusItemOnOpenRef = reactExports.useRef(focusItemOnOpen);
  const indexRef = reactExports.useRef(selectedIndex != null ? selectedIndex : -1);
  const keyRef = reactExports.useRef(null);
  const isPointerModalityRef = reactExports.useRef(true);
  const previousOnNavigateRef = reactExports.useRef(onNavigate);
  const previousMountedRef = reactExports.useRef(!!floating);
  const forceSyncFocus = reactExports.useRef(false);
  const forceScrollIntoViewRef = reactExports.useRef(false);
  const disabledIndicesRef = useLatestRef(disabledIndices);
  const latestOpenRef = useLatestRef(open);
  const scrollItemIntoViewRef = useLatestRef(scrollItemIntoView);
  const [activeId, setActiveId] = reactExports.useState();
  const focusItem = useEffectEvent(function(listRef2, indexRef2, forceScrollIntoView) {
    if (forceScrollIntoView === void 0) {
      forceScrollIntoView = false;
    }
    const item2 = listRef2.current[indexRef2.current];
    if (!item2)
      return;
    if (virtual) {
      setActiveId(item2.id);
    } else {
      enqueueFocus(item2, {
        preventScroll: true,
        // Mac Safari does not move the virtual cursor unless the focus call
        // is sync. However, for the very first focus call, we need to wait
        // for the position to be ready in order to prevent unwanted
        // scrolling. This means the virtual cursor will not move to the first
        // item when first opening the floating element, but will on
        // subsequent calls. `preventScroll` is supported in modern Safari,
        // so we can use that instead.
        // iOS Safari must be async or the first item will not be focused.
        sync: isMac() && isSafari() ? isPreventScrollSupported || forceSyncFocus.current : false
      });
    }
    requestAnimationFrame(() => {
      const scrollIntoViewOptions = scrollItemIntoViewRef.current;
      const shouldScrollIntoView = scrollIntoViewOptions && item2 && (forceScrollIntoView || !isPointerModalityRef.current);
      if (shouldScrollIntoView) {
        item2.scrollIntoView == null ? void 0 : item2.scrollIntoView(typeof scrollIntoViewOptions === "boolean" ? {
          block: "nearest",
          inline: "nearest"
        } : scrollIntoViewOptions);
      }
    });
  });
  index$1(() => {
    document.createElement("div").focus({
      get preventScroll() {
        isPreventScrollSupported = true;
        return false;
      }
    });
  }, []);
  index$1(() => {
    if (!enabled) {
      return;
    }
    if (open && floating) {
      if (focusItemOnOpenRef.current && selectedIndex != null) {
        forceScrollIntoViewRef.current = true;
        onNavigate(selectedIndex);
      }
    } else if (previousMountedRef.current) {
      indexRef.current = -1;
      previousOnNavigateRef.current(null);
    }
  }, [enabled, open, floating, selectedIndex, onNavigate]);
  index$1(() => {
    if (!enabled) {
      return;
    }
    if (open && floating) {
      if (activeIndex == null) {
        forceSyncFocus.current = false;
        if (selectedIndex != null) {
          return;
        }
        if (previousMountedRef.current) {
          indexRef.current = -1;
          focusItem(listRef, indexRef);
        }
        if (!previousMountedRef.current && focusItemOnOpenRef.current && (keyRef.current != null || focusItemOnOpenRef.current === true && keyRef.current == null)) {
          let runs = 0;
          const waitForListPopulated = () => {
            if (listRef.current[0] == null) {
              if (runs < 2) {
                const scheduler2 = runs ? requestAnimationFrame : queueMicrotask;
                scheduler2(waitForListPopulated);
              }
              runs++;
            } else {
              indexRef.current = keyRef.current == null || isMainOrientationToEndKey(keyRef.current, orientation, rtl) || nested ? getMinIndex(listRef, disabledIndicesRef.current) : getMaxIndex(listRef, disabledIndicesRef.current);
              keyRef.current = null;
              onNavigate(indexRef.current);
            }
          };
          waitForListPopulated();
        }
      } else if (!isIndexOutOfBounds(listRef, activeIndex)) {
        indexRef.current = activeIndex;
        focusItem(listRef, indexRef, forceScrollIntoViewRef.current);
        forceScrollIntoViewRef.current = false;
      }
    }
  }, [enabled, open, floating, activeIndex, selectedIndex, nested, listRef, orientation, rtl, onNavigate, focusItem, disabledIndicesRef]);
  index$1(() => {
    if (!enabled) {
      return;
    }
    if (previousMountedRef.current && !floating && tree) {
      var _nodes$find, _nodes$find$context;
      const nodes2 = tree.nodesRef.current;
      const parent = (_nodes$find = nodes2.find((node) => node.id === parentId)) == null ? void 0 : (_nodes$find$context = _nodes$find.context) == null ? void 0 : _nodes$find$context.elements.floating;
      const activeEl = activeElement(getDocument(floating));
      const treeContainsActiveEl = nodes2.some((node) => node.context && contains(node.context.elements.floating, activeEl));
      if (parent && !treeContainsActiveEl) {
        parent.focus({
          preventScroll: true
        });
      }
    }
  }, [enabled, floating, tree, parentId]);
  index$1(() => {
    previousOnNavigateRef.current = onNavigate;
    previousMountedRef.current = !!floating;
  });
  index$1(() => {
    if (!open) {
      keyRef.current = null;
    }
  }, [open]);
  const hasActiveIndex = activeIndex != null;
  const item = reactExports.useMemo(() => {
    function syncCurrentTarget(currentTarget) {
      if (!open)
        return;
      const index2 = listRef.current.indexOf(currentTarget);
      if (index2 !== -1) {
        onNavigate(index2);
      }
    }
    const props2 = {
      onFocus(_ref) {
        let {
          currentTarget
        } = _ref;
        syncCurrentTarget(currentTarget);
      },
      onClick: (_ref2) => {
        let {
          currentTarget
        } = _ref2;
        return currentTarget.focus({
          preventScroll: true
        });
      },
      // Safari
      ...focusItemOnHover && {
        onMouseMove(_ref3) {
          let {
            currentTarget
          } = _ref3;
          syncCurrentTarget(currentTarget);
        },
        onPointerLeave(_ref4) {
          let {
            pointerType
          } = _ref4;
          if (!isPointerModalityRef.current || pointerType === "touch") {
            return;
          }
          indexRef.current = -1;
          focusItem(listRef, indexRef);
          onNavigate(null);
          if (!virtual) {
            enqueueFocus(refs.floating.current, {
              preventScroll: true
            });
          }
        }
      }
    };
    return props2;
  }, [open, refs, focusItem, focusItemOnHover, listRef, onNavigate, virtual]);
  return reactExports.useMemo(() => {
    if (!enabled) {
      return {};
    }
    const disabledIndices2 = disabledIndicesRef.current;
    function onKeyDown(event) {
      isPointerModalityRef.current = false;
      forceSyncFocus.current = true;
      if (!latestOpenRef.current && event.currentTarget === refs.floating.current) {
        return;
      }
      if (nested && isCrossOrientationCloseKey(event.key, orientation, rtl)) {
        stopEvent(event);
        onOpenChange(false, event.nativeEvent);
        if (isHTMLElement(domReference)) {
          domReference.focus();
        }
        return;
      }
      const currentIndex = indexRef.current;
      const minIndex = getMinIndex(listRef, disabledIndices2);
      const maxIndex = getMaxIndex(listRef, disabledIndices2);
      if (event.key === "Home") {
        stopEvent(event);
        indexRef.current = minIndex;
        onNavigate(indexRef.current);
      }
      if (event.key === "End") {
        stopEvent(event);
        indexRef.current = maxIndex;
        onNavigate(indexRef.current);
      }
      if (cols > 1) {
        const prevIndex = indexRef.current;
        if (event.key === ARROW_UP) {
          stopEvent(event);
          if (prevIndex === -1) {
            indexRef.current = maxIndex;
          } else {
            indexRef.current = findNonDisabledIndex(listRef, {
              startingIndex: prevIndex,
              amount: cols,
              decrement: true,
              disabledIndices: disabledIndices2
            });
            if (loop && (prevIndex - cols < minIndex || indexRef.current < 0)) {
              const col = prevIndex % cols;
              const maxCol = maxIndex % cols;
              const offset3 = maxIndex - (maxCol - col);
              if (maxCol === col) {
                indexRef.current = maxIndex;
              } else {
                indexRef.current = maxCol > col ? offset3 : offset3 - cols;
              }
            }
          }
          if (isIndexOutOfBounds(listRef, indexRef.current)) {
            indexRef.current = prevIndex;
          }
          onNavigate(indexRef.current);
        }
        if (event.key === ARROW_DOWN) {
          stopEvent(event);
          if (prevIndex === -1) {
            indexRef.current = minIndex;
          } else {
            indexRef.current = findNonDisabledIndex(listRef, {
              startingIndex: prevIndex,
              amount: cols,
              disabledIndices: disabledIndices2
            });
            if (loop && prevIndex + cols > maxIndex) {
              indexRef.current = findNonDisabledIndex(listRef, {
                startingIndex: prevIndex % cols - cols,
                amount: cols,
                disabledIndices: disabledIndices2
              });
            }
          }
          if (isIndexOutOfBounds(listRef, indexRef.current)) {
            indexRef.current = prevIndex;
          }
          onNavigate(indexRef.current);
        }
        if (orientation === "both") {
          const prevRow = Math.floor(prevIndex / cols);
          if (event.key === ARROW_RIGHT) {
            stopEvent(event);
            if (prevIndex % cols !== cols - 1) {
              indexRef.current = findNonDisabledIndex(listRef, {
                startingIndex: prevIndex,
                disabledIndices: disabledIndices2
              });
              if (loop && isDifferentRow(indexRef.current, cols, prevRow)) {
                indexRef.current = findNonDisabledIndex(listRef, {
                  startingIndex: prevIndex - prevIndex % cols - 1,
                  disabledIndices: disabledIndices2
                });
              }
            } else if (loop) {
              indexRef.current = findNonDisabledIndex(listRef, {
                startingIndex: prevIndex - prevIndex % cols - 1,
                disabledIndices: disabledIndices2
              });
            }
            if (isDifferentRow(indexRef.current, cols, prevRow)) {
              indexRef.current = prevIndex;
            }
          }
          if (event.key === ARROW_LEFT) {
            stopEvent(event);
            if (prevIndex % cols !== 0) {
              indexRef.current = findNonDisabledIndex(listRef, {
                startingIndex: prevIndex,
                disabledIndices: disabledIndices2,
                decrement: true
              });
              if (loop && isDifferentRow(indexRef.current, cols, prevRow)) {
                indexRef.current = findNonDisabledIndex(listRef, {
                  startingIndex: prevIndex + (cols - prevIndex % cols),
                  decrement: true,
                  disabledIndices: disabledIndices2
                });
              }
            } else if (loop) {
              indexRef.current = findNonDisabledIndex(listRef, {
                startingIndex: prevIndex + (cols - prevIndex % cols),
                decrement: true,
                disabledIndices: disabledIndices2
              });
            }
            if (isDifferentRow(indexRef.current, cols, prevRow)) {
              indexRef.current = prevIndex;
            }
          }
          const lastRow = Math.floor(maxIndex / cols) === prevRow;
          if (isIndexOutOfBounds(listRef, indexRef.current)) {
            if (loop && lastRow) {
              indexRef.current = event.key === ARROW_LEFT ? maxIndex : findNonDisabledIndex(listRef, {
                startingIndex: prevIndex - prevIndex % cols - 1,
                disabledIndices: disabledIndices2
              });
            } else {
              indexRef.current = prevIndex;
            }
          }
          onNavigate(indexRef.current);
          return;
        }
      }
      if (isMainOrientationKey(event.key, orientation)) {
        stopEvent(event);
        if (open && !virtual && activeElement(event.currentTarget.ownerDocument) === event.currentTarget) {
          indexRef.current = isMainOrientationToEndKey(event.key, orientation, rtl) ? minIndex : maxIndex;
          onNavigate(indexRef.current);
          return;
        }
        if (isMainOrientationToEndKey(event.key, orientation, rtl)) {
          if (loop) {
            indexRef.current = currentIndex >= maxIndex ? allowEscape && currentIndex !== listRef.current.length ? -1 : minIndex : findNonDisabledIndex(listRef, {
              startingIndex: currentIndex,
              disabledIndices: disabledIndices2
            });
          } else {
            indexRef.current = Math.min(maxIndex, findNonDisabledIndex(listRef, {
              startingIndex: currentIndex,
              disabledIndices: disabledIndices2
            }));
          }
        } else {
          if (loop) {
            indexRef.current = currentIndex <= minIndex ? allowEscape && currentIndex !== -1 ? listRef.current.length : maxIndex : findNonDisabledIndex(listRef, {
              startingIndex: currentIndex,
              decrement: true,
              disabledIndices: disabledIndices2
            });
          } else {
            indexRef.current = Math.max(minIndex, findNonDisabledIndex(listRef, {
              startingIndex: currentIndex,
              decrement: true,
              disabledIndices: disabledIndices2
            }));
          }
        }
        if (isIndexOutOfBounds(listRef, indexRef.current)) {
          onNavigate(null);
        } else {
          onNavigate(indexRef.current);
        }
      }
    }
    function checkVirtualMouse(event) {
      if (focusItemOnOpen === "auto" && isVirtualClick(event.nativeEvent)) {
        focusItemOnOpenRef.current = true;
      }
    }
    function checkVirtualPointer(event) {
      focusItemOnOpenRef.current = focusItemOnOpen;
      if (focusItemOnOpen === "auto" && isVirtualPointerEvent(event.nativeEvent)) {
        focusItemOnOpenRef.current = true;
      }
    }
    const ariaActiveDescendantProp = virtual && open && hasActiveIndex && {
      "aria-activedescendant": activeId
    };
    return {
      reference: {
        ...ariaActiveDescendantProp,
        onKeyDown(event) {
          isPointerModalityRef.current = false;
          const isArrowKey = event.key.indexOf("Arrow") === 0;
          if (virtual && open) {
            return onKeyDown(event);
          }
          if (!open && !openOnArrowKeyDown && isArrowKey) {
            return;
          }
          const isNavigationKey = isArrowKey || event.key === "Enter" || event.key.trim() === "";
          const isMainKey = isMainOrientationKey(event.key, orientation);
          const isCrossKey = isCrossOrientationOpenKey(event.key, orientation, rtl);
          if (isNavigationKey) {
            keyRef.current = nested && isMainKey ? null : event.key;
          }
          if (nested) {
            if (isCrossKey) {
              stopEvent(event);
              if (open) {
                indexRef.current = getMinIndex(listRef, disabledIndices2);
                onNavigate(indexRef.current);
              } else {
                onOpenChange(true, event.nativeEvent);
              }
            }
            return;
          }
          if (isMainKey) {
            if (selectedIndex != null) {
              indexRef.current = selectedIndex;
            }
            stopEvent(event);
            if (!open && openOnArrowKeyDown) {
              onOpenChange(true, event.nativeEvent);
            } else {
              onKeyDown(event);
            }
            if (open) {
              onNavigate(indexRef.current);
            }
          }
        },
        onFocus() {
          if (open) {
            onNavigate(null);
          }
        },
        onPointerDown: checkVirtualPointer,
        onMouseDown: checkVirtualMouse,
        onClick: checkVirtualMouse
      },
      floating: {
        "aria-orientation": orientation === "both" ? void 0 : orientation,
        ...ariaActiveDescendantProp,
        onKeyDown,
        onPointerMove() {
          isPointerModalityRef.current = true;
        }
      },
      item
    };
  }, [domReference, refs, activeId, disabledIndicesRef, latestOpenRef, listRef, enabled, orientation, rtl, virtual, open, hasActiveIndex, nested, selectedIndex, openOnArrowKeyDown, allowEscape, cols, loop, focusItemOnOpen, onNavigate, onOpenChange, item]);
}
function useMergeRefs(refs) {
  return reactExports.useMemo(() => {
    if (refs.every((ref) => ref == null)) {
      return null;
    }
    return (value) => {
      refs.forEach((ref) => {
        if (typeof ref === "function") {
          ref(value);
        } else if (ref != null) {
          ref.current = value;
        }
      });
    };
  }, refs);
}
function useRole(context, props) {
  if (props === void 0) {
    props = {};
  }
  const {
    open,
    floatingId
  } = context;
  const {
    enabled = true,
    role = "dialog"
  } = props;
  const referenceId = useId();
  return reactExports.useMemo(() => {
    const floatingProps = {
      id: floatingId,
      role
    };
    if (!enabled) {
      return {};
    }
    if (role === "tooltip") {
      return {
        reference: {
          "aria-describedby": open ? floatingId : void 0
        },
        floating: floatingProps
      };
    }
    return {
      reference: {
        "aria-expanded": open ? "true" : "false",
        "aria-haspopup": role === "alertdialog" ? "dialog" : role,
        "aria-controls": open ? floatingId : void 0,
        ...role === "listbox" && {
          role: "combobox"
        },
        ...role === "menu" && {
          id: referenceId
        }
      },
      floating: {
        ...floatingProps,
        ...role === "menu" && {
          "aria-labelledby": referenceId
        }
      }
    };
  }, [enabled, role, open, floatingId, referenceId]);
}
function useTypeahead(context, props) {
  var _ref;
  const {
    open,
    dataRef
  } = context;
  const {
    listRef,
    activeIndex,
    onMatch: unstable_onMatch,
    onTypingChange: unstable_onTypingChange,
    enabled = true,
    findMatch = null,
    resetMs = 750,
    ignoreKeys = [],
    selectedIndex = null
  } = props;
  const timeoutIdRef = reactExports.useRef();
  const stringRef = reactExports.useRef("");
  const prevIndexRef = reactExports.useRef((_ref = selectedIndex != null ? selectedIndex : activeIndex) != null ? _ref : -1);
  const matchIndexRef = reactExports.useRef(null);
  const onMatch = useEffectEvent(unstable_onMatch);
  const onTypingChange = useEffectEvent(unstable_onTypingChange);
  const findMatchRef = useLatestRef(findMatch);
  const ignoreKeysRef = useLatestRef(ignoreKeys);
  index$1(() => {
    if (open) {
      clearTimeout(timeoutIdRef.current);
      matchIndexRef.current = null;
      stringRef.current = "";
    }
  }, [open]);
  index$1(() => {
    if (open && stringRef.current === "") {
      var _ref2;
      prevIndexRef.current = (_ref2 = selectedIndex != null ? selectedIndex : activeIndex) != null ? _ref2 : -1;
    }
  }, [open, selectedIndex, activeIndex]);
  return reactExports.useMemo(() => {
    if (!enabled) {
      return {};
    }
    function setTypingChange(value) {
      if (value) {
        if (!dataRef.current.typing) {
          dataRef.current.typing = value;
          onTypingChange(value);
        }
      } else {
        if (dataRef.current.typing) {
          dataRef.current.typing = value;
          onTypingChange(value);
        }
      }
    }
    function getMatchingIndex(list, orderedList, string) {
      const str = findMatchRef.current ? findMatchRef.current(orderedList, string) : orderedList.find((text) => (text == null ? void 0 : text.toLocaleLowerCase().indexOf(string.toLocaleLowerCase())) === 0);
      return str ? list.indexOf(str) : -1;
    }
    function onKeyDown(event) {
      const listContent = listRef.current;
      if (stringRef.current.length > 0 && stringRef.current[0] !== " ") {
        if (getMatchingIndex(listContent, listContent, stringRef.current) === -1) {
          setTypingChange(false);
        } else if (event.key === " ") {
          stopEvent(event);
        }
      }
      if (listContent == null || ignoreKeysRef.current.includes(event.key) || // Character key.
      event.key.length !== 1 || // Modifier key.
      event.ctrlKey || event.metaKey || event.altKey) {
        return;
      }
      if (open && event.key !== " ") {
        stopEvent(event);
        setTypingChange(true);
      }
      const allowRapidSuccessionOfFirstLetter = listContent.every((text) => {
        var _text$, _text$2;
        return text ? ((_text$ = text[0]) == null ? void 0 : _text$.toLocaleLowerCase()) !== ((_text$2 = text[1]) == null ? void 0 : _text$2.toLocaleLowerCase()) : true;
      });
      if (allowRapidSuccessionOfFirstLetter && stringRef.current === event.key) {
        stringRef.current = "";
        prevIndexRef.current = matchIndexRef.current;
      }
      stringRef.current += event.key;
      clearTimeout(timeoutIdRef.current);
      timeoutIdRef.current = setTimeout(() => {
        stringRef.current = "";
        prevIndexRef.current = matchIndexRef.current;
        setTypingChange(false);
      }, resetMs);
      const prevIndex = prevIndexRef.current;
      const index2 = getMatchingIndex(listContent, [...listContent.slice((prevIndex || 0) + 1), ...listContent.slice(0, (prevIndex || 0) + 1)], stringRef.current);
      if (index2 !== -1) {
        onMatch(index2);
        matchIndexRef.current = index2;
      } else if (event.key !== " ") {
        stringRef.current = "";
        setTypingChange(false);
      }
    }
    return {
      reference: {
        onKeyDown
      },
      floating: {
        onKeyDown,
        onKeyUp(event) {
          if (event.key === " ") {
            setTypingChange(false);
          }
        }
      }
    };
  }, [enabled, open, dataRef, listRef, resetMs, ignoreKeysRef, findMatchRef, onMatch, onTypingChange]);
}
function isPointInPolygon(point, polygon) {
  const [x, y2] = point;
  let isInside2 = false;
  const length = polygon.length;
  for (let i2 = 0, j2 = length - 1; i2 < length; j2 = i2++) {
    const [xi2, yi2] = polygon[i2] || [0, 0];
    const [xj2, yj2] = polygon[j2] || [0, 0];
    const intersect = yi2 >= y2 !== yj2 >= y2 && x <= (xj2 - xi2) * (y2 - yi2) / (yj2 - yi2) + xi2;
    if (intersect) {
      isInside2 = !isInside2;
    }
  }
  return isInside2;
}
function isInside(point, rect) {
  return point[0] >= rect.x && point[0] <= rect.x + rect.width && point[1] >= rect.y && point[1] <= rect.y + rect.height;
}
function safePolygon(options) {
  if (options === void 0) {
    options = {};
  }
  const {
    buffer = 0.5,
    blockPointerEvents = false,
    requireIntent = true
  } = options;
  let timeoutId2;
  let hasLanded = false;
  let lastX = null;
  let lastY = null;
  let lastCursorTime = performance.now();
  function getCursorSpeed(x, y2) {
    const currentTime = performance.now();
    const elapsedTime = currentTime - lastCursorTime;
    if (lastX === null || lastY === null || elapsedTime === 0) {
      lastX = x;
      lastY = y2;
      lastCursorTime = currentTime;
      return null;
    }
    const deltaX = x - lastX;
    const deltaY = y2 - lastY;
    const distance3 = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
    const speed = distance3 / elapsedTime;
    lastX = x;
    lastY = y2;
    lastCursorTime = currentTime;
    return speed;
  }
  const fn2 = (_ref) => {
    let {
      x,
      y: y2,
      placement,
      elements,
      onClose,
      nodeId,
      tree
    } = _ref;
    return function onMouseMove(event) {
      function close() {
        clearTimeout(timeoutId2);
        onClose();
      }
      clearTimeout(timeoutId2);
      if (!elements.domReference || !elements.floating || placement == null || x == null || y2 == null) {
        return;
      }
      const {
        clientX,
        clientY
      } = event;
      const clientPoint = [clientX, clientY];
      const target = getTarget$1(event);
      const isLeave = event.type === "mouseleave";
      const isOverFloatingEl = contains(elements.floating, target);
      const isOverReferenceEl = contains(elements.domReference, target);
      const refRect = elements.domReference.getBoundingClientRect();
      const rect = elements.floating.getBoundingClientRect();
      const side = placement.split("-")[0];
      const cursorLeaveFromRight = x > rect.right - rect.width / 2;
      const cursorLeaveFromBottom = y2 > rect.bottom - rect.height / 2;
      const isOverReferenceRect = isInside(clientPoint, refRect);
      const isFloatingWider = rect.width > refRect.width;
      const isFloatingTaller = rect.height > refRect.height;
      const left = (isFloatingWider ? refRect : rect).left;
      const right = (isFloatingWider ? refRect : rect).right;
      const top = (isFloatingTaller ? refRect : rect).top;
      const bottom = (isFloatingTaller ? refRect : rect).bottom;
      if (isOverFloatingEl) {
        hasLanded = true;
        if (!isLeave) {
          return;
        }
      }
      if (isOverReferenceEl) {
        hasLanded = false;
      }
      if (isOverReferenceEl && !isLeave) {
        hasLanded = true;
        return;
      }
      if (isLeave && isElement$1(event.relatedTarget) && contains(elements.floating, event.relatedTarget)) {
        return;
      }
      if (tree && getChildren(tree.nodesRef.current, nodeId).some((_ref2) => {
        let {
          context
        } = _ref2;
        return context == null ? void 0 : context.open;
      })) {
        return;
      }
      if (side === "top" && y2 >= refRect.bottom - 1 || side === "bottom" && y2 <= refRect.top + 1 || side === "left" && x >= refRect.right - 1 || side === "right" && x <= refRect.left + 1) {
        return close();
      }
      let rectPoly = [];
      switch (side) {
        case "top":
          rectPoly = [[left, refRect.top + 1], [left, rect.bottom - 1], [right, rect.bottom - 1], [right, refRect.top + 1]];
          break;
        case "bottom":
          rectPoly = [[left, rect.top + 1], [left, refRect.bottom - 1], [right, refRect.bottom - 1], [right, rect.top + 1]];
          break;
        case "left":
          rectPoly = [[rect.right - 1, bottom], [rect.right - 1, top], [refRect.left + 1, top], [refRect.left + 1, bottom]];
          break;
        case "right":
          rectPoly = [[refRect.right - 1, bottom], [refRect.right - 1, top], [rect.left + 1, top], [rect.left + 1, bottom]];
          break;
      }
      function getPolygon(_ref3) {
        let [x2, y3] = _ref3;
        switch (side) {
          case "top": {
            const cursorPointOne = [isFloatingWider ? x2 + buffer / 2 : cursorLeaveFromRight ? x2 + buffer * 4 : x2 - buffer * 4, y3 + buffer + 1];
            const cursorPointTwo = [isFloatingWider ? x2 - buffer / 2 : cursorLeaveFromRight ? x2 + buffer * 4 : x2 - buffer * 4, y3 + buffer + 1];
            const commonPoints = [[rect.left, cursorLeaveFromRight ? rect.bottom - buffer : isFloatingWider ? rect.bottom - buffer : rect.top], [rect.right, cursorLeaveFromRight ? isFloatingWider ? rect.bottom - buffer : rect.top : rect.bottom - buffer]];
            return [cursorPointOne, cursorPointTwo, ...commonPoints];
          }
          case "bottom": {
            const cursorPointOne = [isFloatingWider ? x2 + buffer / 2 : cursorLeaveFromRight ? x2 + buffer * 4 : x2 - buffer * 4, y3 - buffer];
            const cursorPointTwo = [isFloatingWider ? x2 - buffer / 2 : cursorLeaveFromRight ? x2 + buffer * 4 : x2 - buffer * 4, y3 - buffer];
            const commonPoints = [[rect.left, cursorLeaveFromRight ? rect.top + buffer : isFloatingWider ? rect.top + buffer : rect.bottom], [rect.right, cursorLeaveFromRight ? isFloatingWider ? rect.top + buffer : rect.bottom : rect.top + buffer]];
            return [cursorPointOne, cursorPointTwo, ...commonPoints];
          }
          case "left": {
            const cursorPointOne = [x2 + buffer + 1, isFloatingTaller ? y3 + buffer / 2 : cursorLeaveFromBottom ? y3 + buffer * 4 : y3 - buffer * 4];
            const cursorPointTwo = [x2 + buffer + 1, isFloatingTaller ? y3 - buffer / 2 : cursorLeaveFromBottom ? y3 + buffer * 4 : y3 - buffer * 4];
            const commonPoints = [[cursorLeaveFromBottom ? rect.right - buffer : isFloatingTaller ? rect.right - buffer : rect.left, rect.top], [cursorLeaveFromBottom ? isFloatingTaller ? rect.right - buffer : rect.left : rect.right - buffer, rect.bottom]];
            return [...commonPoints, cursorPointOne, cursorPointTwo];
          }
          case "right": {
            const cursorPointOne = [x2 - buffer, isFloatingTaller ? y3 + buffer / 2 : cursorLeaveFromBottom ? y3 + buffer * 4 : y3 - buffer * 4];
            const cursorPointTwo = [x2 - buffer, isFloatingTaller ? y3 - buffer / 2 : cursorLeaveFromBottom ? y3 + buffer * 4 : y3 - buffer * 4];
            const commonPoints = [[cursorLeaveFromBottom ? rect.left + buffer : isFloatingTaller ? rect.left + buffer : rect.right, rect.top], [cursorLeaveFromBottom ? isFloatingTaller ? rect.left + buffer : rect.right : rect.left + buffer, rect.bottom]];
            return [cursorPointOne, cursorPointTwo, ...commonPoints];
          }
        }
      }
      if (isPointInPolygon([clientX, clientY], rectPoly)) {
        return;
      } else if (hasLanded && !isOverReferenceRect) {
        return close();
      }
      if (!isLeave && requireIntent) {
        const cursorSpeed = getCursorSpeed(event.clientX, event.clientY);
        const cursorSpeedThreshold = 0.1;
        if (cursorSpeed !== null && cursorSpeed < cursorSpeedThreshold) {
          return close();
        }
      }
      if (!isPointInPolygon([clientX, clientY], getPolygon([x, y2]))) {
        close();
      } else if (!hasLanded && requireIntent) {
        timeoutId2 = window.setTimeout(close, 40);
      }
    };
  };
  fn2.__options = {
    blockPointerEvents
  };
  return fn2;
}
const DropdownDivider = ({ className, ...props }) => {
  const theme2 = useTheme().theme.dropdown.floating.divider;
  return jsxRuntimeExports.jsx("div", { className: twMerge(theme2, className), ...props });
};
const DropdownHeader = ({ children, className, ...props }) => {
  const theme2 = useTheme().theme.dropdown.floating.header;
  return jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [jsxRuntimeExports.jsx("div", { className: twMerge(theme2, className), ...props, children }), jsxRuntimeExports.jsx(DropdownDivider, {})] });
};
const DropdownItem = ({ children, className, icon: Icon2, onClick, theme: customTheme = {}, ...props }) => {
  const { ref, index: index2 } = useListItem({ label: typeof children === "string" ? children : void 0 });
  const { activeIndex, dismissOnClick, getItemProps, handleSelect } = reactExports.useContext(DropdownContext);
  const isActive = activeIndex === index2;
  const theme2 = mergeDeep(useTheme().theme.dropdown.floating.item, customTheme);
  const theirProps = props;
  return jsxRuntimeExports.jsx("li", { role: "menuitem", className: theme2.container, children: jsxRuntimeExports.jsxs(ButtonBase, { ref, className: twMerge(theme2.base, className), ...theirProps, ...getItemProps({
    onClick: () => {
      onClick && onClick();
      dismissOnClick && handleSelect(null);
    }
  }), tabIndex: isActive ? 0 : -1, children: [Icon2 && jsxRuntimeExports.jsx(Icon2, { className: theme2.icon }), children] }) });
};
const getMiddleware = ({ arrowRef, placement }) => {
  const middleware = [];
  middleware.push(offset$1(8));
  middleware.push(placement === "auto" ? autoPlacement() : flip());
  middleware.push(shift$1({ padding: 8 }));
  if (arrowRef == null ? void 0 : arrowRef.current) {
    middleware.push(arrow({ element: arrowRef.current }));
  }
  return middleware;
};
const getPlacement = ({ placement }) => {
  return placement === "auto" ? void 0 : placement;
};
const getArrowPlacement = ({ placement }) => {
  return {
    top: "bottom",
    right: "left",
    bottom: "top",
    left: "right"
  }[placement.split("-")[0]];
};
const useBaseFLoating = ({ open, arrowRef, placement = "top", setOpen }) => {
  return useFloating({
    placement: getPlacement({ placement }),
    open,
    onOpenChange: setOpen,
    whileElementsMounted: autoUpdate,
    middleware: getMiddleware({ placement, arrowRef })
  });
};
const useFloatingInteractions = ({ context, trigger, role = "tooltip", interactions = [] }) => {
  return useInteractions([
    useClick(context, { enabled: trigger === "click" }),
    useHover(context, {
      enabled: trigger === "hover",
      handleClose: safePolygon()
    }),
    useDismiss(context),
    useRole(context, { role }),
    ...interactions
  ]);
};
const icons = {
  top: HiOutlineChevronUp,
  right: HiOutlineChevronRight,
  bottom: HiOutlineChevronDown,
  left: HiOutlineChevronLeft
};
const Trigger = ({ refs, children, inline, theme: theme2, disabled, setButtonWidth, getReferenceProps, renderTrigger, ...buttonProps }) => {
  const ref = refs.reference;
  const a11yProps = getReferenceProps();
  reactExports.useEffect(() => {
    if (ref.current) {
      setButtonWidth == null ? void 0 : setButtonWidth(ref.current.clientWidth);
    }
  }, [ref, setButtonWidth]);
  if (renderTrigger) {
    const triggerElement = renderTrigger(theme2);
    return reactExports.cloneElement(triggerElement, { ref: refs.setReference, disabled, ...a11yProps, ...triggerElement.props });
  }
  return inline ? jsxRuntimeExports.jsx("button", { type: "button", ref: refs.setReference, className: theme2 == null ? void 0 : theme2.inlineWrapper, disabled, ...a11yProps, children }) : jsxRuntimeExports.jsx(Button, { ...buttonProps, disabled, type: "button", ref: refs.setReference, ...a11yProps, children });
};
const DropdownContext = reactExports.createContext({});
const DropdownComponent = ({ children, className, dismissOnClick = true, theme: customTheme = {}, renderTrigger, ...props }) => {
  const [open, setOpen] = reactExports.useState(false);
  const [activeIndex, setActiveIndex] = reactExports.useState(null);
  const [selectedIndex, setSelectedIndex] = reactExports.useState(null);
  const [buttonWidth, setButtonWidth] = reactExports.useState(void 0);
  const elementsRef = reactExports.useRef([]);
  const labelsRef = reactExports.useRef([]);
  const theme2 = mergeDeep(useTheme().theme.dropdown, customTheme);
  const theirProps = props;
  const dataTestId = props["data-testid"] || "flowbite-dropdown-target";
  const { placement = props.inline ? "bottom-start" : "bottom", trigger = "click", label, inline, arrowIcon = true, ...buttonProps } = theirProps;
  const handleSelect = reactExports.useCallback((index2) => {
    setSelectedIndex(index2);
    setOpen(false);
  }, []);
  const handleTypeaheadMatch = reactExports.useCallback((index2) => {
    if (open) {
      setActiveIndex(index2);
    } else {
      handleSelect(index2);
    }
  }, [open, handleSelect]);
  const { context, floatingStyles, refs } = useBaseFLoating({
    open,
    setOpen,
    placement
  });
  const listNav = useListNavigation(context, {
    listRef: elementsRef,
    activeIndex,
    selectedIndex,
    onNavigate: setActiveIndex
  });
  const typeahead = useTypeahead(context, {
    listRef: labelsRef,
    activeIndex,
    selectedIndex,
    onMatch: handleTypeaheadMatch
  });
  const { getReferenceProps, getFloatingProps, getItemProps } = useFloatingInteractions({
    context,
    role: "menu",
    trigger,
    interactions: [listNav, typeahead]
  });
  const Icon2 = reactExports.useMemo(() => {
    const [p2] = placement.split("-");
    return icons[p2] ?? HiOutlineChevronDown;
  }, [placement]);
  return jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [jsxRuntimeExports.jsxs(Trigger, { ...buttonProps, refs, inline, theme: theme2, "data-testid": dataTestId, className: twMerge(theme2.floating.target, buttonProps.className), setButtonWidth, getReferenceProps, renderTrigger, children: [label, arrowIcon && jsxRuntimeExports.jsx(Icon2, { className: theme2.arrowIcon })] }), jsxRuntimeExports.jsx(DropdownContext.Provider, { value: {
    activeIndex,
    dismissOnClick,
    getItemProps,
    handleSelect
  }, children: open && jsxRuntimeExports.jsx(FloatingFocusManager, { context, modal: false, children: jsxRuntimeExports.jsx("div", { ref: refs.setFloating, style: { ...floatingStyles, minWidth: buttonWidth }, "data-testid": "flowbite-dropdown", "aria-expanded": open, ...getFloatingProps({
    className: twMerge(theme2.floating.base, theme2.floating.animation, "duration-100", !open && theme2.floating.hidden, theme2.floating.style.auto, className)
  }), children: jsxRuntimeExports.jsx(FloatingList, { elementsRef, labelsRef, children: jsxRuntimeExports.jsx("ul", { className: theme2.content, tabIndex: -1, children }) }) }) }) })] });
};
DropdownComponent.displayName = "Dropdown";
DropdownHeader.displayName = "Dropdown.Header";
DropdownDivider.displayName = "Dropdown.Divider";
Object.assign(DropdownComponent, {
  Item: DropdownItem,
  Header: DropdownHeader,
  Divider: DropdownDivider
});
const FileInput = reactExports.forwardRef(({ className, color = "gray", helperText, sizing = "md", theme: customTheme = {}, ...props }, ref) => {
  const theme2 = mergeDeep(useTheme().theme.fileInput, customTheme);
  return jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [jsxRuntimeExports.jsx("div", { className: twMerge(theme2.root.base, className), children: jsxRuntimeExports.jsx("div", { className: theme2.field.base, children: jsxRuntimeExports.jsx("input", { className: twMerge(theme2.field.input.base, theme2.field.input.colors[color], theme2.field.input.sizes[sizing]), ...props, type: "file", ref }) }) }), helperText && jsxRuntimeExports.jsx(HelperText, { color, children: helperText })] });
});
FileInput.displayName = "FileInput";
const FooterBrand = ({ alt, className, children, href, name, src, theme: customTheme = {}, ...props }) => {
  const theme2 = mergeDeep(useTheme().theme.footer.brand, customTheme);
  return jsxRuntimeExports.jsx("div", { children: href ? jsxRuntimeExports.jsxs("a", { "data-testid": "flowbite-footer-brand", href, className: twMerge(theme2.base, className), ...props, children: [jsxRuntimeExports.jsx("img", { alt, src, className: theme2.img }), jsxRuntimeExports.jsx("span", { "data-testid": "flowbite-footer-brand-span", className: theme2.span, children: name }), children] }) : jsxRuntimeExports.jsx("img", { alt, "data-testid": "flowbite-footer-brand", src, className: twMerge(theme2.img, className), ...props }) });
};
const FooterCopyright = ({ by, className, href, theme: customTheme = {}, year, ...props }) => {
  const theme2 = mergeDeep(useTheme().theme.footer.copyright, customTheme);
  return jsxRuntimeExports.jsxs("div", { "data-testid": "flowbite-footer-copyright", className: twMerge(theme2.base, className), ...props, children: ["© ", year, href ? jsxRuntimeExports.jsx("a", { href, className: theme2.href, children: by }) : jsxRuntimeExports.jsx("span", { "data-testid": "flowbite-footer-copyright-span", className: theme2.span, children: by })] });
};
const FooterDivider = ({ className, theme: customTheme = {}, ...props }) => {
  const theme2 = mergeDeep(useTheme().theme.footer.divider, customTheme);
  return jsxRuntimeExports.jsx("hr", { "data-testid": "footer-divider", className: twMerge(theme2.base, className), ...props });
};
const FooterIcon = ({ ariaLabel, className, href, icon: Icon2, theme: customTheme = {}, ...props }) => {
  const theme2 = mergeDeep(useTheme().theme.footer.icon, customTheme);
  return jsxRuntimeExports.jsx("div", { children: href ? jsxRuntimeExports.jsx("a", { "aria-label": ariaLabel, "data-testid": "flowbite-footer-icon", href, className: twMerge(theme2.base, className), ...props, children: jsxRuntimeExports.jsx(Icon2, { className: theme2.size }) }) : jsxRuntimeExports.jsx(Icon2, { "data-testid": "flowbite-footer-icon", className: theme2.size, ...props }) });
};
const FooterLink = ({ as: Component = "a", children, className, href, theme: customTheme = {}, ...props }) => {
  const theme2 = mergeDeep(useTheme().theme.footer.groupLink.link, customTheme);
  return jsxRuntimeExports.jsx("li", { className: twMerge(theme2.base, className), children: jsxRuntimeExports.jsx(Component, { href, className: theme2.href, ...props, children }) });
};
const FooterLinkGroup = ({ children, className, col = false, theme: customTheme = {}, ...props }) => {
  const theme2 = mergeDeep(useTheme().theme.footer.groupLink, customTheme);
  return jsxRuntimeExports.jsx("ul", { "data-testid": "footer-groupLink", className: twMerge(theme2.base, col && theme2.col, className), ...props, children });
};
const FooterTitle = ({ as: Component = "h2", className, theme: customTheme = {}, title, ...props }) => {
  const theme2 = mergeDeep(useTheme().theme.footer.title, customTheme);
  return jsxRuntimeExports.jsx(Component, { "data-testid": "flowbite-footer-title", className: twMerge(theme2.base, className), ...props, children: title });
};
const FooterComponent = ({ bgDark = false, children, className, container = false, theme: customTheme = {}, ...props }) => {
  const theme2 = mergeDeep(useTheme().theme.footer, customTheme);
  return jsxRuntimeExports.jsx("footer", { "data-testid": "flowbite-footer", className: twMerge(theme2.root.base, bgDark && theme2.root.bgDark, container && theme2.root.container, className), ...props, children });
};
FooterComponent.displayName = "Footer";
FooterCopyright.displayName = "Footer.Copyright";
FooterLink.displayName = "Footer.Link";
FooterBrand.displayName = "Footer.Brand";
FooterLinkGroup.displayName = "Footer.LinkGroup";
FooterIcon.displayName = "Footer.Icon";
FooterTitle.displayName = "Footer.Title";
FooterDivider.displayName = "Footer.Divider";
Object.assign(FooterComponent, {
  Copyright: FooterCopyright,
  Link: FooterLink,
  LinkGroup: FooterLinkGroup,
  Brand: FooterBrand,
  Icon: FooterIcon,
  Title: FooterTitle,
  Divider: FooterDivider
});
const HelperText = ({ children, className, color = "default", theme: customTheme = {}, value, ...props }) => {
  const theme2 = mergeDeep(useTheme().theme.helperText, customTheme);
  return jsxRuntimeExports.jsx("p", { className: twMerge(theme2.root.base, theme2.root.colors[color], className), ...props, children: value ?? children ?? "" });
};
HelperText.displayName = "HelperText";
const ListGroupItem = ({ active: isActive, children, className, href, icon: Icon2, onClick, theme: customTheme = {}, ...props }) => {
  const theme2 = mergeDeep(useTheme().theme.listGroup.item, customTheme);
  const isLink = typeof href !== "undefined";
  const Component = isLink ? "a" : "button";
  return jsxRuntimeExports.jsx("li", { className: twMerge(theme2.base, className), children: jsxRuntimeExports.jsxs(Component, { href, onClick, type: isLink ? void 0 : "button", className: twMerge(theme2.link.active[isActive ? "on" : "off"], theme2.link.base, theme2.link.href[isLink ? "on" : "off"]), ...props, children: [Icon2 && jsxRuntimeExports.jsx(Icon2, { "aria-hidden": true, "data-testid": "flowbite-list-group-item-icon", className: theme2.link.icon }), children] }) });
};
const ListGroupComponent = ({ children, className, theme: customTheme = {}, ...props }) => {
  const theme2 = mergeDeep(useTheme().theme.listGroup, customTheme);
  return jsxRuntimeExports.jsx("ul", { className: twMerge(theme2.root.base, className), ...props, children });
};
ListGroupComponent.displayName = "ListGroup";
ListGroupItem.displayName = "ListGroup.Item";
Object.assign(ListGroupComponent, { Item: ListGroupItem });
const ModalContext = reactExports.createContext(void 0);
function useModalContext() {
  const context = reactExports.useContext(ModalContext);
  if (!context) {
    throw new Error("useModalContext should be used within the ModalContext provider!");
  }
  return context;
}
const ModalBody = ({ children, className, theme: customTheme = {}, ...props }) => {
  const theme2 = mergeDeep(useTheme().theme.modal.body, customTheme);
  const { popup } = useModalContext();
  return jsxRuntimeExports.jsx("div", { className: twMerge(theme2.base, popup && [theme2.popup], className), ...props, children });
};
const ModalFooter$1 = ({ children, className, theme: customTheme = {}, ...props }) => {
  const theme2 = mergeDeep(useTheme().theme.modal.footer, customTheme);
  const { popup } = useModalContext();
  return jsxRuntimeExports.jsx("div", { className: twMerge(theme2.base, !popup && theme2.popup, className), ...props, children });
};
const ModalHeader = ({ as: Component = "h3", children, className, theme: customTheme = {}, id: id2, ...props }) => {
  const innerHeaderId = reactExports.useId();
  const headerId = id2 || innerHeaderId;
  const theme2 = mergeDeep(useTheme().theme.modal.header, customTheme);
  const { popup, onClose, setHeaderId } = useModalContext();
  reactExports.useLayoutEffect(() => {
    setHeaderId(headerId);
    return () => setHeaderId(void 0);
  }, [headerId, setHeaderId]);
  return jsxRuntimeExports.jsxs("div", { className: twMerge(theme2.base, popup && theme2.popup, className), ...props, children: [jsxRuntimeExports.jsx(Component, { id: headerId, className: theme2.title, children }), jsxRuntimeExports.jsx("button", { "aria-label": "Close", className: theme2.close.base, type: "button", onClick: onClose, children: jsxRuntimeExports.jsx(HiOutlineX, { "aria-hidden": true, className: theme2.close.icon }) })] });
};
const ModalComponent = reactExports.forwardRef(({ children, className, dismissible = false, onClose, popup, position: position3 = "center", root, show, size = "2xl", theme: customTheme = {}, initialFocus, ...props }, theirRef) => {
  const [headerId, setHeaderId] = reactExports.useState(void 0);
  const theme2 = mergeDeep(useTheme().theme.modal, customTheme);
  const { context } = useFloating({
    open: show,
    onOpenChange: () => onClose && onClose()
  });
  const ref = useMergeRefs([context.refs.setFloating, theirRef]);
  const click = useClick(context);
  const dismiss = useDismiss(context, { outsidePressEvent: "mousedown", enabled: dismissible });
  const role = useRole(context);
  const { getFloatingProps } = useInteractions([click, dismiss, role]);
  if (!show) {
    return null;
  }
  return jsxRuntimeExports.jsx(ModalContext.Provider, { value: { popup, onClose, setHeaderId }, children: jsxRuntimeExports.jsx(FloatingPortal, { root, children: jsxRuntimeExports.jsx(FloatingOverlay, { lockScroll: true, "data-testid": "modal-overlay", className: twMerge(theme2.root.base, theme2.root.positions[position3], show ? theme2.root.show.on : theme2.root.show.off, className), ...props, children: jsxRuntimeExports.jsx(FloatingFocusManager, { context, initialFocus, children: jsxRuntimeExports.jsx("div", { ref, ...getFloatingProps(props), "aria-labelledby": headerId, className: twMerge(theme2.content.base, theme2.root.sizes[size]), children: jsxRuntimeExports.jsx("div", { className: theme2.content.inner, children }) }) }) }) }) });
});
ModalComponent.displayName = "Modal";
ModalHeader.displayName = "Modal.Header";
ModalBody.displayName = "Modal.Body";
ModalFooter$1.displayName = "Modal.Footer";
Object.assign(ModalComponent, { Header: ModalHeader, Body: ModalBody, Footer: ModalFooter$1 });
const NavbarBrand = ({ as: Component = "a", children, className, theme: customTheme = {}, ...props }) => {
  const theme2 = mergeDeep(useTheme().theme.navbar.brand, customTheme);
  return jsxRuntimeExports.jsx(Component, { className: twMerge(theme2.base, className), ...props, children });
};
const NavbarContext = reactExports.createContext(void 0);
function useNavbarContext() {
  const context = reactExports.useContext(NavbarContext);
  if (!context) {
    throw new Error("useNavBarContext should be used within the NavbarContext provider!");
  }
  return context;
}
const NavbarCollapse = ({ children, className, theme: customTheme = {}, ...props }) => {
  const { isOpen } = useNavbarContext();
  const theme2 = mergeDeep(useTheme().theme.navbar.collapse, customTheme);
  return jsxRuntimeExports.jsx("div", { "data-testid": "flowbite-navbar-collapse", className: twMerge(theme2.base, theme2.hidden[!isOpen ? "on" : "off"], className), ...props, children: jsxRuntimeExports.jsx("ul", { className: theme2.list, children }) });
};
const NavbarLink = ({ active, as: Component = "a", disabled, children, className, theme: customTheme = {}, ...props }) => {
  const theme2 = mergeDeep(useTheme().theme.navbar.link, customTheme);
  return jsxRuntimeExports.jsx("li", { children: jsxRuntimeExports.jsx(Component, { className: twMerge(theme2.base, active && theme2.active.on, !active && !disabled && theme2.active.off, theme2.disabled[disabled ? "on" : "off"], className), ...props, children }) });
};
function FaBars(props) {
  return GenIcon({ "tag": "svg", "attr": { "viewBox": "0 0 448 512" }, "child": [{ "tag": "path", "attr": { "d": "M16 132h416c8.837 0 16-7.163 16-16V76c0-8.837-7.163-16-16-16H16C7.163 60 0 67.163 0 76v40c0 8.837 7.163 16 16 16zm0 160h416c8.837 0 16-7.163 16-16v-40c0-8.837-7.163-16-16-16H16c-8.837 0-16 7.163-16 16v40c0 8.837 7.163 16 16 16zm0 160h416c8.837 0 16-7.163 16-16v-40c0-8.837-7.163-16-16-16H16c-8.837 0-16 7.163-16 16v40c0 8.837 7.163 16 16 16z" } }] })(props);
}
const NavbarToggle = ({ barIcon: BarIcon = FaBars, className, theme: customTheme = {}, ...props }) => {
  const { isOpen, setIsOpen } = useNavbarContext();
  const theme2 = mergeDeep(useTheme().theme.navbar.toggle, customTheme);
  const handleClick = () => {
    setIsOpen(!isOpen);
  };
  return jsxRuntimeExports.jsxs("button", { "data-testid": "flowbite-navbar-toggle", onClick: handleClick, className: twMerge(theme2.base, className), ...props, children: [jsxRuntimeExports.jsx("span", { className: "sr-only", children: "Open main menu" }), jsxRuntimeExports.jsx(BarIcon, { "aria-hidden": true, className: theme2.icon })] });
};
const NavbarComponent = ({ border, children, className, fluid = false, menuOpen, rounded, theme: customTheme = {}, ...props }) => {
  const [isOpen, setIsOpen] = reactExports.useState(menuOpen);
  const theme2 = mergeDeep(useTheme().theme.navbar.root, customTheme);
  return jsxRuntimeExports.jsx(NavbarContext.Provider, { value: { isOpen, setIsOpen }, children: jsxRuntimeExports.jsx("nav", { className: twMerge(theme2.base, theme2.bordered[border ? "on" : "off"], theme2.rounded[rounded ? "on" : "off"], className), ...props, children: jsxRuntimeExports.jsx("div", { className: twMerge(theme2.inner.base, theme2.inner.fluid[fluid ? "on" : "off"]), children }) }) });
};
NavbarComponent.displayName = "Navbar";
NavbarBrand.displayName = "Navbar.Brand";
NavbarCollapse.displayName = "Navbar.Collapse";
NavbarLink.displayName = "Navbar.Link";
NavbarToggle.displayName = "Navbar.Toggle";
Object.assign(NavbarComponent, {
  Brand: NavbarBrand,
  Collapse: NavbarCollapse,
  Link: NavbarLink,
  Toggle: NavbarToggle
});
const PaginationButton = ({ active, children, className, onClick, theme: customTheme = {}, ...props }) => {
  const theme2 = mergeDeep(useTheme().theme.pagination, customTheme);
  return jsxRuntimeExports.jsx("button", { type: "button", className: twMerge(active && theme2.pages.selector.active, className), onClick, ...props, children });
};
PaginationButton.displayName = "Pagination.Button";
const PaginationNavigation = ({ children, className, onClick, theme: customTheme = {}, disabled = false, ...props }) => {
  const theme2 = mergeDeep(useTheme().theme.pagination, customTheme);
  return jsxRuntimeExports.jsx("button", { type: "button", className: twMerge(disabled && theme2.pages.selector.disabled, className), disabled, onClick, ...props, children });
};
PaginationNavigation.displayName = "Pagination.Navigation";
const range = (start, end2) => {
  if (start >= end2) {
    return [];
  }
  return [...Array(end2 - start + 1).keys()].map((key) => key + start);
};
const PaginationComponent = ({ className, currentPage, layout = "pagination", nextLabel = "Next", onPageChange, previousLabel = "Previous", renderPaginationButton = (props2) => jsxRuntimeExports.jsx(PaginationButton, { ...props2 }), showIcons: showIcon = false, theme: customTheme = {}, totalPages, ...props }) => {
  const theme2 = mergeDeep(useTheme().theme.pagination, customTheme);
  const lastPage = Math.min(Math.max(currentPage + 2, 5), totalPages);
  const firstPage = Math.max(1, lastPage - 4);
  const goToNextPage = () => {
    onPageChange(Math.min(currentPage + 1, totalPages));
  };
  const goToPreviousPage = () => {
    onPageChange(Math.max(currentPage - 1, 1));
  };
  return jsxRuntimeExports.jsxs("nav", { className: twMerge(theme2.base, className), ...props, children: [layout === "table" && jsxRuntimeExports.jsxs("div", { className: theme2.layout.table.base, children: ["Showing ", jsxRuntimeExports.jsx("span", { className: theme2.layout.table.span, children: firstPage }), " to ", jsxRuntimeExports.jsx("span", { className: theme2.layout.table.span, children: lastPage }), " of ", jsxRuntimeExports.jsx("span", { className: theme2.layout.table.span, children: totalPages }), " Entries"] }), jsxRuntimeExports.jsxs("ul", { className: theme2.pages.base, children: [jsxRuntimeExports.jsx("li", { children: jsxRuntimeExports.jsxs(PaginationNavigation, { className: twMerge(theme2.pages.previous.base, showIcon && theme2.pages.showIcon), onClick: goToPreviousPage, disabled: currentPage === 1, children: [showIcon && jsxRuntimeExports.jsx(HiChevronLeft, { "aria-hidden": true, className: theme2.pages.previous.icon }), previousLabel] }) }), layout === "pagination" && range(firstPage, lastPage).map((page) => jsxRuntimeExports.jsx("li", { "aria-current": page === currentPage ? "page" : void 0, children: renderPaginationButton({
    className: twMerge(theme2.pages.selector.base, currentPage === page && theme2.pages.selector.active),
    active: page === currentPage,
    onClick: () => onPageChange(page),
    children: page
  }) }, page)), jsxRuntimeExports.jsx("li", { children: jsxRuntimeExports.jsxs(PaginationNavigation, { className: twMerge(theme2.pages.next.base, showIcon && theme2.pages.showIcon), onClick: goToNextPage, disabled: currentPage === totalPages, children: [nextLabel, showIcon && jsxRuntimeExports.jsx(HiChevronRight, { "aria-hidden": true, className: theme2.pages.next.icon })] }) })] })] });
};
PaginationComponent.displayName = "Pagination";
Object.assign(PaginationComponent, {
  Button: PaginationButton
});
const Radio = reactExports.forwardRef(({ className, theme: customTheme = {}, ...props }, ref) => {
  const theme2 = mergeDeep(useTheme().theme.radio, customTheme);
  return jsxRuntimeExports.jsx("input", { ref, type: "radio", className: twMerge(theme2.root.base, className), ...props });
});
Radio.displayName = "Radio";
const RangeSlider = reactExports.forwardRef(({ className, sizing = "md", theme: customTheme = {}, ...props }, ref) => {
  const theme2 = mergeDeep(useTheme().theme.rangeSlider, customTheme);
  return jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children: jsxRuntimeExports.jsx("div", { "data-testid": "flowbite-range-slider", className: twMerge(theme2.root.base, className), children: jsxRuntimeExports.jsx("div", { className: theme2.field.base, children: jsxRuntimeExports.jsx("input", { ref, type: "range", className: twMerge(theme2.field.input.base, theme2.field.input.sizes[sizing]), ...props }) }) }) });
});
RangeSlider.displayName = "RangeSlider";
const RatingAdvanced = ({ children, className, percentFilled = 0, theme: customTheme = {}, ...props }) => {
  const theme2 = mergeDeep(useTheme().theme.rating.advanced, customTheme);
  return jsxRuntimeExports.jsxs("div", { className: twMerge(theme2.base, className), ...props, children: [jsxRuntimeExports.jsx("span", { className: theme2.label, children }), jsxRuntimeExports.jsx("div", { className: theme2.progress.base, children: jsxRuntimeExports.jsx("div", { className: theme2.progress.fill, "data-testid": "flowbite-rating-fill", style: { width: `${percentFilled}%` } }) }), jsxRuntimeExports.jsx("span", { className: theme2.progress.label, children: `${percentFilled}%` })] });
};
const RatingContext = reactExports.createContext(void 0);
function useRatingContext() {
  const context = reactExports.useContext(RatingContext);
  if (!context) {
    throw new Error("useRatingContext should be used within the RatingContext provider!");
  }
  return context;
}
const RatingStar = ({ className, filled = true, starIcon: Icon2 = HiStar, theme: customTheme = {}, ...props }) => {
  const { size = "sm" } = useRatingContext();
  const theme2 = mergeDeep(useTheme().theme.rating.star, customTheme);
  return jsxRuntimeExports.jsx(Icon2, { "data-testid": "flowbite-rating-star", className: twMerge(theme2.sizes[size], theme2[filled ? "filled" : "empty"], className), ...props });
};
const RatingComponent = ({ children, className, size = "sm", theme: customTheme = {}, ...props }) => {
  const theme2 = mergeDeep(useTheme().theme.rating, customTheme);
  return jsxRuntimeExports.jsx(RatingContext.Provider, { value: { size }, children: jsxRuntimeExports.jsx("div", { className: twMerge(theme2.root.base, className), ...props, children }) });
};
RatingComponent.displayName = "Rating";
RatingStar.displayName = "Rating.Star";
RatingAdvanced.displayName = "Rating.Advanced";
Object.assign(RatingComponent, {
  Star: RatingStar,
  Advanced: RatingAdvanced
});
const Select = reactExports.forwardRef(({ addon, children, className, color = "gray", helperText, icon: Icon2, shadow, sizing = "md", theme: customTheme = {}, ...props }, ref) => {
  const theme2 = mergeDeep(useTheme().theme.select, customTheme);
  return jsxRuntimeExports.jsxs("div", { className: twMerge(theme2.base, className), children: [addon && jsxRuntimeExports.jsx("span", { className: theme2.addon, children: addon }), jsxRuntimeExports.jsxs("div", { className: theme2.field.base, children: [Icon2 && jsxRuntimeExports.jsx("div", { className: theme2.field.icon.base, children: jsxRuntimeExports.jsx(Icon2, { className: theme2.field.icon.svg }) }), jsxRuntimeExports.jsx("select", { className: twMerge(theme2.field.select.base, theme2.field.select.colors[color], theme2.field.select.sizes[sizing], theme2.field.select.withIcon[Icon2 ? "on" : "off"], theme2.field.select.withAddon[addon ? "on" : "off"], theme2.field.select.withShadow[shadow ? "on" : "off"]), ...props, ref, children }), helperText && jsxRuntimeExports.jsx(HelperText, { color, children: helperText })] })] });
});
Select.displayName = "Select";
const SidebarContext = reactExports.createContext(void 0);
function useSidebarContext() {
  const context = reactExports.useContext(SidebarContext);
  if (!context) {
    throw new Error("useSidebarContext should be used within the SidebarContext provider!");
  }
  return context;
}
const SidebarCTA = ({ children, color = "info", className, theme: customTheme = {}, ...props }) => {
  const { isCollapsed } = useSidebarContext();
  const theme2 = mergeDeep(useTheme().theme.sidebar.cta, customTheme);
  return jsxRuntimeExports.jsx("div", { "data-testid": "sidebar-cta", hidden: isCollapsed, className: twMerge(theme2.base, theme2.color[color], className), ...props, children });
};
SidebarCTA.displayName = "Sidebar.CTA";
const SidebarItemContext = reactExports.createContext(void 0);
function useSidebarItemContext() {
  const context = reactExports.useContext(SidebarItemContext);
  if (!context) {
    throw new Error("useSidebarItemContext should be used within the SidebarItemContext provider!");
  }
  return context;
}
const SidebarCollapse = ({ children, className, icon: Icon2, label, chevronIcon: ChevronIcon = HiChevronDown, renderChevronIcon, open = false, theme: customTheme = {}, ...props }) => {
  const id2 = reactExports.useId();
  const { isCollapsed } = useSidebarContext();
  const [isOpen, setOpen] = reactExports.useState(open);
  const theme2 = mergeDeep(useTheme().theme.sidebar.collapse, customTheme);
  reactExports.useEffect(() => setOpen(open), [open]);
  const Wrapper = ({ children: children2 }) => jsxRuntimeExports.jsx("li", { children: isCollapsed && !isOpen ? jsxRuntimeExports.jsx(Tooltip, { content: label, placement: "right", children: children2 }) : children2 });
  return jsxRuntimeExports.jsxs(Wrapper, { children: [jsxRuntimeExports.jsxs("button", { id: `flowbite-sidebar-collapse-${id2}`, onClick: () => setOpen(!isOpen), title: label, type: "button", className: twMerge(theme2.button, className), ...props, children: [Icon2 && jsxRuntimeExports.jsx(Icon2, { "aria-hidden": true, "data-testid": "flowbite-sidebar-collapse-icon", className: twMerge(theme2.icon.base, theme2.icon.open[isOpen ? "on" : "off"]) }), isCollapsed ? jsxRuntimeExports.jsx("span", { className: "sr-only", children: label }) : jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [jsxRuntimeExports.jsx("span", { "data-testid": "flowbite-sidebar-collapse-label", className: theme2.label.base, children: label }), renderChevronIcon ? renderChevronIcon(theme2, isOpen) : jsxRuntimeExports.jsx(ChevronIcon, { "aria-hidden": true, className: twMerge(theme2.label.icon.base, theme2.label.icon.open[isOpen ? "on" : "off"]) })] })] }), jsxRuntimeExports.jsx("ul", { "aria-labelledby": `flowbite-sidebar-collapse-${id2}`, hidden: !isOpen, className: theme2.list, children: jsxRuntimeExports.jsx(SidebarItemContext.Provider, { value: { isInsideCollapse: true }, children }) })] });
};
SidebarCollapse.displayName = "Sidebar.Collapse";
const ListItem = ({ id: id2, isCollapsed, tooltipChildren, children: wrapperChildren, ...props }) => jsxRuntimeExports.jsx("li", { ...props, children: isCollapsed ? jsxRuntimeExports.jsx(Tooltip, { content: jsxRuntimeExports.jsx(TooltipContent, { id: id2, children: tooltipChildren }), placement: "right", children: wrapperChildren }) : wrapperChildren });
const TooltipContent = ({ id: id2, children }) => jsxRuntimeExports.jsx(Children, { id: id2, children });
const Children = ({ id: id2, children }) => {
  const theme2 = useTheme().theme.sidebar.item;
  return jsxRuntimeExports.jsx("span", { "data-testid": "flowbite-sidebar-item-content", id: `flowbite-sidebar-item-${id2}`, className: twMerge(theme2.content.base), children });
};
const SidebarItem = reactExports.forwardRef(({ active: isActive, as: Component = "a", children, className, icon: Icon2, label, labelColor = "info", theme: customTheme = {}, ...props }, ref) => {
  var _a, _b, _c, _d;
  const id2 = reactExports.useId();
  const { isCollapsed } = useSidebarContext();
  const { isInsideCollapse } = useSidebarItemContext();
  const theme2 = mergeDeep(useTheme().theme.sidebar.item, customTheme);
  return jsxRuntimeExports.jsx(ListItem, { className: theme2.listItem, id: id2, isCollapsed, tooltipChildren: children, children: jsxRuntimeExports.jsxs(Component, { "aria-labelledby": `flowbite-sidebar-item-${id2}`, ref, className: twMerge(theme2.base, isActive && theme2.active, !isCollapsed && isInsideCollapse && ((_a = theme2.collapsed) == null ? void 0 : _a.insideCollapse), className), ...props, children: [Icon2 && jsxRuntimeExports.jsx(Icon2, { "aria-hidden": true, "data-testid": "flowbite-sidebar-item-icon", className: twMerge((_b = theme2.icon) == null ? void 0 : _b.base, isActive && ((_c = theme2.icon) == null ? void 0 : _c.active)) }), isCollapsed && !Icon2 && jsxRuntimeExports.jsx("span", { className: (_d = theme2.collapsed) == null ? void 0 : _d.noIcon, children: children.charAt(0).toLocaleUpperCase() ?? "?" }), !isCollapsed && jsxRuntimeExports.jsx(Children, { id: id2, children }), !isCollapsed && label && jsxRuntimeExports.jsx(Badge, { color: labelColor, "data-testid": "flowbite-sidebar-label", hidden: isCollapsed, className: theme2.label, children: label })] }) });
});
SidebarItem.displayName = "Sidebar.Item";
const SidebarItemGroup = ({ children, className, ...props }) => {
  const theme2 = useTheme().theme.sidebar.itemGroup;
  return jsxRuntimeExports.jsx("ul", { "data-testid": "flowbite-sidebar-item-group", className: twMerge(theme2, className), ...props, children: jsxRuntimeExports.jsx(SidebarItemContext.Provider, { value: { isInsideCollapse: false }, children }) });
};
SidebarItemGroup.displayName = "Sidebar.ItemGroup";
const SidebarItems = ({ children, className, ...props }) => {
  const theme2 = useTheme().theme.sidebar.items;
  return jsxRuntimeExports.jsx("div", { className: twMerge(theme2, className), "data-testid": "flowbite-sidebar-items", ...props, children });
};
SidebarItems.displayName = "Sidebar.Items";
const SidebarLogo = ({ children, className, href, img, imgAlt = "", theme: customTheme = {}, ...props }) => {
  const id2 = reactExports.useId();
  const { isCollapsed } = useSidebarContext();
  const theme2 = mergeDeep(useTheme().theme.sidebar.logo, customTheme);
  return jsxRuntimeExports.jsxs("a", { "aria-labelledby": `flowbite-sidebar-logo-${id2}`, href, className: twMerge(theme2.base, className), ...props, children: [jsxRuntimeExports.jsx("img", { alt: imgAlt, src: img, className: theme2.img }), jsxRuntimeExports.jsx("span", { className: theme2.collapsed[isCollapsed ? "on" : "off"], id: `flowbite-sidebar-logo-${id2}`, children })] });
};
SidebarLogo.displayName = "Sidebar.Logo";
const SidebarComponent = ({ children, as: Component = "nav", collapseBehavior = "collapse", collapsed: isCollapsed = false, theme: customTheme = {}, className, ...props }) => {
  const theme2 = mergeDeep(useTheme().theme.sidebar, customTheme);
  return jsxRuntimeExports.jsx(SidebarContext.Provider, { value: { isCollapsed }, children: jsxRuntimeExports.jsx(Component, { "aria-label": "Sidebar", hidden: isCollapsed && collapseBehavior === "hide", className: twMerge(theme2.root.base, theme2.root.collapsed[isCollapsed ? "on" : "off"], className), ...props, children: jsxRuntimeExports.jsx("div", { className: theme2.root.inner, children }) }) });
};
SidebarComponent.displayName = "Sidebar";
Object.assign(SidebarComponent, {
  Collapse: SidebarCollapse,
  CTA: SidebarCTA,
  Item: SidebarItem,
  Items: SidebarItems,
  ItemGroup: SidebarItemGroup,
  Logo: SidebarLogo
});
const Spinner = ({ className, color = "info", light, size = "md", theme: customTheme = {}, ...props }) => {
  const theme2 = mergeDeep(useTheme().theme.spinner, customTheme);
  return jsxRuntimeExports.jsx("span", { role: "status", ...props, children: jsxRuntimeExports.jsxs("svg", { fill: "none", viewBox: "0 0 100 101", className: twMerge(theme2.base, theme2.color[color], theme2.light[light ? "on" : "off"].base, theme2.light[light ? "on" : "off"].color[color], theme2.size[size], className), children: [jsxRuntimeExports.jsx("path", { d: "M100 50.5908C100 78.2051 77.6142 100.591 50 100.591C22.3858 100.591 0 78.2051 0 50.5908C0 22.9766 22.3858 0.59082 50 0.59082C77.6142 0.59082 100 22.9766 100 50.5908ZM9.08144 50.5908C9.08144 73.1895 27.4013 91.5094 50 91.5094C72.5987 91.5094 90.9186 73.1895 90.9186 50.5908C90.9186 27.9921 72.5987 9.67226 50 9.67226C27.4013 9.67226 9.08144 27.9921 9.08144 50.5908Z", fill: "currentColor" }), jsxRuntimeExports.jsx("path", { d: "M93.9676 39.0409C96.393 38.4038 97.8624 35.9116 97.0079 33.5539C95.2932 28.8227 92.871 24.3692 89.8167 20.348C85.8452 15.1192 80.8826 10.7238 75.2124 7.41289C69.5422 4.10194 63.2754 1.94025 56.7698 1.05124C51.7666 0.367541 46.6976 0.446843 41.7345 1.27873C39.2613 1.69328 37.813 4.19778 38.4501 6.62326C39.0873 9.04874 41.5694 10.4717 44.0505 10.1071C47.8511 9.54855 51.7191 9.52689 55.5402 10.0491C60.8642 10.7766 65.9928 12.5457 70.6331 15.2552C75.2735 17.9648 79.3347 21.5619 82.5849 25.841C84.9175 28.9121 86.7997 32.2913 88.1811 35.8758C89.083 38.2158 91.5421 39.6781 93.9676 39.0409Z", fill: "currentFill" })] }) });
};
Spinner.displayName = "Spinner";
const TabsComponent = reactExports.forwardRef(({ children, className, onActiveTabChange, style: style2 = "default", theme: customTheme = {}, ...props }, ref) => {
  const theme2 = mergeDeep(useTheme().theme.tab, customTheme);
  const id2 = reactExports.useId();
  const tabs = reactExports.useMemo(() => reactExports.Children.map(reactExports.Children.toArray(children), ({ props: props2 }) => props2), [children]);
  const tabRefs = reactExports.useRef([]);
  const [activeTab, setActiveTab] = reactExports.useState(Math.max(0, tabs.findIndex((tab2) => tab2.active)));
  const [focusedTab, setFocusedTab] = reactExports.useState(-1);
  const setActiveTabWithCallback = (activeTab2) => {
    setActiveTab(activeTab2);
    if (onActiveTabChange)
      onActiveTabChange(activeTab2);
  };
  const handleClick = ({ target }) => {
    setActiveTabWithCallback(target);
    setFocusedTab(target);
  };
  const handleKeyboard = ({ event, target }) => {
    if (event.key === "ArrowLeft") {
      setFocusedTab(Math.max(0, focusedTab - 1));
    }
    if (event.key === "ArrowRight") {
      setFocusedTab(Math.min(tabs.length - 1, focusedTab + 1));
    }
    if (event.key === "Enter") {
      setActiveTabWithCallback(target);
      setFocusedTab(target);
    }
  };
  const tabItemStyle = theme2.tablist.tabitem.styles[style2];
  const tabItemContainerStyle = theme2.tabitemcontainer.styles[style2];
  reactExports.useEffect(() => {
    var _a;
    (_a = tabRefs.current[focusedTab]) == null ? void 0 : _a.focus();
  }, [focusedTab]);
  reactExports.useImperativeHandle(ref, () => ({
    setActiveTab: setActiveTabWithCallback
  }));
  return jsxRuntimeExports.jsxs("div", { className: twMerge(theme2.base, className), children: [jsxRuntimeExports.jsx("div", { "aria-label": "Tabs", role: "tablist", className: twMerge(theme2.tablist.base, theme2.tablist.styles[style2], className), ...props, children: tabs.map((tab2, index2) => jsxRuntimeExports.jsxs("button", { type: "button", "aria-controls": `${id2}-tabpanel-${index2}`, "aria-selected": index2 === activeTab, className: twMerge(theme2.tablist.tabitem.base, tabItemStyle.base, index2 === activeTab && tabItemStyle.active.on, index2 !== activeTab && !tab2.disabled && tabItemStyle.active.off), disabled: tab2.disabled, id: `${id2}-tab-${index2}`, onClick: () => handleClick({ target: index2 }), onKeyDown: (event) => handleKeyboard({ event, target: index2 }), ref: (element) => tabRefs.current[index2] = element, role: "tab", tabIndex: index2 === focusedTab ? 0 : -1, style: { zIndex: index2 === focusedTab ? 2 : 1 }, children: [tab2.icon && jsxRuntimeExports.jsx(tab2.icon, { className: theme2.tablist.tabitem.icon }), tab2.title] }, index2)) }), jsxRuntimeExports.jsx("div", { className: twMerge(theme2.tabitemcontainer.base, tabItemContainerStyle), children: tabs.map((tab2, index2) => jsxRuntimeExports.jsx("div", { "aria-labelledby": `${id2}-tab-${index2}`, className: theme2.tabpanel, hidden: index2 !== activeTab, id: `${id2}-tabpanel-${index2}`, role: "tabpanel", tabIndex: 0, children: tab2.children }, index2)) })] });
});
TabsComponent.displayName = "Tabs.Group";
const TableBody = ({ children, className, theme: customTheme = {}, ...props }) => {
  const theme2 = mergeDeep(useTheme().theme.table.body, customTheme);
  return jsxRuntimeExports.jsx("tbody", { className: twMerge(theme2.base, className), ...props, children });
};
const TableCell = ({ children, className, theme: customTheme = {}, ...props }) => {
  const theme2 = mergeDeep(useTheme().theme.table.body.cell, customTheme);
  return jsxRuntimeExports.jsx("td", { className: twMerge(theme2.base, className), ...props, children });
};
const TableContext = reactExports.createContext(void 0);
function useTableContext() {
  const context = reactExports.useContext(TableContext);
  if (!context) {
    throw new Error("useTableContext should be used within the TableContext provider!");
  }
  return context;
}
const TableHead = ({ children, className, theme: customTheme = {}, ...props }) => {
  const theme2 = mergeDeep(useTheme().theme.table, customTheme);
  return jsxRuntimeExports.jsx("thead", { className: twMerge(theme2.head.base, className), ...props, children: jsxRuntimeExports.jsx("tr", { children }) });
};
const TableHeadCell = ({ children, className, theme: customTheme = {}, ...props }) => {
  const theme2 = mergeDeep(useTheme().theme.table.head.cell, customTheme);
  return jsxRuntimeExports.jsx("th", { className: twMerge(theme2.base, className), ...props, children });
};
const TableRow = ({ children, className, theme: customTheme = {}, ...props }) => {
  const { hoverable, striped } = useTableContext();
  const theme2 = mergeDeep(useTheme().theme.table.row, customTheme);
  return jsxRuntimeExports.jsx("tr", { "data-testid": "table-row-element", className: twMerge(theme2.base, striped && theme2.striped, hoverable && theme2.hovered, className), ...props, children });
};
const TableComponent = ({ children, className, hoverable, striped, theme: customTheme = {}, ...props }) => {
  const theme2 = mergeDeep(useTheme().theme.table, customTheme);
  return jsxRuntimeExports.jsx("div", { "data-testid": "table-element", className: twMerge(theme2.root.wrapper), children: jsxRuntimeExports.jsxs(TableContext.Provider, { value: { striped, hoverable }, children: [jsxRuntimeExports.jsx("div", { className: twMerge(theme2.root.shadow, className) }), jsxRuntimeExports.jsx("table", { className: twMerge(theme2.root.base, className), ...props, children })] }) });
};
TableComponent.displayName = "Table";
TableHead.displayName = "Table.Head";
TableBody.displayName = "Table.Body";
TableRow.displayName = "Table.Row";
TableCell.displayName = "Table.Cell";
TableHeadCell.displayName = "Table.HeadCell";
Object.assign(TableComponent, {
  Head: TableHead,
  Body: TableBody,
  Row: TableRow,
  Cell: TableCell,
  HeadCell: TableHeadCell
});
const TextInput = reactExports.forwardRef(({ addon, className, color = "gray", helperText, icon: Icon2, rightIcon: RightIcon, shadow, sizing = "md", theme: customTheme = {}, ...props }, ref) => {
  const theme2 = mergeDeep(useTheme().theme.textInput, customTheme);
  return jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [jsxRuntimeExports.jsxs("div", { className: twMerge(theme2.base, className), children: [addon && jsxRuntimeExports.jsx("span", { className: theme2.addon, children: addon }), jsxRuntimeExports.jsxs("div", { className: theme2.field.base, children: [Icon2 && jsxRuntimeExports.jsx("div", { className: theme2.field.icon.base, children: jsxRuntimeExports.jsx(Icon2, { className: theme2.field.icon.svg }) }), RightIcon && jsxRuntimeExports.jsx("div", { "data-testid": "right-icon", className: theme2.field.rightIcon.base, children: jsxRuntimeExports.jsx(RightIcon, { className: theme2.field.rightIcon.svg }) }), jsxRuntimeExports.jsx("input", { className: twMerge(theme2.field.input.base, theme2.field.input.colors[color], theme2.field.input.sizes[sizing], theme2.field.input.withIcon[Icon2 ? "on" : "off"], theme2.field.input.withRightIcon[RightIcon ? "on" : "off"], theme2.field.input.withAddon[addon ? "on" : "off"], theme2.field.input.withShadow[shadow ? "on" : "off"]), ...props, ref })] })] }), helperText && jsxRuntimeExports.jsx(HelperText, { color, children: helperText })] });
});
TextInput.displayName = "TextInput";
const Textarea = reactExports.forwardRef(({ className, color = "gray", helperText, shadow, theme: customTheme = {}, ...props }, ref) => {
  const theme2 = mergeDeep(useTheme().theme.textarea, customTheme);
  return jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [jsxRuntimeExports.jsx("textarea", { ref, className: twMerge(theme2.base, theme2.colors[color], theme2.withShadow[shadow ? "on" : "off"], className), ...props }), helperText && jsxRuntimeExports.jsx(HelperText, { color, children: helperText })] });
});
Textarea.displayName = "Textarea";
const TimelineBody = ({ children, className, theme: customTheme = {}, ...props }) => {
  const theme2 = mergeDeep(useTheme().theme.timeline.item.content, customTheme).body;
  return jsxRuntimeExports.jsx("div", { className: twMerge(theme2, className), ...props, children });
};
const TimelineContext = reactExports.createContext(void 0);
function useTimelineContext() {
  const context = reactExports.useContext(TimelineContext);
  if (!context) {
    throw new Error("useTimelineContext should be used within the TimelineContext providor!");
  }
  return context;
}
const TimelineContent = ({ children, className, theme: customTheme = {}, ...props }) => {
  const theme2 = mergeDeep(useTheme().theme.timeline.item.content, customTheme);
  const { horizontal: horizontal2 } = useTimelineContext();
  return jsxRuntimeExports.jsx("div", { "data-testid": "timeline-content", className: twMerge(horizontal2 && theme2.root.base, className), ...props, children });
};
const TimelineItem = ({ children, className, theme: customTheme = {}, ...props }) => {
  const theme2 = mergeDeep(useTheme().theme.timeline.item, customTheme);
  const { horizontal: horizontal2 } = useTimelineContext();
  return jsxRuntimeExports.jsx("li", { "data-testid": "timeline-item", className: twMerge(horizontal2 && theme2.root.horizontal, !horizontal2 && theme2.root.vertical, className), ...props, children });
};
const TimelinePoint = ({ children, className, icon: Icon2, theme: customTheme = {}, ...props }) => {
  const theme2 = mergeDeep(useTheme().theme.timeline.item.point, customTheme);
  const { horizontal: horizontal2 } = useTimelineContext();
  return jsxRuntimeExports.jsxs("div", { "data-testid": "timeline-point", className: twMerge(horizontal2 && theme2.horizontal, !horizontal2 && theme2.vertical, className), ...props, children: [children, Icon2 ? jsxRuntimeExports.jsx("span", { className: twMerge(theme2.marker.icon.wrapper), children: jsxRuntimeExports.jsx(Icon2, { "aria-hidden": true, className: twMerge(theme2.marker.icon.base) }) }) : jsxRuntimeExports.jsx("div", { className: twMerge(horizontal2 && theme2.marker.base.horizontal, !horizontal2 && theme2.marker.base.vertical) }), horizontal2 && jsxRuntimeExports.jsx("div", { className: twMerge(theme2.line) })] });
};
const TimelineTime = ({ children, className, theme: customTheme = {}, ...props }) => {
  const theme2 = mergeDeep(useTheme().theme.timeline.item.content, customTheme).time;
  return jsxRuntimeExports.jsx("time", { className: twMerge(theme2, className), ...props, children });
};
const TimelineTitle = ({ as: Tag = "h3", children, className, theme: customTheme = {}, ...props }) => {
  const theme2 = mergeDeep(useTheme().theme.timeline.item.content, customTheme).title;
  return jsxRuntimeExports.jsx(Tag, { className: twMerge(theme2, className), ...props, children });
};
const TimelineComponent = ({ children, className, horizontal: horizontal2, theme: customTheme = {}, ...props }) => {
  const theme2 = mergeDeep(useTheme().theme.timeline, customTheme);
  return jsxRuntimeExports.jsx(TimelineContext.Provider, { value: { horizontal: horizontal2 }, children: jsxRuntimeExports.jsx("ol", { "data-testid": "timeline-component", className: twMerge(horizontal2 && theme2.root.direction.horizontal, !horizontal2 && theme2.root.direction.vertical, className), ...props, children }) });
};
TimelineComponent.displayName = "Timeline";
TimelineItem.displayName = "Timeline.Item";
TimelinePoint.displayName = "Timeline.Point";
TimelineContent.displayName = "Timeline.Content";
TimelineTime.displayName = "Timeline.Time";
TimelineTitle.displayName = "Timeline.Title";
TimelineBody.displayName = "Timeline.Body";
Object.assign(TimelineComponent, {
  Item: TimelineItem,
  Point: TimelinePoint,
  Content: TimelineContent,
  Time: TimelineTime,
  Title: TimelineTitle,
  Body: TimelineBody
});
const ToastContext = reactExports.createContext(void 0);
function useToastContext() {
  const context = reactExports.useContext(ToastContext);
  if (!context) {
    throw new Error("useToastContext should be used within the ToastContext provider!");
  }
  return context;
}
const ToastToggle = ({ className, onClick, theme: customTheme = {}, xIcon: XIcon = HiX, onDismiss, ...props }) => {
  const theme2 = mergeDeep(useTheme().theme.toast.toggle, customTheme);
  const { duration, isClosed, isRemoved, setIsClosed, setIsRemoved } = useToastContext();
  const handleClick = (e2) => {
    if (onClick)
      onClick(e2);
    if (onDismiss) {
      onDismiss();
      return;
    }
    setIsClosed(!isClosed);
    setTimeout(() => setIsRemoved(!isRemoved), duration);
  };
  return jsxRuntimeExports.jsx("button", { "aria-label": "Close", onClick: handleClick, type: "button", className: twMerge(theme2.base, className), ...props, children: jsxRuntimeExports.jsx(XIcon, { "aria-hidden": true, className: theme2.icon }) });
};
const durationClasses = {
  75: "duration-75",
  100: "duration-100",
  150: "duration-150",
  200: "duration-200",
  300: "duration-300",
  500: "duration-500",
  700: "duration-700",
  1e3: "duration-1000"
};
const ToastComponent = ({ children, className, duration = 300, theme: customTheme = {}, ...props }) => {
  const [isClosed, setIsClosed] = reactExports.useState(false);
  const [isRemoved, setIsRemoved] = reactExports.useState(false);
  const theme2 = mergeDeep(useTheme().theme.toast, customTheme);
  if (isRemoved) {
    return null;
  }
  return jsxRuntimeExports.jsx(ToastContext.Provider, { value: { duration, isClosed, isRemoved, setIsClosed, setIsRemoved }, children: jsxRuntimeExports.jsx("div", { "data-testid": "flowbite-toast", role: "alert", className: twMerge(theme2.root.base, durationClasses[duration], isClosed && theme2.root.closed, className), ...props, children }) });
};
ToastComponent.displayName = "Toast";
ToastToggle.displayName = "Toast.Toggle";
Object.assign(ToastComponent, {
  Toggle: ToastToggle
});
const Floating = ({ animation = "duration-300", arrow: arrow2 = true, children, className, content, placement = "top", style: style2 = "dark", theme: theme2, trigger = "hover", minWidth, ...props }) => {
  const arrowRef = reactExports.useRef(null);
  const [open, setOpen] = reactExports.useState(false);
  const floatingProperties = useBaseFLoating({
    open,
    placement,
    arrowRef,
    setOpen
  });
  const { context, middlewareData: { arrow: { x: arrowX, y: arrowY } = {} }, refs, strategy, update: update2, x, y: y2 } = floatingProperties;
  const focus2 = useFocus(context);
  const { getFloatingProps, getReferenceProps } = useFloatingInteractions({
    context,
    role: "tooltip",
    trigger,
    interactions: [focus2]
  });
  reactExports.useEffect(() => {
    if (refs.reference.current && refs.floating.current && open) {
      return autoUpdate(refs.reference.current, refs.floating.current, update2);
    }
  }, [open, refs.floating, refs.reference, update2]);
  return jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [jsxRuntimeExports.jsx("div", { ref: refs.setReference, className: theme2.target, "data-testid": "flowbite-tooltip-target", ...getReferenceProps(), children }), jsxRuntimeExports.jsxs("div", { ref: refs.setFloating, "data-testid": "flowbite-tooltip", ...getFloatingProps({
    className: twMerge(theme2.base, animation && `${theme2.animation} ${animation}`, !open && theme2.hidden, theme2.style[style2], className),
    style: {
      position: strategy,
      top: y2 ?? " ",
      left: x ?? " ",
      minWidth
    },
    ...props
  }), children: [jsxRuntimeExports.jsx("div", { className: theme2.content, children: content }), arrow2 && jsxRuntimeExports.jsx("div", { className: twMerge(theme2.arrow.base, style2 === "dark" && theme2.arrow.style.dark, style2 === "light" && theme2.arrow.style.light, style2 === "auto" && theme2.arrow.style.auto), "data-testid": "flowbite-tooltip-arrow", ref: arrowRef, style: {
    top: arrowY ?? " ",
    left: arrowX ?? " ",
    right: " ",
    bottom: " ",
    [getArrowPlacement({ placement: floatingProperties.placement })]: theme2.arrow.placement
  }, children: " " })] })] });
};
const Tooltip = ({ animation = "duration-300", arrow: arrow2 = true, children, className, content, placement = "top", style: style2 = "dark", theme: customTheme = {}, trigger = "hover", ...props }) => {
  const theme2 = mergeDeep(useTheme().theme.tooltip, customTheme);
  return jsxRuntimeExports.jsx(Floating, { animation, arrow: arrow2, content, placement, style: style2, theme: theme2, trigger, className, ...props, children });
};
Tooltip.displayName = "Tooltip";
const FloatingActionButton = ({
  onClick,
  disabled,
  isLoading,
  buttonText,
  loadingText,
  disabledReason,
  show = true,
  status = null,
  // 'saving', 'saved', 'error', or null
  errorMessage = "Failed to save changes",
  additionalErrorMessage = null,
  progressMessage = null,
  // Message to show while in progress (replaces 'Saving...')
  successMessage = null
  // Message to show on success (replaces 'Saved!')
}) => {
  const { tabNavigationWidth } = useFloatingButton();
  const [mounted, setMounted] = reactExports.useState(false);
  const [windowWidth, setWindowWidth] = reactExports.useState(window.innerWidth);
  const tooltipRef = reactExports.useRef(null);
  const planType = Recoil_index_20(planTypeSelector);
  reactExports.useEffect(() => {
    setMounted(true);
    const handleResize = () => {
      setWindowWidth(window.innerWidth);
    };
    window.addEventListener("resize", handleResize);
    return () => {
      window.removeEventListener("resize", handleResize);
      setMounted(false);
    };
  }, []);
  reactExports.useEffect(() => {
    if (!mounted)
      return;
    const modifyTooltipTarget = () => {
      const tooltipTargets = document.querySelectorAll('[data-testid="flowbite-tooltip-target"]');
      tooltipTargets.forEach((target) => {
        target.classList.remove("w-fit");
        target.classList.add("w-full");
        target.style.display = "block";
        target.style.width = "100%";
      });
    };
    modifyTooltipTarget();
    const observer = new MutationObserver((mutations) => {
      mutations.forEach(() => {
        modifyTooltipTarget();
      });
    });
    observer.observe(document.body, { childList: true, subtree: true });
    return () => {
      observer.disconnect();
    };
  }, [mounted]);
  const getButtonColor = () => {
    if (status === "saved")
      return "bg-green-500 hover:bg-green-600";
    if (status === "error")
      return "bg-red-500 hover:bg-red-600";
    return "bg-indigo-500 hover:bg-indigo-600";
  };
  const getButtonText = () => {
    if (status === "saving")
      return progressMessage || "Saving...";
    if (status === "saved")
      return successMessage || "Saved!";
    if (status === "error") {
      return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex flex-col items-center", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: errorMessage || "Error!" }),
        additionalErrorMessage && /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "mt-1 text-sm font-normal", children: additionalErrorMessage })
      ] });
    }
    if (isLoading) {
      return /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: "flex items-center justify-center", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs(
          "svg",
          {
            className: "text-white -ml-1 mr-3 h-5 w-5 animate-spin",
            xmlns: "http://www.w3.org/2000/svg",
            fill: "none",
            viewBox: "0 0 24 24",
            children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                "circle",
                {
                  className: "opacity-25",
                  cx: "12",
                  cy: "12",
                  r: "10",
                  stroke: "currentColor",
                  strokeWidth: "4"
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                "path",
                {
                  className: "opacity-75",
                  fill: "currentColor",
                  d: "M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"
                }
              )
            ]
          }
        ),
        loadingText
      ] });
    }
    return buttonText;
  };
  const contentWidth = windowWidth - tabNavigationWidth;
  const buttonWidth = contentWidth * 0.9;
  const wrapperStyle = {
    position: "fixed",
    bottom: "1.5rem",
    left: "50%",
    transform: "translateX(-50%)",
    zIndex: 49,
    width: `${buttonWidth}px`,
    marginLeft: `${tabNavigationWidth / 2}px`
    // Offset to account for tab navigation
  };
  const buttonStyle = {
    width: "100%"
  };
  const button = /* @__PURE__ */ jsxRuntimeExports.jsx(
    "button",
    {
      onClick,
      disabled: disabled || status === "saving" || status === "saved" || status === "error" || planType === "free",
      style: buttonStyle,
      className: `text-white rounded-lg py-3 font-semibold shadow-lg transition-all duration-300 ${disabled ? "cursor-not-allowed" : "cursor-pointer"} ${show ? "opacity-100" : "pointer-events-none opacity-0"} ${getButtonColor()}`,
      children: getButtonText()
    }
  );
  const renderButton = () => {
    const wrapperElement = /* @__PURE__ */ jsxRuntimeExports.jsx(
      "div",
      {
        style: wrapperStyle,
        className: `transition-all duration-300 ${show ? "translate-y-0" : "translate-y-16"}`,
        ref: tooltipRef,
        children: disabled && disabledReason && !status ? /* @__PURE__ */ jsxRuntimeExports.jsx(
          Tooltip,
          {
            content: planType === "free" ? "Upgrade to paid to use this feature" : disabledReason,
            placement: "top",
            className: "text-xs",
            children: button
          }
        ) : button
      }
    );
    return wrapperElement;
  };
  if (mounted) {
    return reactDomExports.createPortal(renderButton(), document.body);
  }
  return null;
};
const AIReplySuggestionsTab = () => {
  const [rules, setRules] = reactExports.useState([]);
  const [newRule, setNewRule] = reactExports.useState("");
  const [updateMessage, setUpdateMessage] = reactExports.useState("");
  const [updateStatus, setUpdateStatus] = reactExports.useState("");
  const [hasChanges, setHasChanges] = reactExports.useState(false);
  const [initialRules, setInitialRules] = reactExports.useState([]);
  const [aiRepliesEnabled, setAiRepliesEnabled] = reactExports.useState(true);
  const [initialAiRepliesEnabled, setInitialAiRepliesEnabled] = reactExports.useState(true);
  const setHasUnsavedChanges = Recoil_index_24(hasUnsavedChangesAtom);
  const { updateCreatorSettings } = useNetworkManager();
  const [buttonStatus, setButtonStatus] = reactExports.useState(null);
  const textareaRef = reactExports.useRef(null);
  const aiRepliesEnabledSetting = Recoil_index_20(aiRepliesEnabledSelector);
  const aiRulesSetting = Recoil_index_20(aiRulesSelector);
  reactExports.useEffect(() => {
    setAiRepliesEnabled(aiRepliesEnabledSetting);
    setInitialAiRepliesEnabled(aiRepliesEnabledSetting);
  }, [aiRepliesEnabledSetting]);
  reactExports.useEffect(() => {
    setRules(aiRulesSetting);
    setInitialRules(aiRulesSetting);
  }, [aiRulesSetting]);
  reactExports.useEffect(() => {
    const safeRules = Array.isArray(rules) ? rules : [];
    const safeInitialRules = Array.isArray(initialRules) ? initialRules : [];
    const rulesChanged = JSON.stringify(safeRules) !== JSON.stringify(safeInitialRules);
    const aiRepliesEnabledChanged = aiRepliesEnabled !== initialAiRepliesEnabled;
    const hasAnyChanges = rulesChanged || aiRepliesEnabledChanged;
    setHasChanges(hasAnyChanges);
    setHasUnsavedChanges(hasAnyChanges);
  }, [rules, initialRules, aiRepliesEnabled, initialAiRepliesEnabled, setHasUnsavedChanges]);
  reactExports.useEffect(() => {
    if (textareaRef.current && aiRepliesEnabled) {
      textareaRef.current.focus();
    }
  }, [aiRepliesEnabled]);
  const handleAddRule = () => {
    if (!newRule.trim() || !aiRepliesEnabled)
      return;
    const newRuleObj = {
      id: `rule-${Math.random().toString(36).substr(2, 9)}`,
      rule: newRule.trim(),
      enabled: true
    };
    const safeRules = Array.isArray(rules) ? rules : [];
    setRules([...safeRules, newRuleObj]);
    setNewRule("");
  };
  const handleDeleteRule = (ruleId) => {
    if (!aiRepliesEnabled)
      return;
    const safeRules = Array.isArray(rules) ? rules : [];
    setRules(safeRules.filter((rule) => rule.id !== ruleId));
  };
  const handleEditRule = (ruleId, newRuleText) => {
    if (!aiRepliesEnabled)
      return;
    const safeRules = Array.isArray(rules) ? rules : [];
    setRules(
      safeRules.map(
        (rule) => rule.id === ruleId ? { ...rule, rule: newRuleText, editMode: false } : rule
      )
    );
  };
  const toggleEditMode = (ruleId) => {
    if (!aiRepliesEnabled)
      return;
    const safeRules = Array.isArray(rules) ? rules : [];
    setRules(
      safeRules.map(
        (rule) => rule.id === ruleId ? { ...rule, editMode: !rule.editMode, editText: rule.rule } : rule
      )
    );
  };
  const handleRuleEnabledChange = (ruleId, enabled) => {
    if (!aiRepliesEnabled)
      return;
    const safeRules = Array.isArray(rules) ? rules : [];
    setRules(safeRules.map((rule) => rule.id === ruleId ? { ...rule, enabled } : rule));
  };
  const handleToggleAiReplies = (e2) => {
    setAiRepliesEnabled(e2.target.checked);
  };
  const handleSave = async () => {
    if (!hasChanges)
      return;
    setButtonStatus("saving");
    const safeRules = Array.isArray(rules) ? rules : [];
    try {
      const response = await updateCreatorSettings({
        aiRules: safeRules,
        aiRepliesEnabled
      });
      if (response.status === 200) {
        setUpdateMessage("AI settings updated successfully!");
        setUpdateStatus("success");
        setInitialRules([...safeRules]);
        setInitialAiRepliesEnabled(aiRepliesEnabled);
        setHasChanges(false);
        setHasUnsavedChanges(false);
        setButtonStatus("saved");
        setTimeout(() => {
          setButtonStatus(null);
          setUpdateMessage("");
          setUpdateStatus("");
        }, 2e3);
      } else {
        const errorMsg = "Failed to update AI settings. Please try again.";
        setUpdateMessage(errorMsg);
        setUpdateStatus("error");
        setButtonStatus("error");
        setTimeout(() => {
          setButtonStatus(null);
          setUpdateMessage("");
          setUpdateStatus("");
        }, 3e3);
      }
    } catch (error) {
      console.error("Error saving AI settings:", error);
      const errorMsg = "An error occurred while updating AI settings.";
      setUpdateMessage(errorMsg);
      setUpdateStatus("error");
      setButtonStatus("error");
      setTimeout(() => {
        setButtonStatus(null);
        setUpdateMessage("");
        setUpdateStatus("");
      }, 3e3);
    }
  };
  const handleRuleKeyDown = (e2) => {
    if (!aiRepliesEnabled)
      return;
    if (e2.key === "Enter") {
      if (e2.shiftKey) {
        return;
      }
      e2.preventDefault();
      if (newRule.trim()) {
        handleAddRule();
      }
    }
  };
  const handleBannerHide = () => {
    setUpdateMessage("");
    setUpdateStatus("");
  };
  const renderRulesList = () => {
    const safeRules = Array.isArray(rules) ? rules : [];
    if ((safeRules == null ? void 0 : safeRules.length) === 0) {
      return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "rounded-lg border border-indigo-100 bg-indigo-50 p-4 text-center text-indigo-800", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: "You don't have any AI rules yet. Add your first rule above to get started!" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "mt-2 text-sm", children: "Rules help the AI understand your preferred tone and style when generating message suggestions." })
      ] });
    }
    return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "space-y-3", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("h4", { className: "text-md font-medium", children: "Your AI Rules" }),
      safeRules.map((rule) => /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "bg-white rounded-lg border p-3 shadow-sm", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center justify-between", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex w-full items-center space-x-3", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "input",
            {
              type: "checkbox",
              checked: rule.enabled,
              onChange: (e2) => handleRuleEnabledChange(rule.id, e2.target.checked),
              className: "rounded-sm text-indigo-500 focus:ring-indigo-500",
              disabled: !aiRepliesEnabled
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "w-full flex-grow", children: rule.editMode ? /* @__PURE__ */ jsxRuntimeExports.jsx(
            "textarea",
            {
              value: rule.editText || rule.rule,
              onChange: (e2) => {
                const safeRules2 = Array.isArray(rules) ? rules : [];
                setRules(
                  safeRules2.map(
                    (r2) => r2.id === rule.id ? { ...r2, editText: e2.target.value } : r2
                  )
                );
              },
              onBlur: () => handleEditRule(rule.id, rule.editText || rule.rule),
              onKeyDown: (e2) => {
                if (e2.key === "Enter" && !e2.shiftKey) {
                  e2.preventDefault();
                  handleEditRule(rule.id, rule.editText || rule.rule);
                }
              },
              className: "min-h-[60px] w-full rounded border p-2 focus:outline-none focus:ring-2 focus:ring-indigo-500",
              autoFocus: true,
              disabled: !aiRepliesEnabled
            }
          ) : /* @__PURE__ */ jsxRuntimeExports.jsx(
            "p",
            {
              className: `whitespace-pre-wrap text-left ${!rule.enabled || !aiRepliesEnabled ? "text-gray-400" : ""}`,
              children: rule.rule
            }
          ) })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "ml-2 flex flex-shrink-0 items-center space-x-2", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "button",
            {
              onClick: () => toggleEditMode(rule.id),
              className: `p-1 text-gray-500 hover:text-gray-700 ${!aiRepliesEnabled ? "cursor-not-allowed" : ""}`,
              disabled: !aiRepliesEnabled,
              children: /* @__PURE__ */ jsxRuntimeExports.jsx(Pen, { className: "h-4 w-4" })
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "button",
            {
              onClick: () => handleDeleteRule(rule.id),
              className: `p-1 text-red-500 hover:text-red-700 ${!aiRepliesEnabled ? "cursor-not-allowed" : ""}`,
              disabled: !aiRepliesEnabled,
              children: /* @__PURE__ */ jsxRuntimeExports.jsx(Trash2, { className: "h-4 w-4" })
            }
          )
        ] })
      ] }) }, rule.id))
    ] });
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "w-full pb-20 text-left", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      TabHeader,
      {
        title: "Personalize AI Reply Suggestions ✨",
        subtitle: "Customize how the AI generates reply suggestions to your fans by adding rules. These rules will guide the AI in generating suggestions that match your style and preferences."
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "mb-6", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "mb-6 flex flex-row items-start space-x-6 text-left text-base text-gray-600", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("label", { className: "flex flex-row items-start space-x-6", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          "input",
          {
            type: "checkbox",
            checked: aiRepliesEnabled,
            onChange: handleToggleAiReplies,
            className: "mt-1 rounded-sm text-base text-black-spicy accent-indigo-500 checked:border-indigo-500 checked:bg-indigo-500 focus:ring-indigo-500"
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex flex-col space-y-2", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "font-bold text-black-spicy", children: "Enable AI Reply Suggestions" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: "When enabled, the AI will generate personalized reply suggestions based on your rules. Turn this off if you prefer to write all messages manually without AI assistance." })
        ] })
      ] }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs(
        "div",
        {
          className: `transition-opacity duration-300 ${aiRepliesEnabled ? "opacity-100" : "pointer-events-none opacity-50"}`,
          children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "mb-2", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: "text-lg font-semibold", children: (Array.isArray(rules) ? rules.length : 0) === 0 ? "Add your first rule" : "Customize AI rules" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-sm text-gray-600", children: "Add rules to guide how the AI generates responses. Be specific about tone, style, and content preferences." })
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "mb-4 flex flex-col", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                "textarea",
                {
                  ref: textareaRef,
                  value: newRule,
                  onChange: (e2) => setNewRule(e2.target.value),
                  onKeyDown: handleRuleKeyDown,
                  placeholder: "Example: Use a friendly tone with lots of emojis",
                  className: "mb-2 min-h-[80px] w-full rounded-md border bg-transparent p-3 focus:border-indigo-500 focus:ring-0",
                  disabled: !aiRepliesEnabled
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex justify-end", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                "button",
                {
                  onClick: handleAddRule,
                  disabled: !newRule.trim() || !aiRepliesEnabled,
                  className: `text-white flex items-center gap-1 rounded-md bg-indigo-500 px-4 py-2 transition-colors hover:bg-indigo-600 ${!newRule.trim() || !aiRepliesEnabled ? "cursor-not-allowed opacity-50" : ""}`,
                  children: "Add rule"
                }
              ) })
            ] }),
            renderRulesList(),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "mt-8 rounded-lg bg-purple-100 p-4", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: "mb-2 text-left text-lg font-semibold", children: "Example Rules" }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("ul", { className: "list-disc pl-5 text-sm", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("li", { className: "mb-1", children: "Use a flirty tone with lots of emojis" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("li", { className: "mb-1", children: "Keep messages short and to the point" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("li", { className: "mb-1", children: "Always ask a question at the end of messages" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("li", { className: "mb-1", children: "Avoid using explicit language in initial messages" })
              ] })
            ] })
          ]
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        FloatingActionButton,
        {
          onClick: handleSave,
          disabled: !hasChanges,
          buttonText: "Save",
          show: hasChanges || buttonStatus,
          status: buttonStatus
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        FloatingStatusBanner,
        {
          message: updateMessage,
          type: updateStatus === "success" ? "success" : "error",
          show: !!updateMessage && buttonStatus !== "error",
          onHide: handleBannerHide,
          autoHideDelay: 3e3
        }
      )
    ] })
  ] });
};
const iconMedia$1 = "" + new URL("icon-media-c0e58e75.svg", import.meta.url).href;
const iconVideo = "" + new URL("icon-video-0aec679b.svg", import.meta.url).href;
const iconAudio = "" + new URL("icon-voice-0a7e0fa6.svg", import.meta.url).href;
const OFMediaAsset = ({ item, src, alt, className }) => {
  const mediaType = (item == null ? void 0 : item.type) || "photo";
  const getMediaIcon = () => {
    switch (mediaType) {
      case "video":
        return iconVideo;
      case "audio":
        return iconAudio;
      default:
        return iconMedia$1;
    }
  };
  const formatDate = (dateString) => {
    if (!dateString)
      return "";
    const date = new Date(dateString);
    const currentYear = (/* @__PURE__ */ new Date()).getFullYear();
    const month = date.toLocaleString("en-US", { month: "short" });
    const day = date.getDate();
    const year = date.getFullYear();
    if (year < currentYear) {
      return `${month} ${day}, ${year}`;
    }
    return `${month} ${day}`;
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
    "div",
    {
      className: `ph-no-capture relative ${className} ${mediaType === "audio" ? "to-white bg-gradient-to-b from-gray-300" : ""}`,
      children: [
        mediaType !== "audio" ? /* @__PURE__ */ jsxRuntimeExports.jsx("img", { src, alt, className: "h-full w-full object-cover" }) : null,
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "absolute left-2 top-2 flex items-center", children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex items-center rounded-sm bg-black-spicy bg-opacity-25 px-2 py-0.5 opacity-75", children: (item == null ? void 0 : item.createdAt) && /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "text-xs font-medium text-white-spicy", children: formatDate(item.createdAt) }) }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "absolute bottom-2 left-2 flex items-center", children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex items-center justify-center rounded-full bg-black-spicy bg-opacity-25 p-1.5 opacity-75", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          "img",
          {
            src: getMediaIcon(),
            alt: mediaType,
            className: "h-4 w-4 text-white-spicy brightness-0 invert"
          }
        ) }) })
      ]
    }
  );
};
const APIPlaygroundTab = () => {
  const onlyFansAPI = useOnlyFansAPI();
  const [expandedSection, setExpandedSection] = reactExports.useState(null);
  const [apiResults, setApiResults] = reactExports.useState({});
  const [loading, setLoading] = reactExports.useState({});
  const [localTab, setLocalTab] = reactExports.useState("general");
  const [inputs, setInputs] = reactExports.useState({
    sendMessage: { userId: "", message: "" },
    queueMessage: { userIds: "", message: "", price: "0", mediaIds: "" },
    followUser: { userId: "" },
    unfollowUser: { userId: "" },
    updateUserNote: { userId: "", note: "" },
    getMessagesByMediaId: { mediaId: "" },
    getUserData: { username: "" },
    getMediaWithPurchaseStatus: { userId: "", limit: "20", offset: "0" },
    getExpiredSubscribers: { limit: "100", offset: "0" },
    getActiveSubscribersCount: {},
    getOnlineSubscribers: { limit: "20", offset: "0" },
    getCreatorStartDate: {},
    getLatestExpiredSubscribers: {
      offset: "0"
    }
  });
  const apiMethods = [
    { name: "getVaultMedia", method: onlyFansAPI.getVaultMedia },
    { name: "sendMessage", method: onlyFansAPI.sendMessage },
    { name: "queueMessage", method: onlyFansAPI.queueMessage },
    { name: "followUser", method: onlyFansAPI.followUser },
    { name: "unfollowUser", method: onlyFansAPI.unfollowUser },
    { name: "updateUserNote", method: onlyFansAPI.updateUserNote },
    // { name: 'getCurrentUserId', method: onlyFansAPI.getCurrentUserId },
    { name: "getChats", method: onlyFansAPI.getChats },
    { name: "getTransactions", method: onlyFansAPI.getTransactions },
    { name: "getChargebacks", method: onlyFansAPI.getChargebacks },
    { name: "getLikeNotifications", method: onlyFansAPI.getLikeNotifications },
    { name: "getSubscribers", method: onlyFansAPI.getSubscribers },
    { name: "getUserProfile", method: onlyFansAPI.getUserProfile },
    { name: "getMessagesByMediaId", method: onlyFansAPI.getMessagesByMediaId },
    { name: "getUserData", method: onlyFansAPI.getUserData },
    {
      name: "getMediaWithPurchaseStatus",
      method: onlyFansAPI.getMediaWithPurchaseStatus
    }
  ];
  reactExports.useEffect(() => {
    const testAPIs = async () => {
      for (const { name, method } of apiMethods) {
        if ([
          "sendMessage",
          "queueMessage",
          "followUser",
          "unfollowUser",
          "updateUserNote",
          "getMessagesByMediaId",
          "getUserData",
          "getMediaWithPurchaseStatus"
        ].includes(name))
          continue;
        try {
          setLoading((prev) => ({ ...prev, [name]: true }));
          const result = await method();
          setApiResults((prev) => ({
            ...prev,
            [name]: { success: true, data: result }
          }));
        } catch (error) {
          setApiResults((prev) => ({
            ...prev,
            [name]: { success: false, error: error.message }
          }));
        } finally {
          setLoading((prev) => ({ ...prev, [name]: false }));
        }
      }
    };
    testAPIs();
  }, []);
  const toggleSection = (name) => {
    setExpandedSection(expandedSection === name ? null : name);
  };
  const handleInputChange = (method, field, value) => {
    setInputs((prev) => ({
      ...prev,
      [method]: { ...prev[method], [field]: value }
    }));
  };
  const additionalApiMethods = [
    {
      name: "getExpiredSubscribers",
      method: onlyFansAPI.getExpiredSubscribers
    },
    {
      name: "getActiveSubscribersCount",
      method: onlyFansAPI.getActiveSubscribersCount
    },
    { name: "getOnlineSubscribers", method: onlyFansAPI.getOnlineSubscribers },
    { name: "getCreatorStartDate", method: onlyFansAPI.getCreatorStartDate },
    { name: "getLatestExpiredSubscribers", method: onlyFansAPI.getLatestExpiredSubscribers }
  ];
  const handleSubmit = async (name) => {
    var _a;
    setLoading((prev) => ({ ...prev, [name]: true }));
    try {
      let result;
      switch (name) {
        case "sendMessage":
          result = await onlyFansAPI.sendMessage(
            inputs.sendMessage.userId,
            inputs.sendMessage.message
          );
          break;
        case "queueMessage":
          const userIdsArray = inputs.queueMessage.userIds.split(",").map((id2) => id2.trim()).filter((id2) => id2);
          const mediaIdsArray = inputs.queueMessage.mediaIds ? inputs.queueMessage.mediaIds.split(",").map((id2) => id2.trim()).filter((id2) => id2) : [];
          const queueResult = await onlyFansAPI.queueMessage(
            userIdsArray,
            inputs.queueMessage.message,
            parseInt(inputs.queueMessage.price) || 0,
            mediaIdsArray
          );
          if (queueResult && (queueResult.error || queueResult.hasError || queueResult.isCanceled)) {
            const errorMessage = ((_a = queueResult.error) == null ? void 0 : _a.message) || "Queue operation failed";
            throw new Error(`Queue failed: ${errorMessage}`);
          }
          result = queueResult;
          break;
        case "followUser":
          result = await onlyFansAPI.followUser(inputs.followUser.userId);
          break;
        case "unfollowUser":
          result = await onlyFansAPI.unfollowUser(inputs.unfollowUser.userId);
          break;
        case "updateUserNote":
          result = await onlyFansAPI.updateUserNote(
            inputs.updateUserNote.userId,
            inputs.updateUserNote.note
          );
          break;
        case "getMessagesByMediaId":
          result = await onlyFansAPI.getMessagesByMediaId(inputs.getMessagesByMediaId.mediaId);
          break;
        case "getUserData":
          result = await onlyFansAPI.getUserData(inputs.getUserData.username);
          break;
        case "getMediaWithPurchaseStatus":
          result = await onlyFansAPI.getMediaWithPurchaseStatus(
            inputs.getMediaWithPurchaseStatus.userId,
            parseInt(inputs.getMediaWithPurchaseStatus.limit),
            parseInt(inputs.getMediaWithPurchaseStatus.offset)
          );
          break;
        case "getExpiredSubscribers":
          result = await onlyFansAPI[name](
            parseInt(inputs[name].limit),
            parseInt(inputs[name].offset)
          );
          break;
        case "getActiveSubscribersCount":
          result = await onlyFansAPI.getActiveSubscribersCount();
          break;
        case "getOnlineSubscribers":
          result = await onlyFansAPI.getOnlineSubscribers(
            parseInt(inputs.getOnlineSubscribers.limit),
            parseInt(inputs.getOnlineSubscribers.offset)
          );
          break;
        case "getCreatorStartDate":
          result = await onlyFansAPI.getCreatorStartDate();
          break;
        case "getLatestExpiredSubscribers":
          result = await onlyFansAPI.getLatestExpiredSubscribers(
            parseInt(inputs.getLatestExpiredSubscribers.offset)
          );
          break;
      }
      setApiResults((prev) => ({
        ...prev,
        [name]: { success: true, data: result }
      }));
    } catch (error) {
      setApiResults((prev) => ({
        ...prev,
        [name]: { success: false, error: error.message }
      }));
    } finally {
      setLoading((prev) => ({ ...prev, [name]: false }));
    }
  };
  const renderInputs = (name) => {
    switch (name) {
      case "getExpiredSubscribers":
      case "getOnlineSubscribers":
        return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "input",
            {
              type: "number",
              placeholder: "Limit",
              value: inputs[name].limit,
              onChange: (e2) => handleInputChange(name, "limit", e2.target.value),
              className: "mr-2 rounded border p-1"
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "input",
            {
              type: "number",
              placeholder: "Offset",
              value: inputs[name].offset,
              onChange: (e2) => handleInputChange(name, "offset", e2.target.value),
              className: "mr-2 rounded border p-1"
            }
          )
        ] });
      case "getCreatorStartDate":
        return null;
      case "getLatestExpiredSubscribers":
        return /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          "input",
          {
            type: "number",
            placeholder: "Offset",
            value: inputs[name].offset,
            onChange: (e2) => handleInputChange(name, "offset", e2.target.value),
            className: "mr-2 rounded border p-1"
          }
        ) });
      default:
        return null;
    }
  };
  const renderMediaItem = (item) => {
    var _a, _b;
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      OFMediaAsset,
      {
        item,
        src: (_b = (_a = item.files) == null ? void 0 : _a.thumb) == null ? void 0 : _b.url,
        alt: `Media ${item.id}`,
        className: "m-1 h-24 w-24"
      },
      item.id
    );
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "rounded-lg bg-blue-spicy p-4 shadow-md", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { className: "mb-4 text-xl font-bold text-darkBlue-spicy", children: "API Playground" }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "mb-4", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        "button",
        {
          onClick: () => setLocalTab("general"),
          className: `mr-2 rounded px-4 py-2 ${localTab === "general" ? "text-white bg-blue-500" : "bg-gray-200"}`,
          children: "General APIs"
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        "button",
        {
          onClick: () => setLocalTab("additional"),
          className: `rounded px-4 py-2 ${localTab === "additional" ? "text-white bg-blue-500" : "bg-gray-200"}`,
          children: "Additional APIs"
        }
      )
    ] }),
    localTab === "general" ? (
      // Render existing API methods
      apiMethods.map(({ name }) => /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "mb-4 rounded-lg border p-2", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs(
          "button",
          {
            onClick: () => toggleSection(name),
            className: "flex w-full items-center justify-between text-left font-semibold",
            children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: name }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: expandedSection === name ? "▼" : "▶" })
            ]
          }
        ),
        loading[name] ? /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "mt-2", children: "♻️ Loading..." }) : apiResults[name] ? /* @__PURE__ */ jsxRuntimeExports.jsxs(
          "div",
          {
            className: `mt-2 ${apiResults[name].success ? "text-green-600" : "text-red-600"}`,
            children: [
              "Status: ",
              apiResults[name].success ? "Success" : "Failed"
            ]
          }
        ) : /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "mt-2", children: "No results" }),
        expandedSection === name && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "mt-2", children: [
          "sendMessage",
          "queueMessage",
          "followUser",
          "unfollowUser",
          "updateUserNote",
          "getMessagesByMediaId",
          "getUserData",
          "getMediaWithPurchaseStatus",
          "getVaultMedia"
        ].includes(name) ? /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
          name === "getVaultMedia" && /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children: apiResults[name] && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "mt-2", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: "font-semibold", children: "Vault Media:" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex flex-wrap", children: apiResults[name].data.list.map(renderMediaItem) })
          ] }) }),
          name === "sendMessage" && /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "input",
              {
                type: "text",
                placeholder: "User ID",
                value: inputs.sendMessage.userId,
                onChange: (e2) => handleInputChange("sendMessage", "userId", e2.target.value),
                className: "mr-2 rounded border p-1"
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "input",
              {
                type: "text",
                placeholder: "Message",
                value: inputs.sendMessage.message,
                onChange: (e2) => handleInputChange("sendMessage", "message", e2.target.value),
                className: "mr-2 rounded border p-1"
              }
            )
          ] }),
          name === "queueMessage" && /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "input",
              {
                type: "text",
                placeholder: "User IDs (comma-separated)",
                value: inputs.queueMessage.userIds,
                onChange: (e2) => handleInputChange("queueMessage", "userIds", e2.target.value),
                className: "mr-2 rounded border p-1"
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "input",
              {
                type: "text",
                placeholder: "Message",
                value: inputs.queueMessage.message,
                onChange: (e2) => handleInputChange("queueMessage", "message", e2.target.value),
                className: "mr-2 rounded border p-1"
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "input",
              {
                type: "number",
                placeholder: "Price (optional)",
                value: inputs.queueMessage.price,
                onChange: (e2) => handleInputChange("queueMessage", "price", e2.target.value),
                className: "mr-2 rounded border p-1"
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "input",
              {
                type: "text",
                placeholder: "Media IDs (comma-separated, optional)",
                value: inputs.queueMessage.mediaIds,
                onChange: (e2) => handleInputChange("queueMessage", "mediaIds", e2.target.value),
                className: "mr-2 rounded border p-1"
              }
            )
          ] }),
          (name === "followUser" || name === "unfollowUser") && /* @__PURE__ */ jsxRuntimeExports.jsx(
            "input",
            {
              type: "text",
              placeholder: "User ID",
              value: inputs[name].userId,
              onChange: (e2) => handleInputChange(name, "userId", e2.target.value),
              className: "mr-2 rounded border p-1"
            }
          ),
          name === "updateUserNote" && /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "input",
              {
                type: "text",
                placeholder: "User ID",
                value: inputs.updateUserNote.userId,
                onChange: (e2) => handleInputChange("updateUserNote", "userId", e2.target.value),
                className: "mr-2 rounded border p-1"
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "input",
              {
                type: "text",
                placeholder: "Note",
                value: inputs.updateUserNote.note,
                onChange: (e2) => handleInputChange("updateUserNote", "note", e2.target.value),
                className: "mr-2 rounded border p-1"
              }
            )
          ] }),
          name === "getMessagesByMediaId" && /* @__PURE__ */ jsxRuntimeExports.jsx(
            "input",
            {
              type: "text",
              placeholder: "Media ID",
              value: inputs.getMessagesByMediaId.mediaId,
              onChange: (e2) => handleInputChange("getMessagesByMediaId", "mediaId", e2.target.value),
              className: "mr-2 rounded border p-1"
            }
          ),
          name === "getUserData" && /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "input",
              {
                type: "text",
                placeholder: "Username",
                value: inputs.getUserData.username,
                onChange: (e2) => handleInputChange("getUserData", "username", e2.target.value),
                className: "mr-2 rounded border p-1"
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "button",
              {
                onClick: () => handleSubmit(name),
                className: "text-white rounded bg-blue-500 px-2 py-1",
                children: "Submit"
              }
            ),
            apiResults[name] && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "mt-2", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: "font-semibold", children: "User Data:" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("pre", { className: "overflow-x-auto rounded bg-gray-100 p-2 text-left", children: JSON.stringify(apiResults[name].data, null, 2) })
            ] })
          ] }),
          name === "getMediaWithPurchaseStatus" && /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "input",
              {
                type: "text",
                placeholder: "User ID",
                value: inputs.getMediaWithPurchaseStatus.userId,
                onChange: (e2) => handleInputChange(
                  "getMediaWithPurchaseStatus",
                  "userId",
                  e2.target.value
                ),
                className: "mr-2 rounded border p-1"
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "input",
              {
                type: "number",
                placeholder: "Limit",
                value: inputs.getMediaWithPurchaseStatus.limit,
                onChange: (e2) => handleInputChange(
                  "getMediaWithPurchaseStatus",
                  "limit",
                  e2.target.value
                ),
                className: "mr-2 rounded border p-1"
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "input",
              {
                type: "number",
                placeholder: "Offset",
                value: inputs.getMediaWithPurchaseStatus.offset,
                onChange: (e2) => handleInputChange(
                  "getMediaWithPurchaseStatus",
                  "offset",
                  e2.target.value
                ),
                className: "mr-2 rounded border p-1"
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "button",
              {
                onClick: () => handleSubmit(name),
                className: "text-white rounded bg-blue-500 px-2 py-1",
                children: "Submit"
              }
            ),
            apiResults[name] && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "mt-2", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: "font-semibold", children: "Media with Purchase Status:" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex flex-wrap", children: apiResults[name].data.list.map((item, index2) => /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "relative m-2", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  "div",
                  {
                    className: `h-24 w-24 border-4 ${item.status === "message" ? "border-blue-500" : item.status === "unlocked" ? "border-green-500" : item.status === "free" ? "border-yellow-500" : item.status === "locked" ? "border-red-500" : "border-gray-500"}`,
                    children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex h-full w-full items-center justify-center text-center text-xs", children: [
                      item.id,
                      /* @__PURE__ */ jsxRuntimeExports.jsx("br", {}),
                      item.type,
                      /* @__PURE__ */ jsxRuntimeExports.jsx("br", {}),
                      item.fromUser.id,
                      /* @__PURE__ */ jsxRuntimeExports.jsx("br", {}),
                      new Date(item.createdAt).toLocaleDateString()
                    ] })
                  }
                ),
                /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "bg-black text-white absolute bottom-0 left-0 p-1 text-xs", children: item.status })
              ] }, index2)) })
            ] })
          ] }),
          name !== "getUserData" && name !== "getMediaWithPurchaseStatus" && /* @__PURE__ */ jsxRuntimeExports.jsx(
            "button",
            {
              onClick: () => handleSubmit(name),
              className: "text-white rounded bg-blue-500 px-2 py-1",
              children: "Submit"
            }
          )
        ] }) : /* @__PURE__ */ jsxRuntimeExports.jsx("pre", { className: "overflow-x-auto rounded bg-gray-100 p-2 text-left", children: JSON.stringify(apiResults[name], null, 2) }) })
      ] }, name))
    ) : (
      // Render additional API methods
      additionalApiMethods.map(({ name }) => /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "mb-4 rounded-lg border p-2", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs(
          "button",
          {
            onClick: () => toggleSection(name),
            className: "flex w-full items-center justify-between text-left font-semibold",
            children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: name }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: expandedSection === name ? "▼" : "▶" })
            ]
          }
        ),
        loading[name] ? /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "mt-2", children: "♻️ Loading..." }) : apiResults[name] ? /* @__PURE__ */ jsxRuntimeExports.jsxs(
          "div",
          {
            className: `mt-2 ${apiResults[name].success ? "text-green-600" : "text-red-600"}`,
            children: [
              "Status: ",
              apiResults[name].success ? "Success" : "Failed"
            ]
          }
        ) : /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "mt-2", children: "No results" }),
        expandedSection === name && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "mt-2", children: [
          renderInputs(name),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "button",
            {
              onClick: () => handleSubmit(name),
              className: "text-white rounded bg-blue-500 px-2 py-1",
              children: "Submit"
            }
          ),
          apiResults[name] && /* @__PURE__ */ jsxRuntimeExports.jsx("pre", { className: "mt-2 overflow-x-auto rounded bg-gray-100 p-2 text-left", children: JSON.stringify(apiResults[name].data, null, 2) })
        ] })
      ] }, name))
    )
  ] });
};
const chatLabelsEnabledSelector = Recoil_index_9({
  key: "chatLabelsEnabledSelector",
  get: ({ get: get2 }) => {
    const currentCreatorSettings = get2(currentCreatorSettingsSelector);
    if (currentCreatorSettings === void 0) {
      return false;
    }
    if (currentCreatorSettings === null) {
      return false;
    }
    return currentCreatorSettings.chatLabelsEnabled !== void 0 ? currentCreatorSettings.chatLabelsEnabled : false;
  }
});
const ChatLabelsTab = () => {
  Recoil_index_20(subscriptionSettingsIdSelector);
  const ofUserId = Recoil_index_20(ofUserIdAtom);
  const chatLabelsEnabled = Recoil_index_20(chatLabelsEnabledSelector);
  const setSubscriptionSettings = Recoil_index_24(subscriptionSettingsAtom);
  const { updateCreatorSettings } = useNetworkManager();
  const [updateMessage, setUpdateMessage] = reactExports.useState("");
  const [updateStatus, setUpdateStatus] = reactExports.useState("");
  const [labelsEnabled, setLabelsEnabled] = reactExports.useState(true);
  const [hasChanges, setHasChanges] = reactExports.useState(false);
  const [initialState, setInitialState] = reactExports.useState(true);
  const setHasUnsavedChanges = Recoil_index_24(hasUnsavedChangesAtom);
  const [buttonStatus, setButtonStatus] = reactExports.useState(null);
  reactExports.useEffect(() => {
    setLabelsEnabled(chatLabelsEnabled);
    setInitialState(chatLabelsEnabled);
  }, [chatLabelsEnabled]);
  reactExports.useEffect(() => {
    const hasChanges2 = labelsEnabled !== initialState;
    setHasChanges(hasChanges2);
    setHasUnsavedChanges(hasChanges2);
  }, [labelsEnabled, initialState, setHasUnsavedChanges]);
  const handleToggleChatLabels = (e2) => {
    setLabelsEnabled(e2.target.checked);
  };
  const handleSave = async () => {
    if (!hasChanges || !ofUserId)
      return;
    setButtonStatus("saving");
    try {
      const response = await updateCreatorSettings({
        chatLabelsEnabled: labelsEnabled
      });
      if (response.status === 200) {
        setSubscriptionSettings(response.body);
        setUpdateMessage("Chat labels setting updated successfully!");
        setUpdateStatus("success");
        setInitialState(labelsEnabled);
        setHasChanges(false);
        setHasUnsavedChanges(false);
        setButtonStatus("saved");
        setTimeout(() => {
          setButtonStatus(null);
          setUpdateMessage("");
          setUpdateStatus("");
        }, 2e3);
      } else {
        const errorMsg = "Failed to update chat labels setting. Please try again.";
        setUpdateMessage(errorMsg);
        setUpdateStatus("error");
        setButtonStatus("error");
        setTimeout(() => {
          setButtonStatus(null);
          setUpdateMessage("");
          setUpdateStatus("");
        }, 3e3);
      }
    } catch (error) {
      console.error("Error updating chat labels setting:", error);
      const errorMsg = "An error occurred while updating chat labels setting.";
      setUpdateMessage(errorMsg);
      setUpdateStatus("error");
      setButtonStatus("error");
      setTimeout(() => {
        setButtonStatus(null);
        setUpdateMessage("");
        setUpdateStatus("");
      }, 3e3);
    }
  };
  const handleBannerHide = () => {
    setUpdateMessage("");
    setUpdateStatus("");
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "pb-20", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      TabHeader,
      {
        title: "Chat labels 💰",
        subtitle: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "font-bold", children: "Show spending and subscription labels" }),
          " on your chat list."
        ] })
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex flex-col space-y-20", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text-left text-base font-normal text-gray-600", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: "flex flex-col gap-4", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: "Display spending amounts and subscription status labels on your chat list to help you identify high-value fans and their current subscription status at a glance." }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: `When enabled, you'll see spending totals (LTV) and subscription status indicators like "new", "renew on/off", and "not subscribed" directly in your chat list.` })
      ] }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex flex-row items-start space-x-6 text-left text-base text-gray-600", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("label", { className: "flex flex-row items-start space-x-6", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          "input",
          {
            type: "checkbox",
            checked: labelsEnabled,
            onChange: handleToggleChatLabels,
            className: "mt-1 rounded-sm text-base text-black-spicy accent-indigo-500 checked:border-indigo-500 checked:bg-indigo-500 focus:ring-indigo-500"
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex flex-col space-y-2", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "font-bold text-black-spicy", children: "Show chat labels" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: "Display spending amounts and subscription status information in your chat list to help prioritize conversations with high-value fans." })
        ] })
      ] }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        FloatingActionButton,
        {
          onClick: handleSave,
          disabled: !hasChanges,
          buttonText: "Save",
          show: hasChanges || buttonStatus,
          status: buttonStatus
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        FloatingStatusBanner,
        {
          message: updateMessage,
          type: updateStatus === "success" ? "success" : "error",
          show: !!updateMessage && buttonStatus !== "error",
          onHide: handleBannerHide,
          autoHideDelay: 3e3
        }
      )
    ] })
  ] });
};
const iconMedia = "" + new URL("icon-media-blue-2c14bdef.svg", import.meta.url).href;
const emojiSettingsSelector = Recoil_index_9({
  key: "emojiSettingsSelector",
  get: ({ get: get2 }) => {
    const subscriptionSettings = get2(subscriptionSettingsAtom);
    const ofUserId = get2(ofUserIdAtom);
    console.log("[emojiSettingsSelector] get", subscriptionSettings, ofUserId);
    if (!subscriptionSettings || !ofUserId) {
      return {
        emojisForToolbar: ["💋", "🔥", "💦", "🍑", "😈", "❤️"],
        emojiBarEnabled: true
      };
    }
    const creatorSettings = subscriptionSettings.creatorSettings || [];
    const currentCreatorSettings = creatorSettings.find(
      (setting) => setting.ofCreatorId == ofUserId
    );
    if (!currentCreatorSettings) {
      return {
        emojisForToolbar: ["💋", "🔥", "💦", "🍑", "😈", "❤️"],
        emojiBarEnabled: true
      };
    }
    return {
      emojisForToolbar: currentCreatorSettings.emojisForToolbar || [
        "💋",
        "🔥",
        "💦",
        "🍑",
        "😈",
        "❤️"
      ],
      emojiBarEnabled: currentCreatorSettings.emojiBarEnabled ?? true
    };
  }
});
const iconVault = "" + new URL("icon-vault-2dcaba36.svg", import.meta.url).href;
const VaultListItem = ({ list, isSelected, onClick }) => {
  var _a;
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    "li",
    {
      className: `cursor-pointer border-b border-gray-200 px-4 py-3 hover:bg-blue-50 ${isSelected ? "bg-blue-50" : ""}`,
      onClick,
      children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex w-full flex-row items-center justify-between", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex flex-col justify-between space-y-1.5", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "text-base font-medium", children: list.name }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex flex-row space-x-1 text-sm font-light text-gray-400", children: list.photosCount === 0 && list.videosCount === 0 ? /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: "empty" }) : /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: "flex items-center space-x-1", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                "img",
                {
                  src: iconVault,
                  alt: "Photos",
                  className: "ph-no-capture h-4 w-4 fill-current text-gray-400"
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: list.photosCount })
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-lg", children: "·" }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: "flex items-center space-x-1", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("img", { src: iconVideo, alt: "Videos", className: "h-4 w-4 fill-current text-gray-400" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: list.videosCount })
            ] })
          ] }) })
        ] }),
        ((_a = list.medias) == null ? void 0 : _a.length) > 0 && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "mt-1 hidden -space-x-5 sm:flex", children: list.medias.slice(0, 3).map((media, index2) => /* @__PURE__ */ jsxRuntimeExports.jsx(
          OFMediaAsset,
          {
            src: media == null ? void 0 : media.url,
            alt: `Preview ${index2 + 1}`,
            className: "h-10 w-10 overflow-clip rounded-lg border-2 border-white-spicy object-cover"
          },
          index2
        )) })
      ] })
    }
  );
};
const MediaGridItem = ({ item, isSelected, onToggle }) => {
  var _a, _b;
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
    "div",
    {
      className: "aspect-square relative max-h-36 w-1/3 cursor-pointer overflow-clip",
      onClick: () => onToggle(item),
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          OFMediaAsset,
          {
            item,
            src: (_b = (_a = item.files) == null ? void 0 : _a.thumb) == null ? void 0 : _b.url,
            alt: `Vault media ${item.id}`,
            className: "h-full w-full object-cover pb-0.5 pr-0.5"
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "absolute right-2 top-2", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          "div",
          {
            className: `h-5 w-5 rounded-full border-2 ${isSelected ? "border-ofBlue-spicy bg-ofBlue-spicy" : "border-gray-200 hover:border-white-spicy"}`,
            children: isSelected && /* @__PURE__ */ jsxRuntimeExports.jsx(
              "svg",
              {
                className: "text-white mx-auto mt-0 h-4 w-4",
                fill: "none",
                stroke: "currentColor",
                viewBox: "0 0 24 24",
                children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: "3", d: "M5 13l4 4L19 7" })
              }
            )
          }
        ) })
      ]
    }
  );
};
const ModalFooter = ({ onClose }) => /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex justify-end p-2", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
  "button",
  {
    className: "rounded-full bg-ofBlue-spicy bg-opacity-0 px-4 py-2 text-sm font-medium text-ofBlue-spicy hover:bg-opacity-10",
    onClick: onClose,
    children: "CLOSE"
  }
) });
const FloatingSelectionBar = ({ count: count2, onConfirm, onClear }) => /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "sticky bottom-2 right-2 w-full pl-4", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "text-white flex w-full items-center justify-between rounded-full bg-black-spicy px-2 py-2 shadow-lg", children: [
  /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center space-x-3", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      "button",
      {
        onClick: onClear,
        className: "text-white ml-2 flex h-6 w-6 items-center justify-center rounded-full bg-ofBlue-spicy hover:opacity-80",
        children: /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { className: "h-4 w-4", fill: "none", stroke: "currentColor", viewBox: "0 0 24 24", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          "path",
          {
            strokeLinecap: "round",
            strokeLinejoin: "round",
            strokeWidth: "3",
            d: "M6 18L18 6M6 6l12 12"
          }
        ) })
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: "text-sm font-normal", children: [
      count2,
      " Selected"
    ] })
  ] }),
  /* @__PURE__ */ jsxRuntimeExports.jsx(
    "button",
    {
      onClick: onConfirm,
      className: "rounded-full bg-ofBlue-spicy px-4 py-2 text-sm font-medium hover:opacity-80",
      children: "ADD"
    }
  )
] }) });
const FilterToggle = ({ filters, activeFilter, onFilterChange }) => /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex gap-2 px-4 py-4", children: filters.map((filter) => /* @__PURE__ */ jsxRuntimeExports.jsx(
  "button",
  {
    onClick: () => onFilterChange(filter),
    className: `rounded-full px-4 py-1.5 text-sm font-normal transition-colors
          ${activeFilter === filter ? "bg-ofBlue-spicy bg-opacity-20 text-black-spicy" : "bg-gray-100 text-black-spicy hover:bg-gray-200"}`,
    children: filter
  },
  filter
)) });
const MediaSelectionModal = ({ showModal, onClose, onConfirm, getInitialImages }) => {
  var _a;
  const [vaultLists, setVaultLists] = reactExports.useState([]);
  const [selectedListId, setSelectedListId] = reactExports.useState("all");
  const [vaultMedia, setVaultMedia] = reactExports.useState([]);
  const [loadingLists, setLoadingLists] = reactExports.useState(false);
  const [loadingMedia, setLoadingMedia] = reactExports.useState(false);
  const [listsOffset, setListsOffset] = reactExports.useState(0);
  const [mediaOffset, setMediaOffset] = reactExports.useState(0);
  const [hasMoreLists, setHasMoreLists] = reactExports.useState(true);
  const [hasMoreMedia, setHasMoreMedia] = reactExports.useState(true);
  const onlyFansAPI = useOnlyFansAPI();
  const listsRef = reactExports.useRef(null);
  const mediaRef = reactExports.useRef(null);
  const [selectedImages, setSelectedImages] = reactExports.useState([]);
  const [activeFilter, setActiveFilter] = reactExports.useState("All");
  reactExports.useEffect(() => {
    if (showModal) {
      setSelectedImages(getInitialImages());
    }
  }, [showModal, getInitialImages]);
  const loadVaultLists = reactExports.useCallback(async () => {
    if (loadingLists || !hasMoreLists)
      return;
    setLoadingLists(true);
    try {
      const result = await onlyFansAPI.getVaultLists(10, listsOffset);
      setVaultLists((prev) => [
        ...listsOffset === 0 ? [{ id: "all", name: "All media", ...result.all }] : prev,
        ...result.list
      ]);
      setListsOffset((prev) => {
        var _a2;
        return prev + ((_a2 = result.list) == null ? void 0 : _a2.length);
      });
      setHasMoreLists(result.hasMore);
    } catch (error) {
      console.error("[vaultLists] Error loading vault lists:", error);
      setLoadingLists(false);
      setHasMoreLists(false);
    } finally {
      setLoadingLists(false);
    }
  }, [onlyFansAPI, listsOffset, loadingLists, hasMoreLists]);
  const loadVaultMedia = reactExports.useCallback(async () => {
    if (loadingMedia || !hasMoreMedia)
      return;
    setLoadingMedia(true);
    try {
      const result = await onlyFansAPI.getVaultMedia(
        24,
        mediaOffset,
        "recent",
        "desc",
        selectedListId
      );
      setVaultMedia((prev) => [...prev, ...result.list]);
      setMediaOffset((prev) => {
        var _a2;
        return prev + ((_a2 = result.list) == null ? void 0 : _a2.length);
      });
      setHasMoreMedia(result.hasMore);
    } catch (error) {
      console.error("[vaultMedia] Error loading vault media:", error);
      setLoadingMedia(false);
      setHasMoreMedia(false);
    } finally {
      setLoadingMedia(false);
    }
  }, [onlyFansAPI, selectedListId, mediaOffset, loadingMedia, hasMoreMedia]);
  reactExports.useEffect(() => {
    if (showModal && vaultLists.length === 0) {
      loadVaultLists();
    }
  }, [showModal, loadVaultLists, vaultLists.length]);
  reactExports.useEffect(() => {
    if (showModal && vaultMedia.length === 0) {
      loadVaultMedia();
    }
  }, [showModal, loadVaultMedia, vaultMedia.length, selectedListId]);
  const handleListSelect = (listId) => {
    setSelectedListId(listId);
    setVaultMedia([]);
    setMediaOffset(0);
    setHasMoreMedia(true);
    if (mediaRef.current) {
      mediaRef.current.scrollTop = 0;
    }
  };
  const handleListScroll = reactExports.useCallback(() => {
    if (listsRef.current) {
      const { scrollTop, scrollHeight, clientHeight } = listsRef.current;
      if (scrollHeight - scrollTop <= clientHeight + 1) {
        loadVaultLists();
      }
    }
  }, [loadVaultLists]);
  const handleMediaScroll = reactExports.useCallback(() => {
    if (mediaRef.current) {
      const { scrollTop, scrollHeight, clientHeight } = mediaRef.current;
      if (scrollHeight - scrollTop <= clientHeight + 1) {
        loadVaultMedia();
      }
    }
  }, [loadVaultMedia]);
  reactExports.useEffect(() => {
    const listsElement = listsRef.current;
    const mediaElement = mediaRef.current;
    if (listsElement)
      listsElement.addEventListener("scroll", handleListScroll);
    if (mediaElement)
      mediaElement.addEventListener("scroll", handleMediaScroll);
    return () => {
      if (listsElement)
        listsElement.removeEventListener("scroll", handleListScroll);
      if (mediaElement)
        mediaElement.removeEventListener("scroll", handleMediaScroll);
    };
  }, [handleListScroll, handleMediaScroll]);
  const onToggleImageSelection = reactExports.useCallback((item) => {
    setSelectedImages((prev) => {
      const isSelected = prev.some((img) => img.id === item.id);
      if (isSelected) {
        return prev.filter((img) => img.id !== item.id);
      } else {
        return [...prev, item];
      }
    });
  }, []);
  const handleConfirm = reactExports.useCallback(() => {
    onConfirm(selectedImages);
  }, [onConfirm, selectedImages]);
  const handleClose = reactExports.useCallback(() => {
    setSelectedImages([]);
    onClose();
  }, [onClose]);
  const handleBackgroundClick = (e2) => {
    if (e2.target === e2.currentTarget) {
      handleClose();
    }
  };
  const filteredMedia = reactExports.useMemo(() => {
    if (activeFilter === "All")
      return vaultMedia;
    return vaultMedia.filter((item) => {
      if (activeFilter === "Photo")
        return item.type === "photo";
      if (activeFilter === "Video")
        return item.type === "video";
      if (activeFilter === "Audio")
        return item.type === "audio";
      return true;
    });
  }, [vaultMedia, activeFilter]);
  if (!showModal)
    return null;
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    "div",
    {
      className: "fixed inset-0 z-50 flex items-center justify-center bg-black-spicy bg-opacity-50",
      onClick: handleBackgroundClick,
      children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "mx-10 my-10 max-h-[600px] min-h-[600px] w-full max-w-[880px] overflow-clip rounded-lg bg-white-spicy text-black-spicy shadow-xl", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex flex-grow overflow-hidden", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs(
            "div",
            {
              className: "vault-scrollbar h-[540px] w-1/3 overflow-y-auto overflow-x-hidden md:w-1/2",
              ref: listsRef,
              children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: "sticky top-0 z-10 border-b border-gray-200 bg-white-spicy py-5 pl-4 text-sm font-semibold", children: "VAULT" }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs("ul", { className: "pb-2", children: [
                  vaultLists.map((list) => /* @__PURE__ */ jsxRuntimeExports.jsx(
                    VaultListItem,
                    {
                      list,
                      isSelected: selectedListId === list.id,
                      onClick: () => handleListSelect(list.id)
                    },
                    list.id
                  )),
                  loadingLists && /* @__PURE__ */ jsxRuntimeExports.jsx(LoadingSpinner, {})
                ] })
              ]
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsxs(
            "div",
            {
              className: "vault-scrollbar relative max-h-[540px] w-2/3 overflow-y-auto overflow-x-hidden border-b border-l border-gray-200 md:w-1/2",
              ref: mediaRef,
              children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: "sticky top-0 z-10 border-b border-gray-200 bg-white-spicy py-5 pl-4 text-sm font-semibold", children: selectedListId && !loadingLists ? (_a = vaultLists.find((list) => list.id === selectedListId)) == null ? void 0 : _a.name.toUpperCase() : "SELECT A LIST" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  FilterToggle,
                  {
                    filters: ["All", "Photo", "Video", "Audio"],
                    activeFilter,
                    onFilterChange: setActiveFilter
                  }
                ),
                /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex h-full w-full flex-wrap overflow-y-auto", children: filteredMedia.map((item) => /* @__PURE__ */ jsxRuntimeExports.jsx(
                  MediaGridItem,
                  {
                    item,
                    isSelected: selectedImages.some((img) => img.id === item.id),
                    onToggle: onToggleImageSelection
                  },
                  item.id
                )) }),
                loadingMedia && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "mt-4 flex h-full items-start justify-start", children: /* @__PURE__ */ jsxRuntimeExports.jsx(LoadingSpinner, {}) }),
                selectedImages.length > 0 && /* @__PURE__ */ jsxRuntimeExports.jsx(
                  FloatingSelectionBar,
                  {
                    count: selectedImages.length,
                    onConfirm: handleConfirm,
                    onClear: () => setSelectedImages([])
                  }
                )
              ]
            }
          )
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(ModalFooter, { onClose: handleClose })
      ] })
    }
  );
};
const MessageInput = ({ message, setMessage, placeholder, onImagesSelected }) => {
  const [showModal, setShowModal] = reactExports.useState(false);
  const [selectedImages, setSelectedImages] = reactExports.useState([]);
  const emojiSettings = Recoil_index_20(emojiSettingsSelector);
  const { emojisForToolbar, emojiBarEnabled } = emojiSettings || {
    emojisForToolbar: ["💋", "🔥", "💦", "🍑", "😈", "❤️"],
    emojiBarEnabled: true
  };
  const textareaRef = reactExports.useRef(null);
  reactExports.useEffect(() => {
    if (textareaRef.current) {
      textareaRef.current.focus();
    }
  }, []);
  const handleAttachMedia = () => {
    setShowModal(true);
  };
  const handleCloseModal = () => {
    setShowModal(false);
  };
  const handleConfirmSelection = (selectedMediaItems) => {
    setShowModal(false);
    setSelectedImages(selectedMediaItems);
    onImagesSelected(selectedMediaItems == null ? void 0 : selectedMediaItems.map((img) => img.id));
  };
  const getInitialImages = reactExports.useCallback(() => {
    return selectedImages;
  }, [selectedImages]);
  const handleDeselectImage = (imageId) => {
    const updatedImages = selectedImages.filter((img) => img.id !== imageId);
    setSelectedImages(updatedImages);
    onImagesSelected(updatedImages.map((img) => img.id));
  };
  const handleEmojiClick = (emoji) => {
    setMessage((prevMessage) => prevMessage + emoji);
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "text-left", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: "mb-2 text-base font-semibold", children: "Message" }),
    selectedImages.length > 0 && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "mb-1 flex w-full flex-row space-x-1 overflow-x-auto", children: selectedImages.map((image) => {
      var _a, _b;
      return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "relative", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          OFMediaAsset,
          {
            item: image,
            src: (_b = (_a = image.files) == null ? void 0 : _a.thumb) == null ? void 0 : _b.url,
            alt: `Selected media ${image.id}`,
            className: "h-28 w-28 overflow-clip rounded-md"
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          "button",
          {
            onClick: () => handleDeselectImage(image.id),
            className: "text-white absolute right-2 top-2 flex h-5 w-5 items-center justify-center rounded-full bg-ofBlue-spicy hover:opacity-80",
            children: /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { className: "h-4 w-4", fill: "none", stroke: "currentColor", viewBox: "0 0 24 24", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
              "path",
              {
                strokeLinecap: "round",
                strokeLinejoin: "round",
                strokeWidth: "3",
                d: "M6 18L18 6M6 6l12 12"
              }
            ) })
          }
        )
      ] }, image.id);
    }) }),
    emojiBarEnabled && /* @__PURE__ */ jsxRuntimeExports.jsx(
      "div",
      {
        className: "flex items-center justify-between rounded-t-lg p-2",
        style: { background: "linear-gradient(to right, #D6E9FF, #EFE5FF)" },
        children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "no-scrollbar flex w-full flex-wrap overflow-auto", children: emojisForToolbar.map((emoji, index2) => /* @__PURE__ */ jsxRuntimeExports.jsx(
          "button",
          {
            className: "select-none px-2 py-0.5 text-[14px]",
            style: {
              WebkitTapHighlightColor: "transparent",
              outline: "none"
            },
            onClick: () => handleEmojiClick(emoji),
            children: emoji
          },
          index2
        )) })
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      "textarea",
      {
        ref: textareaRef,
        value: message,
        onChange: (e2) => setMessage(e2.target.value),
        placeholder,
        className: `w-full border border-gray-300 bg-transparent p-3 ${emojiBarEnabled ? "rounded-b-lg" : "rounded-lg"} resize-none focus:border-indigo-500 focus:outline-none focus:ring-0`,
        style: {
          "--tw-border-opacity": "1",
          "--focus-border-color": "rgb(99 102 241 / var(--tw-border-opacity))"
        },
        rows: "4"
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "mt-2 flex items-center text-ofBlue-spicy", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: "flex cursor-pointer items-center", onClick: handleAttachMedia, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("img", { src: iconMedia, alt: "Media", className: "mr-1 h-4 w-4" }),
      "Attach media from vault"
    ] }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      MediaSelectionModal,
      {
        showModal,
        getInitialImages,
        onClose: handleCloseModal,
        onConfirm: handleConfirmSelection
      }
    )
  ] });
};
const MIN_PRICE = 3;
const MAX_PRICE = 100;
const MIN_LIKES = 1;
const CreateRewardForm = ({ onRewardCreated }) => {
  const [message, setMessage] = reactExports.useState("");
  const [requiredLikes, setRequiredLikes] = reactExports.useState(MIN_LIKES);
  const [isLoading, setIsLoading] = reactExports.useState(false);
  const [price, setPrice] = reactExports.useState("");
  const [mediaIds, setMediaIds] = reactExports.useState([]);
  const networkManager = useNetworkManager();
  const [errorMessage, setErrorMessage] = reactExports.useState("");
  const [buttonStatus, setButtonStatus] = reactExports.useState(null);
  const handleCreateReward = async () => {
    if (!message.trim() || requiredLikes < MIN_LIKES) {
      setErrorMessage("Please enter a valid message and number of required likes (minimum 1).");
      return;
    }
    if (price > 0 && (price < MIN_PRICE || price > MAX_PRICE)) {
      setErrorMessage(`Price must be free or between $${MIN_PRICE} and $${MAX_PRICE}`);
      return;
    }
    setIsLoading(true);
    setButtonStatus("saving");
    try {
      const response = await networkManager.createReward({
        requiredLikes,
        message,
        enabled: true,
        price,
        mediaIds
      });
      if (response) {
        console.log("Reward created successfully:", response);
        setMessage("");
        setRequiredLikes(0);
        setPrice(0);
        setMediaIds([]);
        setButtonStatus("saved");
        setTimeout(() => {
          setButtonStatus(null);
          onRewardCreated();
          setErrorMessage("");
        }, 2e3);
      } else {
        const errorMsg = "Failed to create reward. Please try again.";
        setErrorMessage(errorMsg);
        setButtonStatus("error");
        setTimeout(() => {
          setButtonStatus(null);
        }, 3e3);
      }
    } catch (error) {
      console.error("Error creating reward:", error);
      const errorMsg = "An error occurred while creating the reward.";
      setErrorMessage(errorMsg);
      setButtonStatus("error");
      setTimeout(() => {
        setButtonStatus(null);
      }, 3e3);
    } finally {
      setIsLoading(false);
    }
  };
  const handlePriceChange = (e2) => {
    const newPrice = parseFloat(e2.target.value) || 0;
    setPrice(newPrice);
    if (newPrice === 0 || newPrice >= MIN_PRICE && newPrice <= MAX_PRICE) {
      setErrorMessage("");
    } else {
      setErrorMessage(`Price must be free or between $${MIN_PRICE} and $${MAX_PRICE}`);
    }
  };
  const isFormValid = message.trim() && requiredLikes >= MIN_LIKES && !(errorMessage == null ? void 0 : errorMessage.length);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "w-full", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      TabHeader,
      {
        title: "Create new reward 🥰",
        subtitle: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
          "Automatically send a reward to fans after they've liked a specific number of posts on your wall. Make sure to customize your welcome message",
          " ",
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "a",
            {
              href: "https://onlyfans.com/my/settings/messaging",
              className: "text-ofBlue-spicy hover:underline",
              target: "_blank",
              rel: "noopener noreferrer",
              children: "in your OnlyFans settings here"
            }
          ),
          " ",
          "to let fans know what they need to do!"
        ] })
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      MessageInput,
      {
        message,
        setMessage,
        onImagesSelected: setMediaIds,
        placeholder: "ahhh thank you so much for liking so many things! here's the freebie I promised 💕"
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "my-7 h-px w-full bg-gray-100" }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "mb-6 flex w-full flex-row justify-between", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex flex-col", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: "mb-2 text-base font-semibold", children: "Set reward criteria" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "mb-2 text-sm text-gray-600", children: "How many posts does the fan need to like before they receive the reward message?" })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex items-center justify-end", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
        "input",
        {
          type: "number",
          id: "requiredLikes",
          value: requiredLikes,
          onChange: (e2) => setRequiredLikes(Math.max(MIN_LIKES, parseInt(e2.target.value, 10))),
          className: "w-16 rounded-md border border-gray-300 bg-transparent px-3 py-2 text-right focus:outline-none focus:ring-2 focus:ring-blue-500",
          min: MIN_LIKES
        }
      ) })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "mb-6 flex w-full flex-row justify-between", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex flex-col", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: "mb-2 text-base font-semibold", children: "Set reward price (optional)" }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { className: "mb-2 text-sm text-gray-600", children: [
          "Set a price if you want to charge for this reward message. Price must be between $",
          MIN_PRICE,
          " and $",
          MAX_PRICE
        ] })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex items-center justify-end", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
        "input",
        {
          type: "number",
          value: price,
          onChange: handlePriceChange,
          className: "w-24 rounded-md border border-gray-300 bg-transparent px-3 py-2 text-right focus:outline-none focus:ring-2 focus:ring-blue-500",
          min: "0",
          max: MAX_PRICE,
          placeholder: "Free"
        }
      ) })
    ] }),
    errorMessage && buttonStatus !== "error" && /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "mt-4 text-center text-sm italic text-red-500", children: errorMessage }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "mt-6", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { className: "text-center text-sm text-gray-600", children: [
      "Rewards will be sent out to new fans who meet your criteria.",
      " ",
      /* @__PURE__ */ jsxRuntimeExports.jsx("u", { children: "We will not reward existing fans who have met criteria in the past." }),
      " Reward messages are automatically sent when you are online."
    ] }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      FloatingActionButton,
      {
        onClick: handleCreateReward,
        disabled: !isFormValid,
        isLoading,
        buttonText: "Create reward ⭐️",
        loadingText: "Creating reward...",
        progressMessage: "Creating reward...",
        successMessage: "Reward created!",
        disabledReason: !message.trim() ? "Please enter a message for your reward" : requiredLikes < MIN_LIKES ? `Minimum ${MIN_LIKES} likes required` : price > 0 && (price < MIN_PRICE || price > MAX_PRICE) ? `Price must be free or between $${MIN_PRICE} and $${MAX_PRICE}` : errorMessage || "Please complete all required fields",
        show: true,
        status: buttonStatus,
        errorMessage: errorMessage || "Failed to create reward"
      }
    )
  ] });
};
const RewardCard = ({ reward, onToggleEnabled, isExpired = false, isNewest = false }) => {
  var _a;
  const formattedCreatedDate = new Date(reward.createdAt).toLocaleDateString();
  const formattedEndedDate = reward.endedAt ? new Date(reward.endedAt).toLocaleDateString() : "Today";
  const isActive = !!reward.enabled;
  const dateRange = isActive ? `Active ${formattedCreatedDate} - ${formattedEndedDate ?? "Today"}` : `Deactivated ${formattedCreatedDate} - ${formattedEndedDate}`;
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
    "div",
    {
      className: `overflow-hidden rounded-lg border border-gray-200 ${isNewest ? "shadow-[0_0_15px_rgba(59,130,246,0.5)]" : ""}`,
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: `p-4 ${!reward.enabled ? "opacity-50" : ""}`, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "mb-4 flex items-start justify-between", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: "text-lg font-medium", children: "Reward message" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: `text-sm ${isActive ? "font-bold text-green-600" : "text-gray-500"}`, children: dateRange })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "mb-4 text-base", children: reward.message }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "mb-4", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("h4", { className: "mb-2 text-base font-medium", children: "Reward criteria" }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { className: "text-sm text-gray-600", children: [
              reward.requiredLikes,
              " likes"
            ] }),
            reward.price > 0 && /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { className: "mt-1 text-sm text-gray-600", children: [
              "Price: $",
              reward.price.toFixed(2)
            ] }),
            ((_a = reward.mediaIds) == null ? void 0 : _a.length) > 0 && /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { className: "mt-1 text-sm text-gray-600", children: [
              "Media attachments: ",
              reward.mediaIds.length
            ] })
          ] })
        ] }),
        !isExpired && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "px-4 pb-4", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          "button",
          {
            onClick: () => onToggleEnabled(reward._id, !reward.enabled),
            className: `
              w-full rounded px-4 py-2 text-center text-sm font-medium
              ${reward.enabled ? "bg-red-100 text-red-700 hover:bg-red-200" : "bg-blue-100 text-blue-700 hover:bg-blue-200"}
            `,
            children: reward.enabled ? "Deactivate reward" : "Reactivate reward"
          }
        ) })
      ]
    }
  );
};
const ViewRewards = () => {
  const subscriptionSettingsId = Recoil_index_20(subscriptionSettingsIdSelector);
  const ofUserId = Recoil_index_20(ofUserIdAtom);
  const [rewards, setRewards] = reactExports.useState([]);
  const [isLoading, setIsLoading] = reactExports.useState(true);
  const networkManager = useNetworkManager();
  reactExports.useEffect(() => {
    const fetchRewards = async () => {
      try {
        const fetchedRewards = await networkManager.getRewards();
        setRewards(
          fetchedRewards.sort(
            (a2, b2) => new Date(b2.createdAt).getTime() - new Date(a2.createdAt).getTime()
          )
        );
      } catch (error) {
        console.error("Error fetching rewards:", error);
      } finally {
        setIsLoading(false);
      }
    };
    if (subscriptionSettingsId && ofUserId) {
      fetchRewards();
    }
  }, [subscriptionSettingsId, ofUserId]);
  const handleToggleEnabled = async (rewardId, enabled) => {
    try {
      await networkManager.updateReward(rewardId, {
        enabled
      });
      setRewards(
        rewards.map((reward) => reward._id === rewardId ? { ...reward, enabled } : reward)
      );
    } catch (error) {
      console.error("Error updating reward:", error);
      alert("Failed to update reward status");
    }
  };
  if (isLoading) {
    return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(TabHeader, { title: "View rewards 🎁" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(LoadingSpinner, {})
    ] });
  }
  if (rewards.length === 0) {
    return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      TabHeader,
      {
        title: "View rewards 🎁",
        subtitle: "No rewards created yet. Switch to the Create reward tab to create your first reward!"
      }
    ) });
  }
  const thirtyDaysAgo = /* @__PURE__ */ new Date();
  thirtyDaysAgo.setDate(thirtyDaysAgo.getDate() - 30);
  const activeRewards = rewards.filter(
    (reward) => !reward.endedAt || new Date(reward.endedAt) > thirtyDaysAgo
  );
  const expiredRewards = rewards.filter(
    (reward) => reward.endedAt && new Date(reward.endedAt) <= thirtyDaysAgo
  );
  const [newestReward, ...otherActiveRewards] = activeRewards;
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      TabHeader,
      {
        title: "View rewards 🎁",
        subtitle: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { children: "Manage your current and previously active rewards" }) })
      }
    ),
    newestReward && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "mb-8 rounded-lg border-2 border-ofBlue-spicy border-opacity-80 p-4 shadow-[0_0_15px_rgba(59,130,246,0.5)]", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { className: "mb-2 text-xl font-semibold", children: "Current reward" }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { className: "mb-4 text-sm text-gray-500", children: [
        "This reward will be applied to any fans who have subscribed since the reward was created on ",
        new Date(newestReward.createdAt).toLocaleDateString(),
        "."
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        RewardCard,
        {
          reward: newestReward,
          onToggleEnabled: handleToggleEnabled
        },
        newestReward._id
      )
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "mb-8", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { className: "mb-4 text-xl font-semibold", children: "Previous rewards" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "mb-4 text-sm text-gray-500", children: "Fans will receive the reward which was active at the time of their subscription. These previous rewards will be sent to fans who subscribed during the time the reward was your current reward." }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "space-y-4", children: otherActiveRewards.map((reward) => /* @__PURE__ */ jsxRuntimeExports.jsx(RewardCard, { reward, onToggleEnabled: handleToggleEnabled }, reward._id)) })
    ] }),
    expiredRewards.length > 0 && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { className: "mb-4 text-xl font-semibold", children: "Expired rewards" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "mb-4 text-sm text-gray-600", children: "These past rewards have been permanently deactivated because they are more than 30 days old." }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "space-y-4", children: expiredRewards.map((reward) => /* @__PURE__ */ jsxRuntimeExports.jsx(
        RewardCard,
        {
          reward,
          onToggleEnabled: handleToggleEnabled,
          isExpired: true
        },
        reward._id
      )) })
    ] })
  ] });
};
const CreateRewardsTab = () => {
  const [localTab, setLocalTab] = reactExports.useState("create");
  const tabs = [
    { id: "create", label: "Create reward" },
    { id: "view", label: "View rewards" }
  ];
  const handleRewardCreated = () => {
    setLocalTab("view");
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "mt-0 w-full pb-20 text-left", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "mb-6 border-b border-gray-200", children: /* @__PURE__ */ jsxRuntimeExports.jsx("nav", { className: "-mb-px flex space-x-8", "aria-label": "Tabs", children: tabs.map((tab2) => /* @__PURE__ */ jsxRuntimeExports.jsx(
      "button",
      {
        onClick: () => setLocalTab(tab2.id),
        className: `
                relative whitespace-nowrap px-1 py-1.5 text-sm font-medium
                ${localTab === tab2.id ? "text-sm text-black-spicy" : "text-gray-500 hover:text-gray-600"}
                after:absolute after:bottom-0 after:left-1/2 after:h-0.5
                after:-translate-x-1/2 after:transition-all
                ${localTab === tab2.id ? "after:w-5/6 after:bg-gray-600" : "after:w-0 hover:after:w-5/6 hover:after:bg-gray-300"}
              `,
        children: tab2.label
      },
      tab2.id
    )) }) }),
    localTab === "create" ? /* @__PURE__ */ jsxRuntimeExports.jsx(CreateRewardForm, { onRewardCreated: handleRewardCreated }) : /* @__PURE__ */ jsxRuntimeExports.jsx(ViewRewards, {})
  ] });
};
const templateSettingsSelector = Recoil_index_9({
  key: "templateSettingsSelector",
  get: ({ get: get2 }) => {
    const subscriptionSettings = get2(subscriptionSettingsAtom);
    const ofUserId = get2(ofUserIdAtom);
    console.log("[templateSettingsSelector] get", subscriptionSettings, ofUserId);
    if (!subscriptionSettings || !ofUserId) {
      return {
        folders: [],
        templateBarEnabled: true
      };
    }
    const creatorSettings = subscriptionSettings.creatorSettings || [];
    const currentCreatorSettings = creatorSettings.find(
      (setting) => setting.ofCreatorId == ofUserId
    );
    if (!currentCreatorSettings || !currentCreatorSettings.templateSettingsId) {
      return {
        folders: [],
        templateBarEnabled: true
      };
    }
    return {
      folders: currentCreatorSettings.templateSettingsId.folders || [],
      templateBarEnabled: currentCreatorSettings.templateSettingsId.templateBarEnabled ?? true
    };
  }
});
function _setPrototypeOf(o2, p2) {
  _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o3, p3) {
    o3.__proto__ = p3;
    return o3;
  };
  return _setPrototypeOf(o2, p2);
}
function _inheritsLoose(subClass, superClass) {
  subClass.prototype = Object.create(superClass.prototype);
  subClass.prototype.constructor = subClass;
  _setPrototypeOf(subClass, superClass);
}
function _extends() {
  _extends = Object.assign ? Object.assign.bind() : function(target) {
    for (var i2 = 1; i2 < arguments.length; i2++) {
      var source = arguments[i2];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends.apply(this, arguments);
}
function _typeof(obj) {
  "@babel/helpers - typeof";
  return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj2) {
    return typeof obj2;
  } : function(obj2) {
    return obj2 && "function" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
  }, _typeof(obj);
}
function _toPrimitive(input, hint) {
  if (_typeof(input) !== "object" || input === null)
    return input;
  var prim = input[Symbol.toPrimitive];
  if (prim !== void 0) {
    var res = prim.call(input, hint || "default");
    if (_typeof(res) !== "object")
      return res;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (hint === "string" ? String : Number)(input);
}
function _toPropertyKey(arg) {
  var key = _toPrimitive(arg, "string");
  return _typeof(key) === "symbol" ? key : String(key);
}
function _defineProperty(obj, key, value) {
  key = _toPropertyKey(key);
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}
function ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread2(target) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source = null != arguments[i2] ? arguments[i2] : {};
    i2 % 2 ? ownKeys(Object(source), true).forEach(function(key) {
      _defineProperty(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function(key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
}
function formatProdErrorMessage(code) {
  return "Minified Redux error #" + code + "; visit https://redux.js.org/Errors?code=" + code + " for the full message or use the non-minified dev environment for full errors. ";
}
var $$observable = function() {
  return typeof Symbol === "function" && Symbol.observable || "@@observable";
}();
var randomString = function randomString2() {
  return Math.random().toString(36).substring(7).split("").join(".");
};
var ActionTypes = {
  INIT: "@@redux/INIT" + randomString(),
  REPLACE: "@@redux/REPLACE" + randomString(),
  PROBE_UNKNOWN_ACTION: function PROBE_UNKNOWN_ACTION() {
    return "@@redux/PROBE_UNKNOWN_ACTION" + randomString();
  }
};
function isPlainObject(obj) {
  if (typeof obj !== "object" || obj === null)
    return false;
  var proto = obj;
  while (Object.getPrototypeOf(proto) !== null) {
    proto = Object.getPrototypeOf(proto);
  }
  return Object.getPrototypeOf(obj) === proto;
}
function createStore$1(reducer2, preloadedState, enhancer) {
  var _ref2;
  if (typeof preloadedState === "function" && typeof enhancer === "function" || typeof enhancer === "function" && typeof arguments[3] === "function") {
    throw new Error(formatProdErrorMessage(0));
  }
  if (typeof preloadedState === "function" && typeof enhancer === "undefined") {
    enhancer = preloadedState;
    preloadedState = void 0;
  }
  if (typeof enhancer !== "undefined") {
    if (typeof enhancer !== "function") {
      throw new Error(formatProdErrorMessage(1));
    }
    return enhancer(createStore$1)(reducer2, preloadedState);
  }
  if (typeof reducer2 !== "function") {
    throw new Error(formatProdErrorMessage(2));
  }
  var currentReducer = reducer2;
  var currentState = preloadedState;
  var currentListeners = [];
  var nextListeners = currentListeners;
  var isDispatching = false;
  function ensureCanMutateNextListeners() {
    if (nextListeners === currentListeners) {
      nextListeners = currentListeners.slice();
    }
  }
  function getState() {
    if (isDispatching) {
      throw new Error(formatProdErrorMessage(3));
    }
    return currentState;
  }
  function subscribe(listener) {
    if (typeof listener !== "function") {
      throw new Error(formatProdErrorMessage(4));
    }
    if (isDispatching) {
      throw new Error(formatProdErrorMessage(5));
    }
    var isSubscribed = true;
    ensureCanMutateNextListeners();
    nextListeners.push(listener);
    return function unsubscribe() {
      if (!isSubscribed) {
        return;
      }
      if (isDispatching) {
        throw new Error(formatProdErrorMessage(6));
      }
      isSubscribed = false;
      ensureCanMutateNextListeners();
      var index2 = nextListeners.indexOf(listener);
      nextListeners.splice(index2, 1);
      currentListeners = null;
    };
  }
  function dispatch(action) {
    if (!isPlainObject(action)) {
      throw new Error(formatProdErrorMessage(7));
    }
    if (typeof action.type === "undefined") {
      throw new Error(formatProdErrorMessage(8));
    }
    if (isDispatching) {
      throw new Error(formatProdErrorMessage(9));
    }
    try {
      isDispatching = true;
      currentState = currentReducer(currentState, action);
    } finally {
      isDispatching = false;
    }
    var listeners = currentListeners = nextListeners;
    for (var i2 = 0; i2 < listeners.length; i2++) {
      var listener = listeners[i2];
      listener();
    }
    return action;
  }
  function replaceReducer(nextReducer) {
    if (typeof nextReducer !== "function") {
      throw new Error(formatProdErrorMessage(10));
    }
    currentReducer = nextReducer;
    dispatch({
      type: ActionTypes.REPLACE
    });
  }
  function observable() {
    var _ref;
    var outerSubscribe = subscribe;
    return _ref = {
      /**
       * The minimal observable subscription method.
       * @param {Object} observer Any object that can be used as an observer.
       * The observer object should have a `next` method.
       * @returns {subscription} An object with an `unsubscribe` method that can
       * be used to unsubscribe the observable from the store, and prevent further
       * emission of values from the observable.
       */
      subscribe: function subscribe2(observer) {
        if (typeof observer !== "object" || observer === null) {
          throw new Error(formatProdErrorMessage(11));
        }
        function observeState() {
          if (observer.next) {
            observer.next(getState());
          }
        }
        observeState();
        var unsubscribe = outerSubscribe(observeState);
        return {
          unsubscribe
        };
      }
    }, _ref[$$observable] = function() {
      return this;
    }, _ref;
  }
  dispatch({
    type: ActionTypes.INIT
  });
  return _ref2 = {
    dispatch,
    subscribe,
    getState,
    replaceReducer
  }, _ref2[$$observable] = observable, _ref2;
}
function bindActionCreator(actionCreator, dispatch) {
  return function() {
    return dispatch(actionCreator.apply(this, arguments));
  };
}
function bindActionCreators$1(actionCreators, dispatch) {
  if (typeof actionCreators === "function") {
    return bindActionCreator(actionCreators, dispatch);
  }
  if (typeof actionCreators !== "object" || actionCreators === null) {
    throw new Error(formatProdErrorMessage(16));
  }
  var boundActionCreators = {};
  for (var key in actionCreators) {
    var actionCreator = actionCreators[key];
    if (typeof actionCreator === "function") {
      boundActionCreators[key] = bindActionCreator(actionCreator, dispatch);
    }
  }
  return boundActionCreators;
}
function compose() {
  for (var _len = arguments.length, funcs = new Array(_len), _key = 0; _key < _len; _key++) {
    funcs[_key] = arguments[_key];
  }
  if (funcs.length === 0) {
    return function(arg) {
      return arg;
    };
  }
  if (funcs.length === 1) {
    return funcs[0];
  }
  return funcs.reduce(function(a2, b2) {
    return function() {
      return a2(b2.apply(void 0, arguments));
    };
  });
}
function applyMiddleware() {
  for (var _len = arguments.length, middlewares = new Array(_len), _key = 0; _key < _len; _key++) {
    middlewares[_key] = arguments[_key];
  }
  return function(createStore2) {
    return function() {
      var store = createStore2.apply(void 0, arguments);
      var _dispatch = function dispatch() {
        throw new Error(formatProdErrorMessage(15));
      };
      var middlewareAPI = {
        getState: store.getState,
        dispatch: function dispatch() {
          return _dispatch.apply(void 0, arguments);
        }
      };
      var chain = middlewares.map(function(middleware) {
        return middleware(middlewareAPI);
      });
      _dispatch = compose.apply(void 0, chain)(store.dispatch);
      return _objectSpread2(_objectSpread2({}, store), {}, {
        dispatch: _dispatch
      });
    };
  };
}
var ReactReduxContext = /* @__PURE__ */ React.createContext(null);
function defaultNoopBatch(callback) {
  callback();
}
var batch = defaultNoopBatch;
var setBatch = function setBatch2(newBatch) {
  return batch = newBatch;
};
var getBatch = function getBatch2() {
  return batch;
};
function createListenerCollection() {
  var batch2 = getBatch();
  var first = null;
  var last = null;
  return {
    clear: function clear() {
      first = null;
      last = null;
    },
    notify: function notify2() {
      batch2(function() {
        var listener = first;
        while (listener) {
          listener.callback();
          listener = listener.next;
        }
      });
    },
    get: function get2() {
      var listeners = [];
      var listener = first;
      while (listener) {
        listeners.push(listener);
        listener = listener.next;
      }
      return listeners;
    },
    subscribe: function subscribe(callback) {
      var isSubscribed = true;
      var listener = last = {
        callback,
        next: null,
        prev: last
      };
      if (listener.prev) {
        listener.prev.next = listener;
      } else {
        first = listener;
      }
      return function unsubscribe() {
        if (!isSubscribed || first === null)
          return;
        isSubscribed = false;
        if (listener.next) {
          listener.next.prev = listener.prev;
        } else {
          last = listener.prev;
        }
        if (listener.prev) {
          listener.prev.next = listener.next;
        } else {
          first = listener.next;
        }
      };
    }
  };
}
var nullListeners = {
  notify: function notify() {
  },
  get: function get() {
    return [];
  }
};
function createSubscription(store, parentSub) {
  var unsubscribe;
  var listeners = nullListeners;
  function addNestedSub(listener) {
    trySubscribe();
    return listeners.subscribe(listener);
  }
  function notifyNestedSubs() {
    listeners.notify();
  }
  function handleChangeWrapper() {
    if (subscription.onStateChange) {
      subscription.onStateChange();
    }
  }
  function isSubscribed() {
    return Boolean(unsubscribe);
  }
  function trySubscribe() {
    if (!unsubscribe) {
      unsubscribe = parentSub ? parentSub.addNestedSub(handleChangeWrapper) : store.subscribe(handleChangeWrapper);
      listeners = createListenerCollection();
    }
  }
  function tryUnsubscribe() {
    if (unsubscribe) {
      unsubscribe();
      unsubscribe = void 0;
      listeners.clear();
      listeners = nullListeners;
    }
  }
  var subscription = {
    addNestedSub,
    notifyNestedSubs,
    handleChangeWrapper,
    isSubscribed,
    trySubscribe,
    tryUnsubscribe,
    getListeners: function getListeners() {
      return listeners;
    }
  };
  return subscription;
}
var useIsomorphicLayoutEffect$1 = typeof window !== "undefined" && typeof window.document !== "undefined" && typeof window.document.createElement !== "undefined" ? reactExports.useLayoutEffect : reactExports.useEffect;
function Provider(_ref) {
  var store = _ref.store, context = _ref.context, children = _ref.children;
  var contextValue = reactExports.useMemo(function() {
    var subscription = createSubscription(store);
    return {
      store,
      subscription
    };
  }, [store]);
  var previousState = reactExports.useMemo(function() {
    return store.getState();
  }, [store]);
  useIsomorphicLayoutEffect$1(function() {
    var subscription = contextValue.subscription;
    subscription.onStateChange = subscription.notifyNestedSubs;
    subscription.trySubscribe();
    if (previousState !== store.getState()) {
      subscription.notifyNestedSubs();
    }
    return function() {
      subscription.tryUnsubscribe();
      subscription.onStateChange = null;
    };
  }, [contextValue, previousState]);
  var Context = context || ReactReduxContext;
  return /* @__PURE__ */ React.createElement(Context.Provider, {
    value: contextValue
  }, children);
}
function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null)
    return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i2;
  for (i2 = 0; i2 < sourceKeys.length; i2++) {
    key = sourceKeys[i2];
    if (excluded.indexOf(key) >= 0)
      continue;
    target[key] = source[key];
  }
  return target;
}
var reactIs$2 = { exports: {} };
var reactIs_production_min$1 = {};
/** @license React v16.13.1
 * react-is.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var b$1 = "function" === typeof Symbol && Symbol.for, c$1 = b$1 ? Symbol.for("react.element") : 60103, d$1 = b$1 ? Symbol.for("react.portal") : 60106, e$1 = b$1 ? Symbol.for("react.fragment") : 60107, f$1 = b$1 ? Symbol.for("react.strict_mode") : 60108, g$1 = b$1 ? Symbol.for("react.profiler") : 60114, h$1 = b$1 ? Symbol.for("react.provider") : 60109, k$1 = b$1 ? Symbol.for("react.context") : 60110, l$1 = b$1 ? Symbol.for("react.async_mode") : 60111, m$1 = b$1 ? Symbol.for("react.concurrent_mode") : 60111, n$1 = b$1 ? Symbol.for("react.forward_ref") : 60112, p$1 = b$1 ? Symbol.for("react.suspense") : 60113, q$1 = b$1 ? Symbol.for("react.suspense_list") : 60120, r$1 = b$1 ? Symbol.for("react.memo") : 60115, t = b$1 ? Symbol.for("react.lazy") : 60116, v$1 = b$1 ? Symbol.for("react.block") : 60121, w$1 = b$1 ? Symbol.for("react.fundamental") : 60117, x$1 = b$1 ? Symbol.for("react.responder") : 60118, y$1 = b$1 ? Symbol.for("react.scope") : 60119;
function z$1(a2) {
  if ("object" === typeof a2 && null !== a2) {
    var u2 = a2.$$typeof;
    switch (u2) {
      case c$1:
        switch (a2 = a2.type, a2) {
          case l$1:
          case m$1:
          case e$1:
          case g$1:
          case f$1:
          case p$1:
            return a2;
          default:
            switch (a2 = a2 && a2.$$typeof, a2) {
              case k$1:
              case n$1:
              case t:
              case r$1:
              case h$1:
                return a2;
              default:
                return u2;
            }
        }
      case d$1:
        return u2;
    }
  }
}
function A$1(a2) {
  return z$1(a2) === m$1;
}
reactIs_production_min$1.AsyncMode = l$1;
reactIs_production_min$1.ConcurrentMode = m$1;
reactIs_production_min$1.ContextConsumer = k$1;
reactIs_production_min$1.ContextProvider = h$1;
reactIs_production_min$1.Element = c$1;
reactIs_production_min$1.ForwardRef = n$1;
reactIs_production_min$1.Fragment = e$1;
reactIs_production_min$1.Lazy = t;
reactIs_production_min$1.Memo = r$1;
reactIs_production_min$1.Portal = d$1;
reactIs_production_min$1.Profiler = g$1;
reactIs_production_min$1.StrictMode = f$1;
reactIs_production_min$1.Suspense = p$1;
reactIs_production_min$1.isAsyncMode = function(a2) {
  return A$1(a2) || z$1(a2) === l$1;
};
reactIs_production_min$1.isConcurrentMode = A$1;
reactIs_production_min$1.isContextConsumer = function(a2) {
  return z$1(a2) === k$1;
};
reactIs_production_min$1.isContextProvider = function(a2) {
  return z$1(a2) === h$1;
};
reactIs_production_min$1.isElement = function(a2) {
  return "object" === typeof a2 && null !== a2 && a2.$$typeof === c$1;
};
reactIs_production_min$1.isForwardRef = function(a2) {
  return z$1(a2) === n$1;
};
reactIs_production_min$1.isFragment = function(a2) {
  return z$1(a2) === e$1;
};
reactIs_production_min$1.isLazy = function(a2) {
  return z$1(a2) === t;
};
reactIs_production_min$1.isMemo = function(a2) {
  return z$1(a2) === r$1;
};
reactIs_production_min$1.isPortal = function(a2) {
  return z$1(a2) === d$1;
};
reactIs_production_min$1.isProfiler = function(a2) {
  return z$1(a2) === g$1;
};
reactIs_production_min$1.isStrictMode = function(a2) {
  return z$1(a2) === f$1;
};
reactIs_production_min$1.isSuspense = function(a2) {
  return z$1(a2) === p$1;
};
reactIs_production_min$1.isValidElementType = function(a2) {
  return "string" === typeof a2 || "function" === typeof a2 || a2 === e$1 || a2 === m$1 || a2 === g$1 || a2 === f$1 || a2 === p$1 || a2 === q$1 || "object" === typeof a2 && null !== a2 && (a2.$$typeof === t || a2.$$typeof === r$1 || a2.$$typeof === h$1 || a2.$$typeof === k$1 || a2.$$typeof === n$1 || a2.$$typeof === w$1 || a2.$$typeof === x$1 || a2.$$typeof === y$1 || a2.$$typeof === v$1);
};
reactIs_production_min$1.typeOf = z$1;
{
  reactIs$2.exports = reactIs_production_min$1;
}
var reactIsExports$1 = reactIs$2.exports;
var reactIs$1 = reactIsExports$1;
var REACT_STATICS = {
  childContextTypes: true,
  contextType: true,
  contextTypes: true,
  defaultProps: true,
  displayName: true,
  getDefaultProps: true,
  getDerivedStateFromError: true,
  getDerivedStateFromProps: true,
  mixins: true,
  propTypes: true,
  type: true
};
var KNOWN_STATICS = {
  name: true,
  length: true,
  prototype: true,
  caller: true,
  callee: true,
  arguments: true,
  arity: true
};
var FORWARD_REF_STATICS = {
  "$$typeof": true,
  render: true,
  defaultProps: true,
  displayName: true,
  propTypes: true
};
var MEMO_STATICS = {
  "$$typeof": true,
  compare: true,
  defaultProps: true,
  displayName: true,
  propTypes: true,
  type: true
};
var TYPE_STATICS = {};
TYPE_STATICS[reactIs$1.ForwardRef] = FORWARD_REF_STATICS;
TYPE_STATICS[reactIs$1.Memo] = MEMO_STATICS;
function getStatics(component) {
  if (reactIs$1.isMemo(component)) {
    return MEMO_STATICS;
  }
  return TYPE_STATICS[component["$$typeof"]] || REACT_STATICS;
}
var defineProperty = Object.defineProperty;
var getOwnPropertyNames = Object.getOwnPropertyNames;
var getOwnPropertySymbols = Object.getOwnPropertySymbols;
var getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
var getPrototypeOf = Object.getPrototypeOf;
var objectPrototype = Object.prototype;
function hoistNonReactStatics(targetComponent, sourceComponent, blacklist) {
  if (typeof sourceComponent !== "string") {
    if (objectPrototype) {
      var inheritedComponent = getPrototypeOf(sourceComponent);
      if (inheritedComponent && inheritedComponent !== objectPrototype) {
        hoistNonReactStatics(targetComponent, inheritedComponent, blacklist);
      }
    }
    var keys = getOwnPropertyNames(sourceComponent);
    if (getOwnPropertySymbols) {
      keys = keys.concat(getOwnPropertySymbols(sourceComponent));
    }
    var targetStatics = getStatics(targetComponent);
    var sourceStatics = getStatics(sourceComponent);
    for (var i2 = 0; i2 < keys.length; ++i2) {
      var key = keys[i2];
      if (!KNOWN_STATICS[key] && !(blacklist && blacklist[key]) && !(sourceStatics && sourceStatics[key]) && !(targetStatics && targetStatics[key])) {
        var descriptor = getOwnPropertyDescriptor(sourceComponent, key);
        try {
          defineProperty(targetComponent, key, descriptor);
        } catch (e2) {
        }
      }
    }
  }
  return targetComponent;
}
var hoistNonReactStatics_cjs = hoistNonReactStatics;
const hoistStatics = /* @__PURE__ */ getDefaultExportFromCjs(hoistNonReactStatics_cjs);
var reactIs = { exports: {} };
var reactIs_production_min = {};
/** @license React v17.0.2
 * react-is.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var b = 60103, c = 60106, d = 60107, e = 60108, f = 60114, g = 60109, h = 60110, k = 60112, l = 60113, m = 60120, n = 60115, p = 60116, q = 60121, r = 60122, u = 60117, v = 60129, w = 60131;
if ("function" === typeof Symbol && Symbol.for) {
  var x = Symbol.for;
  b = x("react.element");
  c = x("react.portal");
  d = x("react.fragment");
  e = x("react.strict_mode");
  f = x("react.profiler");
  g = x("react.provider");
  h = x("react.context");
  k = x("react.forward_ref");
  l = x("react.suspense");
  m = x("react.suspense_list");
  n = x("react.memo");
  p = x("react.lazy");
  q = x("react.block");
  r = x("react.server.block");
  u = x("react.fundamental");
  v = x("react.debug_trace_mode");
  w = x("react.legacy_hidden");
}
function y(a2) {
  if ("object" === typeof a2 && null !== a2) {
    var t2 = a2.$$typeof;
    switch (t2) {
      case b:
        switch (a2 = a2.type, a2) {
          case d:
          case f:
          case e:
          case l:
          case m:
            return a2;
          default:
            switch (a2 = a2 && a2.$$typeof, a2) {
              case h:
              case k:
              case p:
              case n:
              case g:
                return a2;
              default:
                return t2;
            }
        }
      case c:
        return t2;
    }
  }
}
var z = g, A = b, B = k, C = d, D = p, E = n, F = c, G = f, H = e, I = l;
reactIs_production_min.ContextConsumer = h;
reactIs_production_min.ContextProvider = z;
reactIs_production_min.Element = A;
reactIs_production_min.ForwardRef = B;
reactIs_production_min.Fragment = C;
reactIs_production_min.Lazy = D;
reactIs_production_min.Memo = E;
reactIs_production_min.Portal = F;
reactIs_production_min.Profiler = G;
reactIs_production_min.StrictMode = H;
reactIs_production_min.Suspense = I;
reactIs_production_min.isAsyncMode = function() {
  return false;
};
reactIs_production_min.isConcurrentMode = function() {
  return false;
};
reactIs_production_min.isContextConsumer = function(a2) {
  return y(a2) === h;
};
reactIs_production_min.isContextProvider = function(a2) {
  return y(a2) === g;
};
reactIs_production_min.isElement = function(a2) {
  return "object" === typeof a2 && null !== a2 && a2.$$typeof === b;
};
reactIs_production_min.isForwardRef = function(a2) {
  return y(a2) === k;
};
reactIs_production_min.isFragment = function(a2) {
  return y(a2) === d;
};
reactIs_production_min.isLazy = function(a2) {
  return y(a2) === p;
};
reactIs_production_min.isMemo = function(a2) {
  return y(a2) === n;
};
reactIs_production_min.isPortal = function(a2) {
  return y(a2) === c;
};
reactIs_production_min.isProfiler = function(a2) {
  return y(a2) === f;
};
reactIs_production_min.isStrictMode = function(a2) {
  return y(a2) === e;
};
reactIs_production_min.isSuspense = function(a2) {
  return y(a2) === l;
};
reactIs_production_min.isValidElementType = function(a2) {
  return "string" === typeof a2 || "function" === typeof a2 || a2 === d || a2 === f || a2 === v || a2 === e || a2 === l || a2 === m || a2 === w || "object" === typeof a2 && null !== a2 && (a2.$$typeof === p || a2.$$typeof === n || a2.$$typeof === g || a2.$$typeof === h || a2.$$typeof === k || a2.$$typeof === u || a2.$$typeof === q || a2[0] === r) ? true : false;
};
reactIs_production_min.typeOf = y;
{
  reactIs.exports = reactIs_production_min;
}
var reactIsExports = reactIs.exports;
var _excluded$2 = ["getDisplayName", "methodName", "renderCountProp", "shouldHandleStateChanges", "storeKey", "withRef", "forwardRef", "context"], _excluded2 = ["reactReduxForwardedRef"];
var EMPTY_ARRAY = [];
var NO_SUBSCRIPTION_ARRAY = [null, null];
function storeStateUpdatesReducer(state, action) {
  var updateCount = state[1];
  return [action.payload, updateCount + 1];
}
function useIsomorphicLayoutEffectWithArgs(effectFunc, effectArgs, dependencies) {
  useIsomorphicLayoutEffect$1(function() {
    return effectFunc.apply(void 0, effectArgs);
  }, dependencies);
}
function captureWrapperProps(lastWrapperProps, lastChildProps, renderIsScheduled, wrapperProps, actualChildProps, childPropsFromStoreUpdate, notifyNestedSubs) {
  lastWrapperProps.current = wrapperProps;
  lastChildProps.current = actualChildProps;
  renderIsScheduled.current = false;
  if (childPropsFromStoreUpdate.current) {
    childPropsFromStoreUpdate.current = null;
    notifyNestedSubs();
  }
}
function subscribeUpdates(shouldHandleStateChanges, store, subscription, childPropsSelector, lastWrapperProps, lastChildProps, renderIsScheduled, childPropsFromStoreUpdate, notifyNestedSubs, forceComponentUpdateDispatch) {
  if (!shouldHandleStateChanges)
    return;
  var didUnsubscribe = false;
  var lastThrownError = null;
  var checkForUpdates = function checkForUpdates2() {
    if (didUnsubscribe) {
      return;
    }
    var latestStoreState = store.getState();
    var newChildProps, error;
    try {
      newChildProps = childPropsSelector(latestStoreState, lastWrapperProps.current);
    } catch (e2) {
      error = e2;
      lastThrownError = e2;
    }
    if (!error) {
      lastThrownError = null;
    }
    if (newChildProps === lastChildProps.current) {
      if (!renderIsScheduled.current) {
        notifyNestedSubs();
      }
    } else {
      lastChildProps.current = newChildProps;
      childPropsFromStoreUpdate.current = newChildProps;
      renderIsScheduled.current = true;
      forceComponentUpdateDispatch({
        type: "STORE_UPDATED",
        payload: {
          error
        }
      });
    }
  };
  subscription.onStateChange = checkForUpdates;
  subscription.trySubscribe();
  checkForUpdates();
  var unsubscribeWrapper = function unsubscribeWrapper2() {
    didUnsubscribe = true;
    subscription.tryUnsubscribe();
    subscription.onStateChange = null;
    if (lastThrownError) {
      throw lastThrownError;
    }
  };
  return unsubscribeWrapper;
}
var initStateUpdates = function initStateUpdates2() {
  return [null, 0];
};
function connectAdvanced(selectorFactory, _ref) {
  if (_ref === void 0) {
    _ref = {};
  }
  var _ref2 = _ref, _ref2$getDisplayName = _ref2.getDisplayName, getDisplayName = _ref2$getDisplayName === void 0 ? function(name) {
    return "ConnectAdvanced(" + name + ")";
  } : _ref2$getDisplayName, _ref2$methodName = _ref2.methodName, methodName = _ref2$methodName === void 0 ? "connectAdvanced" : _ref2$methodName, _ref2$renderCountProp = _ref2.renderCountProp, renderCountProp = _ref2$renderCountProp === void 0 ? void 0 : _ref2$renderCountProp, _ref2$shouldHandleSta = _ref2.shouldHandleStateChanges, shouldHandleStateChanges = _ref2$shouldHandleSta === void 0 ? true : _ref2$shouldHandleSta, _ref2$storeKey = _ref2.storeKey, storeKey = _ref2$storeKey === void 0 ? "store" : _ref2$storeKey;
  _ref2.withRef;
  var _ref2$forwardRef = _ref2.forwardRef, forwardRef = _ref2$forwardRef === void 0 ? false : _ref2$forwardRef, _ref2$context = _ref2.context, context = _ref2$context === void 0 ? ReactReduxContext : _ref2$context, connectOptions = _objectWithoutPropertiesLoose(_ref2, _excluded$2);
  var Context = context;
  return function wrapWithConnect(WrappedComponent) {
    var wrappedComponentName = WrappedComponent.displayName || WrappedComponent.name || "Component";
    var displayName = getDisplayName(wrappedComponentName);
    var selectorFactoryOptions = _extends({}, connectOptions, {
      getDisplayName,
      methodName,
      renderCountProp,
      shouldHandleStateChanges,
      storeKey,
      displayName,
      wrappedComponentName,
      WrappedComponent
    });
    var pure = connectOptions.pure;
    function createChildSelector(store) {
      return selectorFactory(store.dispatch, selectorFactoryOptions);
    }
    var usePureOnlyMemo = pure ? reactExports.useMemo : function(callback) {
      return callback();
    };
    function ConnectFunction(props) {
      var _useMemo = reactExports.useMemo(function() {
        var reactReduxForwardedRef2 = props.reactReduxForwardedRef, wrapperProps2 = _objectWithoutPropertiesLoose(props, _excluded2);
        return [props.context, reactReduxForwardedRef2, wrapperProps2];
      }, [props]), propsContext = _useMemo[0], reactReduxForwardedRef = _useMemo[1], wrapperProps = _useMemo[2];
      var ContextToUse = reactExports.useMemo(function() {
        return propsContext && propsContext.Consumer && reactIsExports.isContextConsumer(/* @__PURE__ */ React.createElement(propsContext.Consumer, null)) ? propsContext : Context;
      }, [propsContext, Context]);
      var contextValue = reactExports.useContext(ContextToUse);
      var didStoreComeFromProps = Boolean(props.store) && Boolean(props.store.getState) && Boolean(props.store.dispatch);
      Boolean(contextValue) && Boolean(contextValue.store);
      var store = didStoreComeFromProps ? props.store : contextValue.store;
      var childPropsSelector = reactExports.useMemo(function() {
        return createChildSelector(store);
      }, [store]);
      var _useMemo2 = reactExports.useMemo(function() {
        if (!shouldHandleStateChanges)
          return NO_SUBSCRIPTION_ARRAY;
        var subscription2 = createSubscription(store, didStoreComeFromProps ? null : contextValue.subscription);
        var notifyNestedSubs2 = subscription2.notifyNestedSubs.bind(subscription2);
        return [subscription2, notifyNestedSubs2];
      }, [store, didStoreComeFromProps, contextValue]), subscription = _useMemo2[0], notifyNestedSubs = _useMemo2[1];
      var overriddenContextValue = reactExports.useMemo(function() {
        if (didStoreComeFromProps) {
          return contextValue;
        }
        return _extends({}, contextValue, {
          subscription
        });
      }, [didStoreComeFromProps, contextValue, subscription]);
      var _useReducer = reactExports.useReducer(storeStateUpdatesReducer, EMPTY_ARRAY, initStateUpdates), _useReducer$ = _useReducer[0], previousStateUpdateResult = _useReducer$[0], forceComponentUpdateDispatch = _useReducer[1];
      if (previousStateUpdateResult && previousStateUpdateResult.error) {
        throw previousStateUpdateResult.error;
      }
      var lastChildProps = reactExports.useRef();
      var lastWrapperProps = reactExports.useRef(wrapperProps);
      var childPropsFromStoreUpdate = reactExports.useRef();
      var renderIsScheduled = reactExports.useRef(false);
      var actualChildProps = usePureOnlyMemo(function() {
        if (childPropsFromStoreUpdate.current && wrapperProps === lastWrapperProps.current) {
          return childPropsFromStoreUpdate.current;
        }
        return childPropsSelector(store.getState(), wrapperProps);
      }, [store, previousStateUpdateResult, wrapperProps]);
      useIsomorphicLayoutEffectWithArgs(captureWrapperProps, [lastWrapperProps, lastChildProps, renderIsScheduled, wrapperProps, actualChildProps, childPropsFromStoreUpdate, notifyNestedSubs]);
      useIsomorphicLayoutEffectWithArgs(subscribeUpdates, [shouldHandleStateChanges, store, subscription, childPropsSelector, lastWrapperProps, lastChildProps, renderIsScheduled, childPropsFromStoreUpdate, notifyNestedSubs, forceComponentUpdateDispatch], [store, subscription, childPropsSelector]);
      var renderedWrappedComponent = reactExports.useMemo(function() {
        return /* @__PURE__ */ React.createElement(WrappedComponent, _extends({}, actualChildProps, {
          ref: reactReduxForwardedRef
        }));
      }, [reactReduxForwardedRef, WrappedComponent, actualChildProps]);
      var renderedChild = reactExports.useMemo(function() {
        if (shouldHandleStateChanges) {
          return /* @__PURE__ */ React.createElement(ContextToUse.Provider, {
            value: overriddenContextValue
          }, renderedWrappedComponent);
        }
        return renderedWrappedComponent;
      }, [ContextToUse, renderedWrappedComponent, overriddenContextValue]);
      return renderedChild;
    }
    var Connect = pure ? React.memo(ConnectFunction) : ConnectFunction;
    Connect.WrappedComponent = WrappedComponent;
    Connect.displayName = ConnectFunction.displayName = displayName;
    if (forwardRef) {
      var forwarded = React.forwardRef(function forwardConnectRef(props, ref) {
        return /* @__PURE__ */ React.createElement(Connect, _extends({}, props, {
          reactReduxForwardedRef: ref
        }));
      });
      forwarded.displayName = displayName;
      forwarded.WrappedComponent = WrappedComponent;
      return hoistStatics(forwarded, WrappedComponent);
    }
    return hoistStatics(Connect, WrappedComponent);
  };
}
function is(x, y2) {
  if (x === y2) {
    return x !== 0 || y2 !== 0 || 1 / x === 1 / y2;
  } else {
    return x !== x && y2 !== y2;
  }
}
function shallowEqual(objA, objB) {
  if (is(objA, objB))
    return true;
  if (typeof objA !== "object" || objA === null || typeof objB !== "object" || objB === null) {
    return false;
  }
  var keysA = Object.keys(objA);
  var keysB = Object.keys(objB);
  if (keysA.length !== keysB.length)
    return false;
  for (var i2 = 0; i2 < keysA.length; i2++) {
    if (!Object.prototype.hasOwnProperty.call(objB, keysA[i2]) || !is(objA[keysA[i2]], objB[keysA[i2]])) {
      return false;
    }
  }
  return true;
}
function bindActionCreators(actionCreators, dispatch) {
  var boundActionCreators = {};
  var _loop = function _loop2(key2) {
    var actionCreator = actionCreators[key2];
    if (typeof actionCreator === "function") {
      boundActionCreators[key2] = function() {
        return dispatch(actionCreator.apply(void 0, arguments));
      };
    }
  };
  for (var key in actionCreators) {
    _loop(key);
  }
  return boundActionCreators;
}
function wrapMapToPropsConstant(getConstant) {
  return function initConstantSelector(dispatch, options) {
    var constant = getConstant(dispatch, options);
    function constantSelector2() {
      return constant;
    }
    constantSelector2.dependsOnOwnProps = false;
    return constantSelector2;
  };
}
function getDependsOnOwnProps(mapToProps) {
  return mapToProps.dependsOnOwnProps !== null && mapToProps.dependsOnOwnProps !== void 0 ? Boolean(mapToProps.dependsOnOwnProps) : mapToProps.length !== 1;
}
function wrapMapToPropsFunc(mapToProps, methodName) {
  return function initProxySelector(dispatch, _ref) {
    _ref.displayName;
    var proxy = function mapToPropsProxy(stateOrDispatch, ownProps) {
      return proxy.dependsOnOwnProps ? proxy.mapToProps(stateOrDispatch, ownProps) : proxy.mapToProps(stateOrDispatch);
    };
    proxy.dependsOnOwnProps = true;
    proxy.mapToProps = function detectFactoryAndVerify(stateOrDispatch, ownProps) {
      proxy.mapToProps = mapToProps;
      proxy.dependsOnOwnProps = getDependsOnOwnProps(mapToProps);
      var props = proxy(stateOrDispatch, ownProps);
      if (typeof props === "function") {
        proxy.mapToProps = props;
        proxy.dependsOnOwnProps = getDependsOnOwnProps(props);
        props = proxy(stateOrDispatch, ownProps);
      }
      return props;
    };
    return proxy;
  };
}
function whenMapDispatchToPropsIsFunction(mapDispatchToProps2) {
  return typeof mapDispatchToProps2 === "function" ? wrapMapToPropsFunc(mapDispatchToProps2) : void 0;
}
function whenMapDispatchToPropsIsMissing(mapDispatchToProps2) {
  return !mapDispatchToProps2 ? wrapMapToPropsConstant(function(dispatch) {
    return {
      dispatch
    };
  }) : void 0;
}
function whenMapDispatchToPropsIsObject(mapDispatchToProps2) {
  return mapDispatchToProps2 && typeof mapDispatchToProps2 === "object" ? wrapMapToPropsConstant(function(dispatch) {
    return bindActionCreators(mapDispatchToProps2, dispatch);
  }) : void 0;
}
const defaultMapDispatchToPropsFactories = [whenMapDispatchToPropsIsFunction, whenMapDispatchToPropsIsMissing, whenMapDispatchToPropsIsObject];
function whenMapStateToPropsIsFunction(mapStateToProps) {
  return typeof mapStateToProps === "function" ? wrapMapToPropsFunc(mapStateToProps) : void 0;
}
function whenMapStateToPropsIsMissing(mapStateToProps) {
  return !mapStateToProps ? wrapMapToPropsConstant(function() {
    return {};
  }) : void 0;
}
const defaultMapStateToPropsFactories = [whenMapStateToPropsIsFunction, whenMapStateToPropsIsMissing];
function defaultMergeProps(stateProps, dispatchProps, ownProps) {
  return _extends({}, ownProps, stateProps, dispatchProps);
}
function wrapMergePropsFunc(mergeProps2) {
  return function initMergePropsProxy(dispatch, _ref) {
    _ref.displayName;
    var pure = _ref.pure, areMergedPropsEqual = _ref.areMergedPropsEqual;
    var hasRunOnce = false;
    var mergedProps;
    return function mergePropsProxy(stateProps, dispatchProps, ownProps) {
      var nextMergedProps = mergeProps2(stateProps, dispatchProps, ownProps);
      if (hasRunOnce) {
        if (!pure || !areMergedPropsEqual(nextMergedProps, mergedProps))
          mergedProps = nextMergedProps;
      } else {
        hasRunOnce = true;
        mergedProps = nextMergedProps;
      }
      return mergedProps;
    };
  };
}
function whenMergePropsIsFunction(mergeProps2) {
  return typeof mergeProps2 === "function" ? wrapMergePropsFunc(mergeProps2) : void 0;
}
function whenMergePropsIsOmitted(mergeProps2) {
  return !mergeProps2 ? function() {
    return defaultMergeProps;
  } : void 0;
}
const defaultMergePropsFactories = [whenMergePropsIsFunction, whenMergePropsIsOmitted];
var _excluded$1 = ["initMapStateToProps", "initMapDispatchToProps", "initMergeProps"];
function impureFinalPropsSelectorFactory(mapStateToProps, mapDispatchToProps2, mergeProps2, dispatch) {
  return function impureFinalPropsSelector(state, ownProps) {
    return mergeProps2(mapStateToProps(state, ownProps), mapDispatchToProps2(dispatch, ownProps), ownProps);
  };
}
function pureFinalPropsSelectorFactory(mapStateToProps, mapDispatchToProps2, mergeProps2, dispatch, _ref) {
  var areStatesEqual = _ref.areStatesEqual, areOwnPropsEqual = _ref.areOwnPropsEqual, areStatePropsEqual = _ref.areStatePropsEqual;
  var hasRunAtLeastOnce = false;
  var state;
  var ownProps;
  var stateProps;
  var dispatchProps;
  var mergedProps;
  function handleFirstCall(firstState, firstOwnProps) {
    state = firstState;
    ownProps = firstOwnProps;
    stateProps = mapStateToProps(state, ownProps);
    dispatchProps = mapDispatchToProps2(dispatch, ownProps);
    mergedProps = mergeProps2(stateProps, dispatchProps, ownProps);
    hasRunAtLeastOnce = true;
    return mergedProps;
  }
  function handleNewPropsAndNewState() {
    stateProps = mapStateToProps(state, ownProps);
    if (mapDispatchToProps2.dependsOnOwnProps)
      dispatchProps = mapDispatchToProps2(dispatch, ownProps);
    mergedProps = mergeProps2(stateProps, dispatchProps, ownProps);
    return mergedProps;
  }
  function handleNewProps() {
    if (mapStateToProps.dependsOnOwnProps)
      stateProps = mapStateToProps(state, ownProps);
    if (mapDispatchToProps2.dependsOnOwnProps)
      dispatchProps = mapDispatchToProps2(dispatch, ownProps);
    mergedProps = mergeProps2(stateProps, dispatchProps, ownProps);
    return mergedProps;
  }
  function handleNewState() {
    var nextStateProps = mapStateToProps(state, ownProps);
    var statePropsChanged = !areStatePropsEqual(nextStateProps, stateProps);
    stateProps = nextStateProps;
    if (statePropsChanged)
      mergedProps = mergeProps2(stateProps, dispatchProps, ownProps);
    return mergedProps;
  }
  function handleSubsequentCalls(nextState, nextOwnProps) {
    var propsChanged = !areOwnPropsEqual(nextOwnProps, ownProps);
    var stateChanged = !areStatesEqual(nextState, state, nextOwnProps, ownProps);
    state = nextState;
    ownProps = nextOwnProps;
    if (propsChanged && stateChanged)
      return handleNewPropsAndNewState();
    if (propsChanged)
      return handleNewProps();
    if (stateChanged)
      return handleNewState();
    return mergedProps;
  }
  return function pureFinalPropsSelector(nextState, nextOwnProps) {
    return hasRunAtLeastOnce ? handleSubsequentCalls(nextState, nextOwnProps) : handleFirstCall(nextState, nextOwnProps);
  };
}
function finalPropsSelectorFactory(dispatch, _ref2) {
  var initMapStateToProps = _ref2.initMapStateToProps, initMapDispatchToProps = _ref2.initMapDispatchToProps, initMergeProps = _ref2.initMergeProps, options = _objectWithoutPropertiesLoose(_ref2, _excluded$1);
  var mapStateToProps = initMapStateToProps(dispatch, options);
  var mapDispatchToProps2 = initMapDispatchToProps(dispatch, options);
  var mergeProps2 = initMergeProps(dispatch, options);
  var selectorFactory = options.pure ? pureFinalPropsSelectorFactory : impureFinalPropsSelectorFactory;
  return selectorFactory(mapStateToProps, mapDispatchToProps2, mergeProps2, dispatch, options);
}
var _excluded = ["pure", "areStatesEqual", "areOwnPropsEqual", "areStatePropsEqual", "areMergedPropsEqual"];
function match(arg, factories, name) {
  for (var i2 = factories.length - 1; i2 >= 0; i2--) {
    var result = factories[i2](arg);
    if (result)
      return result;
  }
  return function(dispatch, options) {
    throw new Error("Invalid value of type " + typeof arg + " for " + name + " argument when connecting component " + options.wrappedComponentName + ".");
  };
}
function strictEqual(a2, b2) {
  return a2 === b2;
}
function createConnect(_temp) {
  var _ref = _temp === void 0 ? {} : _temp, _ref$connectHOC = _ref.connectHOC, connectHOC = _ref$connectHOC === void 0 ? connectAdvanced : _ref$connectHOC, _ref$mapStateToPropsF = _ref.mapStateToPropsFactories, mapStateToPropsFactories = _ref$mapStateToPropsF === void 0 ? defaultMapStateToPropsFactories : _ref$mapStateToPropsF, _ref$mapDispatchToPro = _ref.mapDispatchToPropsFactories, mapDispatchToPropsFactories = _ref$mapDispatchToPro === void 0 ? defaultMapDispatchToPropsFactories : _ref$mapDispatchToPro, _ref$mergePropsFactor = _ref.mergePropsFactories, mergePropsFactories = _ref$mergePropsFactor === void 0 ? defaultMergePropsFactories : _ref$mergePropsFactor, _ref$selectorFactory = _ref.selectorFactory, selectorFactory = _ref$selectorFactory === void 0 ? finalPropsSelectorFactory : _ref$selectorFactory;
  return function connect2(mapStateToProps, mapDispatchToProps2, mergeProps2, _ref2) {
    if (_ref2 === void 0) {
      _ref2 = {};
    }
    var _ref3 = _ref2, _ref3$pure = _ref3.pure, pure = _ref3$pure === void 0 ? true : _ref3$pure, _ref3$areStatesEqual = _ref3.areStatesEqual, areStatesEqual = _ref3$areStatesEqual === void 0 ? strictEqual : _ref3$areStatesEqual, _ref3$areOwnPropsEqua = _ref3.areOwnPropsEqual, areOwnPropsEqual = _ref3$areOwnPropsEqua === void 0 ? shallowEqual : _ref3$areOwnPropsEqua, _ref3$areStatePropsEq = _ref3.areStatePropsEqual, areStatePropsEqual = _ref3$areStatePropsEq === void 0 ? shallowEqual : _ref3$areStatePropsEq, _ref3$areMergedPropsE = _ref3.areMergedPropsEqual, areMergedPropsEqual = _ref3$areMergedPropsE === void 0 ? shallowEqual : _ref3$areMergedPropsE, extraOptions = _objectWithoutPropertiesLoose(_ref3, _excluded);
    var initMapStateToProps = match(mapStateToProps, mapStateToPropsFactories, "mapStateToProps");
    var initMapDispatchToProps = match(mapDispatchToProps2, mapDispatchToPropsFactories, "mapDispatchToProps");
    var initMergeProps = match(mergeProps2, mergePropsFactories, "mergeProps");
    return connectHOC(selectorFactory, _extends({
      // used in error messages
      methodName: "connect",
      // used to compute Connect's displayName from the wrapped component's displayName.
      getDisplayName: function getDisplayName(name) {
        return "Connect(" + name + ")";
      },
      // if mapStateToProps is falsy, the Connect component doesn't subscribe to store state changes
      shouldHandleStateChanges: Boolean(mapStateToProps),
      // passed through to selectorFactory
      initMapStateToProps,
      initMapDispatchToProps,
      initMergeProps,
      pure,
      areStatesEqual,
      areOwnPropsEqual,
      areStatePropsEqual,
      areMergedPropsEqual
    }, extraOptions));
  };
}
const connect = /* @__PURE__ */ createConnect();
setBatch(reactDomExports.unstable_batchedUpdates);
function areInputsEqual$1(newInputs, lastInputs) {
  if (newInputs.length !== lastInputs.length) {
    return false;
  }
  for (var i2 = 0; i2 < newInputs.length; i2++) {
    if (newInputs[i2] !== lastInputs[i2]) {
      return false;
    }
  }
  return true;
}
function useMemoOne(getResult, inputs) {
  var initial = reactExports.useState(function() {
    return {
      inputs,
      result: getResult()
    };
  })[0];
  var isFirstRun = reactExports.useRef(true);
  var committed = reactExports.useRef(initial);
  var useCache = isFirstRun.current || Boolean(inputs && committed.current.inputs && areInputsEqual$1(inputs, committed.current.inputs));
  var cache = useCache ? committed.current : {
    inputs,
    result: getResult()
  };
  reactExports.useEffect(function() {
    isFirstRun.current = false;
    committed.current = cache;
  }, [cache]);
  return cache.result;
}
function useCallbackOne(callback, inputs) {
  return useMemoOne(function() {
    return callback;
  }, inputs);
}
var useMemo = useMemoOne;
var useCallback = useCallbackOne;
var isProduction = true;
var prefix$2 = "Invariant failed";
function invariant$1(condition, message) {
  if (condition) {
    return;
  }
  if (isProduction) {
    throw new Error(prefix$2);
  }
  var provided = typeof message === "function" ? message() : message;
  var value = provided ? "".concat(prefix$2, ": ").concat(provided) : prefix$2;
  throw new Error(value);
}
var getRect = function getRect2(_ref) {
  var top = _ref.top, right = _ref.right, bottom = _ref.bottom, left = _ref.left;
  var width = right - left;
  var height = bottom - top;
  var rect = {
    top,
    right,
    bottom,
    left,
    width,
    height,
    x: left,
    y: top,
    center: {
      x: (right + left) / 2,
      y: (bottom + top) / 2
    }
  };
  return rect;
};
var expand = function expand2(target, expandBy) {
  return {
    top: target.top - expandBy.top,
    left: target.left - expandBy.left,
    bottom: target.bottom + expandBy.bottom,
    right: target.right + expandBy.right
  };
};
var shrink = function shrink2(target, shrinkBy) {
  return {
    top: target.top + shrinkBy.top,
    left: target.left + shrinkBy.left,
    bottom: target.bottom - shrinkBy.bottom,
    right: target.right - shrinkBy.right
  };
};
var shift = function shift2(target, shiftBy) {
  return {
    top: target.top + shiftBy.y,
    left: target.left + shiftBy.x,
    bottom: target.bottom + shiftBy.y,
    right: target.right + shiftBy.x
  };
};
var noSpacing$1 = {
  top: 0,
  right: 0,
  bottom: 0,
  left: 0
};
var createBox = function createBox2(_ref2) {
  var borderBox = _ref2.borderBox, _ref2$margin = _ref2.margin, margin = _ref2$margin === void 0 ? noSpacing$1 : _ref2$margin, _ref2$border = _ref2.border, border = _ref2$border === void 0 ? noSpacing$1 : _ref2$border, _ref2$padding = _ref2.padding, padding = _ref2$padding === void 0 ? noSpacing$1 : _ref2$padding;
  var marginBox = getRect(expand(borderBox, margin));
  var paddingBox = getRect(shrink(borderBox, border));
  var contentBox = getRect(shrink(paddingBox, padding));
  return {
    marginBox,
    borderBox: getRect(borderBox),
    paddingBox,
    contentBox,
    margin,
    border,
    padding
  };
};
var parse = function parse2(raw) {
  var value = raw.slice(0, -2);
  var suffix = raw.slice(-2);
  if (suffix !== "px") {
    return 0;
  }
  var result = Number(value);
  !!isNaN(result) ? invariant$1(false) : void 0;
  return result;
};
var getWindowScroll$1 = function getWindowScroll() {
  return {
    x: window.pageXOffset,
    y: window.pageYOffset
  };
};
var offset = function offset2(original, change) {
  var borderBox = original.borderBox, border = original.border, margin = original.margin, padding = original.padding;
  var shifted = shift(borderBox, change);
  return createBox({
    borderBox: shifted,
    border,
    margin,
    padding
  });
};
var withScroll = function withScroll2(original, scroll3) {
  if (scroll3 === void 0) {
    scroll3 = getWindowScroll$1();
  }
  return offset(original, scroll3);
};
var calculateBox = function calculateBox2(borderBox, styles) {
  var margin = {
    top: parse(styles.marginTop),
    right: parse(styles.marginRight),
    bottom: parse(styles.marginBottom),
    left: parse(styles.marginLeft)
  };
  var padding = {
    top: parse(styles.paddingTop),
    right: parse(styles.paddingRight),
    bottom: parse(styles.paddingBottom),
    left: parse(styles.paddingLeft)
  };
  var border = {
    top: parse(styles.borderTopWidth),
    right: parse(styles.borderRightWidth),
    bottom: parse(styles.borderBottomWidth),
    left: parse(styles.borderLeftWidth)
  };
  return createBox({
    borderBox,
    margin,
    padding,
    border
  });
};
var getBox = function getBox2(el2) {
  var borderBox = el2.getBoundingClientRect();
  var styles = window.getComputedStyle(el2);
  return calculateBox(borderBox, styles);
};
var safeIsNaN = Number.isNaN || function ponyfill(value) {
  return typeof value === "number" && value !== value;
};
function isEqual$2(first, second) {
  if (first === second) {
    return true;
  }
  if (safeIsNaN(first) && safeIsNaN(second)) {
    return true;
  }
  return false;
}
function areInputsEqual(newInputs, lastInputs) {
  if (newInputs.length !== lastInputs.length) {
    return false;
  }
  for (var i2 = 0; i2 < newInputs.length; i2++) {
    if (!isEqual$2(newInputs[i2], lastInputs[i2])) {
      return false;
    }
  }
  return true;
}
function memoizeOne(resultFn, isEqual4) {
  if (isEqual4 === void 0) {
    isEqual4 = areInputsEqual;
  }
  var lastThis;
  var lastArgs = [];
  var lastResult;
  var calledOnce = false;
  function memoized() {
    var newArgs = [];
    for (var _i2 = 0; _i2 < arguments.length; _i2++) {
      newArgs[_i2] = arguments[_i2];
    }
    if (calledOnce && lastThis === this && isEqual4(newArgs, lastArgs)) {
      return lastResult;
    }
    lastResult = resultFn.apply(this, newArgs);
    calledOnce = true;
    lastThis = this;
    lastArgs = newArgs;
    return lastResult;
  }
  return memoized;
}
var rafSchd = function rafSchd2(fn2) {
  var lastArgs = [];
  var frameId = null;
  var wrapperFn = function wrapperFn2() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    lastArgs = args;
    if (frameId) {
      return;
    }
    frameId = requestAnimationFrame(function() {
      frameId = null;
      fn2.apply(void 0, lastArgs);
    });
  };
  wrapperFn.cancel = function() {
    if (!frameId) {
      return;
    }
    cancelAnimationFrame(frameId);
    frameId = null;
  };
  return wrapperFn;
};
const rafSchd$1 = rafSchd;
function log(type, message) {
  {
    return;
  }
}
log.bind(null, "warn");
log.bind(null, "error");
function noop() {
}
function getOptions(shared, fromBinding) {
  return _extends({}, shared, {}, fromBinding);
}
function bindEvents(el2, bindings, sharedOptions) {
  var unbindings = bindings.map(function(binding) {
    var options = getOptions(sharedOptions, binding.options);
    el2.addEventListener(binding.eventName, binding.fn, options);
    return function unbind() {
      el2.removeEventListener(binding.eventName, binding.fn, options);
    };
  });
  return function unbindAll() {
    unbindings.forEach(function(unbind) {
      unbind();
    });
  };
}
var prefix = "Invariant failed";
function RbdInvariant(message) {
  this.message = message;
}
RbdInvariant.prototype.toString = function toString() {
  return this.message;
};
function invariant(condition, message) {
  if (condition) {
    return;
  }
  {
    throw new RbdInvariant(prefix);
  }
}
var ErrorBoundary = function(_React$Component) {
  _inheritsLoose(ErrorBoundary2, _React$Component);
  function ErrorBoundary2() {
    var _this;
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _React$Component.call.apply(_React$Component, [this].concat(args)) || this;
    _this.callbacks = null;
    _this.unbind = noop;
    _this.onWindowError = function(event) {
      var callbacks = _this.getCallbacks();
      if (callbacks.isDragging()) {
        callbacks.tryAbort();
      }
      var err2 = event.error;
      if (err2 instanceof RbdInvariant) {
        event.preventDefault();
      }
    };
    _this.getCallbacks = function() {
      if (!_this.callbacks) {
        throw new Error("Unable to find AppCallbacks in <ErrorBoundary/>");
      }
      return _this.callbacks;
    };
    _this.setCallbacks = function(callbacks) {
      _this.callbacks = callbacks;
    };
    return _this;
  }
  var _proto = ErrorBoundary2.prototype;
  _proto.componentDidMount = function componentDidMount() {
    this.unbind = bindEvents(window, [{
      eventName: "error",
      fn: this.onWindowError
    }]);
  };
  _proto.componentDidCatch = function componentDidCatch(err2) {
    if (err2 instanceof RbdInvariant) {
      this.setState({});
      return;
    }
    throw err2;
  };
  _proto.componentWillUnmount = function componentWillUnmount() {
    this.unbind();
  };
  _proto.render = function render() {
    return this.props.children(this.setCallbacks);
  };
  return ErrorBoundary2;
}(React.Component);
var dragHandleUsageInstructions = "\n  Press space bar to start a drag.\n  When dragging you can use the arrow keys to move the item around and escape to cancel.\n  Some screen readers may require you to be in focus mode or to use your pass through key\n";
var position = function position2(index2) {
  return index2 + 1;
};
var onDragStart = function onDragStart2(start) {
  return "\n  You have lifted an item in position " + position(start.source.index) + "\n";
};
var withLocation = function withLocation2(source, destination) {
  var isInHomeList = source.droppableId === destination.droppableId;
  var startPosition = position(source.index);
  var endPosition = position(destination.index);
  if (isInHomeList) {
    return "\n      You have moved the item from position " + startPosition + "\n      to position " + endPosition + "\n    ";
  }
  return "\n    You have moved the item from position " + startPosition + "\n    in list " + source.droppableId + "\n    to list " + destination.droppableId + "\n    in position " + endPosition + "\n  ";
};
var withCombine = function withCombine2(id2, source, combine2) {
  var inHomeList = source.droppableId === combine2.droppableId;
  if (inHomeList) {
    return "\n      The item " + id2 + "\n      has been combined with " + combine2.draggableId;
  }
  return "\n      The item " + id2 + "\n      in list " + source.droppableId + "\n      has been combined with " + combine2.draggableId + "\n      in list " + combine2.droppableId + "\n    ";
};
var onDragUpdate = function onDragUpdate2(update2) {
  var location2 = update2.destination;
  if (location2) {
    return withLocation(update2.source, location2);
  }
  var combine2 = update2.combine;
  if (combine2) {
    return withCombine(update2.draggableId, update2.source, combine2);
  }
  return "You are over an area that cannot be dropped on";
};
var returnedToStart = function returnedToStart2(source) {
  return "\n  The item has returned to its starting position\n  of " + position(source.index) + "\n";
};
var onDragEnd = function onDragEnd2(result) {
  if (result.reason === "CANCEL") {
    return "\n      Movement cancelled.\n      " + returnedToStart(result.source) + "\n    ";
  }
  var location2 = result.destination;
  var combine2 = result.combine;
  if (location2) {
    return "\n      You have dropped the item.\n      " + withLocation(result.source, location2) + "\n    ";
  }
  if (combine2) {
    return "\n      You have dropped the item.\n      " + withCombine(result.draggableId, result.source, combine2) + "\n    ";
  }
  return "\n    The item has been dropped while not over a drop area.\n    " + returnedToStart(result.source) + "\n  ";
};
var preset = {
  dragHandleUsageInstructions,
  onDragStart,
  onDragUpdate,
  onDragEnd
};
var origin = {
  x: 0,
  y: 0
};
var add = function add2(point1, point2) {
  return {
    x: point1.x + point2.x,
    y: point1.y + point2.y
  };
};
var subtract = function subtract2(point1, point2) {
  return {
    x: point1.x - point2.x,
    y: point1.y - point2.y
  };
};
var isEqual = function isEqual2(point1, point2) {
  return point1.x === point2.x && point1.y === point2.y;
};
var negate = function negate2(point) {
  return {
    x: point.x !== 0 ? -point.x : 0,
    y: point.y !== 0 ? -point.y : 0
  };
};
var patch = function patch2(line, value, otherValue) {
  var _ref;
  if (otherValue === void 0) {
    otherValue = 0;
  }
  return _ref = {}, _ref[line] = value, _ref[line === "x" ? "y" : "x"] = otherValue, _ref;
};
var distance = function distance2(point1, point2) {
  return Math.sqrt(Math.pow(point2.x - point1.x, 2) + Math.pow(point2.y - point1.y, 2));
};
var closest = function closest2(target, points) {
  return Math.min.apply(Math, points.map(function(point) {
    return distance(target, point);
  }));
};
var apply = function apply2(fn2) {
  return function(point) {
    return {
      x: fn2(point.x),
      y: fn2(point.y)
    };
  };
};
var executeClip = function(frame, subject) {
  var result = getRect({
    top: Math.max(subject.top, frame.top),
    right: Math.min(subject.right, frame.right),
    bottom: Math.min(subject.bottom, frame.bottom),
    left: Math.max(subject.left, frame.left)
  });
  if (result.width <= 0 || result.height <= 0) {
    return null;
  }
  return result;
};
var offsetByPosition = function offsetByPosition2(spacing, point) {
  return {
    top: spacing.top + point.y,
    left: spacing.left + point.x,
    bottom: spacing.bottom + point.y,
    right: spacing.right + point.x
  };
};
var getCorners = function getCorners2(spacing) {
  return [{
    x: spacing.left,
    y: spacing.top
  }, {
    x: spacing.right,
    y: spacing.top
  }, {
    x: spacing.left,
    y: spacing.bottom
  }, {
    x: spacing.right,
    y: spacing.bottom
  }];
};
var noSpacing = {
  top: 0,
  right: 0,
  bottom: 0,
  left: 0
};
var scroll = function scroll2(target, frame) {
  if (!frame) {
    return target;
  }
  return offsetByPosition(target, frame.scroll.diff.displacement);
};
var increase = function increase2(target, axis, withPlaceholder) {
  if (withPlaceholder && withPlaceholder.increasedBy) {
    var _extends2;
    return _extends({}, target, (_extends2 = {}, _extends2[axis.end] = target[axis.end] + withPlaceholder.increasedBy[axis.line], _extends2));
  }
  return target;
};
var clip = function clip2(target, frame) {
  if (frame && frame.shouldClipSubject) {
    return executeClip(frame.pageMarginBox, target);
  }
  return getRect(target);
};
var getSubject = function(_ref) {
  var page = _ref.page, withPlaceholder = _ref.withPlaceholder, axis = _ref.axis, frame = _ref.frame;
  var scrolled = scroll(page.marginBox, frame);
  var increased = increase(scrolled, axis, withPlaceholder);
  var clipped = clip(increased, frame);
  return {
    page,
    withPlaceholder,
    active: clipped
  };
};
var scrollDroppable = function(droppable2, newScroll) {
  !droppable2.frame ? invariant(false) : void 0;
  var scrollable = droppable2.frame;
  var scrollDiff = subtract(newScroll, scrollable.scroll.initial);
  var scrollDisplacement = negate(scrollDiff);
  var frame = _extends({}, scrollable, {
    scroll: {
      initial: scrollable.scroll.initial,
      current: newScroll,
      diff: {
        value: scrollDiff,
        displacement: scrollDisplacement
      },
      max: scrollable.scroll.max
    }
  });
  var subject = getSubject({
    page: droppable2.subject.page,
    withPlaceholder: droppable2.subject.withPlaceholder,
    axis: droppable2.axis,
    frame
  });
  var result = _extends({}, droppable2, {
    frame,
    subject
  });
  return result;
};
function values(map) {
  if (Object.values) {
    return Object.values(map);
  }
  return Object.keys(map).map(function(key) {
    return map[key];
  });
}
function findIndex(list, predicate) {
  if (list.findIndex) {
    return list.findIndex(predicate);
  }
  for (var i2 = 0; i2 < list.length; i2++) {
    if (predicate(list[i2])) {
      return i2;
    }
  }
  return -1;
}
function find(list, predicate) {
  if (list.find) {
    return list.find(predicate);
  }
  var index2 = findIndex(list, predicate);
  if (index2 !== -1) {
    return list[index2];
  }
  return void 0;
}
function toArray(list) {
  return Array.prototype.slice.call(list);
}
var toDroppableMap = memoizeOne(function(droppables) {
  return droppables.reduce(function(previous, current) {
    previous[current.descriptor.id] = current;
    return previous;
  }, {});
});
var toDraggableMap = memoizeOne(function(draggables) {
  return draggables.reduce(function(previous, current) {
    previous[current.descriptor.id] = current;
    return previous;
  }, {});
});
var toDroppableList = memoizeOne(function(droppables) {
  return values(droppables);
});
var toDraggableList = memoizeOne(function(draggables) {
  return values(draggables);
});
var getDraggablesInsideDroppable = memoizeOne(function(droppableId, draggables) {
  var result = toDraggableList(draggables).filter(function(draggable2) {
    return droppableId === draggable2.descriptor.droppableId;
  }).sort(function(a2, b2) {
    return a2.descriptor.index - b2.descriptor.index;
  });
  return result;
});
function tryGetDestination(impact) {
  if (impact.at && impact.at.type === "REORDER") {
    return impact.at.destination;
  }
  return null;
}
function tryGetCombine(impact) {
  if (impact.at && impact.at.type === "COMBINE") {
    return impact.at.combine;
  }
  return null;
}
var removeDraggableFromList = memoizeOne(function(remove, list) {
  return list.filter(function(item) {
    return item.descriptor.id !== remove.descriptor.id;
  });
});
var moveToNextCombine = function(_ref) {
  var isMovingForward = _ref.isMovingForward, draggable2 = _ref.draggable, destination = _ref.destination, insideDestination = _ref.insideDestination, previousImpact = _ref.previousImpact;
  if (!destination.isCombineEnabled) {
    return null;
  }
  var location2 = tryGetDestination(previousImpact);
  if (!location2) {
    return null;
  }
  function getImpact(target) {
    var at2 = {
      type: "COMBINE",
      combine: {
        draggableId: target,
        droppableId: destination.descriptor.id
      }
    };
    return _extends({}, previousImpact, {
      at: at2
    });
  }
  var all = previousImpact.displaced.all;
  var closestId = all.length ? all[0] : null;
  if (isMovingForward) {
    return closestId ? getImpact(closestId) : null;
  }
  var withoutDraggable = removeDraggableFromList(draggable2, insideDestination);
  if (!closestId) {
    if (!withoutDraggable.length) {
      return null;
    }
    var last = withoutDraggable[withoutDraggable.length - 1];
    return getImpact(last.descriptor.id);
  }
  var indexOfClosest = findIndex(withoutDraggable, function(d2) {
    return d2.descriptor.id === closestId;
  });
  !(indexOfClosest !== -1) ? invariant(false) : void 0;
  var proposedIndex = indexOfClosest - 1;
  if (proposedIndex < 0) {
    return null;
  }
  var before = withoutDraggable[proposedIndex];
  return getImpact(before.descriptor.id);
};
var isHomeOf = function(draggable2, destination) {
  return draggable2.descriptor.droppableId === destination.descriptor.id;
};
var noDisplacedBy = {
  point: origin,
  value: 0
};
var emptyGroups = {
  invisible: {},
  visible: {},
  all: []
};
var noImpact = {
  displaced: emptyGroups,
  displacedBy: noDisplacedBy,
  at: null
};
var isWithin = function(lowerBound, upperBound) {
  return function(value) {
    return lowerBound <= value && value <= upperBound;
  };
};
var isPartiallyVisibleThroughFrame = function(frame) {
  var isWithinVertical = isWithin(frame.top, frame.bottom);
  var isWithinHorizontal = isWithin(frame.left, frame.right);
  return function(subject) {
    var isContained = isWithinVertical(subject.top) && isWithinVertical(subject.bottom) && isWithinHorizontal(subject.left) && isWithinHorizontal(subject.right);
    if (isContained) {
      return true;
    }
    var isPartiallyVisibleVertically = isWithinVertical(subject.top) || isWithinVertical(subject.bottom);
    var isPartiallyVisibleHorizontally = isWithinHorizontal(subject.left) || isWithinHorizontal(subject.right);
    var isPartiallyContained = isPartiallyVisibleVertically && isPartiallyVisibleHorizontally;
    if (isPartiallyContained) {
      return true;
    }
    var isBiggerVertically = subject.top < frame.top && subject.bottom > frame.bottom;
    var isBiggerHorizontally = subject.left < frame.left && subject.right > frame.right;
    var isTargetBiggerThanFrame = isBiggerVertically && isBiggerHorizontally;
    if (isTargetBiggerThanFrame) {
      return true;
    }
    var isTargetBiggerOnOneAxis = isBiggerVertically && isPartiallyVisibleHorizontally || isBiggerHorizontally && isPartiallyVisibleVertically;
    return isTargetBiggerOnOneAxis;
  };
};
var isTotallyVisibleThroughFrame = function(frame) {
  var isWithinVertical = isWithin(frame.top, frame.bottom);
  var isWithinHorizontal = isWithin(frame.left, frame.right);
  return function(subject) {
    var isContained = isWithinVertical(subject.top) && isWithinVertical(subject.bottom) && isWithinHorizontal(subject.left) && isWithinHorizontal(subject.right);
    return isContained;
  };
};
var vertical = {
  direction: "vertical",
  line: "y",
  crossAxisLine: "x",
  start: "top",
  end: "bottom",
  size: "height",
  crossAxisStart: "left",
  crossAxisEnd: "right",
  crossAxisSize: "width"
};
var horizontal = {
  direction: "horizontal",
  line: "x",
  crossAxisLine: "y",
  start: "left",
  end: "right",
  size: "width",
  crossAxisStart: "top",
  crossAxisEnd: "bottom",
  crossAxisSize: "height"
};
var isTotallyVisibleThroughFrameOnAxis = function(axis) {
  return function(frame) {
    var isWithinVertical = isWithin(frame.top, frame.bottom);
    var isWithinHorizontal = isWithin(frame.left, frame.right);
    return function(subject) {
      if (axis === vertical) {
        return isWithinVertical(subject.top) && isWithinVertical(subject.bottom);
      }
      return isWithinHorizontal(subject.left) && isWithinHorizontal(subject.right);
    };
  };
};
var getDroppableDisplaced = function getDroppableDisplaced2(target, destination) {
  var displacement = destination.frame ? destination.frame.scroll.diff.displacement : origin;
  return offsetByPosition(target, displacement);
};
var isVisibleInDroppable = function isVisibleInDroppable2(target, destination, isVisibleThroughFrameFn) {
  if (!destination.subject.active) {
    return false;
  }
  return isVisibleThroughFrameFn(destination.subject.active)(target);
};
var isVisibleInViewport = function isVisibleInViewport2(target, viewport, isVisibleThroughFrameFn) {
  return isVisibleThroughFrameFn(viewport)(target);
};
var isVisible = function isVisible2(_ref) {
  var toBeDisplaced = _ref.target, destination = _ref.destination, viewport = _ref.viewport, withDroppableDisplacement2 = _ref.withDroppableDisplacement, isVisibleThroughFrameFn = _ref.isVisibleThroughFrameFn;
  var displacedTarget = withDroppableDisplacement2 ? getDroppableDisplaced(toBeDisplaced, destination) : toBeDisplaced;
  return isVisibleInDroppable(displacedTarget, destination, isVisibleThroughFrameFn) && isVisibleInViewport(displacedTarget, viewport, isVisibleThroughFrameFn);
};
var isPartiallyVisible = function isPartiallyVisible2(args) {
  return isVisible(_extends({}, args, {
    isVisibleThroughFrameFn: isPartiallyVisibleThroughFrame
  }));
};
var isTotallyVisible = function isTotallyVisible2(args) {
  return isVisible(_extends({}, args, {
    isVisibleThroughFrameFn: isTotallyVisibleThroughFrame
  }));
};
var isTotallyVisibleOnAxis = function isTotallyVisibleOnAxis2(args) {
  return isVisible(_extends({}, args, {
    isVisibleThroughFrameFn: isTotallyVisibleThroughFrameOnAxis(args.destination.axis)
  }));
};
var getShouldAnimate = function getShouldAnimate2(id2, last, forceShouldAnimate) {
  if (typeof forceShouldAnimate === "boolean") {
    return forceShouldAnimate;
  }
  if (!last) {
    return true;
  }
  var invisible = last.invisible, visible = last.visible;
  if (invisible[id2]) {
    return false;
  }
  var previous = visible[id2];
  return previous ? previous.shouldAnimate : true;
};
function getTarget(draggable2, displacedBy) {
  var marginBox = draggable2.page.marginBox;
  var expandBy = {
    top: displacedBy.point.y,
    right: 0,
    bottom: 0,
    left: displacedBy.point.x
  };
  return getRect(expand(marginBox, expandBy));
}
function getDisplacementGroups(_ref) {
  var afterDragging = _ref.afterDragging, destination = _ref.destination, displacedBy = _ref.displacedBy, viewport = _ref.viewport, forceShouldAnimate = _ref.forceShouldAnimate, last = _ref.last;
  return afterDragging.reduce(function process2(groups, draggable2) {
    var target = getTarget(draggable2, displacedBy);
    var id2 = draggable2.descriptor.id;
    groups.all.push(id2);
    var isVisible3 = isPartiallyVisible({
      target,
      destination,
      viewport,
      withDroppableDisplacement: true
    });
    if (!isVisible3) {
      groups.invisible[draggable2.descriptor.id] = true;
      return groups;
    }
    var shouldAnimate = getShouldAnimate(id2, last, forceShouldAnimate);
    var displacement = {
      draggableId: id2,
      shouldAnimate
    };
    groups.visible[id2] = displacement;
    return groups;
  }, {
    all: [],
    visible: {},
    invisible: {}
  });
}
function getIndexOfLastItem(draggables, options) {
  if (!draggables.length) {
    return 0;
  }
  var indexOfLastItem = draggables[draggables.length - 1].descriptor.index;
  return options.inHomeList ? indexOfLastItem : indexOfLastItem + 1;
}
function goAtEnd(_ref) {
  var insideDestination = _ref.insideDestination, inHomeList = _ref.inHomeList, displacedBy = _ref.displacedBy, destination = _ref.destination;
  var newIndex = getIndexOfLastItem(insideDestination, {
    inHomeList
  });
  return {
    displaced: emptyGroups,
    displacedBy,
    at: {
      type: "REORDER",
      destination: {
        droppableId: destination.descriptor.id,
        index: newIndex
      }
    }
  };
}
function calculateReorderImpact(_ref2) {
  var draggable2 = _ref2.draggable, insideDestination = _ref2.insideDestination, destination = _ref2.destination, viewport = _ref2.viewport, displacedBy = _ref2.displacedBy, last = _ref2.last, index2 = _ref2.index, forceShouldAnimate = _ref2.forceShouldAnimate;
  var inHomeList = isHomeOf(draggable2, destination);
  if (index2 == null) {
    return goAtEnd({
      insideDestination,
      inHomeList,
      displacedBy,
      destination
    });
  }
  var match2 = find(insideDestination, function(item) {
    return item.descriptor.index === index2;
  });
  if (!match2) {
    return goAtEnd({
      insideDestination,
      inHomeList,
      displacedBy,
      destination
    });
  }
  var withoutDragging = removeDraggableFromList(draggable2, insideDestination);
  var sliceFrom = insideDestination.indexOf(match2);
  var impacted = withoutDragging.slice(sliceFrom);
  var displaced = getDisplacementGroups({
    afterDragging: impacted,
    destination,
    displacedBy,
    last,
    viewport: viewport.frame,
    forceShouldAnimate
  });
  return {
    displaced,
    displacedBy,
    at: {
      type: "REORDER",
      destination: {
        droppableId: destination.descriptor.id,
        index: index2
      }
    }
  };
}
function didStartAfterCritical(draggableId, afterCritical) {
  return Boolean(afterCritical.effected[draggableId]);
}
var fromCombine = function(_ref) {
  var isMovingForward = _ref.isMovingForward, destination = _ref.destination, draggables = _ref.draggables, combine2 = _ref.combine, afterCritical = _ref.afterCritical;
  if (!destination.isCombineEnabled) {
    return null;
  }
  var combineId = combine2.draggableId;
  var combineWith = draggables[combineId];
  var combineWithIndex = combineWith.descriptor.index;
  var didCombineWithStartAfterCritical = didStartAfterCritical(combineId, afterCritical);
  if (didCombineWithStartAfterCritical) {
    if (isMovingForward) {
      return combineWithIndex;
    }
    return combineWithIndex - 1;
  }
  if (isMovingForward) {
    return combineWithIndex + 1;
  }
  return combineWithIndex;
};
var fromReorder = function(_ref) {
  var isMovingForward = _ref.isMovingForward, isInHomeList = _ref.isInHomeList, insideDestination = _ref.insideDestination, location2 = _ref.location;
  if (!insideDestination.length) {
    return null;
  }
  var currentIndex = location2.index;
  var proposedIndex = isMovingForward ? currentIndex + 1 : currentIndex - 1;
  var firstIndex = insideDestination[0].descriptor.index;
  var lastIndex = insideDestination[insideDestination.length - 1].descriptor.index;
  var upperBound = isInHomeList ? lastIndex : lastIndex + 1;
  if (proposedIndex < firstIndex) {
    return null;
  }
  if (proposedIndex > upperBound) {
    return null;
  }
  return proposedIndex;
};
var moveToNextIndex = function(_ref) {
  var isMovingForward = _ref.isMovingForward, isInHomeList = _ref.isInHomeList, draggable2 = _ref.draggable, draggables = _ref.draggables, destination = _ref.destination, insideDestination = _ref.insideDestination, previousImpact = _ref.previousImpact, viewport = _ref.viewport, afterCritical = _ref.afterCritical;
  var wasAt = previousImpact.at;
  !wasAt ? invariant(false) : void 0;
  if (wasAt.type === "REORDER") {
    var _newIndex = fromReorder({
      isMovingForward,
      isInHomeList,
      location: wasAt.destination,
      insideDestination
    });
    if (_newIndex == null) {
      return null;
    }
    return calculateReorderImpact({
      draggable: draggable2,
      insideDestination,
      destination,
      viewport,
      last: previousImpact.displaced,
      displacedBy: previousImpact.displacedBy,
      index: _newIndex
    });
  }
  var newIndex = fromCombine({
    isMovingForward,
    destination,
    displaced: previousImpact.displaced,
    draggables,
    combine: wasAt.combine,
    afterCritical
  });
  if (newIndex == null) {
    return null;
  }
  return calculateReorderImpact({
    draggable: draggable2,
    insideDestination,
    destination,
    viewport,
    last: previousImpact.displaced,
    displacedBy: previousImpact.displacedBy,
    index: newIndex
  });
};
var getCombinedItemDisplacement = function(_ref) {
  var displaced = _ref.displaced, afterCritical = _ref.afterCritical, combineWith = _ref.combineWith, displacedBy = _ref.displacedBy;
  var isDisplaced = Boolean(displaced.visible[combineWith] || displaced.invisible[combineWith]);
  if (didStartAfterCritical(combineWith, afterCritical)) {
    return isDisplaced ? origin : negate(displacedBy.point);
  }
  return isDisplaced ? displacedBy.point : origin;
};
var whenCombining = function(_ref) {
  var afterCritical = _ref.afterCritical, impact = _ref.impact, draggables = _ref.draggables;
  var combine2 = tryGetCombine(impact);
  !combine2 ? invariant(false) : void 0;
  var combineWith = combine2.draggableId;
  var center = draggables[combineWith].page.borderBox.center;
  var displaceBy = getCombinedItemDisplacement({
    displaced: impact.displaced,
    afterCritical,
    combineWith,
    displacedBy: impact.displacedBy
  });
  return add(center, displaceBy);
};
var distanceFromStartToBorderBoxCenter = function distanceFromStartToBorderBoxCenter2(axis, box) {
  return box.margin[axis.start] + box.borderBox[axis.size] / 2;
};
var distanceFromEndToBorderBoxCenter = function distanceFromEndToBorderBoxCenter2(axis, box) {
  return box.margin[axis.end] + box.borderBox[axis.size] / 2;
};
var getCrossAxisBorderBoxCenter = function getCrossAxisBorderBoxCenter2(axis, target, isMoving) {
  return target[axis.crossAxisStart] + isMoving.margin[axis.crossAxisStart] + isMoving.borderBox[axis.crossAxisSize] / 2;
};
var goAfter = function goAfter2(_ref) {
  var axis = _ref.axis, moveRelativeTo = _ref.moveRelativeTo, isMoving = _ref.isMoving;
  return patch(axis.line, moveRelativeTo.marginBox[axis.end] + distanceFromStartToBorderBoxCenter(axis, isMoving), getCrossAxisBorderBoxCenter(axis, moveRelativeTo.marginBox, isMoving));
};
var goBefore = function goBefore2(_ref2) {
  var axis = _ref2.axis, moveRelativeTo = _ref2.moveRelativeTo, isMoving = _ref2.isMoving;
  return patch(axis.line, moveRelativeTo.marginBox[axis.start] - distanceFromEndToBorderBoxCenter(axis, isMoving), getCrossAxisBorderBoxCenter(axis, moveRelativeTo.marginBox, isMoving));
};
var goIntoStart = function goIntoStart2(_ref3) {
  var axis = _ref3.axis, moveInto = _ref3.moveInto, isMoving = _ref3.isMoving;
  return patch(axis.line, moveInto.contentBox[axis.start] + distanceFromStartToBorderBoxCenter(axis, isMoving), getCrossAxisBorderBoxCenter(axis, moveInto.contentBox, isMoving));
};
var whenReordering = function(_ref) {
  var impact = _ref.impact, draggable2 = _ref.draggable, draggables = _ref.draggables, droppable2 = _ref.droppable, afterCritical = _ref.afterCritical;
  var insideDestination = getDraggablesInsideDroppable(droppable2.descriptor.id, draggables);
  var draggablePage = draggable2.page;
  var axis = droppable2.axis;
  if (!insideDestination.length) {
    return goIntoStart({
      axis,
      moveInto: droppable2.page,
      isMoving: draggablePage
    });
  }
  var displaced = impact.displaced, displacedBy = impact.displacedBy;
  var closestAfter = displaced.all[0];
  if (closestAfter) {
    var closest3 = draggables[closestAfter];
    if (didStartAfterCritical(closestAfter, afterCritical)) {
      return goBefore({
        axis,
        moveRelativeTo: closest3.page,
        isMoving: draggablePage
      });
    }
    var withDisplacement = offset(closest3.page, displacedBy.point);
    return goBefore({
      axis,
      moveRelativeTo: withDisplacement,
      isMoving: draggablePage
    });
  }
  var last = insideDestination[insideDestination.length - 1];
  if (last.descriptor.id === draggable2.descriptor.id) {
    return draggablePage.borderBox.center;
  }
  if (didStartAfterCritical(last.descriptor.id, afterCritical)) {
    var page = offset(last.page, negate(afterCritical.displacedBy.point));
    return goAfter({
      axis,
      moveRelativeTo: page,
      isMoving: draggablePage
    });
  }
  return goAfter({
    axis,
    moveRelativeTo: last.page,
    isMoving: draggablePage
  });
};
var withDroppableDisplacement = function(droppable2, point) {
  var frame = droppable2.frame;
  if (!frame) {
    return point;
  }
  return add(point, frame.scroll.diff.displacement);
};
var getResultWithoutDroppableDisplacement = function getResultWithoutDroppableDisplacement2(_ref) {
  var impact = _ref.impact, draggable2 = _ref.draggable, droppable2 = _ref.droppable, draggables = _ref.draggables, afterCritical = _ref.afterCritical;
  var original = draggable2.page.borderBox.center;
  var at2 = impact.at;
  if (!droppable2) {
    return original;
  }
  if (!at2) {
    return original;
  }
  if (at2.type === "REORDER") {
    return whenReordering({
      impact,
      draggable: draggable2,
      draggables,
      droppable: droppable2,
      afterCritical
    });
  }
  return whenCombining({
    impact,
    draggables,
    afterCritical
  });
};
var getPageBorderBoxCenterFromImpact = function(args) {
  var withoutDisplacement = getResultWithoutDroppableDisplacement(args);
  var droppable2 = args.droppable;
  var withDisplacement = droppable2 ? withDroppableDisplacement(droppable2, withoutDisplacement) : withoutDisplacement;
  return withDisplacement;
};
var scrollViewport = function(viewport, newScroll) {
  var diff = subtract(newScroll, viewport.scroll.initial);
  var displacement = negate(diff);
  var frame = getRect({
    top: newScroll.y,
    bottom: newScroll.y + viewport.frame.height,
    left: newScroll.x,
    right: newScroll.x + viewport.frame.width
  });
  var updated = {
    frame,
    scroll: {
      initial: viewport.scroll.initial,
      max: viewport.scroll.max,
      current: newScroll,
      diff: {
        value: diff,
        displacement
      }
    }
  };
  return updated;
};
function getDraggables(ids, draggables) {
  return ids.map(function(id2) {
    return draggables[id2];
  });
}
function tryGetVisible(id2, groups) {
  for (var i2 = 0; i2 < groups.length; i2++) {
    var displacement = groups[i2].visible[id2];
    if (displacement) {
      return displacement;
    }
  }
  return null;
}
var speculativelyIncrease = function(_ref) {
  var impact = _ref.impact, viewport = _ref.viewport, destination = _ref.destination, draggables = _ref.draggables, maxScrollChange = _ref.maxScrollChange;
  var scrolledViewport = scrollViewport(viewport, add(viewport.scroll.current, maxScrollChange));
  var scrolledDroppable = destination.frame ? scrollDroppable(destination, add(destination.frame.scroll.current, maxScrollChange)) : destination;
  var last = impact.displaced;
  var withViewportScroll = getDisplacementGroups({
    afterDragging: getDraggables(last.all, draggables),
    destination,
    displacedBy: impact.displacedBy,
    viewport: scrolledViewport.frame,
    last,
    forceShouldAnimate: false
  });
  var withDroppableScroll2 = getDisplacementGroups({
    afterDragging: getDraggables(last.all, draggables),
    destination: scrolledDroppable,
    displacedBy: impact.displacedBy,
    viewport: viewport.frame,
    last,
    forceShouldAnimate: false
  });
  var invisible = {};
  var visible = {};
  var groups = [last, withViewportScroll, withDroppableScroll2];
  last.all.forEach(function(id2) {
    var displacement = tryGetVisible(id2, groups);
    if (displacement) {
      visible[id2] = displacement;
      return;
    }
    invisible[id2] = true;
  });
  var newImpact = _extends({}, impact, {
    displaced: {
      all: last.all,
      invisible,
      visible
    }
  });
  return newImpact;
};
var withViewportDisplacement = function(viewport, point) {
  return add(viewport.scroll.diff.displacement, point);
};
var getClientFromPageBorderBoxCenter = function(_ref) {
  var pageBorderBoxCenter = _ref.pageBorderBoxCenter, draggable2 = _ref.draggable, viewport = _ref.viewport;
  var withoutPageScrollChange = withViewportDisplacement(viewport, pageBorderBoxCenter);
  var offset3 = subtract(withoutPageScrollChange, draggable2.page.borderBox.center);
  return add(draggable2.client.borderBox.center, offset3);
};
var isTotallyVisibleInNewLocation = function(_ref) {
  var draggable2 = _ref.draggable, destination = _ref.destination, newPageBorderBoxCenter = _ref.newPageBorderBoxCenter, viewport = _ref.viewport, withDroppableDisplacement2 = _ref.withDroppableDisplacement, _ref$onlyOnMainAxis = _ref.onlyOnMainAxis, onlyOnMainAxis = _ref$onlyOnMainAxis === void 0 ? false : _ref$onlyOnMainAxis;
  var changeNeeded = subtract(newPageBorderBoxCenter, draggable2.page.borderBox.center);
  var shifted = offsetByPosition(draggable2.page.borderBox, changeNeeded);
  var args = {
    target: shifted,
    destination,
    withDroppableDisplacement: withDroppableDisplacement2,
    viewport
  };
  return onlyOnMainAxis ? isTotallyVisibleOnAxis(args) : isTotallyVisible(args);
};
var moveToNextPlace = function(_ref) {
  var isMovingForward = _ref.isMovingForward, draggable2 = _ref.draggable, destination = _ref.destination, draggables = _ref.draggables, previousImpact = _ref.previousImpact, viewport = _ref.viewport, previousPageBorderBoxCenter = _ref.previousPageBorderBoxCenter, previousClientSelection = _ref.previousClientSelection, afterCritical = _ref.afterCritical;
  if (!destination.isEnabled) {
    return null;
  }
  var insideDestination = getDraggablesInsideDroppable(destination.descriptor.id, draggables);
  var isInHomeList = isHomeOf(draggable2, destination);
  var impact = moveToNextCombine({
    isMovingForward,
    draggable: draggable2,
    destination,
    insideDestination,
    previousImpact
  }) || moveToNextIndex({
    isMovingForward,
    isInHomeList,
    draggable: draggable2,
    draggables,
    destination,
    insideDestination,
    previousImpact,
    viewport,
    afterCritical
  });
  if (!impact) {
    return null;
  }
  var pageBorderBoxCenter = getPageBorderBoxCenterFromImpact({
    impact,
    draggable: draggable2,
    droppable: destination,
    draggables,
    afterCritical
  });
  var isVisibleInNewLocation = isTotallyVisibleInNewLocation({
    draggable: draggable2,
    destination,
    newPageBorderBoxCenter: pageBorderBoxCenter,
    viewport: viewport.frame,
    withDroppableDisplacement: false,
    onlyOnMainAxis: true
  });
  if (isVisibleInNewLocation) {
    var clientSelection = getClientFromPageBorderBoxCenter({
      pageBorderBoxCenter,
      draggable: draggable2,
      viewport
    });
    return {
      clientSelection,
      impact,
      scrollJumpRequest: null
    };
  }
  var distance3 = subtract(pageBorderBoxCenter, previousPageBorderBoxCenter);
  var cautious = speculativelyIncrease({
    impact,
    viewport,
    destination,
    draggables,
    maxScrollChange: distance3
  });
  return {
    clientSelection: previousClientSelection,
    impact: cautious,
    scrollJumpRequest: distance3
  };
};
var getKnownActive = function getKnownActive2(droppable2) {
  var rect = droppable2.subject.active;
  !rect ? invariant(false) : void 0;
  return rect;
};
var getBestCrossAxisDroppable = function(_ref) {
  var isMovingForward = _ref.isMovingForward, pageBorderBoxCenter = _ref.pageBorderBoxCenter, source = _ref.source, droppables = _ref.droppables, viewport = _ref.viewport;
  var active = source.subject.active;
  if (!active) {
    return null;
  }
  var axis = source.axis;
  var isBetweenSourceClipped = isWithin(active[axis.start], active[axis.end]);
  var candidates = toDroppableList(droppables).filter(function(droppable2) {
    return droppable2 !== source;
  }).filter(function(droppable2) {
    return droppable2.isEnabled;
  }).filter(function(droppable2) {
    return Boolean(droppable2.subject.active);
  }).filter(function(droppable2) {
    return isPartiallyVisibleThroughFrame(viewport.frame)(getKnownActive(droppable2));
  }).filter(function(droppable2) {
    var activeOfTarget = getKnownActive(droppable2);
    if (isMovingForward) {
      return active[axis.crossAxisEnd] < activeOfTarget[axis.crossAxisEnd];
    }
    return activeOfTarget[axis.crossAxisStart] < active[axis.crossAxisStart];
  }).filter(function(droppable2) {
    var activeOfTarget = getKnownActive(droppable2);
    var isBetweenDestinationClipped = isWithin(activeOfTarget[axis.start], activeOfTarget[axis.end]);
    return isBetweenSourceClipped(activeOfTarget[axis.start]) || isBetweenSourceClipped(activeOfTarget[axis.end]) || isBetweenDestinationClipped(active[axis.start]) || isBetweenDestinationClipped(active[axis.end]);
  }).sort(function(a2, b2) {
    var first = getKnownActive(a2)[axis.crossAxisStart];
    var second = getKnownActive(b2)[axis.crossAxisStart];
    if (isMovingForward) {
      return first - second;
    }
    return second - first;
  }).filter(function(droppable2, index2, array) {
    return getKnownActive(droppable2)[axis.crossAxisStart] === getKnownActive(array[0])[axis.crossAxisStart];
  });
  if (!candidates.length) {
    return null;
  }
  if (candidates.length === 1) {
    return candidates[0];
  }
  var contains2 = candidates.filter(function(droppable2) {
    var isWithinDroppable = isWithin(getKnownActive(droppable2)[axis.start], getKnownActive(droppable2)[axis.end]);
    return isWithinDroppable(pageBorderBoxCenter[axis.line]);
  });
  if (contains2.length === 1) {
    return contains2[0];
  }
  if (contains2.length > 1) {
    return contains2.sort(function(a2, b2) {
      return getKnownActive(a2)[axis.start] - getKnownActive(b2)[axis.start];
    })[0];
  }
  return candidates.sort(function(a2, b2) {
    var first = closest(pageBorderBoxCenter, getCorners(getKnownActive(a2)));
    var second = closest(pageBorderBoxCenter, getCorners(getKnownActive(b2)));
    if (first !== second) {
      return first - second;
    }
    return getKnownActive(a2)[axis.start] - getKnownActive(b2)[axis.start];
  })[0];
};
var getCurrentPageBorderBoxCenter = function getCurrentPageBorderBoxCenter2(draggable2, afterCritical) {
  var original = draggable2.page.borderBox.center;
  return didStartAfterCritical(draggable2.descriptor.id, afterCritical) ? subtract(original, afterCritical.displacedBy.point) : original;
};
var getCurrentPageBorderBox = function getCurrentPageBorderBox2(draggable2, afterCritical) {
  var original = draggable2.page.borderBox;
  return didStartAfterCritical(draggable2.descriptor.id, afterCritical) ? offsetByPosition(original, negate(afterCritical.displacedBy.point)) : original;
};
var getClosestDraggable = function(_ref) {
  var pageBorderBoxCenter = _ref.pageBorderBoxCenter, viewport = _ref.viewport, destination = _ref.destination, insideDestination = _ref.insideDestination, afterCritical = _ref.afterCritical;
  var sorted = insideDestination.filter(function(draggable2) {
    return isTotallyVisible({
      target: getCurrentPageBorderBox(draggable2, afterCritical),
      destination,
      viewport: viewport.frame,
      withDroppableDisplacement: true
    });
  }).sort(function(a2, b2) {
    var distanceToA = distance(pageBorderBoxCenter, withDroppableDisplacement(destination, getCurrentPageBorderBoxCenter(a2, afterCritical)));
    var distanceToB = distance(pageBorderBoxCenter, withDroppableDisplacement(destination, getCurrentPageBorderBoxCenter(b2, afterCritical)));
    if (distanceToA < distanceToB) {
      return -1;
    }
    if (distanceToB < distanceToA) {
      return 1;
    }
    return a2.descriptor.index - b2.descriptor.index;
  });
  return sorted[0] || null;
};
var getDisplacedBy = memoizeOne(function getDisplacedBy2(axis, displaceBy) {
  var displacement = displaceBy[axis.line];
  return {
    value: displacement,
    point: patch(axis.line, displacement)
  };
});
var getRequiredGrowthForPlaceholder = function getRequiredGrowthForPlaceholder2(droppable2, placeholderSize, draggables) {
  var axis = droppable2.axis;
  if (droppable2.descriptor.mode === "virtual") {
    return patch(axis.line, placeholderSize[axis.line]);
  }
  var availableSpace = droppable2.subject.page.contentBox[axis.size];
  var insideDroppable = getDraggablesInsideDroppable(droppable2.descriptor.id, draggables);
  var spaceUsed = insideDroppable.reduce(function(sum, dimension) {
    return sum + dimension.client.marginBox[axis.size];
  }, 0);
  var requiredSpace = spaceUsed + placeholderSize[axis.line];
  var needsToGrowBy = requiredSpace - availableSpace;
  if (needsToGrowBy <= 0) {
    return null;
  }
  return patch(axis.line, needsToGrowBy);
};
var withMaxScroll = function withMaxScroll2(frame, max2) {
  return _extends({}, frame, {
    scroll: _extends({}, frame.scroll, {
      max: max2
    })
  });
};
var addPlaceholder = function addPlaceholder2(droppable2, draggable2, draggables) {
  var frame = droppable2.frame;
  !!isHomeOf(draggable2, droppable2) ? invariant(false) : void 0;
  !!droppable2.subject.withPlaceholder ? invariant(false) : void 0;
  var placeholderSize = getDisplacedBy(droppable2.axis, draggable2.displaceBy).point;
  var requiredGrowth = getRequiredGrowthForPlaceholder(droppable2, placeholderSize, draggables);
  var added = {
    placeholderSize,
    increasedBy: requiredGrowth,
    oldFrameMaxScroll: droppable2.frame ? droppable2.frame.scroll.max : null
  };
  if (!frame) {
    var _subject = getSubject({
      page: droppable2.subject.page,
      withPlaceholder: added,
      axis: droppable2.axis,
      frame: droppable2.frame
    });
    return _extends({}, droppable2, {
      subject: _subject
    });
  }
  var maxScroll = requiredGrowth ? add(frame.scroll.max, requiredGrowth) : frame.scroll.max;
  var newFrame = withMaxScroll(frame, maxScroll);
  var subject = getSubject({
    page: droppable2.subject.page,
    withPlaceholder: added,
    axis: droppable2.axis,
    frame: newFrame
  });
  return _extends({}, droppable2, {
    subject,
    frame: newFrame
  });
};
var removePlaceholder = function removePlaceholder2(droppable2) {
  var added = droppable2.subject.withPlaceholder;
  !added ? invariant(false) : void 0;
  var frame = droppable2.frame;
  if (!frame) {
    var _subject2 = getSubject({
      page: droppable2.subject.page,
      axis: droppable2.axis,
      frame: null,
      withPlaceholder: null
    });
    return _extends({}, droppable2, {
      subject: _subject2
    });
  }
  var oldMaxScroll = added.oldFrameMaxScroll;
  !oldMaxScroll ? invariant(false) : void 0;
  var newFrame = withMaxScroll(frame, oldMaxScroll);
  var subject = getSubject({
    page: droppable2.subject.page,
    axis: droppable2.axis,
    frame: newFrame,
    withPlaceholder: null
  });
  return _extends({}, droppable2, {
    subject,
    frame: newFrame
  });
};
var moveToNewDroppable = function(_ref) {
  var previousPageBorderBoxCenter = _ref.previousPageBorderBoxCenter, moveRelativeTo = _ref.moveRelativeTo, insideDestination = _ref.insideDestination, draggable2 = _ref.draggable, draggables = _ref.draggables, destination = _ref.destination, viewport = _ref.viewport, afterCritical = _ref.afterCritical;
  if (!moveRelativeTo) {
    if (insideDestination.length) {
      return null;
    }
    var proposed = {
      displaced: emptyGroups,
      displacedBy: noDisplacedBy,
      at: {
        type: "REORDER",
        destination: {
          droppableId: destination.descriptor.id,
          index: 0
        }
      }
    };
    var proposedPageBorderBoxCenter = getPageBorderBoxCenterFromImpact({
      impact: proposed,
      draggable: draggable2,
      droppable: destination,
      draggables,
      afterCritical
    });
    var withPlaceholder = isHomeOf(draggable2, destination) ? destination : addPlaceholder(destination, draggable2, draggables);
    var isVisibleInNewLocation = isTotallyVisibleInNewLocation({
      draggable: draggable2,
      destination: withPlaceholder,
      newPageBorderBoxCenter: proposedPageBorderBoxCenter,
      viewport: viewport.frame,
      withDroppableDisplacement: false,
      onlyOnMainAxis: true
    });
    return isVisibleInNewLocation ? proposed : null;
  }
  var isGoingBeforeTarget = Boolean(previousPageBorderBoxCenter[destination.axis.line] <= moveRelativeTo.page.borderBox.center[destination.axis.line]);
  var proposedIndex = function() {
    var relativeTo = moveRelativeTo.descriptor.index;
    if (moveRelativeTo.descriptor.id === draggable2.descriptor.id) {
      return relativeTo;
    }
    if (isGoingBeforeTarget) {
      return relativeTo;
    }
    return relativeTo + 1;
  }();
  var displacedBy = getDisplacedBy(destination.axis, draggable2.displaceBy);
  return calculateReorderImpact({
    draggable: draggable2,
    insideDestination,
    destination,
    viewport,
    displacedBy,
    last: emptyGroups,
    index: proposedIndex
  });
};
var moveCrossAxis = function(_ref) {
  var isMovingForward = _ref.isMovingForward, previousPageBorderBoxCenter = _ref.previousPageBorderBoxCenter, draggable2 = _ref.draggable, isOver = _ref.isOver, draggables = _ref.draggables, droppables = _ref.droppables, viewport = _ref.viewport, afterCritical = _ref.afterCritical;
  var destination = getBestCrossAxisDroppable({
    isMovingForward,
    pageBorderBoxCenter: previousPageBorderBoxCenter,
    source: isOver,
    droppables,
    viewport
  });
  if (!destination) {
    return null;
  }
  var insideDestination = getDraggablesInsideDroppable(destination.descriptor.id, draggables);
  var moveRelativeTo = getClosestDraggable({
    pageBorderBoxCenter: previousPageBorderBoxCenter,
    viewport,
    destination,
    insideDestination,
    afterCritical
  });
  var impact = moveToNewDroppable({
    previousPageBorderBoxCenter,
    destination,
    draggable: draggable2,
    draggables,
    moveRelativeTo,
    insideDestination,
    viewport,
    afterCritical
  });
  if (!impact) {
    return null;
  }
  var pageBorderBoxCenter = getPageBorderBoxCenterFromImpact({
    impact,
    draggable: draggable2,
    droppable: destination,
    draggables,
    afterCritical
  });
  var clientSelection = getClientFromPageBorderBoxCenter({
    pageBorderBoxCenter,
    draggable: draggable2,
    viewport
  });
  return {
    clientSelection,
    impact,
    scrollJumpRequest: null
  };
};
var whatIsDraggedOver = function(impact) {
  var at2 = impact.at;
  if (!at2) {
    return null;
  }
  if (at2.type === "REORDER") {
    return at2.destination.droppableId;
  }
  return at2.combine.droppableId;
};
var getDroppableOver = function getDroppableOver2(impact, droppables) {
  var id2 = whatIsDraggedOver(impact);
  return id2 ? droppables[id2] : null;
};
var moveInDirection = function(_ref) {
  var state = _ref.state, type = _ref.type;
  var isActuallyOver = getDroppableOver(state.impact, state.dimensions.droppables);
  var isMainAxisMovementAllowed = Boolean(isActuallyOver);
  var home2 = state.dimensions.droppables[state.critical.droppable.id];
  var isOver = isActuallyOver || home2;
  var direction = isOver.axis.direction;
  var isMovingOnMainAxis = direction === "vertical" && (type === "MOVE_UP" || type === "MOVE_DOWN") || direction === "horizontal" && (type === "MOVE_LEFT" || type === "MOVE_RIGHT");
  if (isMovingOnMainAxis && !isMainAxisMovementAllowed) {
    return null;
  }
  var isMovingForward = type === "MOVE_DOWN" || type === "MOVE_RIGHT";
  var draggable2 = state.dimensions.draggables[state.critical.draggable.id];
  var previousPageBorderBoxCenter = state.current.page.borderBoxCenter;
  var _state$dimensions = state.dimensions, draggables = _state$dimensions.draggables, droppables = _state$dimensions.droppables;
  return isMovingOnMainAxis ? moveToNextPlace({
    isMovingForward,
    previousPageBorderBoxCenter,
    draggable: draggable2,
    destination: isOver,
    draggables,
    viewport: state.viewport,
    previousClientSelection: state.current.client.selection,
    previousImpact: state.impact,
    afterCritical: state.afterCritical
  }) : moveCrossAxis({
    isMovingForward,
    previousPageBorderBoxCenter,
    draggable: draggable2,
    isOver,
    draggables,
    droppables,
    viewport: state.viewport,
    afterCritical: state.afterCritical
  });
};
function isMovementAllowed(state) {
  return state.phase === "DRAGGING" || state.phase === "COLLECTING";
}
function isPositionInFrame(frame) {
  var isWithinVertical = isWithin(frame.top, frame.bottom);
  var isWithinHorizontal = isWithin(frame.left, frame.right);
  return function run(point) {
    return isWithinVertical(point.y) && isWithinHorizontal(point.x);
  };
}
function getHasOverlap(first, second) {
  return first.left < second.right && first.right > second.left && first.top < second.bottom && first.bottom > second.top;
}
function getFurthestAway(_ref) {
  var pageBorderBox = _ref.pageBorderBox, draggable2 = _ref.draggable, candidates = _ref.candidates;
  var startCenter = draggable2.page.borderBox.center;
  var sorted = candidates.map(function(candidate) {
    var axis = candidate.axis;
    var target = patch(candidate.axis.line, pageBorderBox.center[axis.line], candidate.page.borderBox.center[axis.crossAxisLine]);
    return {
      id: candidate.descriptor.id,
      distance: distance(startCenter, target)
    };
  }).sort(function(a2, b2) {
    return b2.distance - a2.distance;
  });
  return sorted[0] ? sorted[0].id : null;
}
function getDroppableOver$1(_ref2) {
  var pageBorderBox = _ref2.pageBorderBox, draggable2 = _ref2.draggable, droppables = _ref2.droppables;
  var candidates = toDroppableList(droppables).filter(function(item) {
    if (!item.isEnabled) {
      return false;
    }
    var active = item.subject.active;
    if (!active) {
      return false;
    }
    if (!getHasOverlap(pageBorderBox, active)) {
      return false;
    }
    if (isPositionInFrame(active)(pageBorderBox.center)) {
      return true;
    }
    var axis = item.axis;
    var childCenter = active.center[axis.crossAxisLine];
    var crossAxisStart = pageBorderBox[axis.crossAxisStart];
    var crossAxisEnd = pageBorderBox[axis.crossAxisEnd];
    var isContained = isWithin(active[axis.crossAxisStart], active[axis.crossAxisEnd]);
    var isStartContained = isContained(crossAxisStart);
    var isEndContained = isContained(crossAxisEnd);
    if (!isStartContained && !isEndContained) {
      return true;
    }
    if (isStartContained) {
      return crossAxisStart < childCenter;
    }
    return crossAxisEnd > childCenter;
  });
  if (!candidates.length) {
    return null;
  }
  if (candidates.length === 1) {
    return candidates[0].descriptor.id;
  }
  return getFurthestAway({
    pageBorderBox,
    draggable: draggable2,
    candidates
  });
}
var offsetRectByPosition = function offsetRectByPosition2(rect, point) {
  return getRect(offsetByPosition(rect, point));
};
var withDroppableScroll = function(droppable2, area) {
  var frame = droppable2.frame;
  if (!frame) {
    return area;
  }
  return offsetRectByPosition(area, frame.scroll.diff.value);
};
function getIsDisplaced(_ref) {
  var displaced = _ref.displaced, id2 = _ref.id;
  return Boolean(displaced.visible[id2] || displaced.invisible[id2]);
}
function atIndex(_ref) {
  var draggable2 = _ref.draggable, closest3 = _ref.closest, inHomeList = _ref.inHomeList;
  if (!closest3) {
    return null;
  }
  if (!inHomeList) {
    return closest3.descriptor.index;
  }
  if (closest3.descriptor.index > draggable2.descriptor.index) {
    return closest3.descriptor.index - 1;
  }
  return closest3.descriptor.index;
}
var getReorderImpact = function(_ref2) {
  var targetRect = _ref2.pageBorderBoxWithDroppableScroll, draggable2 = _ref2.draggable, destination = _ref2.destination, insideDestination = _ref2.insideDestination, last = _ref2.last, viewport = _ref2.viewport, afterCritical = _ref2.afterCritical;
  var axis = destination.axis;
  var displacedBy = getDisplacedBy(destination.axis, draggable2.displaceBy);
  var displacement = displacedBy.value;
  var targetStart = targetRect[axis.start];
  var targetEnd = targetRect[axis.end];
  var withoutDragging = removeDraggableFromList(draggable2, insideDestination);
  var closest3 = find(withoutDragging, function(child) {
    var id2 = child.descriptor.id;
    var childCenter = child.page.borderBox.center[axis.line];
    var didStartAfterCritical$1 = didStartAfterCritical(id2, afterCritical);
    var isDisplaced = getIsDisplaced({
      displaced: last,
      id: id2
    });
    if (didStartAfterCritical$1) {
      if (isDisplaced) {
        return targetEnd <= childCenter;
      }
      return targetStart < childCenter - displacement;
    }
    if (isDisplaced) {
      return targetEnd <= childCenter + displacement;
    }
    return targetStart < childCenter;
  });
  var newIndex = atIndex({
    draggable: draggable2,
    closest: closest3,
    inHomeList: isHomeOf(draggable2, destination)
  });
  return calculateReorderImpact({
    draggable: draggable2,
    insideDestination,
    destination,
    viewport,
    last,
    displacedBy,
    index: newIndex
  });
};
var combineThresholdDivisor = 4;
var getCombineImpact = function(_ref) {
  var draggable2 = _ref.draggable, targetRect = _ref.pageBorderBoxWithDroppableScroll, previousImpact = _ref.previousImpact, destination = _ref.destination, insideDestination = _ref.insideDestination, afterCritical = _ref.afterCritical;
  if (!destination.isCombineEnabled) {
    return null;
  }
  var axis = destination.axis;
  var displacedBy = getDisplacedBy(destination.axis, draggable2.displaceBy);
  var displacement = displacedBy.value;
  var targetStart = targetRect[axis.start];
  var targetEnd = targetRect[axis.end];
  var withoutDragging = removeDraggableFromList(draggable2, insideDestination);
  var combineWith = find(withoutDragging, function(child) {
    var id2 = child.descriptor.id;
    var childRect = child.page.borderBox;
    var childSize = childRect[axis.size];
    var threshold = childSize / combineThresholdDivisor;
    var didStartAfterCritical$1 = didStartAfterCritical(id2, afterCritical);
    var isDisplaced = getIsDisplaced({
      displaced: previousImpact.displaced,
      id: id2
    });
    if (didStartAfterCritical$1) {
      if (isDisplaced) {
        return targetEnd > childRect[axis.start] + threshold && targetEnd < childRect[axis.end] - threshold;
      }
      return targetStart > childRect[axis.start] - displacement + threshold && targetStart < childRect[axis.end] - displacement - threshold;
    }
    if (isDisplaced) {
      return targetEnd > childRect[axis.start] + displacement + threshold && targetEnd < childRect[axis.end] + displacement - threshold;
    }
    return targetStart > childRect[axis.start] + threshold && targetStart < childRect[axis.end] - threshold;
  });
  if (!combineWith) {
    return null;
  }
  var impact = {
    displacedBy,
    displaced: previousImpact.displaced,
    at: {
      type: "COMBINE",
      combine: {
        draggableId: combineWith.descriptor.id,
        droppableId: destination.descriptor.id
      }
    }
  };
  return impact;
};
var getDragImpact = function(_ref) {
  var pageOffset = _ref.pageOffset, draggable2 = _ref.draggable, draggables = _ref.draggables, droppables = _ref.droppables, previousImpact = _ref.previousImpact, viewport = _ref.viewport, afterCritical = _ref.afterCritical;
  var pageBorderBox = offsetRectByPosition(draggable2.page.borderBox, pageOffset);
  var destinationId = getDroppableOver$1({
    pageBorderBox,
    draggable: draggable2,
    droppables
  });
  if (!destinationId) {
    return noImpact;
  }
  var destination = droppables[destinationId];
  var insideDestination = getDraggablesInsideDroppable(destination.descriptor.id, draggables);
  var pageBorderBoxWithDroppableScroll = withDroppableScroll(destination, pageBorderBox);
  return getCombineImpact({
    pageBorderBoxWithDroppableScroll,
    draggable: draggable2,
    previousImpact,
    destination,
    insideDestination,
    afterCritical
  }) || getReorderImpact({
    pageBorderBoxWithDroppableScroll,
    draggable: draggable2,
    destination,
    insideDestination,
    last: previousImpact.displaced,
    viewport,
    afterCritical
  });
};
var patchDroppableMap = function(droppables, updated) {
  var _extends2;
  return _extends({}, droppables, (_extends2 = {}, _extends2[updated.descriptor.id] = updated, _extends2));
};
var clearUnusedPlaceholder = function clearUnusedPlaceholder2(_ref) {
  var previousImpact = _ref.previousImpact, impact = _ref.impact, droppables = _ref.droppables;
  var last = whatIsDraggedOver(previousImpact);
  var now = whatIsDraggedOver(impact);
  if (!last) {
    return droppables;
  }
  if (last === now) {
    return droppables;
  }
  var lastDroppable = droppables[last];
  if (!lastDroppable.subject.withPlaceholder) {
    return droppables;
  }
  var updated = removePlaceholder(lastDroppable);
  return patchDroppableMap(droppables, updated);
};
var recomputePlaceholders = function(_ref2) {
  var draggable2 = _ref2.draggable, draggables = _ref2.draggables, droppables = _ref2.droppables, previousImpact = _ref2.previousImpact, impact = _ref2.impact;
  var cleaned = clearUnusedPlaceholder({
    previousImpact,
    impact,
    droppables
  });
  var isOver = whatIsDraggedOver(impact);
  if (!isOver) {
    return cleaned;
  }
  var droppable2 = droppables[isOver];
  if (isHomeOf(draggable2, droppable2)) {
    return cleaned;
  }
  if (droppable2.subject.withPlaceholder) {
    return cleaned;
  }
  var patched = addPlaceholder(droppable2, draggable2, draggables);
  return patchDroppableMap(cleaned, patched);
};
var update = function(_ref) {
  var state = _ref.state, forcedClientSelection = _ref.clientSelection, forcedDimensions = _ref.dimensions, forcedViewport = _ref.viewport, forcedImpact = _ref.impact, scrollJumpRequest = _ref.scrollJumpRequest;
  var viewport = forcedViewport || state.viewport;
  var dimensions = forcedDimensions || state.dimensions;
  var clientSelection = forcedClientSelection || state.current.client.selection;
  var offset3 = subtract(clientSelection, state.initial.client.selection);
  var client2 = {
    offset: offset3,
    selection: clientSelection,
    borderBoxCenter: add(state.initial.client.borderBoxCenter, offset3)
  };
  var page = {
    selection: add(client2.selection, viewport.scroll.current),
    borderBoxCenter: add(client2.borderBoxCenter, viewport.scroll.current),
    offset: add(client2.offset, viewport.scroll.diff.value)
  };
  var current = {
    client: client2,
    page
  };
  if (state.phase === "COLLECTING") {
    return _extends({
      phase: "COLLECTING"
    }, state, {
      dimensions,
      viewport,
      current
    });
  }
  var draggable2 = dimensions.draggables[state.critical.draggable.id];
  var newImpact = forcedImpact || getDragImpact({
    pageOffset: page.offset,
    draggable: draggable2,
    draggables: dimensions.draggables,
    droppables: dimensions.droppables,
    previousImpact: state.impact,
    viewport,
    afterCritical: state.afterCritical
  });
  var withUpdatedPlaceholders = recomputePlaceholders({
    draggable: draggable2,
    impact: newImpact,
    previousImpact: state.impact,
    draggables: dimensions.draggables,
    droppables: dimensions.droppables
  });
  var result = _extends({}, state, {
    current,
    dimensions: {
      draggables: dimensions.draggables,
      droppables: withUpdatedPlaceholders
    },
    impact: newImpact,
    viewport,
    scrollJumpRequest: scrollJumpRequest || null,
    forceShouldAnimate: scrollJumpRequest ? false : null
  });
  return result;
};
function getDraggables$1(ids, draggables) {
  return ids.map(function(id2) {
    return draggables[id2];
  });
}
var recompute = function(_ref) {
  var impact = _ref.impact, viewport = _ref.viewport, draggables = _ref.draggables, destination = _ref.destination, forceShouldAnimate = _ref.forceShouldAnimate;
  var last = impact.displaced;
  var afterDragging = getDraggables$1(last.all, draggables);
  var displaced = getDisplacementGroups({
    afterDragging,
    destination,
    displacedBy: impact.displacedBy,
    viewport: viewport.frame,
    forceShouldAnimate,
    last
  });
  return _extends({}, impact, {
    displaced
  });
};
var getClientBorderBoxCenter = function(_ref) {
  var impact = _ref.impact, draggable2 = _ref.draggable, droppable2 = _ref.droppable, draggables = _ref.draggables, viewport = _ref.viewport, afterCritical = _ref.afterCritical;
  var pageBorderBoxCenter = getPageBorderBoxCenterFromImpact({
    impact,
    draggable: draggable2,
    draggables,
    droppable: droppable2,
    afterCritical
  });
  return getClientFromPageBorderBoxCenter({
    pageBorderBoxCenter,
    draggable: draggable2,
    viewport
  });
};
var refreshSnap = function(_ref) {
  var state = _ref.state, forcedDimensions = _ref.dimensions, forcedViewport = _ref.viewport;
  !(state.movementMode === "SNAP") ? invariant(false) : void 0;
  var needsVisibilityCheck = state.impact;
  var viewport = forcedViewport || state.viewport;
  var dimensions = forcedDimensions || state.dimensions;
  var draggables = dimensions.draggables, droppables = dimensions.droppables;
  var draggable2 = draggables[state.critical.draggable.id];
  var isOver = whatIsDraggedOver(needsVisibilityCheck);
  !isOver ? invariant(false) : void 0;
  var destination = droppables[isOver];
  var impact = recompute({
    impact: needsVisibilityCheck,
    viewport,
    destination,
    draggables
  });
  var clientSelection = getClientBorderBoxCenter({
    impact,
    draggable: draggable2,
    droppable: destination,
    draggables,
    viewport,
    afterCritical: state.afterCritical
  });
  return update({
    impact,
    clientSelection,
    state,
    dimensions,
    viewport
  });
};
var getHomeLocation = function(descriptor) {
  return {
    index: descriptor.index,
    droppableId: descriptor.droppableId
  };
};
var getLiftEffect = function(_ref) {
  var draggable2 = _ref.draggable, home2 = _ref.home, draggables = _ref.draggables, viewport = _ref.viewport;
  var displacedBy = getDisplacedBy(home2.axis, draggable2.displaceBy);
  var insideHome = getDraggablesInsideDroppable(home2.descriptor.id, draggables);
  var rawIndex = insideHome.indexOf(draggable2);
  !(rawIndex !== -1) ? invariant(false) : void 0;
  var afterDragging = insideHome.slice(rawIndex + 1);
  var effected = afterDragging.reduce(function(previous, item) {
    previous[item.descriptor.id] = true;
    return previous;
  }, {});
  var afterCritical = {
    inVirtualList: home2.descriptor.mode === "virtual",
    displacedBy,
    effected
  };
  var displaced = getDisplacementGroups({
    afterDragging,
    destination: home2,
    displacedBy,
    last: null,
    viewport: viewport.frame,
    forceShouldAnimate: false
  });
  var impact = {
    displaced,
    displacedBy,
    at: {
      type: "REORDER",
      destination: getHomeLocation(draggable2.descriptor)
    }
  };
  return {
    impact,
    afterCritical
  };
};
var patchDimensionMap = function(dimensions, updated) {
  return {
    draggables: dimensions.draggables,
    droppables: patchDroppableMap(dimensions.droppables, updated)
  };
};
var offsetDraggable = function(_ref) {
  var draggable2 = _ref.draggable, offset$12 = _ref.offset, initialWindowScroll = _ref.initialWindowScroll;
  var client2 = offset(draggable2.client, offset$12);
  var page = withScroll(client2, initialWindowScroll);
  var moved = _extends({}, draggable2, {
    placeholder: _extends({}, draggable2.placeholder, {
      client: client2
    }),
    client: client2,
    page
  });
  return moved;
};
var getFrame = function(droppable2) {
  var frame = droppable2.frame;
  !frame ? invariant(false) : void 0;
  return frame;
};
var adjustAdditionsForScrollChanges = function(_ref) {
  var additions = _ref.additions, updatedDroppables = _ref.updatedDroppables, viewport = _ref.viewport;
  var windowScrollChange = viewport.scroll.diff.value;
  return additions.map(function(draggable2) {
    var droppableId = draggable2.descriptor.droppableId;
    var modified = updatedDroppables[droppableId];
    var frame = getFrame(modified);
    var droppableScrollChange = frame.scroll.diff.value;
    var totalChange = add(windowScrollChange, droppableScrollChange);
    var moved = offsetDraggable({
      draggable: draggable2,
      offset: totalChange,
      initialWindowScroll: viewport.scroll.initial
    });
    return moved;
  });
};
var publishWhileDraggingInVirtual = function(_ref) {
  var state = _ref.state, published = _ref.published;
  var withScrollChange = published.modified.map(function(update2) {
    var existing = state.dimensions.droppables[update2.droppableId];
    var scrolled = scrollDroppable(existing, update2.scroll);
    return scrolled;
  });
  var droppables = _extends({}, state.dimensions.droppables, {}, toDroppableMap(withScrollChange));
  var updatedAdditions = toDraggableMap(adjustAdditionsForScrollChanges({
    additions: published.additions,
    updatedDroppables: droppables,
    viewport: state.viewport
  }));
  var draggables = _extends({}, state.dimensions.draggables, {}, updatedAdditions);
  published.removals.forEach(function(id2) {
    delete draggables[id2];
  });
  var dimensions = {
    droppables,
    draggables
  };
  var wasOverId = whatIsDraggedOver(state.impact);
  var wasOver = wasOverId ? dimensions.droppables[wasOverId] : null;
  var draggable2 = dimensions.draggables[state.critical.draggable.id];
  var home2 = dimensions.droppables[state.critical.droppable.id];
  var _getLiftEffect = getLiftEffect({
    draggable: draggable2,
    home: home2,
    draggables,
    viewport: state.viewport
  }), onLiftImpact = _getLiftEffect.impact, afterCritical = _getLiftEffect.afterCritical;
  var previousImpact = wasOver && wasOver.isCombineEnabled ? state.impact : onLiftImpact;
  var impact = getDragImpact({
    pageOffset: state.current.page.offset,
    draggable: dimensions.draggables[state.critical.draggable.id],
    draggables: dimensions.draggables,
    droppables: dimensions.droppables,
    previousImpact,
    viewport: state.viewport,
    afterCritical
  });
  var draggingState = _extends({
    phase: "DRAGGING"
  }, state, {
    phase: "DRAGGING",
    impact,
    onLiftImpact,
    dimensions,
    afterCritical,
    forceShouldAnimate: false
  });
  if (state.phase === "COLLECTING") {
    return draggingState;
  }
  var dropPending3 = _extends({
    phase: "DROP_PENDING"
  }, draggingState, {
    phase: "DROP_PENDING",
    reason: state.reason,
    isWaiting: false
  });
  return dropPending3;
};
var isSnapping = function isSnapping2(state) {
  return state.movementMode === "SNAP";
};
var postDroppableChange = function postDroppableChange2(state, updated, isEnabledChanging) {
  var dimensions = patchDimensionMap(state.dimensions, updated);
  if (!isSnapping(state) || isEnabledChanging) {
    return update({
      state,
      dimensions
    });
  }
  return refreshSnap({
    state,
    dimensions
  });
};
function removeScrollJumpRequest(state) {
  if (state.isDragging && state.movementMode === "SNAP") {
    return _extends({
      phase: "DRAGGING"
    }, state, {
      scrollJumpRequest: null
    });
  }
  return state;
}
var idle = {
  phase: "IDLE",
  completed: null,
  shouldFlush: false
};
var reducer = function(state, action) {
  if (state === void 0) {
    state = idle;
  }
  if (action.type === "FLUSH") {
    return _extends({}, idle, {
      shouldFlush: true
    });
  }
  if (action.type === "INITIAL_PUBLISH") {
    !(state.phase === "IDLE") ? invariant(false) : void 0;
    var _action$payload = action.payload, critical = _action$payload.critical, clientSelection = _action$payload.clientSelection, viewport = _action$payload.viewport, dimensions = _action$payload.dimensions, movementMode = _action$payload.movementMode;
    var draggable2 = dimensions.draggables[critical.draggable.id];
    var home2 = dimensions.droppables[critical.droppable.id];
    var client2 = {
      selection: clientSelection,
      borderBoxCenter: draggable2.client.borderBox.center,
      offset: origin
    };
    var initial = {
      client: client2,
      page: {
        selection: add(client2.selection, viewport.scroll.initial),
        borderBoxCenter: add(client2.selection, viewport.scroll.initial),
        offset: add(client2.selection, viewport.scroll.diff.value)
      }
    };
    var isWindowScrollAllowed = toDroppableList(dimensions.droppables).every(function(item) {
      return !item.isFixedOnPage;
    });
    var _getLiftEffect = getLiftEffect({
      draggable: draggable2,
      home: home2,
      draggables: dimensions.draggables,
      viewport
    }), impact = _getLiftEffect.impact, afterCritical = _getLiftEffect.afterCritical;
    var result = {
      phase: "DRAGGING",
      isDragging: true,
      critical,
      movementMode,
      dimensions,
      initial,
      current: initial,
      isWindowScrollAllowed,
      impact,
      afterCritical,
      onLiftImpact: impact,
      viewport,
      scrollJumpRequest: null,
      forceShouldAnimate: null
    };
    return result;
  }
  if (action.type === "COLLECTION_STARTING") {
    if (state.phase === "COLLECTING" || state.phase === "DROP_PENDING") {
      return state;
    }
    !(state.phase === "DRAGGING") ? invariant(false) : void 0;
    var _result = _extends({
      phase: "COLLECTING"
    }, state, {
      phase: "COLLECTING"
    });
    return _result;
  }
  if (action.type === "PUBLISH_WHILE_DRAGGING") {
    !(state.phase === "COLLECTING" || state.phase === "DROP_PENDING") ? invariant(false) : void 0;
    return publishWhileDraggingInVirtual({
      state,
      published: action.payload
    });
  }
  if (action.type === "MOVE") {
    if (state.phase === "DROP_PENDING") {
      return state;
    }
    !isMovementAllowed(state) ? invariant(false) : void 0;
    var _clientSelection = action.payload.client;
    if (isEqual(_clientSelection, state.current.client.selection)) {
      return state;
    }
    return update({
      state,
      clientSelection: _clientSelection,
      impact: isSnapping(state) ? state.impact : null
    });
  }
  if (action.type === "UPDATE_DROPPABLE_SCROLL") {
    if (state.phase === "DROP_PENDING") {
      return removeScrollJumpRequest(state);
    }
    if (state.phase === "COLLECTING") {
      return removeScrollJumpRequest(state);
    }
    !isMovementAllowed(state) ? invariant(false) : void 0;
    var _action$payload2 = action.payload, id2 = _action$payload2.id, newScroll = _action$payload2.newScroll;
    var target = state.dimensions.droppables[id2];
    if (!target) {
      return state;
    }
    var scrolled = scrollDroppable(target, newScroll);
    return postDroppableChange(state, scrolled, false);
  }
  if (action.type === "UPDATE_DROPPABLE_IS_ENABLED") {
    if (state.phase === "DROP_PENDING") {
      return state;
    }
    !isMovementAllowed(state) ? invariant(false) : void 0;
    var _action$payload3 = action.payload, _id = _action$payload3.id, isEnabled = _action$payload3.isEnabled;
    var _target = state.dimensions.droppables[_id];
    !_target ? invariant(false) : void 0;
    !(_target.isEnabled !== isEnabled) ? invariant(false) : void 0;
    var updated = _extends({}, _target, {
      isEnabled
    });
    return postDroppableChange(state, updated, true);
  }
  if (action.type === "UPDATE_DROPPABLE_IS_COMBINE_ENABLED") {
    if (state.phase === "DROP_PENDING") {
      return state;
    }
    !isMovementAllowed(state) ? invariant(false) : void 0;
    var _action$payload4 = action.payload, _id2 = _action$payload4.id, isCombineEnabled = _action$payload4.isCombineEnabled;
    var _target2 = state.dimensions.droppables[_id2];
    !_target2 ? invariant(false) : void 0;
    !(_target2.isCombineEnabled !== isCombineEnabled) ? invariant(false) : void 0;
    var _updated = _extends({}, _target2, {
      isCombineEnabled
    });
    return postDroppableChange(state, _updated, true);
  }
  if (action.type === "MOVE_BY_WINDOW_SCROLL") {
    if (state.phase === "DROP_PENDING" || state.phase === "DROP_ANIMATING") {
      return state;
    }
    !isMovementAllowed(state) ? invariant(false) : void 0;
    !state.isWindowScrollAllowed ? invariant(false) : void 0;
    var _newScroll = action.payload.newScroll;
    if (isEqual(state.viewport.scroll.current, _newScroll)) {
      return removeScrollJumpRequest(state);
    }
    var _viewport = scrollViewport(state.viewport, _newScroll);
    if (isSnapping(state)) {
      return refreshSnap({
        state,
        viewport: _viewport
      });
    }
    return update({
      state,
      viewport: _viewport
    });
  }
  if (action.type === "UPDATE_VIEWPORT_MAX_SCROLL") {
    if (!isMovementAllowed(state)) {
      return state;
    }
    var maxScroll = action.payload.maxScroll;
    if (isEqual(maxScroll, state.viewport.scroll.max)) {
      return state;
    }
    var withMaxScroll3 = _extends({}, state.viewport, {
      scroll: _extends({}, state.viewport.scroll, {
        max: maxScroll
      })
    });
    return _extends({
      phase: "DRAGGING"
    }, state, {
      viewport: withMaxScroll3
    });
  }
  if (action.type === "MOVE_UP" || action.type === "MOVE_DOWN" || action.type === "MOVE_LEFT" || action.type === "MOVE_RIGHT") {
    if (state.phase === "COLLECTING" || state.phase === "DROP_PENDING") {
      return state;
    }
    !(state.phase === "DRAGGING") ? invariant(false) : void 0;
    var _result2 = moveInDirection({
      state,
      type: action.type
    });
    if (!_result2) {
      return state;
    }
    return update({
      state,
      impact: _result2.impact,
      clientSelection: _result2.clientSelection,
      scrollJumpRequest: _result2.scrollJumpRequest
    });
  }
  if (action.type === "DROP_PENDING") {
    var reason = action.payload.reason;
    !(state.phase === "COLLECTING") ? invariant(false) : void 0;
    var newState = _extends({
      phase: "DROP_PENDING"
    }, state, {
      phase: "DROP_PENDING",
      isWaiting: true,
      reason
    });
    return newState;
  }
  if (action.type === "DROP_ANIMATE") {
    var _action$payload5 = action.payload, completed = _action$payload5.completed, dropDuration = _action$payload5.dropDuration, newHomeClientOffset = _action$payload5.newHomeClientOffset;
    !(state.phase === "DRAGGING" || state.phase === "DROP_PENDING") ? invariant(false) : void 0;
    var _result3 = {
      phase: "DROP_ANIMATING",
      completed,
      dropDuration,
      newHomeClientOffset,
      dimensions: state.dimensions
    };
    return _result3;
  }
  if (action.type === "DROP_COMPLETE") {
    var _completed = action.payload.completed;
    return {
      phase: "IDLE",
      completed: _completed,
      shouldFlush: false
    };
  }
  return state;
};
var beforeInitialCapture = function beforeInitialCapture2(args) {
  return {
    type: "BEFORE_INITIAL_CAPTURE",
    payload: args
  };
};
var lift = function lift2(args) {
  return {
    type: "LIFT",
    payload: args
  };
};
var initialPublish = function initialPublish2(args) {
  return {
    type: "INITIAL_PUBLISH",
    payload: args
  };
};
var publishWhileDragging = function publishWhileDragging2(args) {
  return {
    type: "PUBLISH_WHILE_DRAGGING",
    payload: args
  };
};
var collectionStarting = function collectionStarting2() {
  return {
    type: "COLLECTION_STARTING",
    payload: null
  };
};
var updateDroppableScroll = function updateDroppableScroll2(args) {
  return {
    type: "UPDATE_DROPPABLE_SCROLL",
    payload: args
  };
};
var updateDroppableIsEnabled = function updateDroppableIsEnabled2(args) {
  return {
    type: "UPDATE_DROPPABLE_IS_ENABLED",
    payload: args
  };
};
var updateDroppableIsCombineEnabled = function updateDroppableIsCombineEnabled2(args) {
  return {
    type: "UPDATE_DROPPABLE_IS_COMBINE_ENABLED",
    payload: args
  };
};
var move = function move2(args) {
  return {
    type: "MOVE",
    payload: args
  };
};
var moveByWindowScroll = function moveByWindowScroll2(args) {
  return {
    type: "MOVE_BY_WINDOW_SCROLL",
    payload: args
  };
};
var updateViewportMaxScroll = function updateViewportMaxScroll2(args) {
  return {
    type: "UPDATE_VIEWPORT_MAX_SCROLL",
    payload: args
  };
};
var moveUp = function moveUp2() {
  return {
    type: "MOVE_UP",
    payload: null
  };
};
var moveDown = function moveDown2() {
  return {
    type: "MOVE_DOWN",
    payload: null
  };
};
var moveRight = function moveRight2() {
  return {
    type: "MOVE_RIGHT",
    payload: null
  };
};
var moveLeft = function moveLeft2() {
  return {
    type: "MOVE_LEFT",
    payload: null
  };
};
var flush = function flush2() {
  return {
    type: "FLUSH",
    payload: null
  };
};
var animateDrop = function animateDrop2(args) {
  return {
    type: "DROP_ANIMATE",
    payload: args
  };
};
var completeDrop = function completeDrop2(args) {
  return {
    type: "DROP_COMPLETE",
    payload: args
  };
};
var drop = function drop2(args) {
  return {
    type: "DROP",
    payload: args
  };
};
var dropPending = function dropPending2(args) {
  return {
    type: "DROP_PENDING",
    payload: args
  };
};
var dropAnimationFinished = function dropAnimationFinished2() {
  return {
    type: "DROP_ANIMATION_FINISHED",
    payload: null
  };
};
var lift$1 = function(marshal) {
  return function(_ref) {
    var getState = _ref.getState, dispatch = _ref.dispatch;
    return function(next) {
      return function(action) {
        if (action.type !== "LIFT") {
          next(action);
          return;
        }
        var _action$payload = action.payload, id2 = _action$payload.id, clientSelection = _action$payload.clientSelection, movementMode = _action$payload.movementMode;
        var initial = getState();
        if (initial.phase === "DROP_ANIMATING") {
          dispatch(completeDrop({
            completed: initial.completed
          }));
        }
        !(getState().phase === "IDLE") ? invariant(false) : void 0;
        dispatch(flush());
        dispatch(beforeInitialCapture({
          draggableId: id2,
          movementMode
        }));
        var scrollOptions = {
          shouldPublishImmediately: movementMode === "SNAP"
        };
        var request = {
          draggableId: id2,
          scrollOptions
        };
        var _marshal$startPublish = marshal.startPublishing(request), critical = _marshal$startPublish.critical, dimensions = _marshal$startPublish.dimensions, viewport = _marshal$startPublish.viewport;
        dispatch(initialPublish({
          critical,
          dimensions,
          clientSelection,
          movementMode,
          viewport
        }));
      };
    };
  };
};
var style = function(marshal) {
  return function() {
    return function(next) {
      return function(action) {
        if (action.type === "INITIAL_PUBLISH") {
          marshal.dragging();
        }
        if (action.type === "DROP_ANIMATE") {
          marshal.dropping(action.payload.completed.result.reason);
        }
        if (action.type === "FLUSH" || action.type === "DROP_COMPLETE") {
          marshal.resting();
        }
        next(action);
      };
    };
  };
};
var curves = {
  outOfTheWay: "cubic-bezier(0.2, 0, 0, 1)",
  drop: "cubic-bezier(.2,1,.1,1)"
};
var combine = {
  opacity: {
    drop: 0,
    combining: 0.7
  },
  scale: {
    drop: 0.75
  }
};
var timings = {
  outOfTheWay: 0.2,
  minDropTime: 0.33,
  maxDropTime: 0.55
};
var outOfTheWayTiming = timings.outOfTheWay + "s " + curves.outOfTheWay;
var transitions = {
  fluid: "opacity " + outOfTheWayTiming,
  snap: "transform " + outOfTheWayTiming + ", opacity " + outOfTheWayTiming,
  drop: function drop3(duration) {
    var timing = duration + "s " + curves.drop;
    return "transform " + timing + ", opacity " + timing;
  },
  outOfTheWay: "transform " + outOfTheWayTiming,
  placeholder: "height " + outOfTheWayTiming + ", width " + outOfTheWayTiming + ", margin " + outOfTheWayTiming
};
var moveTo = function moveTo2(offset3) {
  return isEqual(offset3, origin) ? null : "translate(" + offset3.x + "px, " + offset3.y + "px)";
};
var transforms = {
  moveTo,
  drop: function drop4(offset3, isCombining) {
    var translate = moveTo(offset3);
    if (!translate) {
      return null;
    }
    if (!isCombining) {
      return translate;
    }
    return translate + " scale(" + combine.scale.drop + ")";
  }
};
var minDropTime = timings.minDropTime, maxDropTime = timings.maxDropTime;
var dropTimeRange = maxDropTime - minDropTime;
var maxDropTimeAtDistance = 1500;
var cancelDropModifier = 0.6;
var getDropDuration = function(_ref) {
  var current = _ref.current, destination = _ref.destination, reason = _ref.reason;
  var distance$1 = distance(current, destination);
  if (distance$1 <= 0) {
    return minDropTime;
  }
  if (distance$1 >= maxDropTimeAtDistance) {
    return maxDropTime;
  }
  var percentage = distance$1 / maxDropTimeAtDistance;
  var duration = minDropTime + dropTimeRange * percentage;
  var withDuration = reason === "CANCEL" ? duration * cancelDropModifier : duration;
  return Number(withDuration.toFixed(2));
};
var getNewHomeClientOffset = function(_ref) {
  var impact = _ref.impact, draggable2 = _ref.draggable, dimensions = _ref.dimensions, viewport = _ref.viewport, afterCritical = _ref.afterCritical;
  var draggables = dimensions.draggables, droppables = dimensions.droppables;
  var droppableId = whatIsDraggedOver(impact);
  var destination = droppableId ? droppables[droppableId] : null;
  var home2 = droppables[draggable2.descriptor.droppableId];
  var newClientCenter = getClientBorderBoxCenter({
    impact,
    draggable: draggable2,
    draggables,
    afterCritical,
    droppable: destination || home2,
    viewport
  });
  var offset3 = subtract(newClientCenter, draggable2.client.borderBox.center);
  return offset3;
};
var getDropImpact = function(_ref) {
  var draggables = _ref.draggables, reason = _ref.reason, lastImpact = _ref.lastImpact, home2 = _ref.home, viewport = _ref.viewport, onLiftImpact = _ref.onLiftImpact;
  if (!lastImpact.at || reason !== "DROP") {
    var recomputedHomeImpact = recompute({
      draggables,
      impact: onLiftImpact,
      destination: home2,
      viewport,
      forceShouldAnimate: true
    });
    return {
      impact: recomputedHomeImpact,
      didDropInsideDroppable: false
    };
  }
  if (lastImpact.at.type === "REORDER") {
    return {
      impact: lastImpact,
      didDropInsideDroppable: true
    };
  }
  var withoutMovement = _extends({}, lastImpact, {
    displaced: emptyGroups
  });
  return {
    impact: withoutMovement,
    didDropInsideDroppable: true
  };
};
var drop$1 = function(_ref) {
  var getState = _ref.getState, dispatch = _ref.dispatch;
  return function(next) {
    return function(action) {
      if (action.type !== "DROP") {
        next(action);
        return;
      }
      var state = getState();
      var reason = action.payload.reason;
      if (state.phase === "COLLECTING") {
        dispatch(dropPending({
          reason
        }));
        return;
      }
      if (state.phase === "IDLE") {
        return;
      }
      var isWaitingForDrop = state.phase === "DROP_PENDING" && state.isWaiting;
      !!isWaitingForDrop ? invariant(false) : void 0;
      !(state.phase === "DRAGGING" || state.phase === "DROP_PENDING") ? invariant(false) : void 0;
      var critical = state.critical;
      var dimensions = state.dimensions;
      var draggable2 = dimensions.draggables[state.critical.draggable.id];
      var _getDropImpact = getDropImpact({
        reason,
        lastImpact: state.impact,
        afterCritical: state.afterCritical,
        onLiftImpact: state.onLiftImpact,
        home: state.dimensions.droppables[state.critical.droppable.id],
        viewport: state.viewport,
        draggables: state.dimensions.draggables
      }), impact = _getDropImpact.impact, didDropInsideDroppable = _getDropImpact.didDropInsideDroppable;
      var destination = didDropInsideDroppable ? tryGetDestination(impact) : null;
      var combine2 = didDropInsideDroppable ? tryGetCombine(impact) : null;
      var source = {
        index: critical.draggable.index,
        droppableId: critical.droppable.id
      };
      var result = {
        draggableId: draggable2.descriptor.id,
        type: draggable2.descriptor.type,
        source,
        reason,
        mode: state.movementMode,
        destination,
        combine: combine2
      };
      var newHomeClientOffset = getNewHomeClientOffset({
        impact,
        draggable: draggable2,
        dimensions,
        viewport: state.viewport,
        afterCritical: state.afterCritical
      });
      var completed = {
        critical: state.critical,
        afterCritical: state.afterCritical,
        result,
        impact
      };
      var isAnimationRequired = !isEqual(state.current.client.offset, newHomeClientOffset) || Boolean(result.combine);
      if (!isAnimationRequired) {
        dispatch(completeDrop({
          completed
        }));
        return;
      }
      var dropDuration = getDropDuration({
        current: state.current.client.offset,
        destination: newHomeClientOffset,
        reason
      });
      var args = {
        newHomeClientOffset,
        dropDuration,
        completed
      };
      dispatch(animateDrop(args));
    };
  };
};
var getWindowScroll2 = function() {
  return {
    x: window.pageXOffset,
    y: window.pageYOffset
  };
};
function getWindowScrollBinding(update2) {
  return {
    eventName: "scroll",
    options: {
      passive: true,
      capture: false
    },
    fn: function fn2(event) {
      if (event.target !== window && event.target !== window.document) {
        return;
      }
      update2();
    }
  };
}
function getScrollListener(_ref) {
  var onWindowScroll = _ref.onWindowScroll;
  function updateScroll() {
    onWindowScroll(getWindowScroll2());
  }
  var scheduled = rafSchd$1(updateScroll);
  var binding = getWindowScrollBinding(scheduled);
  var unbind = noop;
  function isActive() {
    return unbind !== noop;
  }
  function start() {
    !!isActive() ? invariant(false) : void 0;
    unbind = bindEvents(window, [binding]);
  }
  function stop() {
    !isActive() ? invariant(false) : void 0;
    scheduled.cancel();
    unbind();
    unbind = noop;
  }
  return {
    start,
    stop,
    isActive
  };
}
var shouldEnd = function shouldEnd2(action) {
  return action.type === "DROP_COMPLETE" || action.type === "DROP_ANIMATE" || action.type === "FLUSH";
};
var scrollListener = function(store) {
  var listener = getScrollListener({
    onWindowScroll: function onWindowScroll(newScroll) {
      store.dispatch(moveByWindowScroll({
        newScroll
      }));
    }
  });
  return function(next) {
    return function(action) {
      if (!listener.isActive() && action.type === "INITIAL_PUBLISH") {
        listener.start();
      }
      if (listener.isActive() && shouldEnd(action)) {
        listener.stop();
      }
      next(action);
    };
  };
};
var getExpiringAnnounce = function(announce) {
  var wasCalled = false;
  var isExpired = false;
  var timeoutId2 = setTimeout(function() {
    isExpired = true;
  });
  var result = function result2(message) {
    if (wasCalled) {
      return;
    }
    if (isExpired) {
      return;
    }
    wasCalled = true;
    announce(message);
    clearTimeout(timeoutId2);
  };
  result.wasCalled = function() {
    return wasCalled;
  };
  return result;
};
var getAsyncMarshal = function() {
  var entries = [];
  var execute3 = function execute4(timerId) {
    var index2 = findIndex(entries, function(item) {
      return item.timerId === timerId;
    });
    !(index2 !== -1) ? invariant(false) : void 0;
    var _entries$splice = entries.splice(index2, 1), entry = _entries$splice[0];
    entry.callback();
  };
  var add3 = function add4(fn2) {
    var timerId = setTimeout(function() {
      return execute3(timerId);
    });
    var entry = {
      timerId,
      callback: fn2
    };
    entries.push(entry);
  };
  var flush3 = function flush4() {
    if (!entries.length) {
      return;
    }
    var shallow = [].concat(entries);
    entries.length = 0;
    shallow.forEach(function(entry) {
      clearTimeout(entry.timerId);
      entry.callback();
    });
  };
  return {
    add: add3,
    flush: flush3
  };
};
var areLocationsEqual = function areLocationsEqual2(first, second) {
  if (first == null && second == null) {
    return true;
  }
  if (first == null || second == null) {
    return false;
  }
  return first.droppableId === second.droppableId && first.index === second.index;
};
var isCombineEqual = function isCombineEqual2(first, second) {
  if (first == null && second == null) {
    return true;
  }
  if (first == null || second == null) {
    return false;
  }
  return first.draggableId === second.draggableId && first.droppableId === second.droppableId;
};
var isCriticalEqual = function isCriticalEqual2(first, second) {
  if (first === second) {
    return true;
  }
  var isDraggableEqual = first.draggable.id === second.draggable.id && first.draggable.droppableId === second.draggable.droppableId && first.draggable.type === second.draggable.type && first.draggable.index === second.draggable.index;
  var isDroppableEqual = first.droppable.id === second.droppable.id && first.droppable.type === second.droppable.type;
  return isDraggableEqual && isDroppableEqual;
};
var withTimings = function withTimings2(key, fn2) {
  fn2();
};
var getDragStart = function getDragStart2(critical, mode) {
  return {
    draggableId: critical.draggable.id,
    type: critical.droppable.type,
    source: {
      droppableId: critical.droppable.id,
      index: critical.draggable.index
    },
    mode
  };
};
var execute = function execute2(responder, data, announce, getDefaultMessage) {
  if (!responder) {
    announce(getDefaultMessage(data));
    return;
  }
  var willExpire = getExpiringAnnounce(announce);
  var provided = {
    announce: willExpire
  };
  responder(data, provided);
  if (!willExpire.wasCalled()) {
    announce(getDefaultMessage(data));
  }
};
var getPublisher = function(getResponders, announce) {
  var asyncMarshal = getAsyncMarshal();
  var dragging = null;
  var beforeCapture = function beforeCapture2(draggableId, mode) {
    !!dragging ? invariant(false) : void 0;
    withTimings("onBeforeCapture", function() {
      var fn2 = getResponders().onBeforeCapture;
      if (fn2) {
        var before = {
          draggableId,
          mode
        };
        fn2(before);
      }
    });
  };
  var beforeStart = function beforeStart2(critical, mode) {
    !!dragging ? invariant(false) : void 0;
    withTimings("onBeforeDragStart", function() {
      var fn2 = getResponders().onBeforeDragStart;
      if (fn2) {
        fn2(getDragStart(critical, mode));
      }
    });
  };
  var start = function start2(critical, mode) {
    !!dragging ? invariant(false) : void 0;
    var data = getDragStart(critical, mode);
    dragging = {
      mode,
      lastCritical: critical,
      lastLocation: data.source,
      lastCombine: null
    };
    asyncMarshal.add(function() {
      withTimings("onDragStart", function() {
        return execute(getResponders().onDragStart, data, announce, preset.onDragStart);
      });
    });
  };
  var update2 = function update3(critical, impact) {
    var location2 = tryGetDestination(impact);
    var combine2 = tryGetCombine(impact);
    !dragging ? invariant(false) : void 0;
    var hasCriticalChanged = !isCriticalEqual(critical, dragging.lastCritical);
    if (hasCriticalChanged) {
      dragging.lastCritical = critical;
    }
    var hasLocationChanged = !areLocationsEqual(dragging.lastLocation, location2);
    if (hasLocationChanged) {
      dragging.lastLocation = location2;
    }
    var hasGroupingChanged = !isCombineEqual(dragging.lastCombine, combine2);
    if (hasGroupingChanged) {
      dragging.lastCombine = combine2;
    }
    if (!hasCriticalChanged && !hasLocationChanged && !hasGroupingChanged) {
      return;
    }
    var data = _extends({}, getDragStart(critical, dragging.mode), {
      combine: combine2,
      destination: location2
    });
    asyncMarshal.add(function() {
      withTimings("onDragUpdate", function() {
        return execute(getResponders().onDragUpdate, data, announce, preset.onDragUpdate);
      });
    });
  };
  var flush3 = function flush4() {
    !dragging ? invariant(false) : void 0;
    asyncMarshal.flush();
  };
  var drop5 = function drop6(result) {
    !dragging ? invariant(false) : void 0;
    dragging = null;
    withTimings("onDragEnd", function() {
      return execute(getResponders().onDragEnd, result, announce, preset.onDragEnd);
    });
  };
  var abort = function abort2() {
    if (!dragging) {
      return;
    }
    var result = _extends({}, getDragStart(dragging.lastCritical, dragging.mode), {
      combine: null,
      destination: null,
      reason: "CANCEL"
    });
    drop5(result);
  };
  return {
    beforeCapture,
    beforeStart,
    start,
    update: update2,
    flush: flush3,
    drop: drop5,
    abort
  };
};
var responders = function(getResponders, announce) {
  var publisher = getPublisher(getResponders, announce);
  return function(store) {
    return function(next) {
      return function(action) {
        if (action.type === "BEFORE_INITIAL_CAPTURE") {
          publisher.beforeCapture(action.payload.draggableId, action.payload.movementMode);
          return;
        }
        if (action.type === "INITIAL_PUBLISH") {
          var critical = action.payload.critical;
          publisher.beforeStart(critical, action.payload.movementMode);
          next(action);
          publisher.start(critical, action.payload.movementMode);
          return;
        }
        if (action.type === "DROP_COMPLETE") {
          var result = action.payload.completed.result;
          publisher.flush();
          next(action);
          publisher.drop(result);
          return;
        }
        next(action);
        if (action.type === "FLUSH") {
          publisher.abort();
          return;
        }
        var state = store.getState();
        if (state.phase === "DRAGGING") {
          publisher.update(state.critical, state.impact);
        }
      };
    };
  };
};
var dropAnimationFinish = function(store) {
  return function(next) {
    return function(action) {
      if (action.type !== "DROP_ANIMATION_FINISHED") {
        next(action);
        return;
      }
      var state = store.getState();
      !(state.phase === "DROP_ANIMATING") ? invariant(false) : void 0;
      store.dispatch(completeDrop({
        completed: state.completed
      }));
    };
  };
};
var dropAnimationFlushOnScroll = function(store) {
  var unbind = null;
  var frameId = null;
  function clear() {
    if (frameId) {
      cancelAnimationFrame(frameId);
      frameId = null;
    }
    if (unbind) {
      unbind();
      unbind = null;
    }
  }
  return function(next) {
    return function(action) {
      if (action.type === "FLUSH" || action.type === "DROP_COMPLETE" || action.type === "DROP_ANIMATION_FINISHED") {
        clear();
      }
      next(action);
      if (action.type !== "DROP_ANIMATE") {
        return;
      }
      var binding = {
        eventName: "scroll",
        options: {
          capture: true,
          passive: false,
          once: true
        },
        fn: function flushDropAnimation() {
          var state = store.getState();
          if (state.phase === "DROP_ANIMATING") {
            store.dispatch(dropAnimationFinished());
          }
        }
      };
      frameId = requestAnimationFrame(function() {
        frameId = null;
        unbind = bindEvents(window, [binding]);
      });
    };
  };
};
var dimensionMarshalStopper = function(marshal) {
  return function() {
    return function(next) {
      return function(action) {
        if (action.type === "DROP_COMPLETE" || action.type === "FLUSH" || action.type === "DROP_ANIMATE") {
          marshal.stopPublishing();
        }
        next(action);
      };
    };
  };
};
var focus = function(marshal) {
  var isWatching = false;
  return function() {
    return function(next) {
      return function(action) {
        if (action.type === "INITIAL_PUBLISH") {
          isWatching = true;
          marshal.tryRecordFocus(action.payload.critical.draggable.id);
          next(action);
          marshal.tryRestoreFocusRecorded();
          return;
        }
        next(action);
        if (!isWatching) {
          return;
        }
        if (action.type === "FLUSH") {
          isWatching = false;
          marshal.tryRestoreFocusRecorded();
          return;
        }
        if (action.type === "DROP_COMPLETE") {
          isWatching = false;
          var result = action.payload.completed.result;
          if (result.combine) {
            marshal.tryShiftRecord(result.draggableId, result.combine.draggableId);
          }
          marshal.tryRestoreFocusRecorded();
        }
      };
    };
  };
};
var shouldStop = function shouldStop2(action) {
  return action.type === "DROP_COMPLETE" || action.type === "DROP_ANIMATE" || action.type === "FLUSH";
};
var autoScroll = function(autoScroller) {
  return function(store) {
    return function(next) {
      return function(action) {
        if (shouldStop(action)) {
          autoScroller.stop();
          next(action);
          return;
        }
        if (action.type === "INITIAL_PUBLISH") {
          next(action);
          var state = store.getState();
          !(state.phase === "DRAGGING") ? invariant(false) : void 0;
          autoScroller.start(state);
          return;
        }
        next(action);
        autoScroller.scroll(store.getState());
      };
    };
  };
};
var pendingDrop = function(store) {
  return function(next) {
    return function(action) {
      next(action);
      if (action.type !== "PUBLISH_WHILE_DRAGGING") {
        return;
      }
      var postActionState = store.getState();
      if (postActionState.phase !== "DROP_PENDING") {
        return;
      }
      if (postActionState.isWaiting) {
        return;
      }
      store.dispatch(drop({
        reason: postActionState.reason
      }));
    };
  };
};
var composeEnhancers = compose;
var createStore = function(_ref) {
  var dimensionMarshal = _ref.dimensionMarshal, focusMarshal = _ref.focusMarshal, styleMarshal = _ref.styleMarshal, getResponders = _ref.getResponders, announce = _ref.announce, autoScroller = _ref.autoScroller;
  return createStore$1(reducer, composeEnhancers(applyMiddleware(style(styleMarshal), dimensionMarshalStopper(dimensionMarshal), lift$1(dimensionMarshal), drop$1, dropAnimationFinish, dropAnimationFlushOnScroll, pendingDrop, autoScroll(autoScroller), scrollListener, focus(focusMarshal), responders(getResponders, announce))));
};
var clean$1 = function clean() {
  return {
    additions: {},
    removals: {},
    modified: {}
  };
};
function createPublisher(_ref) {
  var registry = _ref.registry, callbacks = _ref.callbacks;
  var staging2 = clean$1();
  var frameId = null;
  var collect = function collect2() {
    if (frameId) {
      return;
    }
    callbacks.collectionStarting();
    frameId = requestAnimationFrame(function() {
      frameId = null;
      var _staging = staging2, additions = _staging.additions, removals = _staging.removals, modified = _staging.modified;
      var added = Object.keys(additions).map(function(id2) {
        return registry.draggable.getById(id2).getDimension(origin);
      }).sort(function(a2, b2) {
        return a2.descriptor.index - b2.descriptor.index;
      });
      var updated = Object.keys(modified).map(function(id2) {
        var entry = registry.droppable.getById(id2);
        var scroll3 = entry.callbacks.getScrollWhileDragging();
        return {
          droppableId: id2,
          scroll: scroll3
        };
      });
      var result = {
        additions: added,
        removals: Object.keys(removals),
        modified: updated
      };
      staging2 = clean$1();
      callbacks.publish(result);
    });
  };
  var add3 = function add4(entry) {
    var id2 = entry.descriptor.id;
    staging2.additions[id2] = entry;
    staging2.modified[entry.descriptor.droppableId] = true;
    if (staging2.removals[id2]) {
      delete staging2.removals[id2];
    }
    collect();
  };
  var remove = function remove2(entry) {
    var descriptor = entry.descriptor;
    staging2.removals[descriptor.id] = true;
    staging2.modified[descriptor.droppableId] = true;
    if (staging2.additions[descriptor.id]) {
      delete staging2.additions[descriptor.id];
    }
    collect();
  };
  var stop = function stop2() {
    if (!frameId) {
      return;
    }
    cancelAnimationFrame(frameId);
    frameId = null;
    staging2 = clean$1();
  };
  return {
    add: add3,
    remove,
    stop
  };
}
var getMaxScroll = function(_ref) {
  var scrollHeight = _ref.scrollHeight, scrollWidth = _ref.scrollWidth, height = _ref.height, width = _ref.width;
  var maxScroll = subtract({
    x: scrollWidth,
    y: scrollHeight
  }, {
    x: width,
    y: height
  });
  var adjustedMaxScroll = {
    x: Math.max(0, maxScroll.x),
    y: Math.max(0, maxScroll.y)
  };
  return adjustedMaxScroll;
};
var getDocumentElement = function() {
  var doc = document.documentElement;
  !doc ? invariant(false) : void 0;
  return doc;
};
var getMaxWindowScroll = function() {
  var doc = getDocumentElement();
  var maxScroll = getMaxScroll({
    scrollHeight: doc.scrollHeight,
    scrollWidth: doc.scrollWidth,
    width: doc.clientWidth,
    height: doc.clientHeight
  });
  return maxScroll;
};
var getViewport = function() {
  var scroll3 = getWindowScroll2();
  var maxScroll = getMaxWindowScroll();
  var top = scroll3.y;
  var left = scroll3.x;
  var doc = getDocumentElement();
  var width = doc.clientWidth;
  var height = doc.clientHeight;
  var right = left + width;
  var bottom = top + height;
  var frame = getRect({
    top,
    left,
    right,
    bottom
  });
  var viewport = {
    frame,
    scroll: {
      initial: scroll3,
      current: scroll3,
      max: maxScroll,
      diff: {
        value: origin,
        displacement: origin
      }
    }
  };
  return viewport;
};
var getInitialPublish = function(_ref) {
  var critical = _ref.critical, scrollOptions = _ref.scrollOptions, registry = _ref.registry;
  var viewport = getViewport();
  var windowScroll = viewport.scroll.current;
  var home2 = critical.droppable;
  var droppables = registry.droppable.getAllByType(home2.type).map(function(entry) {
    return entry.callbacks.getDimensionAndWatchScroll(windowScroll, scrollOptions);
  });
  var draggables = registry.draggable.getAllByType(critical.draggable.type).map(function(entry) {
    return entry.getDimension(windowScroll);
  });
  var dimensions = {
    draggables: toDraggableMap(draggables),
    droppables: toDroppableMap(droppables)
  };
  var result = {
    dimensions,
    critical,
    viewport
  };
  return result;
};
function shouldPublishUpdate(registry, dragging, entry) {
  if (entry.descriptor.id === dragging.id) {
    return false;
  }
  if (entry.descriptor.type !== dragging.type) {
    return false;
  }
  var home2 = registry.droppable.getById(entry.descriptor.droppableId);
  if (home2.descriptor.mode !== "virtual") {
    return false;
  }
  return true;
}
var createDimensionMarshal = function(registry, callbacks) {
  var collection = null;
  var publisher = createPublisher({
    callbacks: {
      publish: callbacks.publishWhileDragging,
      collectionStarting: callbacks.collectionStarting
    },
    registry
  });
  var updateDroppableIsEnabled3 = function updateDroppableIsEnabled4(id2, isEnabled) {
    !registry.droppable.exists(id2) ? invariant(false) : void 0;
    if (!collection) {
      return;
    }
    callbacks.updateDroppableIsEnabled({
      id: id2,
      isEnabled
    });
  };
  var updateDroppableIsCombineEnabled3 = function updateDroppableIsCombineEnabled4(id2, isCombineEnabled) {
    if (!collection) {
      return;
    }
    !registry.droppable.exists(id2) ? invariant(false) : void 0;
    callbacks.updateDroppableIsCombineEnabled({
      id: id2,
      isCombineEnabled
    });
  };
  var updateDroppableScroll3 = function updateDroppableScroll4(id2, newScroll) {
    if (!collection) {
      return;
    }
    !registry.droppable.exists(id2) ? invariant(false) : void 0;
    callbacks.updateDroppableScroll({
      id: id2,
      newScroll
    });
  };
  var scrollDroppable2 = function scrollDroppable3(id2, change) {
    if (!collection) {
      return;
    }
    registry.droppable.getById(id2).callbacks.scroll(change);
  };
  var stopPublishing = function stopPublishing2() {
    if (!collection) {
      return;
    }
    publisher.stop();
    var home2 = collection.critical.droppable;
    registry.droppable.getAllByType(home2.type).forEach(function(entry) {
      return entry.callbacks.dragStopped();
    });
    collection.unsubscribe();
    collection = null;
  };
  var subscriber = function subscriber2(event) {
    !collection ? invariant(false) : void 0;
    var dragging = collection.critical.draggable;
    if (event.type === "ADDITION") {
      if (shouldPublishUpdate(registry, dragging, event.value)) {
        publisher.add(event.value);
      }
    }
    if (event.type === "REMOVAL") {
      if (shouldPublishUpdate(registry, dragging, event.value)) {
        publisher.remove(event.value);
      }
    }
  };
  var startPublishing = function startPublishing2(request) {
    !!collection ? invariant(false) : void 0;
    var entry = registry.draggable.getById(request.draggableId);
    var home2 = registry.droppable.getById(entry.descriptor.droppableId);
    var critical = {
      draggable: entry.descriptor,
      droppable: home2.descriptor
    };
    var unsubscribe = registry.subscribe(subscriber);
    collection = {
      critical,
      unsubscribe
    };
    return getInitialPublish({
      critical,
      registry,
      scrollOptions: request.scrollOptions
    });
  };
  var marshal = {
    updateDroppableIsEnabled: updateDroppableIsEnabled3,
    updateDroppableIsCombineEnabled: updateDroppableIsCombineEnabled3,
    scrollDroppable: scrollDroppable2,
    updateDroppableScroll: updateDroppableScroll3,
    startPublishing,
    stopPublishing
  };
  return marshal;
};
var canStartDrag = function(state, id2) {
  if (state.phase === "IDLE") {
    return true;
  }
  if (state.phase !== "DROP_ANIMATING") {
    return false;
  }
  if (state.completed.result.draggableId === id2) {
    return false;
  }
  return state.completed.result.reason === "DROP";
};
var scrollWindow = function(change) {
  window.scrollBy(change.x, change.y);
};
var getScrollableDroppables = memoizeOne(function(droppables) {
  return toDroppableList(droppables).filter(function(droppable2) {
    if (!droppable2.isEnabled) {
      return false;
    }
    if (!droppable2.frame) {
      return false;
    }
    return true;
  });
});
var getScrollableDroppableOver = function getScrollableDroppableOver2(target, droppables) {
  var maybe = find(getScrollableDroppables(droppables), function(droppable2) {
    !droppable2.frame ? invariant(false) : void 0;
    return isPositionInFrame(droppable2.frame.pageMarginBox)(target);
  });
  return maybe;
};
var getBestScrollableDroppable = function(_ref) {
  var center = _ref.center, destination = _ref.destination, droppables = _ref.droppables;
  if (destination) {
    var _dimension = droppables[destination];
    if (!_dimension.frame) {
      return null;
    }
    return _dimension;
  }
  var dimension = getScrollableDroppableOver(center, droppables);
  return dimension;
};
var config = {
  startFromPercentage: 0.25,
  maxScrollAtPercentage: 0.05,
  maxPixelScroll: 28,
  ease: function ease(percentage) {
    return Math.pow(percentage, 2);
  },
  durationDampening: {
    stopDampeningAt: 1200,
    accelerateAt: 360
  }
};
var getDistanceThresholds = function(container, axis) {
  var startScrollingFrom = container[axis.size] * config.startFromPercentage;
  var maxScrollValueAt = container[axis.size] * config.maxScrollAtPercentage;
  var thresholds = {
    startScrollingFrom,
    maxScrollValueAt
  };
  return thresholds;
};
var getPercentage = function(_ref) {
  var startOfRange = _ref.startOfRange, endOfRange = _ref.endOfRange, current = _ref.current;
  var range2 = endOfRange - startOfRange;
  if (range2 === 0) {
    return 0;
  }
  var currentInRange = current - startOfRange;
  var percentage = currentInRange / range2;
  return percentage;
};
var minScroll = 1;
var getValueFromDistance = function(distanceToEdge, thresholds) {
  if (distanceToEdge > thresholds.startScrollingFrom) {
    return 0;
  }
  if (distanceToEdge <= thresholds.maxScrollValueAt) {
    return config.maxPixelScroll;
  }
  if (distanceToEdge === thresholds.startScrollingFrom) {
    return minScroll;
  }
  var percentageFromMaxScrollValueAt = getPercentage({
    startOfRange: thresholds.maxScrollValueAt,
    endOfRange: thresholds.startScrollingFrom,
    current: distanceToEdge
  });
  var percentageFromStartScrollingFrom = 1 - percentageFromMaxScrollValueAt;
  var scroll3 = config.maxPixelScroll * config.ease(percentageFromStartScrollingFrom);
  return Math.ceil(scroll3);
};
var accelerateAt = config.durationDampening.accelerateAt;
var stopAt = config.durationDampening.stopDampeningAt;
var dampenValueByTime = function(proposedScroll, dragStartTime) {
  var startOfRange = dragStartTime;
  var endOfRange = stopAt;
  var now = Date.now();
  var runTime = now - startOfRange;
  if (runTime >= stopAt) {
    return proposedScroll;
  }
  if (runTime < accelerateAt) {
    return minScroll;
  }
  var betweenAccelerateAtAndStopAtPercentage = getPercentage({
    startOfRange: accelerateAt,
    endOfRange,
    current: runTime
  });
  var scroll3 = proposedScroll * config.ease(betweenAccelerateAtAndStopAtPercentage);
  return Math.ceil(scroll3);
};
var getValue = function(_ref) {
  var distanceToEdge = _ref.distanceToEdge, thresholds = _ref.thresholds, dragStartTime = _ref.dragStartTime, shouldUseTimeDampening = _ref.shouldUseTimeDampening;
  var scroll3 = getValueFromDistance(distanceToEdge, thresholds);
  if (scroll3 === 0) {
    return 0;
  }
  if (!shouldUseTimeDampening) {
    return scroll3;
  }
  return Math.max(dampenValueByTime(scroll3, dragStartTime), minScroll);
};
var getScrollOnAxis = function(_ref) {
  var container = _ref.container, distanceToEdges = _ref.distanceToEdges, dragStartTime = _ref.dragStartTime, axis = _ref.axis, shouldUseTimeDampening = _ref.shouldUseTimeDampening;
  var thresholds = getDistanceThresholds(container, axis);
  var isCloserToEnd = distanceToEdges[axis.end] < distanceToEdges[axis.start];
  if (isCloserToEnd) {
    return getValue({
      distanceToEdge: distanceToEdges[axis.end],
      thresholds,
      dragStartTime,
      shouldUseTimeDampening
    });
  }
  return -1 * getValue({
    distanceToEdge: distanceToEdges[axis.start],
    thresholds,
    dragStartTime,
    shouldUseTimeDampening
  });
};
var adjustForSizeLimits = function(_ref) {
  var container = _ref.container, subject = _ref.subject, proposedScroll = _ref.proposedScroll;
  var isTooBigVertically = subject.height > container.height;
  var isTooBigHorizontally = subject.width > container.width;
  if (!isTooBigHorizontally && !isTooBigVertically) {
    return proposedScroll;
  }
  if (isTooBigHorizontally && isTooBigVertically) {
    return null;
  }
  return {
    x: isTooBigHorizontally ? 0 : proposedScroll.x,
    y: isTooBigVertically ? 0 : proposedScroll.y
  };
};
var clean$2 = apply(function(value) {
  return value === 0 ? 0 : value;
});
var getScroll = function(_ref) {
  var dragStartTime = _ref.dragStartTime, container = _ref.container, subject = _ref.subject, center = _ref.center, shouldUseTimeDampening = _ref.shouldUseTimeDampening;
  var distanceToEdges = {
    top: center.y - container.top,
    right: container.right - center.x,
    bottom: container.bottom - center.y,
    left: center.x - container.left
  };
  var y2 = getScrollOnAxis({
    container,
    distanceToEdges,
    dragStartTime,
    axis: vertical,
    shouldUseTimeDampening
  });
  var x = getScrollOnAxis({
    container,
    distanceToEdges,
    dragStartTime,
    axis: horizontal,
    shouldUseTimeDampening
  });
  var required = clean$2({
    x,
    y: y2
  });
  if (isEqual(required, origin)) {
    return null;
  }
  var limited = adjustForSizeLimits({
    container,
    subject,
    proposedScroll: required
  });
  if (!limited) {
    return null;
  }
  return isEqual(limited, origin) ? null : limited;
};
var smallestSigned = apply(function(value) {
  if (value === 0) {
    return 0;
  }
  return value > 0 ? 1 : -1;
});
var getOverlap = function() {
  var getRemainder = function getRemainder2(target, max2) {
    if (target < 0) {
      return target;
    }
    if (target > max2) {
      return target - max2;
    }
    return 0;
  };
  return function(_ref) {
    var current = _ref.current, max2 = _ref.max, change = _ref.change;
    var targetScroll = add(current, change);
    var overlap = {
      x: getRemainder(targetScroll.x, max2.x),
      y: getRemainder(targetScroll.y, max2.y)
    };
    if (isEqual(overlap, origin)) {
      return null;
    }
    return overlap;
  };
}();
var canPartiallyScroll = function canPartiallyScroll2(_ref2) {
  var rawMax = _ref2.max, current = _ref2.current, change = _ref2.change;
  var max2 = {
    x: Math.max(current.x, rawMax.x),
    y: Math.max(current.y, rawMax.y)
  };
  var smallestChange = smallestSigned(change);
  var overlap = getOverlap({
    max: max2,
    current,
    change: smallestChange
  });
  if (!overlap) {
    return true;
  }
  if (smallestChange.x !== 0 && overlap.x === 0) {
    return true;
  }
  if (smallestChange.y !== 0 && overlap.y === 0) {
    return true;
  }
  return false;
};
var canScrollWindow = function canScrollWindow2(viewport, change) {
  return canPartiallyScroll({
    current: viewport.scroll.current,
    max: viewport.scroll.max,
    change
  });
};
var getWindowOverlap = function getWindowOverlap2(viewport, change) {
  if (!canScrollWindow(viewport, change)) {
    return null;
  }
  var max2 = viewport.scroll.max;
  var current = viewport.scroll.current;
  return getOverlap({
    current,
    max: max2,
    change
  });
};
var canScrollDroppable = function canScrollDroppable2(droppable2, change) {
  var frame = droppable2.frame;
  if (!frame) {
    return false;
  }
  return canPartiallyScroll({
    current: frame.scroll.current,
    max: frame.scroll.max,
    change
  });
};
var getDroppableOverlap = function getDroppableOverlap2(droppable2, change) {
  var frame = droppable2.frame;
  if (!frame) {
    return null;
  }
  if (!canScrollDroppable(droppable2, change)) {
    return null;
  }
  return getOverlap({
    current: frame.scroll.current,
    max: frame.scroll.max,
    change
  });
};
var getWindowScrollChange = function(_ref) {
  var viewport = _ref.viewport, subject = _ref.subject, center = _ref.center, dragStartTime = _ref.dragStartTime, shouldUseTimeDampening = _ref.shouldUseTimeDampening;
  var scroll3 = getScroll({
    dragStartTime,
    container: viewport.frame,
    subject,
    center,
    shouldUseTimeDampening
  });
  return scroll3 && canScrollWindow(viewport, scroll3) ? scroll3 : null;
};
var getDroppableScrollChange = function(_ref) {
  var droppable2 = _ref.droppable, subject = _ref.subject, center = _ref.center, dragStartTime = _ref.dragStartTime, shouldUseTimeDampening = _ref.shouldUseTimeDampening;
  var frame = droppable2.frame;
  if (!frame) {
    return null;
  }
  var scroll3 = getScroll({
    dragStartTime,
    container: frame.pageMarginBox,
    subject,
    center,
    shouldUseTimeDampening
  });
  return scroll3 && canScrollDroppable(droppable2, scroll3) ? scroll3 : null;
};
var scroll$1 = function(_ref) {
  var state = _ref.state, dragStartTime = _ref.dragStartTime, shouldUseTimeDampening = _ref.shouldUseTimeDampening, scrollWindow2 = _ref.scrollWindow, scrollDroppable2 = _ref.scrollDroppable;
  var center = state.current.page.borderBoxCenter;
  var draggable2 = state.dimensions.draggables[state.critical.draggable.id];
  var subject = draggable2.page.marginBox;
  if (state.isWindowScrollAllowed) {
    var viewport = state.viewport;
    var _change = getWindowScrollChange({
      dragStartTime,
      viewport,
      subject,
      center,
      shouldUseTimeDampening
    });
    if (_change) {
      scrollWindow2(_change);
      return;
    }
  }
  var droppable2 = getBestScrollableDroppable({
    center,
    destination: whatIsDraggedOver(state.impact),
    droppables: state.dimensions.droppables
  });
  if (!droppable2) {
    return;
  }
  var change = getDroppableScrollChange({
    dragStartTime,
    droppable: droppable2,
    subject,
    center,
    shouldUseTimeDampening
  });
  if (change) {
    scrollDroppable2(droppable2.descriptor.id, change);
  }
};
var createFluidScroller = function(_ref) {
  var scrollWindow2 = _ref.scrollWindow, scrollDroppable2 = _ref.scrollDroppable;
  var scheduleWindowScroll = rafSchd$1(scrollWindow2);
  var scheduleDroppableScroll = rafSchd$1(scrollDroppable2);
  var dragging = null;
  var tryScroll = function tryScroll2(state) {
    !dragging ? invariant(false) : void 0;
    var _dragging = dragging, shouldUseTimeDampening = _dragging.shouldUseTimeDampening, dragStartTime = _dragging.dragStartTime;
    scroll$1({
      state,
      scrollWindow: scheduleWindowScroll,
      scrollDroppable: scheduleDroppableScroll,
      dragStartTime,
      shouldUseTimeDampening
    });
  };
  var start$1 = function start$12(state) {
    !!dragging ? invariant(false) : void 0;
    var dragStartTime = Date.now();
    var wasScrollNeeded = false;
    var fakeScrollCallback = function fakeScrollCallback2() {
      wasScrollNeeded = true;
    };
    scroll$1({
      state,
      dragStartTime: 0,
      shouldUseTimeDampening: false,
      scrollWindow: fakeScrollCallback,
      scrollDroppable: fakeScrollCallback
    });
    dragging = {
      dragStartTime,
      shouldUseTimeDampening: wasScrollNeeded
    };
    if (wasScrollNeeded) {
      tryScroll(state);
    }
  };
  var stop = function stop2() {
    if (!dragging) {
      return;
    }
    scheduleWindowScroll.cancel();
    scheduleDroppableScroll.cancel();
    dragging = null;
  };
  return {
    start: start$1,
    stop,
    scroll: tryScroll
  };
};
var createJumpScroller = function(_ref) {
  var move3 = _ref.move, scrollDroppable2 = _ref.scrollDroppable, scrollWindow2 = _ref.scrollWindow;
  var moveByOffset = function moveByOffset2(state, offset3) {
    var client2 = add(state.current.client.selection, offset3);
    move3({
      client: client2
    });
  };
  var scrollDroppableAsMuchAsItCan = function scrollDroppableAsMuchAsItCan2(droppable2, change) {
    if (!canScrollDroppable(droppable2, change)) {
      return change;
    }
    var overlap = getDroppableOverlap(droppable2, change);
    if (!overlap) {
      scrollDroppable2(droppable2.descriptor.id, change);
      return null;
    }
    var whatTheDroppableCanScroll = subtract(change, overlap);
    scrollDroppable2(droppable2.descriptor.id, whatTheDroppableCanScroll);
    var remainder = subtract(change, whatTheDroppableCanScroll);
    return remainder;
  };
  var scrollWindowAsMuchAsItCan = function scrollWindowAsMuchAsItCan2(isWindowScrollAllowed, viewport, change) {
    if (!isWindowScrollAllowed) {
      return change;
    }
    if (!canScrollWindow(viewport, change)) {
      return change;
    }
    var overlap = getWindowOverlap(viewport, change);
    if (!overlap) {
      scrollWindow2(change);
      return null;
    }
    var whatTheWindowCanScroll = subtract(change, overlap);
    scrollWindow2(whatTheWindowCanScroll);
    var remainder = subtract(change, whatTheWindowCanScroll);
    return remainder;
  };
  var jumpScroller = function jumpScroller2(state) {
    var request = state.scrollJumpRequest;
    if (!request) {
      return;
    }
    var destination = whatIsDraggedOver(state.impact);
    !destination ? invariant(false) : void 0;
    var droppableRemainder = scrollDroppableAsMuchAsItCan(state.dimensions.droppables[destination], request);
    if (!droppableRemainder) {
      return;
    }
    var viewport = state.viewport;
    var windowRemainder = scrollWindowAsMuchAsItCan(state.isWindowScrollAllowed, viewport, droppableRemainder);
    if (!windowRemainder) {
      return;
    }
    moveByOffset(state, windowRemainder);
  };
  return jumpScroller;
};
var createAutoScroller = function(_ref) {
  var scrollDroppable2 = _ref.scrollDroppable, scrollWindow2 = _ref.scrollWindow, move3 = _ref.move;
  var fluidScroller = createFluidScroller({
    scrollWindow: scrollWindow2,
    scrollDroppable: scrollDroppable2
  });
  var jumpScroll = createJumpScroller({
    move: move3,
    scrollWindow: scrollWindow2,
    scrollDroppable: scrollDroppable2
  });
  var scroll3 = function scroll4(state) {
    if (state.phase !== "DRAGGING") {
      return;
    }
    if (state.movementMode === "FLUID") {
      fluidScroller.scroll(state);
      return;
    }
    if (!state.scrollJumpRequest) {
      return;
    }
    jumpScroll(state);
  };
  var scroller = {
    scroll: scroll3,
    start: fluidScroller.start,
    stop: fluidScroller.stop
  };
  return scroller;
};
var prefix$1 = "data-rbd";
var dragHandle = function() {
  var base = prefix$1 + "-drag-handle";
  return {
    base,
    draggableId: base + "-draggable-id",
    contextId: base + "-context-id"
  };
}();
var draggable = function() {
  var base = prefix$1 + "-draggable";
  return {
    base,
    contextId: base + "-context-id",
    id: base + "-id"
  };
}();
var droppable = function() {
  var base = prefix$1 + "-droppable";
  return {
    base,
    contextId: base + "-context-id",
    id: base + "-id"
  };
}();
var scrollContainer = {
  contextId: prefix$1 + "-scroll-container-context-id"
};
var makeGetSelector = function makeGetSelector2(context) {
  return function(attribute) {
    return "[" + attribute + '="' + context + '"]';
  };
};
var getStyles = function getStyles2(rules, property) {
  return rules.map(function(rule) {
    var value = rule.styles[property];
    if (!value) {
      return "";
    }
    return rule.selector + " { " + value + " }";
  }).join(" ");
};
var noPointerEvents = "pointer-events: none;";
var getStyles$1 = function(contextId) {
  var getSelector2 = makeGetSelector(contextId);
  var dragHandle$1 = function() {
    var grabCursor = "\n      cursor: -webkit-grab;\n      cursor: grab;\n    ";
    return {
      selector: getSelector2(dragHandle.contextId),
      styles: {
        always: "\n          -webkit-touch-callout: none;\n          -webkit-tap-highlight-color: rgba(0,0,0,0);\n          touch-action: manipulation;\n        ",
        resting: grabCursor,
        dragging: noPointerEvents,
        dropAnimating: grabCursor
      }
    };
  }();
  var draggable$1 = function() {
    var transition = "\n      transition: " + transitions.outOfTheWay + ";\n    ";
    return {
      selector: getSelector2(draggable.contextId),
      styles: {
        dragging: transition,
        dropAnimating: transition,
        userCancel: transition
      }
    };
  }();
  var droppable$1 = {
    selector: getSelector2(droppable.contextId),
    styles: {
      always: "overflow-anchor: none;"
    }
  };
  var body = {
    selector: "body",
    styles: {
      dragging: "\n        cursor: grabbing;\n        cursor: -webkit-grabbing;\n        user-select: none;\n        -webkit-user-select: none;\n        -moz-user-select: none;\n        -ms-user-select: none;\n        overflow-anchor: none;\n      "
    }
  };
  var rules = [draggable$1, dragHandle$1, droppable$1, body];
  return {
    always: getStyles(rules, "always"),
    resting: getStyles(rules, "resting"),
    dragging: getStyles(rules, "dragging"),
    dropAnimating: getStyles(rules, "dropAnimating"),
    userCancel: getStyles(rules, "userCancel")
  };
};
var useIsomorphicLayoutEffect = typeof window !== "undefined" && typeof window.document !== "undefined" && typeof window.document.createElement !== "undefined" ? reactExports.useLayoutEffect : reactExports.useEffect;
var getHead = function getHead2() {
  var head = document.querySelector("head");
  !head ? invariant(false) : void 0;
  return head;
};
var createStyleEl = function createStyleEl2(nonce) {
  var el2 = document.createElement("style");
  if (nonce) {
    el2.setAttribute("nonce", nonce);
  }
  el2.type = "text/css";
  return el2;
};
function useStyleMarshal(contextId, nonce) {
  var styles = useMemo(function() {
    return getStyles$1(contextId);
  }, [contextId]);
  var alwaysRef = reactExports.useRef(null);
  var dynamicRef = reactExports.useRef(null);
  var setDynamicStyle = useCallback(memoizeOne(function(proposed) {
    var el2 = dynamicRef.current;
    !el2 ? invariant(false) : void 0;
    el2.textContent = proposed;
  }), []);
  var setAlwaysStyle = useCallback(function(proposed) {
    var el2 = alwaysRef.current;
    !el2 ? invariant(false) : void 0;
    el2.textContent = proposed;
  }, []);
  useIsomorphicLayoutEffect(function() {
    !(!alwaysRef.current && !dynamicRef.current) ? invariant(false) : void 0;
    var always = createStyleEl(nonce);
    var dynamic = createStyleEl(nonce);
    alwaysRef.current = always;
    dynamicRef.current = dynamic;
    always.setAttribute(prefix$1 + "-always", contextId);
    dynamic.setAttribute(prefix$1 + "-dynamic", contextId);
    getHead().appendChild(always);
    getHead().appendChild(dynamic);
    setAlwaysStyle(styles.always);
    setDynamicStyle(styles.resting);
    return function() {
      var remove = function remove2(ref) {
        var current = ref.current;
        !current ? invariant(false) : void 0;
        getHead().removeChild(current);
        ref.current = null;
      };
      remove(alwaysRef);
      remove(dynamicRef);
    };
  }, [nonce, setAlwaysStyle, setDynamicStyle, styles.always, styles.resting, contextId]);
  var dragging = useCallback(function() {
    return setDynamicStyle(styles.dragging);
  }, [setDynamicStyle, styles.dragging]);
  var dropping = useCallback(function(reason) {
    if (reason === "DROP") {
      setDynamicStyle(styles.dropAnimating);
      return;
    }
    setDynamicStyle(styles.userCancel);
  }, [setDynamicStyle, styles.dropAnimating, styles.userCancel]);
  var resting = useCallback(function() {
    if (!dynamicRef.current) {
      return;
    }
    setDynamicStyle(styles.resting);
  }, [setDynamicStyle, styles.resting]);
  var marshal = useMemo(function() {
    return {
      dragging,
      dropping,
      resting
    };
  }, [dragging, dropping, resting]);
  return marshal;
}
var getWindowFromEl = function(el2) {
  return el2 && el2.ownerDocument ? el2.ownerDocument.defaultView : window;
};
function isHtmlElement(el2) {
  return el2 instanceof getWindowFromEl(el2).HTMLElement;
}
function findDragHandle(contextId, draggableId) {
  var selector2 = "[" + dragHandle.contextId + '="' + contextId + '"]';
  var possible = toArray(document.querySelectorAll(selector2));
  if (!possible.length) {
    return null;
  }
  var handle = find(possible, function(el2) {
    return el2.getAttribute(dragHandle.draggableId) === draggableId;
  });
  if (!handle) {
    return null;
  }
  if (!isHtmlElement(handle)) {
    return null;
  }
  return handle;
}
function useFocusMarshal(contextId) {
  var entriesRef = reactExports.useRef({});
  var recordRef = reactExports.useRef(null);
  var restoreFocusFrameRef = reactExports.useRef(null);
  var isMountedRef = reactExports.useRef(false);
  var register = useCallback(function register2(id2, focus2) {
    var entry = {
      id: id2,
      focus: focus2
    };
    entriesRef.current[id2] = entry;
    return function unregister() {
      var entries = entriesRef.current;
      var current = entries[id2];
      if (current !== entry) {
        delete entries[id2];
      }
    };
  }, []);
  var tryGiveFocus = useCallback(function tryGiveFocus2(tryGiveFocusTo) {
    var handle = findDragHandle(contextId, tryGiveFocusTo);
    if (handle && handle !== document.activeElement) {
      handle.focus();
    }
  }, [contextId]);
  var tryShiftRecord = useCallback(function tryShiftRecord2(previous, redirectTo) {
    if (recordRef.current === previous) {
      recordRef.current = redirectTo;
    }
  }, []);
  var tryRestoreFocusRecorded = useCallback(function tryRestoreFocusRecorded2() {
    if (restoreFocusFrameRef.current) {
      return;
    }
    if (!isMountedRef.current) {
      return;
    }
    restoreFocusFrameRef.current = requestAnimationFrame(function() {
      restoreFocusFrameRef.current = null;
      var record = recordRef.current;
      if (record) {
        tryGiveFocus(record);
      }
    });
  }, [tryGiveFocus]);
  var tryRecordFocus = useCallback(function tryRecordFocus2(id2) {
    recordRef.current = null;
    var focused = document.activeElement;
    if (!focused) {
      return;
    }
    if (focused.getAttribute(dragHandle.draggableId) !== id2) {
      return;
    }
    recordRef.current = id2;
  }, []);
  useIsomorphicLayoutEffect(function() {
    isMountedRef.current = true;
    return function clearFrameOnUnmount() {
      isMountedRef.current = false;
      var frameId = restoreFocusFrameRef.current;
      if (frameId) {
        cancelAnimationFrame(frameId);
      }
    };
  }, []);
  var marshal = useMemo(function() {
    return {
      register,
      tryRecordFocus,
      tryRestoreFocusRecorded,
      tryShiftRecord
    };
  }, [register, tryRecordFocus, tryRestoreFocusRecorded, tryShiftRecord]);
  return marshal;
}
function createRegistry() {
  var entries = {
    draggables: {},
    droppables: {}
  };
  var subscribers = [];
  function subscribe(cb2) {
    subscribers.push(cb2);
    return function unsubscribe() {
      var index2 = subscribers.indexOf(cb2);
      if (index2 === -1) {
        return;
      }
      subscribers.splice(index2, 1);
    };
  }
  function notify2(event) {
    if (subscribers.length) {
      subscribers.forEach(function(cb2) {
        return cb2(event);
      });
    }
  }
  function findDraggableById(id2) {
    return entries.draggables[id2] || null;
  }
  function getDraggableById(id2) {
    var entry = findDraggableById(id2);
    !entry ? invariant(false) : void 0;
    return entry;
  }
  var draggableAPI = {
    register: function register(entry) {
      entries.draggables[entry.descriptor.id] = entry;
      notify2({
        type: "ADDITION",
        value: entry
      });
    },
    update: function update2(entry, last) {
      var current = entries.draggables[last.descriptor.id];
      if (!current) {
        return;
      }
      if (current.uniqueId !== entry.uniqueId) {
        return;
      }
      delete entries.draggables[last.descriptor.id];
      entries.draggables[entry.descriptor.id] = entry;
    },
    unregister: function unregister(entry) {
      var draggableId = entry.descriptor.id;
      var current = findDraggableById(draggableId);
      if (!current) {
        return;
      }
      if (entry.uniqueId !== current.uniqueId) {
        return;
      }
      delete entries.draggables[draggableId];
      notify2({
        type: "REMOVAL",
        value: entry
      });
    },
    getById: getDraggableById,
    findById: findDraggableById,
    exists: function exists(id2) {
      return Boolean(findDraggableById(id2));
    },
    getAllByType: function getAllByType(type) {
      return values(entries.draggables).filter(function(entry) {
        return entry.descriptor.type === type;
      });
    }
  };
  function findDroppableById(id2) {
    return entries.droppables[id2] || null;
  }
  function getDroppableById(id2) {
    var entry = findDroppableById(id2);
    !entry ? invariant(false) : void 0;
    return entry;
  }
  var droppableAPI = {
    register: function register(entry) {
      entries.droppables[entry.descriptor.id] = entry;
    },
    unregister: function unregister(entry) {
      var current = findDroppableById(entry.descriptor.id);
      if (!current) {
        return;
      }
      if (entry.uniqueId !== current.uniqueId) {
        return;
      }
      delete entries.droppables[entry.descriptor.id];
    },
    getById: getDroppableById,
    findById: findDroppableById,
    exists: function exists(id2) {
      return Boolean(findDroppableById(id2));
    },
    getAllByType: function getAllByType(type) {
      return values(entries.droppables).filter(function(entry) {
        return entry.descriptor.type === type;
      });
    }
  };
  function clean2() {
    entries.draggables = {};
    entries.droppables = {};
    subscribers.length = 0;
  }
  return {
    draggable: draggableAPI,
    droppable: droppableAPI,
    subscribe,
    clean: clean2
  };
}
function useRegistry() {
  var registry = useMemo(createRegistry, []);
  reactExports.useEffect(function() {
    return function unmount() {
      requestAnimationFrame(registry.clean);
    };
  }, [registry]);
  return registry;
}
var StoreContext = React.createContext(null);
var getBodyElement = function() {
  var body = document.body;
  !body ? invariant(false) : void 0;
  return body;
};
var visuallyHidden = {
  position: "absolute",
  width: "1px",
  height: "1px",
  margin: "-1px",
  border: "0",
  padding: "0",
  overflow: "hidden",
  clip: "rect(0 0 0 0)",
  "clip-path": "inset(100%)"
};
var getId = function getId2(contextId) {
  return "rbd-announcement-" + contextId;
};
function useAnnouncer(contextId) {
  var id2 = useMemo(function() {
    return getId(contextId);
  }, [contextId]);
  var ref = reactExports.useRef(null);
  reactExports.useEffect(function setup() {
    var el2 = document.createElement("div");
    ref.current = el2;
    el2.id = id2;
    el2.setAttribute("aria-live", "assertive");
    el2.setAttribute("aria-atomic", "true");
    _extends(el2.style, visuallyHidden);
    getBodyElement().appendChild(el2);
    return function cleanup() {
      setTimeout(function remove() {
        var body = getBodyElement();
        if (body.contains(el2)) {
          body.removeChild(el2);
        }
        if (el2 === ref.current) {
          ref.current = null;
        }
      });
    };
  }, [id2]);
  var announce = useCallback(function(message) {
    var el2 = ref.current;
    if (el2) {
      el2.textContent = message;
      return;
    }
  }, []);
  return announce;
}
var count = 0;
var defaults = {
  separator: "::"
};
function useUniqueId(prefix2, options) {
  if (options === void 0) {
    options = defaults;
  }
  return useMemo(function() {
    return "" + prefix2 + options.separator + count++;
  }, [options.separator, prefix2]);
}
function getElementId(_ref) {
  var contextId = _ref.contextId, uniqueId = _ref.uniqueId;
  return "rbd-hidden-text-" + contextId + "-" + uniqueId;
}
function useHiddenTextElement(_ref2) {
  var contextId = _ref2.contextId, text = _ref2.text;
  var uniqueId = useUniqueId("hidden-text", {
    separator: "-"
  });
  var id2 = useMemo(function() {
    return getElementId({
      contextId,
      uniqueId
    });
  }, [uniqueId, contextId]);
  reactExports.useEffect(function mount() {
    var el2 = document.createElement("div");
    el2.id = id2;
    el2.textContent = text;
    el2.style.display = "none";
    getBodyElement().appendChild(el2);
    return function unmount() {
      var body = getBodyElement();
      if (body.contains(el2)) {
        body.removeChild(el2);
      }
    };
  }, [id2, text]);
  return id2;
}
var AppContext = React.createContext(null);
function usePrevious(current) {
  var ref = reactExports.useRef(current);
  reactExports.useEffect(function() {
    ref.current = current;
  });
  return ref;
}
function create() {
  var lock = null;
  function isClaimed() {
    return Boolean(lock);
  }
  function isActive(value) {
    return value === lock;
  }
  function claim(abandon) {
    !!lock ? invariant(false) : void 0;
    var newLock = {
      abandon
    };
    lock = newLock;
    return newLock;
  }
  function release() {
    !lock ? invariant(false) : void 0;
    lock = null;
  }
  function tryAbandon() {
    if (lock) {
      lock.abandon();
      release();
    }
  }
  return {
    isClaimed,
    isActive,
    claim,
    release,
    tryAbandon
  };
}
var tab = 9;
var enter = 13;
var escape = 27;
var space = 32;
var pageUp = 33;
var pageDown = 34;
var end = 35;
var home = 36;
var arrowLeft = 37;
var arrowUp = 38;
var arrowRight = 39;
var arrowDown = 40;
var _preventedKeys;
var preventedKeys = (_preventedKeys = {}, _preventedKeys[enter] = true, _preventedKeys[tab] = true, _preventedKeys);
var preventStandardKeyEvents = function(event) {
  if (preventedKeys[event.keyCode]) {
    event.preventDefault();
  }
};
var supportedEventName = function() {
  var base = "visibilitychange";
  if (typeof document === "undefined") {
    return base;
  }
  var candidates = [base, "ms" + base, "webkit" + base, "moz" + base, "o" + base];
  var supported = find(candidates, function(eventName) {
    return "on" + eventName in document;
  });
  return supported || base;
}();
var primaryButton = 0;
var sloppyClickThreshold = 5;
function isSloppyClickThresholdExceeded(original, current) {
  return Math.abs(current.x - original.x) >= sloppyClickThreshold || Math.abs(current.y - original.y) >= sloppyClickThreshold;
}
var idle$1 = {
  type: "IDLE"
};
function getCaptureBindings(_ref) {
  var cancel = _ref.cancel, completed = _ref.completed, getPhase = _ref.getPhase, setPhase = _ref.setPhase;
  return [{
    eventName: "mousemove",
    fn: function fn2(event) {
      var button = event.button, clientX = event.clientX, clientY = event.clientY;
      if (button !== primaryButton) {
        return;
      }
      var point = {
        x: clientX,
        y: clientY
      };
      var phase = getPhase();
      if (phase.type === "DRAGGING") {
        event.preventDefault();
        phase.actions.move(point);
        return;
      }
      !(phase.type === "PENDING") ? invariant(false) : void 0;
      var pending = phase.point;
      if (!isSloppyClickThresholdExceeded(pending, point)) {
        return;
      }
      event.preventDefault();
      var actions = phase.actions.fluidLift(point);
      setPhase({
        type: "DRAGGING",
        actions
      });
    }
  }, {
    eventName: "mouseup",
    fn: function fn2(event) {
      var phase = getPhase();
      if (phase.type !== "DRAGGING") {
        cancel();
        return;
      }
      event.preventDefault();
      phase.actions.drop({
        shouldBlockNextClick: true
      });
      completed();
    }
  }, {
    eventName: "mousedown",
    fn: function fn2(event) {
      if (getPhase().type === "DRAGGING") {
        event.preventDefault();
      }
      cancel();
    }
  }, {
    eventName: "keydown",
    fn: function fn2(event) {
      var phase = getPhase();
      if (phase.type === "PENDING") {
        cancel();
        return;
      }
      if (event.keyCode === escape) {
        event.preventDefault();
        cancel();
        return;
      }
      preventStandardKeyEvents(event);
    }
  }, {
    eventName: "resize",
    fn: cancel
  }, {
    eventName: "scroll",
    options: {
      passive: true,
      capture: false
    },
    fn: function fn2() {
      if (getPhase().type === "PENDING") {
        cancel();
      }
    }
  }, {
    eventName: "webkitmouseforcedown",
    fn: function fn2(event) {
      var phase = getPhase();
      !(phase.type !== "IDLE") ? invariant(false) : void 0;
      if (phase.actions.shouldRespectForcePress()) {
        cancel();
        return;
      }
      event.preventDefault();
    }
  }, {
    eventName: supportedEventName,
    fn: cancel
  }];
}
function useMouseSensor(api) {
  var phaseRef = reactExports.useRef(idle$1);
  var unbindEventsRef = reactExports.useRef(noop);
  var startCaptureBinding = useMemo(function() {
    return {
      eventName: "mousedown",
      fn: function onMouseDown(event) {
        if (event.defaultPrevented) {
          return;
        }
        if (event.button !== primaryButton) {
          return;
        }
        if (event.ctrlKey || event.metaKey || event.shiftKey || event.altKey) {
          return;
        }
        var draggableId = api.findClosestDraggableId(event);
        if (!draggableId) {
          return;
        }
        var actions = api.tryGetLock(draggableId, stop, {
          sourceEvent: event
        });
        if (!actions) {
          return;
        }
        event.preventDefault();
        var point = {
          x: event.clientX,
          y: event.clientY
        };
        unbindEventsRef.current();
        startPendingDrag(actions, point);
      }
    };
  }, [api]);
  var preventForcePressBinding = useMemo(function() {
    return {
      eventName: "webkitmouseforcewillbegin",
      fn: function fn2(event) {
        if (event.defaultPrevented) {
          return;
        }
        var id2 = api.findClosestDraggableId(event);
        if (!id2) {
          return;
        }
        var options = api.findOptionsForDraggable(id2);
        if (!options) {
          return;
        }
        if (options.shouldRespectForcePress) {
          return;
        }
        if (!api.canGetLock(id2)) {
          return;
        }
        event.preventDefault();
      }
    };
  }, [api]);
  var listenForCapture = useCallback(function listenForCapture2() {
    var options = {
      passive: false,
      capture: true
    };
    unbindEventsRef.current = bindEvents(window, [preventForcePressBinding, startCaptureBinding], options);
  }, [preventForcePressBinding, startCaptureBinding]);
  var stop = useCallback(function() {
    var current = phaseRef.current;
    if (current.type === "IDLE") {
      return;
    }
    phaseRef.current = idle$1;
    unbindEventsRef.current();
    listenForCapture();
  }, [listenForCapture]);
  var cancel = useCallback(function() {
    var phase = phaseRef.current;
    stop();
    if (phase.type === "DRAGGING") {
      phase.actions.cancel({
        shouldBlockNextClick: true
      });
    }
    if (phase.type === "PENDING") {
      phase.actions.abort();
    }
  }, [stop]);
  var bindCapturingEvents = useCallback(function bindCapturingEvents2() {
    var options = {
      capture: true,
      passive: false
    };
    var bindings = getCaptureBindings({
      cancel,
      completed: stop,
      getPhase: function getPhase() {
        return phaseRef.current;
      },
      setPhase: function setPhase(phase) {
        phaseRef.current = phase;
      }
    });
    unbindEventsRef.current = bindEvents(window, bindings, options);
  }, [cancel, stop]);
  var startPendingDrag = useCallback(function startPendingDrag2(actions, point) {
    !(phaseRef.current.type === "IDLE") ? invariant(false) : void 0;
    phaseRef.current = {
      type: "PENDING",
      point,
      actions
    };
    bindCapturingEvents();
  }, [bindCapturingEvents]);
  useIsomorphicLayoutEffect(function mount() {
    listenForCapture();
    return function unmount() {
      unbindEventsRef.current();
    };
  }, [listenForCapture]);
}
var _scrollJumpKeys;
function noop$1() {
}
var scrollJumpKeys = (_scrollJumpKeys = {}, _scrollJumpKeys[pageDown] = true, _scrollJumpKeys[pageUp] = true, _scrollJumpKeys[home] = true, _scrollJumpKeys[end] = true, _scrollJumpKeys);
function getDraggingBindings(actions, stop) {
  function cancel() {
    stop();
    actions.cancel();
  }
  function drop5() {
    stop();
    actions.drop();
  }
  return [{
    eventName: "keydown",
    fn: function fn2(event) {
      if (event.keyCode === escape) {
        event.preventDefault();
        cancel();
        return;
      }
      if (event.keyCode === space) {
        event.preventDefault();
        drop5();
        return;
      }
      if (event.keyCode === arrowDown) {
        event.preventDefault();
        actions.moveDown();
        return;
      }
      if (event.keyCode === arrowUp) {
        event.preventDefault();
        actions.moveUp();
        return;
      }
      if (event.keyCode === arrowRight) {
        event.preventDefault();
        actions.moveRight();
        return;
      }
      if (event.keyCode === arrowLeft) {
        event.preventDefault();
        actions.moveLeft();
        return;
      }
      if (scrollJumpKeys[event.keyCode]) {
        event.preventDefault();
        return;
      }
      preventStandardKeyEvents(event);
    }
  }, {
    eventName: "mousedown",
    fn: cancel
  }, {
    eventName: "mouseup",
    fn: cancel
  }, {
    eventName: "click",
    fn: cancel
  }, {
    eventName: "touchstart",
    fn: cancel
  }, {
    eventName: "resize",
    fn: cancel
  }, {
    eventName: "wheel",
    fn: cancel,
    options: {
      passive: true
    }
  }, {
    eventName: supportedEventName,
    fn: cancel
  }];
}
function useKeyboardSensor(api) {
  var unbindEventsRef = reactExports.useRef(noop$1);
  var startCaptureBinding = useMemo(function() {
    return {
      eventName: "keydown",
      fn: function onKeyDown(event) {
        if (event.defaultPrevented) {
          return;
        }
        if (event.keyCode !== space) {
          return;
        }
        var draggableId = api.findClosestDraggableId(event);
        if (!draggableId) {
          return;
        }
        var preDrag = api.tryGetLock(draggableId, stop, {
          sourceEvent: event
        });
        if (!preDrag) {
          return;
        }
        event.preventDefault();
        var isCapturing = true;
        var actions = preDrag.snapLift();
        unbindEventsRef.current();
        function stop() {
          !isCapturing ? invariant(false) : void 0;
          isCapturing = false;
          unbindEventsRef.current();
          listenForCapture();
        }
        unbindEventsRef.current = bindEvents(window, getDraggingBindings(actions, stop), {
          capture: true,
          passive: false
        });
      }
    };
  }, [api]);
  var listenForCapture = useCallback(function tryStartCapture() {
    var options = {
      passive: false,
      capture: true
    };
    unbindEventsRef.current = bindEvents(window, [startCaptureBinding], options);
  }, [startCaptureBinding]);
  useIsomorphicLayoutEffect(function mount() {
    listenForCapture();
    return function unmount() {
      unbindEventsRef.current();
    };
  }, [listenForCapture]);
}
var idle$2 = {
  type: "IDLE"
};
var timeForLongPress = 120;
var forcePressThreshold = 0.15;
function getWindowBindings(_ref) {
  var cancel = _ref.cancel, getPhase = _ref.getPhase;
  return [{
    eventName: "orientationchange",
    fn: cancel
  }, {
    eventName: "resize",
    fn: cancel
  }, {
    eventName: "contextmenu",
    fn: function fn2(event) {
      event.preventDefault();
    }
  }, {
    eventName: "keydown",
    fn: function fn2(event) {
      if (getPhase().type !== "DRAGGING") {
        cancel();
        return;
      }
      if (event.keyCode === escape) {
        event.preventDefault();
      }
      cancel();
    }
  }, {
    eventName: supportedEventName,
    fn: cancel
  }];
}
function getHandleBindings(_ref2) {
  var cancel = _ref2.cancel, completed = _ref2.completed, getPhase = _ref2.getPhase;
  return [{
    eventName: "touchmove",
    options: {
      capture: false
    },
    fn: function fn2(event) {
      var phase = getPhase();
      if (phase.type !== "DRAGGING") {
        cancel();
        return;
      }
      phase.hasMoved = true;
      var _event$touches$ = event.touches[0], clientX = _event$touches$.clientX, clientY = _event$touches$.clientY;
      var point = {
        x: clientX,
        y: clientY
      };
      event.preventDefault();
      phase.actions.move(point);
    }
  }, {
    eventName: "touchend",
    fn: function fn2(event) {
      var phase = getPhase();
      if (phase.type !== "DRAGGING") {
        cancel();
        return;
      }
      event.preventDefault();
      phase.actions.drop({
        shouldBlockNextClick: true
      });
      completed();
    }
  }, {
    eventName: "touchcancel",
    fn: function fn2(event) {
      if (getPhase().type !== "DRAGGING") {
        cancel();
        return;
      }
      event.preventDefault();
      cancel();
    }
  }, {
    eventName: "touchforcechange",
    fn: function fn2(event) {
      var phase = getPhase();
      !(phase.type !== "IDLE") ? invariant(false) : void 0;
      var touch = event.touches[0];
      if (!touch) {
        return;
      }
      var isForcePress = touch.force >= forcePressThreshold;
      if (!isForcePress) {
        return;
      }
      var shouldRespect = phase.actions.shouldRespectForcePress();
      if (phase.type === "PENDING") {
        if (shouldRespect) {
          cancel();
        }
        return;
      }
      if (shouldRespect) {
        if (phase.hasMoved) {
          event.preventDefault();
          return;
        }
        cancel();
        return;
      }
      event.preventDefault();
    }
  }, {
    eventName: supportedEventName,
    fn: cancel
  }];
}
function useTouchSensor(api) {
  var phaseRef = reactExports.useRef(idle$2);
  var unbindEventsRef = reactExports.useRef(noop);
  var getPhase = useCallback(function getPhase2() {
    return phaseRef.current;
  }, []);
  var setPhase = useCallback(function setPhase2(phase) {
    phaseRef.current = phase;
  }, []);
  var startCaptureBinding = useMemo(function() {
    return {
      eventName: "touchstart",
      fn: function onTouchStart(event) {
        if (event.defaultPrevented) {
          return;
        }
        var draggableId = api.findClosestDraggableId(event);
        if (!draggableId) {
          return;
        }
        var actions = api.tryGetLock(draggableId, stop, {
          sourceEvent: event
        });
        if (!actions) {
          return;
        }
        var touch = event.touches[0];
        var clientX = touch.clientX, clientY = touch.clientY;
        var point = {
          x: clientX,
          y: clientY
        };
        unbindEventsRef.current();
        startPendingDrag(actions, point);
      }
    };
  }, [api]);
  var listenForCapture = useCallback(function listenForCapture2() {
    var options = {
      capture: true,
      passive: false
    };
    unbindEventsRef.current = bindEvents(window, [startCaptureBinding], options);
  }, [startCaptureBinding]);
  var stop = useCallback(function() {
    var current = phaseRef.current;
    if (current.type === "IDLE") {
      return;
    }
    if (current.type === "PENDING") {
      clearTimeout(current.longPressTimerId);
    }
    setPhase(idle$2);
    unbindEventsRef.current();
    listenForCapture();
  }, [listenForCapture, setPhase]);
  var cancel = useCallback(function() {
    var phase = phaseRef.current;
    stop();
    if (phase.type === "DRAGGING") {
      phase.actions.cancel({
        shouldBlockNextClick: true
      });
    }
    if (phase.type === "PENDING") {
      phase.actions.abort();
    }
  }, [stop]);
  var bindCapturingEvents = useCallback(function bindCapturingEvents2() {
    var options = {
      capture: true,
      passive: false
    };
    var args = {
      cancel,
      completed: stop,
      getPhase
    };
    var unbindTarget = bindEvents(window, getHandleBindings(args), options);
    var unbindWindow = bindEvents(window, getWindowBindings(args), options);
    unbindEventsRef.current = function unbindAll() {
      unbindTarget();
      unbindWindow();
    };
  }, [cancel, getPhase, stop]);
  var startDragging = useCallback(function startDragging2() {
    var phase = getPhase();
    !(phase.type === "PENDING") ? invariant(false) : void 0;
    var actions = phase.actions.fluidLift(phase.point);
    setPhase({
      type: "DRAGGING",
      actions,
      hasMoved: false
    });
  }, [getPhase, setPhase]);
  var startPendingDrag = useCallback(function startPendingDrag2(actions, point) {
    !(getPhase().type === "IDLE") ? invariant(false) : void 0;
    var longPressTimerId = setTimeout(startDragging, timeForLongPress);
    setPhase({
      type: "PENDING",
      point,
      actions,
      longPressTimerId
    });
    bindCapturingEvents();
  }, [bindCapturingEvents, getPhase, setPhase, startDragging]);
  useIsomorphicLayoutEffect(function mount() {
    listenForCapture();
    return function unmount() {
      unbindEventsRef.current();
      var phase = getPhase();
      if (phase.type === "PENDING") {
        clearTimeout(phase.longPressTimerId);
        setPhase(idle$2);
      }
    };
  }, [getPhase, listenForCapture, setPhase]);
  useIsomorphicLayoutEffect(function webkitHack() {
    var unbind = bindEvents(window, [{
      eventName: "touchmove",
      fn: function fn2() {
      },
      options: {
        capture: false,
        passive: false
      }
    }]);
    return unbind;
  }, []);
}
var interactiveTagNames = {
  input: true,
  button: true,
  textarea: true,
  select: true,
  option: true,
  optgroup: true,
  video: true,
  audio: true
};
function isAnInteractiveElement(parent, current) {
  if (current == null) {
    return false;
  }
  var hasAnInteractiveTag = Boolean(interactiveTagNames[current.tagName.toLowerCase()]);
  if (hasAnInteractiveTag) {
    return true;
  }
  var attribute = current.getAttribute("contenteditable");
  if (attribute === "true" || attribute === "") {
    return true;
  }
  if (current === parent) {
    return false;
  }
  return isAnInteractiveElement(parent, current.parentElement);
}
function isEventInInteractiveElement(draggable2, event) {
  var target = event.target;
  if (!isHtmlElement(target)) {
    return false;
  }
  return isAnInteractiveElement(draggable2, target);
}
var getBorderBoxCenterPosition = function(el2) {
  return getRect(el2.getBoundingClientRect()).center;
};
function isElement(el2) {
  return el2 instanceof getWindowFromEl(el2).Element;
}
var supportedMatchesName = function() {
  var base = "matches";
  if (typeof document === "undefined") {
    return base;
  }
  var candidates = [base, "msMatchesSelector", "webkitMatchesSelector"];
  var value = find(candidates, function(name) {
    return name in Element.prototype;
  });
  return value || base;
}();
function closestPonyfill(el2, selector2) {
  if (el2 == null) {
    return null;
  }
  if (el2[supportedMatchesName](selector2)) {
    return el2;
  }
  return closestPonyfill(el2.parentElement, selector2);
}
function closest$1(el2, selector2) {
  if (el2.closest) {
    return el2.closest(selector2);
  }
  return closestPonyfill(el2, selector2);
}
function getSelector(contextId) {
  return "[" + dragHandle.contextId + '="' + contextId + '"]';
}
function findClosestDragHandleFromEvent(contextId, event) {
  var target = event.target;
  if (!isElement(target)) {
    return null;
  }
  var selector2 = getSelector(contextId);
  var handle = closest$1(target, selector2);
  if (!handle) {
    return null;
  }
  if (!isHtmlElement(handle)) {
    return null;
  }
  return handle;
}
function tryGetClosestDraggableIdFromEvent(contextId, event) {
  var handle = findClosestDragHandleFromEvent(contextId, event);
  if (!handle) {
    return null;
  }
  return handle.getAttribute(dragHandle.draggableId);
}
function findDraggable(contextId, draggableId) {
  var selector2 = "[" + draggable.contextId + '="' + contextId + '"]';
  var possible = toArray(document.querySelectorAll(selector2));
  var draggable$1 = find(possible, function(el2) {
    return el2.getAttribute(draggable.id) === draggableId;
  });
  if (!draggable$1) {
    return null;
  }
  if (!isHtmlElement(draggable$1)) {
    return null;
  }
  return draggable$1;
}
function preventDefault(event) {
  event.preventDefault();
}
function _isActive(_ref) {
  var expected = _ref.expected, phase = _ref.phase, isLockActive = _ref.isLockActive;
  _ref.shouldWarn;
  if (!isLockActive()) {
    return false;
  }
  if (expected !== phase) {
    return false;
  }
  return true;
}
function canStart(_ref2) {
  var lockAPI = _ref2.lockAPI, store = _ref2.store, registry = _ref2.registry, draggableId = _ref2.draggableId;
  if (lockAPI.isClaimed()) {
    return false;
  }
  var entry = registry.draggable.findById(draggableId);
  if (!entry) {
    return false;
  }
  if (!entry.options.isEnabled) {
    return false;
  }
  if (!canStartDrag(store.getState(), draggableId)) {
    return false;
  }
  return true;
}
function tryStart(_ref3) {
  var lockAPI = _ref3.lockAPI, contextId = _ref3.contextId, store = _ref3.store, registry = _ref3.registry, draggableId = _ref3.draggableId, forceSensorStop = _ref3.forceSensorStop, sourceEvent = _ref3.sourceEvent;
  var shouldStart = canStart({
    lockAPI,
    store,
    registry,
    draggableId
  });
  if (!shouldStart) {
    return null;
  }
  var entry = registry.draggable.getById(draggableId);
  var el2 = findDraggable(contextId, entry.descriptor.id);
  if (!el2) {
    return null;
  }
  if (sourceEvent && !entry.options.canDragInteractiveElements && isEventInInteractiveElement(el2, sourceEvent)) {
    return null;
  }
  var lock = lockAPI.claim(forceSensorStop || noop);
  var phase = "PRE_DRAG";
  function getShouldRespectForcePress() {
    return entry.options.shouldRespectForcePress;
  }
  function isLockActive() {
    return lockAPI.isActive(lock);
  }
  function tryDispatch(expected, getAction) {
    if (_isActive({
      expected,
      phase,
      isLockActive,
      shouldWarn: true
    })) {
      store.dispatch(getAction());
    }
  }
  var tryDispatchWhenDragging = tryDispatch.bind(null, "DRAGGING");
  function lift$12(args) {
    function completed() {
      lockAPI.release();
      phase = "COMPLETED";
    }
    if (phase !== "PRE_DRAG") {
      completed();
      !(phase === "PRE_DRAG") ? invariant(false) : void 0;
    }
    store.dispatch(lift(args.liftActionArgs));
    phase = "DRAGGING";
    function finish(reason, options) {
      if (options === void 0) {
        options = {
          shouldBlockNextClick: false
        };
      }
      args.cleanup();
      if (options.shouldBlockNextClick) {
        var unbind = bindEvents(window, [{
          eventName: "click",
          fn: preventDefault,
          options: {
            once: true,
            passive: false,
            capture: true
          }
        }]);
        setTimeout(unbind);
      }
      completed();
      store.dispatch(drop({
        reason
      }));
    }
    return _extends({
      isActive: function isActive() {
        return _isActive({
          expected: "DRAGGING",
          phase,
          isLockActive,
          shouldWarn: false
        });
      },
      shouldRespectForcePress: getShouldRespectForcePress,
      drop: function drop5(options) {
        return finish("DROP", options);
      },
      cancel: function cancel(options) {
        return finish("CANCEL", options);
      }
    }, args.actions);
  }
  function fluidLift(clientSelection) {
    var move$1 = rafSchd$1(function(client2) {
      tryDispatchWhenDragging(function() {
        return move({
          client: client2
        });
      });
    });
    var api = lift$12({
      liftActionArgs: {
        id: draggableId,
        clientSelection,
        movementMode: "FLUID"
      },
      cleanup: function cleanup() {
        return move$1.cancel();
      },
      actions: {
        move: move$1
      }
    });
    return _extends({}, api, {
      move: move$1
    });
  }
  function snapLift() {
    var actions = {
      moveUp: function moveUp$1() {
        return tryDispatchWhenDragging(moveUp);
      },
      moveRight: function moveRight$1() {
        return tryDispatchWhenDragging(moveRight);
      },
      moveDown: function moveDown$1() {
        return tryDispatchWhenDragging(moveDown);
      },
      moveLeft: function moveLeft$1() {
        return tryDispatchWhenDragging(moveLeft);
      }
    };
    return lift$12({
      liftActionArgs: {
        id: draggableId,
        clientSelection: getBorderBoxCenterPosition(el2),
        movementMode: "SNAP"
      },
      cleanup: noop,
      actions
    });
  }
  function abortPreDrag() {
    var shouldRelease = _isActive({
      expected: "PRE_DRAG",
      phase,
      isLockActive,
      shouldWarn: true
    });
    if (shouldRelease) {
      lockAPI.release();
    }
  }
  var preDrag = {
    isActive: function isActive() {
      return _isActive({
        expected: "PRE_DRAG",
        phase,
        isLockActive,
        shouldWarn: false
      });
    },
    shouldRespectForcePress: getShouldRespectForcePress,
    fluidLift,
    snapLift,
    abort: abortPreDrag
  };
  return preDrag;
}
var defaultSensors = [useMouseSensor, useKeyboardSensor, useTouchSensor];
function useSensorMarshal(_ref4) {
  var contextId = _ref4.contextId, store = _ref4.store, registry = _ref4.registry, customSensors = _ref4.customSensors, enableDefaultSensors = _ref4.enableDefaultSensors;
  var useSensors = [].concat(enableDefaultSensors ? defaultSensors : [], customSensors || []);
  var lockAPI = reactExports.useState(function() {
    return create();
  })[0];
  var tryAbandonLock = useCallback(function tryAbandonLock2(previous, current) {
    if (previous.isDragging && !current.isDragging) {
      lockAPI.tryAbandon();
    }
  }, [lockAPI]);
  useIsomorphicLayoutEffect(function listenToStore() {
    var previous = store.getState();
    var unsubscribe = store.subscribe(function() {
      var current = store.getState();
      tryAbandonLock(previous, current);
      previous = current;
    });
    return unsubscribe;
  }, [lockAPI, store, tryAbandonLock]);
  useIsomorphicLayoutEffect(function() {
    return lockAPI.tryAbandon;
  }, [lockAPI.tryAbandon]);
  var canGetLock = useCallback(function(draggableId) {
    return canStart({
      lockAPI,
      registry,
      store,
      draggableId
    });
  }, [lockAPI, registry, store]);
  var tryGetLock = useCallback(function(draggableId, forceStop, options) {
    return tryStart({
      lockAPI,
      registry,
      contextId,
      store,
      draggableId,
      forceSensorStop: forceStop,
      sourceEvent: options && options.sourceEvent ? options.sourceEvent : null
    });
  }, [contextId, lockAPI, registry, store]);
  var findClosestDraggableId = useCallback(function(event) {
    return tryGetClosestDraggableIdFromEvent(contextId, event);
  }, [contextId]);
  var findOptionsForDraggable = useCallback(function(id2) {
    var entry = registry.draggable.findById(id2);
    return entry ? entry.options : null;
  }, [registry.draggable]);
  var tryReleaseLock = useCallback(function tryReleaseLock2() {
    if (!lockAPI.isClaimed()) {
      return;
    }
    lockAPI.tryAbandon();
    if (store.getState().phase !== "IDLE") {
      store.dispatch(flush());
    }
  }, [lockAPI, store]);
  var isLockClaimed = useCallback(lockAPI.isClaimed, [lockAPI]);
  var api = useMemo(function() {
    return {
      canGetLock,
      tryGetLock,
      findClosestDraggableId,
      findOptionsForDraggable,
      tryReleaseLock,
      isLockClaimed
    };
  }, [canGetLock, tryGetLock, findClosestDraggableId, findOptionsForDraggable, tryReleaseLock, isLockClaimed]);
  for (var i2 = 0; i2 < useSensors.length; i2++) {
    useSensors[i2](api);
  }
}
var createResponders = function createResponders2(props) {
  return {
    onBeforeCapture: props.onBeforeCapture,
    onBeforeDragStart: props.onBeforeDragStart,
    onDragStart: props.onDragStart,
    onDragEnd: props.onDragEnd,
    onDragUpdate: props.onDragUpdate
  };
};
function getStore(lazyRef) {
  !lazyRef.current ? invariant(false) : void 0;
  return lazyRef.current;
}
function App$1(props) {
  var contextId = props.contextId, setCallbacks = props.setCallbacks, sensors = props.sensors, nonce = props.nonce, dragHandleUsageInstructions2 = props.dragHandleUsageInstructions;
  var lazyStoreRef = reactExports.useRef(null);
  var lastPropsRef = usePrevious(props);
  var getResponders = useCallback(function() {
    return createResponders(lastPropsRef.current);
  }, [lastPropsRef]);
  var announce = useAnnouncer(contextId);
  var dragHandleUsageInstructionsId = useHiddenTextElement({
    contextId,
    text: dragHandleUsageInstructions2
  });
  var styleMarshal = useStyleMarshal(contextId, nonce);
  var lazyDispatch = useCallback(function(action) {
    getStore(lazyStoreRef).dispatch(action);
  }, []);
  var marshalCallbacks = useMemo(function() {
    return bindActionCreators$1({
      publishWhileDragging,
      updateDroppableScroll,
      updateDroppableIsEnabled,
      updateDroppableIsCombineEnabled,
      collectionStarting
    }, lazyDispatch);
  }, [lazyDispatch]);
  var registry = useRegistry();
  var dimensionMarshal = useMemo(function() {
    return createDimensionMarshal(registry, marshalCallbacks);
  }, [registry, marshalCallbacks]);
  var autoScroller = useMemo(function() {
    return createAutoScroller(_extends({
      scrollWindow,
      scrollDroppable: dimensionMarshal.scrollDroppable
    }, bindActionCreators$1({
      move
    }, lazyDispatch)));
  }, [dimensionMarshal.scrollDroppable, lazyDispatch]);
  var focusMarshal = useFocusMarshal(contextId);
  var store = useMemo(function() {
    return createStore({
      announce,
      autoScroller,
      dimensionMarshal,
      focusMarshal,
      getResponders,
      styleMarshal
    });
  }, [announce, autoScroller, dimensionMarshal, focusMarshal, getResponders, styleMarshal]);
  lazyStoreRef.current = store;
  var tryResetStore = useCallback(function() {
    var current = getStore(lazyStoreRef);
    var state = current.getState();
    if (state.phase !== "IDLE") {
      current.dispatch(flush());
    }
  }, []);
  var isDragging = useCallback(function() {
    var state = getStore(lazyStoreRef).getState();
    return state.isDragging || state.phase === "DROP_ANIMATING";
  }, []);
  var appCallbacks = useMemo(function() {
    return {
      isDragging,
      tryAbort: tryResetStore
    };
  }, [isDragging, tryResetStore]);
  setCallbacks(appCallbacks);
  var getCanLift = useCallback(function(id2) {
    return canStartDrag(getStore(lazyStoreRef).getState(), id2);
  }, []);
  var getIsMovementAllowed = useCallback(function() {
    return isMovementAllowed(getStore(lazyStoreRef).getState());
  }, []);
  var appContext = useMemo(function() {
    return {
      marshal: dimensionMarshal,
      focus: focusMarshal,
      contextId,
      canLift: getCanLift,
      isMovementAllowed: getIsMovementAllowed,
      dragHandleUsageInstructionsId,
      registry
    };
  }, [contextId, dimensionMarshal, dragHandleUsageInstructionsId, focusMarshal, getCanLift, getIsMovementAllowed, registry]);
  useSensorMarshal({
    contextId,
    store,
    registry,
    customSensors: sensors,
    enableDefaultSensors: props.enableDefaultSensors !== false
  });
  reactExports.useEffect(function() {
    return tryResetStore;
  }, [tryResetStore]);
  return React.createElement(AppContext.Provider, {
    value: appContext
  }, React.createElement(Provider, {
    context: StoreContext,
    store
  }, props.children));
}
var count$1 = 0;
function useInstanceCount() {
  return useMemo(function() {
    return "" + count$1++;
  }, []);
}
function DragDropContext(props) {
  var contextId = useInstanceCount();
  var dragHandleUsageInstructions2 = props.dragHandleUsageInstructions || preset.dragHandleUsageInstructions;
  return React.createElement(ErrorBoundary, null, function(setCallbacks) {
    return React.createElement(App$1, {
      nonce: props.nonce,
      contextId,
      setCallbacks,
      dragHandleUsageInstructions: dragHandleUsageInstructions2,
      enableDefaultSensors: props.enableDefaultSensors,
      sensors: props.sensors,
      onBeforeCapture: props.onBeforeCapture,
      onBeforeDragStart: props.onBeforeDragStart,
      onDragStart: props.onDragStart,
      onDragUpdate: props.onDragUpdate,
      onDragEnd: props.onDragEnd
    }, props.children);
  });
}
var isEqual$1 = function isEqual3(base) {
  return function(value) {
    return base === value;
  };
};
var isScroll = isEqual$1("scroll");
var isAuto = isEqual$1("auto");
var isEither = function isEither2(overflow, fn2) {
  return fn2(overflow.overflowX) || fn2(overflow.overflowY);
};
var isElementScrollable = function isElementScrollable2(el2) {
  var style2 = window.getComputedStyle(el2);
  var overflow = {
    overflowX: style2.overflowX,
    overflowY: style2.overflowY
  };
  return isEither(overflow, isScroll) || isEither(overflow, isAuto);
};
var isBodyScrollable = function isBodyScrollable2() {
  {
    return false;
  }
};
var getClosestScrollable = function getClosestScrollable2(el2) {
  if (el2 == null) {
    return null;
  }
  if (el2 === document.body) {
    return isBodyScrollable() ? el2 : null;
  }
  if (el2 === document.documentElement) {
    return null;
  }
  if (!isElementScrollable(el2)) {
    return getClosestScrollable2(el2.parentElement);
  }
  return el2;
};
var getScroll$1 = function(el2) {
  return {
    x: el2.scrollLeft,
    y: el2.scrollTop
  };
};
var getIsFixed = function getIsFixed2(el2) {
  if (!el2) {
    return false;
  }
  var style2 = window.getComputedStyle(el2);
  if (style2.position === "fixed") {
    return true;
  }
  return getIsFixed2(el2.parentElement);
};
var getEnv = function(start) {
  var closestScrollable = getClosestScrollable(start);
  var isFixedOnPage = getIsFixed(start);
  return {
    closestScrollable,
    isFixedOnPage
  };
};
var getDroppableDimension = function(_ref) {
  var descriptor = _ref.descriptor, isEnabled = _ref.isEnabled, isCombineEnabled = _ref.isCombineEnabled, isFixedOnPage = _ref.isFixedOnPage, direction = _ref.direction, client2 = _ref.client, page = _ref.page, closest3 = _ref.closest;
  var frame = function() {
    if (!closest3) {
      return null;
    }
    var scrollSize = closest3.scrollSize, frameClient = closest3.client;
    var maxScroll = getMaxScroll({
      scrollHeight: scrollSize.scrollHeight,
      scrollWidth: scrollSize.scrollWidth,
      height: frameClient.paddingBox.height,
      width: frameClient.paddingBox.width
    });
    return {
      pageMarginBox: closest3.page.marginBox,
      frameClient,
      scrollSize,
      shouldClipSubject: closest3.shouldClipSubject,
      scroll: {
        initial: closest3.scroll,
        current: closest3.scroll,
        max: maxScroll,
        diff: {
          value: origin,
          displacement: origin
        }
      }
    };
  }();
  var axis = direction === "vertical" ? vertical : horizontal;
  var subject = getSubject({
    page,
    withPlaceholder: null,
    axis,
    frame
  });
  var dimension = {
    descriptor,
    isCombineEnabled,
    isFixedOnPage,
    axis,
    isEnabled,
    client: client2,
    page,
    frame,
    subject
  };
  return dimension;
};
var getClient = function getClient2(targetRef, closestScrollable) {
  var base = getBox(targetRef);
  if (!closestScrollable) {
    return base;
  }
  if (targetRef !== closestScrollable) {
    return base;
  }
  var top = base.paddingBox.top - closestScrollable.scrollTop;
  var left = base.paddingBox.left - closestScrollable.scrollLeft;
  var bottom = top + closestScrollable.scrollHeight;
  var right = left + closestScrollable.scrollWidth;
  var paddingBox = {
    top,
    right,
    bottom,
    left
  };
  var borderBox = expand(paddingBox, base.border);
  var client2 = createBox({
    borderBox,
    margin: base.margin,
    border: base.border,
    padding: base.padding
  });
  return client2;
};
var getDimension = function(_ref) {
  var ref = _ref.ref, descriptor = _ref.descriptor, env2 = _ref.env, windowScroll = _ref.windowScroll, direction = _ref.direction, isDropDisabled = _ref.isDropDisabled, isCombineEnabled = _ref.isCombineEnabled, shouldClipSubject = _ref.shouldClipSubject;
  var closestScrollable = env2.closestScrollable;
  var client2 = getClient(ref, closestScrollable);
  var page = withScroll(client2, windowScroll);
  var closest3 = function() {
    if (!closestScrollable) {
      return null;
    }
    var frameClient = getBox(closestScrollable);
    var scrollSize = {
      scrollHeight: closestScrollable.scrollHeight,
      scrollWidth: closestScrollable.scrollWidth
    };
    return {
      client: frameClient,
      page: withScroll(frameClient, windowScroll),
      scroll: getScroll$1(closestScrollable),
      scrollSize,
      shouldClipSubject
    };
  }();
  var dimension = getDroppableDimension({
    descriptor,
    isEnabled: !isDropDisabled,
    isCombineEnabled,
    isFixedOnPage: env2.isFixedOnPage,
    direction,
    client: client2,
    page,
    closest: closest3
  });
  return dimension;
};
var immediate = {
  passive: false
};
var delayed = {
  passive: true
};
var getListenerOptions = function(options) {
  return options.shouldPublishImmediately ? immediate : delayed;
};
function useRequiredContext(Context) {
  var result = reactExports.useContext(Context);
  !result ? invariant(false) : void 0;
  return result;
}
var getClosestScrollableFromDrag = function getClosestScrollableFromDrag2(dragging) {
  return dragging && dragging.env.closestScrollable || null;
};
function useDroppablePublisher(args) {
  var whileDraggingRef = reactExports.useRef(null);
  var appContext = useRequiredContext(AppContext);
  var uniqueId = useUniqueId("droppable");
  var registry = appContext.registry, marshal = appContext.marshal;
  var previousRef = usePrevious(args);
  var descriptor = useMemo(function() {
    return {
      id: args.droppableId,
      type: args.type,
      mode: args.mode
    };
  }, [args.droppableId, args.mode, args.type]);
  var publishedDescriptorRef = reactExports.useRef(descriptor);
  var memoizedUpdateScroll = useMemo(function() {
    return memoizeOne(function(x, y2) {
      !whileDraggingRef.current ? invariant(false) : void 0;
      var scroll4 = {
        x,
        y: y2
      };
      marshal.updateDroppableScroll(descriptor.id, scroll4);
    });
  }, [descriptor.id, marshal]);
  var getClosestScroll = useCallback(function() {
    var dragging = whileDraggingRef.current;
    if (!dragging || !dragging.env.closestScrollable) {
      return origin;
    }
    return getScroll$1(dragging.env.closestScrollable);
  }, []);
  var updateScroll = useCallback(function() {
    var scroll4 = getClosestScroll();
    memoizedUpdateScroll(scroll4.x, scroll4.y);
  }, [getClosestScroll, memoizedUpdateScroll]);
  var scheduleScrollUpdate = useMemo(function() {
    return rafSchd$1(updateScroll);
  }, [updateScroll]);
  var onClosestScroll = useCallback(function() {
    var dragging = whileDraggingRef.current;
    var closest3 = getClosestScrollableFromDrag(dragging);
    !(dragging && closest3) ? invariant(false) : void 0;
    var options = dragging.scrollOptions;
    if (options.shouldPublishImmediately) {
      updateScroll();
      return;
    }
    scheduleScrollUpdate();
  }, [scheduleScrollUpdate, updateScroll]);
  var getDimensionAndWatchScroll = useCallback(function(windowScroll, options) {
    !!whileDraggingRef.current ? invariant(false) : void 0;
    var previous = previousRef.current;
    var ref = previous.getDroppableRef();
    !ref ? invariant(false) : void 0;
    var env2 = getEnv(ref);
    var dragging = {
      ref,
      descriptor,
      env: env2,
      scrollOptions: options
    };
    whileDraggingRef.current = dragging;
    var dimension = getDimension({
      ref,
      descriptor,
      env: env2,
      windowScroll,
      direction: previous.direction,
      isDropDisabled: previous.isDropDisabled,
      isCombineEnabled: previous.isCombineEnabled,
      shouldClipSubject: !previous.ignoreContainerClipping
    });
    var scrollable = env2.closestScrollable;
    if (scrollable) {
      scrollable.setAttribute(scrollContainer.contextId, appContext.contextId);
      scrollable.addEventListener("scroll", onClosestScroll, getListenerOptions(dragging.scrollOptions));
    }
    return dimension;
  }, [appContext.contextId, descriptor, onClosestScroll, previousRef]);
  var getScrollWhileDragging = useCallback(function() {
    var dragging = whileDraggingRef.current;
    var closest3 = getClosestScrollableFromDrag(dragging);
    !(dragging && closest3) ? invariant(false) : void 0;
    return getScroll$1(closest3);
  }, []);
  var dragStopped = useCallback(function() {
    var dragging = whileDraggingRef.current;
    !dragging ? invariant(false) : void 0;
    var closest3 = getClosestScrollableFromDrag(dragging);
    whileDraggingRef.current = null;
    if (!closest3) {
      return;
    }
    scheduleScrollUpdate.cancel();
    closest3.removeAttribute(scrollContainer.contextId);
    closest3.removeEventListener("scroll", onClosestScroll, getListenerOptions(dragging.scrollOptions));
  }, [onClosestScroll, scheduleScrollUpdate]);
  var scroll3 = useCallback(function(change) {
    var dragging = whileDraggingRef.current;
    !dragging ? invariant(false) : void 0;
    var closest3 = getClosestScrollableFromDrag(dragging);
    !closest3 ? invariant(false) : void 0;
    closest3.scrollTop += change.y;
    closest3.scrollLeft += change.x;
  }, []);
  var callbacks = useMemo(function() {
    return {
      getDimensionAndWatchScroll,
      getScrollWhileDragging,
      dragStopped,
      scroll: scroll3
    };
  }, [dragStopped, getDimensionAndWatchScroll, getScrollWhileDragging, scroll3]);
  var entry = useMemo(function() {
    return {
      uniqueId,
      descriptor,
      callbacks
    };
  }, [callbacks, descriptor, uniqueId]);
  useIsomorphicLayoutEffect(function() {
    publishedDescriptorRef.current = entry.descriptor;
    registry.droppable.register(entry);
    return function() {
      if (whileDraggingRef.current) {
        dragStopped();
      }
      registry.droppable.unregister(entry);
    };
  }, [callbacks, descriptor, dragStopped, entry, marshal, registry.droppable]);
  useIsomorphicLayoutEffect(function() {
    if (!whileDraggingRef.current) {
      return;
    }
    marshal.updateDroppableIsEnabled(publishedDescriptorRef.current.id, !args.isDropDisabled);
  }, [args.isDropDisabled, marshal]);
  useIsomorphicLayoutEffect(function() {
    if (!whileDraggingRef.current) {
      return;
    }
    marshal.updateDroppableIsCombineEnabled(publishedDescriptorRef.current.id, args.isCombineEnabled);
  }, [args.isCombineEnabled, marshal]);
}
function noop$2() {
}
var empty = {
  width: 0,
  height: 0,
  margin: noSpacing
};
var getSize = function getSize2(_ref) {
  var isAnimatingOpenOnMount = _ref.isAnimatingOpenOnMount, placeholder = _ref.placeholder, animate = _ref.animate;
  if (isAnimatingOpenOnMount) {
    return empty;
  }
  if (animate === "close") {
    return empty;
  }
  return {
    height: placeholder.client.borderBox.height,
    width: placeholder.client.borderBox.width,
    margin: placeholder.client.margin
  };
};
var getStyle = function getStyle2(_ref2) {
  var isAnimatingOpenOnMount = _ref2.isAnimatingOpenOnMount, placeholder = _ref2.placeholder, animate = _ref2.animate;
  var size = getSize({
    isAnimatingOpenOnMount,
    placeholder,
    animate
  });
  return {
    display: placeholder.display,
    boxSizing: "border-box",
    width: size.width,
    height: size.height,
    marginTop: size.margin.top,
    marginRight: size.margin.right,
    marginBottom: size.margin.bottom,
    marginLeft: size.margin.left,
    flexShrink: "0",
    flexGrow: "0",
    pointerEvents: "none",
    transition: animate !== "none" ? transitions.placeholder : null
  };
};
function Placeholder(props) {
  var animateOpenTimerRef = reactExports.useRef(null);
  var tryClearAnimateOpenTimer = useCallback(function() {
    if (!animateOpenTimerRef.current) {
      return;
    }
    clearTimeout(animateOpenTimerRef.current);
    animateOpenTimerRef.current = null;
  }, []);
  var animate = props.animate, onTransitionEnd = props.onTransitionEnd, onClose = props.onClose, contextId = props.contextId;
  var _useState = reactExports.useState(props.animate === "open"), isAnimatingOpenOnMount = _useState[0], setIsAnimatingOpenOnMount = _useState[1];
  reactExports.useEffect(function() {
    if (!isAnimatingOpenOnMount) {
      return noop$2;
    }
    if (animate !== "open") {
      tryClearAnimateOpenTimer();
      setIsAnimatingOpenOnMount(false);
      return noop$2;
    }
    if (animateOpenTimerRef.current) {
      return noop$2;
    }
    animateOpenTimerRef.current = setTimeout(function() {
      animateOpenTimerRef.current = null;
      setIsAnimatingOpenOnMount(false);
    });
    return tryClearAnimateOpenTimer;
  }, [animate, isAnimatingOpenOnMount, tryClearAnimateOpenTimer]);
  var onSizeChangeEnd = useCallback(function(event) {
    if (event.propertyName !== "height") {
      return;
    }
    onTransitionEnd();
    if (animate === "close") {
      onClose();
    }
  }, [animate, onClose, onTransitionEnd]);
  var style2 = getStyle({
    isAnimatingOpenOnMount,
    animate: props.animate,
    placeholder: props.placeholder
  });
  return React.createElement(props.placeholder.tagName, {
    style: style2,
    "data-rbd-placeholder-context-id": contextId,
    onTransitionEnd: onSizeChangeEnd,
    ref: props.innerRef
  });
}
var Placeholder$1 = React.memo(Placeholder);
var DroppableContext = React.createContext(null);
var AnimateInOut = function(_React$PureComponent) {
  _inheritsLoose(AnimateInOut2, _React$PureComponent);
  function AnimateInOut2() {
    var _this;
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _React$PureComponent.call.apply(_React$PureComponent, [this].concat(args)) || this;
    _this.state = {
      isVisible: Boolean(_this.props.on),
      data: _this.props.on,
      animate: _this.props.shouldAnimate && _this.props.on ? "open" : "none"
    };
    _this.onClose = function() {
      if (_this.state.animate !== "close") {
        return;
      }
      _this.setState({
        isVisible: false
      });
    };
    return _this;
  }
  AnimateInOut2.getDerivedStateFromProps = function getDerivedStateFromProps(props, state) {
    if (!props.shouldAnimate) {
      return {
        isVisible: Boolean(props.on),
        data: props.on,
        animate: "none"
      };
    }
    if (props.on) {
      return {
        isVisible: true,
        data: props.on,
        animate: "open"
      };
    }
    if (state.isVisible) {
      return {
        isVisible: true,
        data: state.data,
        animate: "close"
      };
    }
    return {
      isVisible: false,
      animate: "close",
      data: null
    };
  };
  var _proto = AnimateInOut2.prototype;
  _proto.render = function render() {
    if (!this.state.isVisible) {
      return null;
    }
    var provided = {
      onClose: this.onClose,
      data: this.state.data,
      animate: this.state.animate
    };
    return this.props.children(provided);
  };
  return AnimateInOut2;
}(React.PureComponent);
var zIndexOptions = {
  dragging: 5e3,
  dropAnimating: 4500
};
var getDraggingTransition = function getDraggingTransition2(shouldAnimateDragMovement, dropping) {
  if (dropping) {
    return transitions.drop(dropping.duration);
  }
  if (shouldAnimateDragMovement) {
    return transitions.snap;
  }
  return transitions.fluid;
};
var getDraggingOpacity = function getDraggingOpacity2(isCombining, isDropAnimating) {
  if (!isCombining) {
    return null;
  }
  return isDropAnimating ? combine.opacity.drop : combine.opacity.combining;
};
var getShouldDraggingAnimate = function getShouldDraggingAnimate2(dragging) {
  if (dragging.forceShouldAnimate != null) {
    return dragging.forceShouldAnimate;
  }
  return dragging.mode === "SNAP";
};
function getDraggingStyle(dragging) {
  var dimension = dragging.dimension;
  var box = dimension.client;
  var offset3 = dragging.offset, combineWith = dragging.combineWith, dropping = dragging.dropping;
  var isCombining = Boolean(combineWith);
  var shouldAnimate = getShouldDraggingAnimate(dragging);
  var isDropAnimating = Boolean(dropping);
  var transform = isDropAnimating ? transforms.drop(offset3, isCombining) : transforms.moveTo(offset3);
  var style2 = {
    position: "fixed",
    top: box.marginBox.top,
    left: box.marginBox.left,
    boxSizing: "border-box",
    width: box.borderBox.width,
    height: box.borderBox.height,
    transition: getDraggingTransition(shouldAnimate, dropping),
    transform,
    opacity: getDraggingOpacity(isCombining, isDropAnimating),
    zIndex: isDropAnimating ? zIndexOptions.dropAnimating : zIndexOptions.dragging,
    pointerEvents: "none"
  };
  return style2;
}
function getSecondaryStyle(secondary) {
  return {
    transform: transforms.moveTo(secondary.offset),
    transition: secondary.shouldAnimateDisplacement ? null : "none"
  };
}
function getStyle$1(mapped) {
  return mapped.type === "DRAGGING" ? getDraggingStyle(mapped) : getSecondaryStyle(mapped);
}
function getDimension$1(descriptor, el2, windowScroll) {
  if (windowScroll === void 0) {
    windowScroll = origin;
  }
  var computedStyles = window.getComputedStyle(el2);
  var borderBox = el2.getBoundingClientRect();
  var client2 = calculateBox(borderBox, computedStyles);
  var page = withScroll(client2, windowScroll);
  var placeholder = {
    client: client2,
    tagName: el2.tagName.toLowerCase(),
    display: computedStyles.display
  };
  var displaceBy = {
    x: client2.marginBox.width,
    y: client2.marginBox.height
  };
  var dimension = {
    descriptor,
    placeholder,
    displaceBy,
    client: client2,
    page
  };
  return dimension;
}
function useDraggablePublisher(args) {
  var uniqueId = useUniqueId("draggable");
  var descriptor = args.descriptor, registry = args.registry, getDraggableRef = args.getDraggableRef, canDragInteractiveElements = args.canDragInteractiveElements, shouldRespectForcePress = args.shouldRespectForcePress, isEnabled = args.isEnabled;
  var options = useMemo(function() {
    return {
      canDragInteractiveElements,
      shouldRespectForcePress,
      isEnabled
    };
  }, [canDragInteractiveElements, isEnabled, shouldRespectForcePress]);
  var getDimension2 = useCallback(function(windowScroll) {
    var el2 = getDraggableRef();
    !el2 ? invariant(false) : void 0;
    return getDimension$1(descriptor, el2, windowScroll);
  }, [descriptor, getDraggableRef]);
  var entry = useMemo(function() {
    return {
      uniqueId,
      descriptor,
      options,
      getDimension: getDimension2
    };
  }, [descriptor, getDimension2, options, uniqueId]);
  var publishedRef = reactExports.useRef(entry);
  var isFirstPublishRef = reactExports.useRef(true);
  useIsomorphicLayoutEffect(function() {
    registry.draggable.register(publishedRef.current);
    return function() {
      return registry.draggable.unregister(publishedRef.current);
    };
  }, [registry.draggable]);
  useIsomorphicLayoutEffect(function() {
    if (isFirstPublishRef.current) {
      isFirstPublishRef.current = false;
      return;
    }
    var last = publishedRef.current;
    publishedRef.current = entry;
    registry.draggable.update(entry, last);
  }, [entry, registry.draggable]);
}
function preventHtml5Dnd(event) {
  event.preventDefault();
}
function Draggable(props) {
  var ref = reactExports.useRef(null);
  var setRef = useCallback(function(el2) {
    ref.current = el2;
  }, []);
  var getRef = useCallback(function() {
    return ref.current;
  }, []);
  var _useRequiredContext = useRequiredContext(AppContext), contextId = _useRequiredContext.contextId, dragHandleUsageInstructionsId = _useRequiredContext.dragHandleUsageInstructionsId, registry = _useRequiredContext.registry;
  var _useRequiredContext2 = useRequiredContext(DroppableContext), type = _useRequiredContext2.type, droppableId = _useRequiredContext2.droppableId;
  var descriptor = useMemo(function() {
    return {
      id: props.draggableId,
      index: props.index,
      type,
      droppableId
    };
  }, [props.draggableId, props.index, type, droppableId]);
  var children = props.children, draggableId = props.draggableId, isEnabled = props.isEnabled, shouldRespectForcePress = props.shouldRespectForcePress, canDragInteractiveElements = props.canDragInteractiveElements, isClone = props.isClone, mapped = props.mapped, dropAnimationFinishedAction = props.dropAnimationFinished;
  if (!isClone) {
    var forPublisher = useMemo(function() {
      return {
        descriptor,
        registry,
        getDraggableRef: getRef,
        canDragInteractiveElements,
        shouldRespectForcePress,
        isEnabled
      };
    }, [descriptor, registry, getRef, canDragInteractiveElements, shouldRespectForcePress, isEnabled]);
    useDraggablePublisher(forPublisher);
  }
  var dragHandleProps = useMemo(function() {
    return isEnabled ? {
      tabIndex: 0,
      role: "button",
      "aria-describedby": dragHandleUsageInstructionsId,
      "data-rbd-drag-handle-draggable-id": draggableId,
      "data-rbd-drag-handle-context-id": contextId,
      draggable: false,
      onDragStart: preventHtml5Dnd
    } : null;
  }, [contextId, dragHandleUsageInstructionsId, draggableId, isEnabled]);
  var onMoveEnd = useCallback(function(event) {
    if (mapped.type !== "DRAGGING") {
      return;
    }
    if (!mapped.dropping) {
      return;
    }
    if (event.propertyName !== "transform") {
      return;
    }
    dropAnimationFinishedAction();
  }, [dropAnimationFinishedAction, mapped]);
  var provided = useMemo(function() {
    var style2 = getStyle$1(mapped);
    var onTransitionEnd = mapped.type === "DRAGGING" && mapped.dropping ? onMoveEnd : null;
    var result = {
      innerRef: setRef,
      draggableProps: {
        "data-rbd-draggable-context-id": contextId,
        "data-rbd-draggable-id": draggableId,
        style: style2,
        onTransitionEnd
      },
      dragHandleProps
    };
    return result;
  }, [contextId, dragHandleProps, draggableId, mapped, onMoveEnd, setRef]);
  var rubric = useMemo(function() {
    return {
      draggableId: descriptor.id,
      type: descriptor.type,
      source: {
        index: descriptor.index,
        droppableId: descriptor.droppableId
      }
    };
  }, [descriptor.droppableId, descriptor.id, descriptor.index, descriptor.type]);
  return children(provided, mapped.snapshot, rubric);
}
var isStrictEqual = function(a2, b2) {
  return a2 === b2;
};
var whatIsDraggedOverFromResult = function(result) {
  var combine2 = result.combine, destination = result.destination;
  if (destination) {
    return destination.droppableId;
  }
  if (combine2) {
    return combine2.droppableId;
  }
  return null;
};
var getCombineWithFromResult = function getCombineWithFromResult2(result) {
  return result.combine ? result.combine.draggableId : null;
};
var getCombineWithFromImpact = function getCombineWithFromImpact2(impact) {
  return impact.at && impact.at.type === "COMBINE" ? impact.at.combine.draggableId : null;
};
function getDraggableSelector() {
  var memoizedOffset = memoizeOne(function(x, y2) {
    return {
      x,
      y: y2
    };
  });
  var getMemoizedSnapshot = memoizeOne(function(mode, isClone, draggingOver, combineWith, dropping) {
    return {
      isDragging: true,
      isClone,
      isDropAnimating: Boolean(dropping),
      dropAnimation: dropping,
      mode,
      draggingOver,
      combineWith,
      combineTargetFor: null
    };
  });
  var getMemoizedProps = memoizeOne(function(offset3, mode, dimension, isClone, draggingOver, combineWith, forceShouldAnimate) {
    return {
      mapped: {
        type: "DRAGGING",
        dropping: null,
        draggingOver,
        combineWith,
        mode,
        offset: offset3,
        dimension,
        forceShouldAnimate,
        snapshot: getMemoizedSnapshot(mode, isClone, draggingOver, combineWith, null)
      }
    };
  });
  var selector2 = function selector3(state, ownProps) {
    if (state.isDragging) {
      if (state.critical.draggable.id !== ownProps.draggableId) {
        return null;
      }
      var offset3 = state.current.client.offset;
      var dimension = state.dimensions.draggables[ownProps.draggableId];
      var draggingOver = whatIsDraggedOver(state.impact);
      var combineWith = getCombineWithFromImpact(state.impact);
      var forceShouldAnimate = state.forceShouldAnimate;
      return getMemoizedProps(memoizedOffset(offset3.x, offset3.y), state.movementMode, dimension, ownProps.isClone, draggingOver, combineWith, forceShouldAnimate);
    }
    if (state.phase === "DROP_ANIMATING") {
      var completed = state.completed;
      if (completed.result.draggableId !== ownProps.draggableId) {
        return null;
      }
      var isClone = ownProps.isClone;
      var _dimension = state.dimensions.draggables[ownProps.draggableId];
      var result = completed.result;
      var mode = result.mode;
      var _draggingOver = whatIsDraggedOverFromResult(result);
      var _combineWith = getCombineWithFromResult(result);
      var duration = state.dropDuration;
      var dropping = {
        duration,
        curve: curves.drop,
        moveTo: state.newHomeClientOffset,
        opacity: _combineWith ? combine.opacity.drop : null,
        scale: _combineWith ? combine.scale.drop : null
      };
      return {
        mapped: {
          type: "DRAGGING",
          offset: state.newHomeClientOffset,
          dimension: _dimension,
          dropping,
          draggingOver: _draggingOver,
          combineWith: _combineWith,
          mode,
          forceShouldAnimate: null,
          snapshot: getMemoizedSnapshot(mode, isClone, _draggingOver, _combineWith, dropping)
        }
      };
    }
    return null;
  };
  return selector2;
}
function getSecondarySnapshot(combineTargetFor) {
  return {
    isDragging: false,
    isDropAnimating: false,
    isClone: false,
    dropAnimation: null,
    mode: null,
    draggingOver: null,
    combineTargetFor,
    combineWith: null
  };
}
var atRest = {
  mapped: {
    type: "SECONDARY",
    offset: origin,
    combineTargetFor: null,
    shouldAnimateDisplacement: true,
    snapshot: getSecondarySnapshot(null)
  }
};
function getSecondarySelector() {
  var memoizedOffset = memoizeOne(function(x, y2) {
    return {
      x,
      y: y2
    };
  });
  var getMemoizedSnapshot = memoizeOne(getSecondarySnapshot);
  var getMemoizedProps = memoizeOne(function(offset3, combineTargetFor, shouldAnimateDisplacement) {
    if (combineTargetFor === void 0) {
      combineTargetFor = null;
    }
    return {
      mapped: {
        type: "SECONDARY",
        offset: offset3,
        combineTargetFor,
        shouldAnimateDisplacement,
        snapshot: getMemoizedSnapshot(combineTargetFor)
      }
    };
  });
  var getFallback = function getFallback2(combineTargetFor) {
    return combineTargetFor ? getMemoizedProps(origin, combineTargetFor, true) : null;
  };
  var getProps = function getProps2(ownId, draggingId, impact, afterCritical) {
    var visualDisplacement = impact.displaced.visible[ownId];
    var isAfterCriticalInVirtualList = Boolean(afterCritical.inVirtualList && afterCritical.effected[ownId]);
    var combine2 = tryGetCombine(impact);
    var combineTargetFor = combine2 && combine2.draggableId === ownId ? draggingId : null;
    if (!visualDisplacement) {
      if (!isAfterCriticalInVirtualList) {
        return getFallback(combineTargetFor);
      }
      if (impact.displaced.invisible[ownId]) {
        return null;
      }
      var change = negate(afterCritical.displacedBy.point);
      var _offset = memoizedOffset(change.x, change.y);
      return getMemoizedProps(_offset, combineTargetFor, true);
    }
    if (isAfterCriticalInVirtualList) {
      return getFallback(combineTargetFor);
    }
    var displaceBy = impact.displacedBy.point;
    var offset3 = memoizedOffset(displaceBy.x, displaceBy.y);
    return getMemoizedProps(offset3, combineTargetFor, visualDisplacement.shouldAnimate);
  };
  var selector2 = function selector3(state, ownProps) {
    if (state.isDragging) {
      if (state.critical.draggable.id === ownProps.draggableId) {
        return null;
      }
      return getProps(ownProps.draggableId, state.critical.draggable.id, state.impact, state.afterCritical);
    }
    if (state.phase === "DROP_ANIMATING") {
      var completed = state.completed;
      if (completed.result.draggableId === ownProps.draggableId) {
        return null;
      }
      return getProps(ownProps.draggableId, completed.result.draggableId, completed.impact, completed.afterCritical);
    }
    return null;
  };
  return selector2;
}
var makeMapStateToProps = function makeMapStateToProps2() {
  var draggingSelector = getDraggableSelector();
  var secondarySelector = getSecondarySelector();
  var selector2 = function selector3(state, ownProps) {
    return draggingSelector(state, ownProps) || secondarySelector(state, ownProps) || atRest;
  };
  return selector2;
};
var mapDispatchToProps = {
  dropAnimationFinished
};
var ConnectedDraggable = connect(makeMapStateToProps, mapDispatchToProps, null, {
  context: StoreContext,
  pure: true,
  areStatePropsEqual: isStrictEqual
})(Draggable);
function PrivateDraggable(props) {
  var droppableContext = useRequiredContext(DroppableContext);
  var isUsingCloneFor = droppableContext.isUsingCloneFor;
  if (isUsingCloneFor === props.draggableId && !props.isClone) {
    return null;
  }
  return React.createElement(ConnectedDraggable, props);
}
function PublicDraggable(props) {
  var isEnabled = typeof props.isDragDisabled === "boolean" ? !props.isDragDisabled : true;
  var canDragInteractiveElements = Boolean(props.disableInteractiveElementBlocking);
  var shouldRespectForcePress = Boolean(props.shouldRespectForcePress);
  return React.createElement(PrivateDraggable, _extends({}, props, {
    isClone: false,
    isEnabled,
    canDragInteractiveElements,
    shouldRespectForcePress
  }));
}
function Droppable(props) {
  var appContext = reactExports.useContext(AppContext);
  !appContext ? invariant(false) : void 0;
  var contextId = appContext.contextId, isMovementAllowed2 = appContext.isMovementAllowed;
  var droppableRef = reactExports.useRef(null);
  var placeholderRef = reactExports.useRef(null);
  var children = props.children, droppableId = props.droppableId, type = props.type, mode = props.mode, direction = props.direction, ignoreContainerClipping = props.ignoreContainerClipping, isDropDisabled = props.isDropDisabled, isCombineEnabled = props.isCombineEnabled, snapshot = props.snapshot, useClone = props.useClone, updateViewportMaxScroll3 = props.updateViewportMaxScroll, getContainerForClone = props.getContainerForClone;
  var getDroppableRef = useCallback(function() {
    return droppableRef.current;
  }, []);
  var setDroppableRef = useCallback(function(value) {
    droppableRef.current = value;
  }, []);
  useCallback(function() {
    return placeholderRef.current;
  }, []);
  var setPlaceholderRef = useCallback(function(value) {
    placeholderRef.current = value;
  }, []);
  var onPlaceholderTransitionEnd = useCallback(function() {
    if (isMovementAllowed2()) {
      updateViewportMaxScroll3({
        maxScroll: getMaxWindowScroll()
      });
    }
  }, [isMovementAllowed2, updateViewportMaxScroll3]);
  useDroppablePublisher({
    droppableId,
    type,
    mode,
    direction,
    isDropDisabled,
    isCombineEnabled,
    ignoreContainerClipping,
    getDroppableRef
  });
  var placeholder = React.createElement(AnimateInOut, {
    on: props.placeholder,
    shouldAnimate: props.shouldAnimatePlaceholder
  }, function(_ref) {
    var onClose = _ref.onClose, data = _ref.data, animate = _ref.animate;
    return React.createElement(Placeholder$1, {
      placeholder: data,
      onClose,
      innerRef: setPlaceholderRef,
      animate,
      contextId,
      onTransitionEnd: onPlaceholderTransitionEnd
    });
  });
  var provided = useMemo(function() {
    return {
      innerRef: setDroppableRef,
      placeholder,
      droppableProps: {
        "data-rbd-droppable-id": droppableId,
        "data-rbd-droppable-context-id": contextId
      }
    };
  }, [contextId, droppableId, placeholder, setDroppableRef]);
  var isUsingCloneFor = useClone ? useClone.dragging.draggableId : null;
  var droppableContext = useMemo(function() {
    return {
      droppableId,
      type,
      isUsingCloneFor
    };
  }, [droppableId, isUsingCloneFor, type]);
  function getClone() {
    if (!useClone) {
      return null;
    }
    var dragging = useClone.dragging, render = useClone.render;
    var node = React.createElement(PrivateDraggable, {
      draggableId: dragging.draggableId,
      index: dragging.source.index,
      isClone: true,
      isEnabled: true,
      shouldRespectForcePress: false,
      canDragInteractiveElements: true
    }, function(draggableProvided, draggableSnapshot) {
      return render(draggableProvided, draggableSnapshot, dragging);
    });
    return ReactDOM.createPortal(node, getContainerForClone());
  }
  return React.createElement(DroppableContext.Provider, {
    value: droppableContext
  }, children(provided, snapshot), getClone());
}
var isMatchingType = function isMatchingType2(type, critical) {
  return type === critical.droppable.type;
};
var getDraggable = function getDraggable2(critical, dimensions) {
  return dimensions.draggables[critical.draggable.id];
};
var makeMapStateToProps$1 = function makeMapStateToProps3() {
  var idleWithAnimation = {
    placeholder: null,
    shouldAnimatePlaceholder: true,
    snapshot: {
      isDraggingOver: false,
      draggingOverWith: null,
      draggingFromThisWith: null,
      isUsingPlaceholder: false
    },
    useClone: null
  };
  var idleWithoutAnimation = _extends({}, idleWithAnimation, {
    shouldAnimatePlaceholder: false
  });
  var getDraggableRubric = memoizeOne(function(descriptor) {
    return {
      draggableId: descriptor.id,
      type: descriptor.type,
      source: {
        index: descriptor.index,
        droppableId: descriptor.droppableId
      }
    };
  });
  var getMapProps = memoizeOne(function(id2, isEnabled, isDraggingOverForConsumer, isDraggingOverForImpact, dragging, renderClone) {
    var draggableId = dragging.descriptor.id;
    var isHome = dragging.descriptor.droppableId === id2;
    if (isHome) {
      var useClone = renderClone ? {
        render: renderClone,
        dragging: getDraggableRubric(dragging.descriptor)
      } : null;
      var _snapshot = {
        isDraggingOver: isDraggingOverForConsumer,
        draggingOverWith: isDraggingOverForConsumer ? draggableId : null,
        draggingFromThisWith: draggableId,
        isUsingPlaceholder: true
      };
      return {
        placeholder: dragging.placeholder,
        shouldAnimatePlaceholder: false,
        snapshot: _snapshot,
        useClone
      };
    }
    if (!isEnabled) {
      return idleWithoutAnimation;
    }
    if (!isDraggingOverForImpact) {
      return idleWithAnimation;
    }
    var snapshot = {
      isDraggingOver: isDraggingOverForConsumer,
      draggingOverWith: draggableId,
      draggingFromThisWith: null,
      isUsingPlaceholder: true
    };
    return {
      placeholder: dragging.placeholder,
      shouldAnimatePlaceholder: true,
      snapshot,
      useClone: null
    };
  });
  var selector2 = function selector3(state, ownProps) {
    var id2 = ownProps.droppableId;
    var type = ownProps.type;
    var isEnabled = !ownProps.isDropDisabled;
    var renderClone = ownProps.renderClone;
    if (state.isDragging) {
      var critical = state.critical;
      if (!isMatchingType(type, critical)) {
        return idleWithoutAnimation;
      }
      var dragging = getDraggable(critical, state.dimensions);
      var isDraggingOver = whatIsDraggedOver(state.impact) === id2;
      return getMapProps(id2, isEnabled, isDraggingOver, isDraggingOver, dragging, renderClone);
    }
    if (state.phase === "DROP_ANIMATING") {
      var completed = state.completed;
      if (!isMatchingType(type, completed.critical)) {
        return idleWithoutAnimation;
      }
      var _dragging = getDraggable(completed.critical, state.dimensions);
      return getMapProps(id2, isEnabled, whatIsDraggedOverFromResult(completed.result) === id2, whatIsDraggedOver(completed.impact) === id2, _dragging, renderClone);
    }
    if (state.phase === "IDLE" && state.completed && !state.shouldFlush) {
      var _completed = state.completed;
      if (!isMatchingType(type, _completed.critical)) {
        return idleWithoutAnimation;
      }
      var wasOver = whatIsDraggedOver(_completed.impact) === id2;
      var wasCombining = Boolean(_completed.impact.at && _completed.impact.at.type === "COMBINE");
      var isHome = _completed.critical.droppable.id === id2;
      if (wasOver) {
        return wasCombining ? idleWithAnimation : idleWithoutAnimation;
      }
      if (isHome) {
        return idleWithAnimation;
      }
      return idleWithoutAnimation;
    }
    return idleWithoutAnimation;
  };
  return selector2;
};
var mapDispatchToProps$1 = {
  updateViewportMaxScroll
};
function getBody() {
  !document.body ? invariant(false) : void 0;
  return document.body;
}
var defaultProps = {
  mode: "standard",
  type: "DEFAULT",
  direction: "vertical",
  isDropDisabled: false,
  isCombineEnabled: false,
  ignoreContainerClipping: false,
  renderClone: null,
  getContainerForClone: getBody
};
var ConnectedDroppable = connect(makeMapStateToProps$1, mapDispatchToProps$1, null, {
  context: StoreContext,
  pure: true,
  areStatePropsEqual: isStrictEqual
})(Droppable);
ConnectedDroppable.defaultProps = defaultProps;
const EmojiSelector = ({
  selectedEmojis,
  onRemoveEmoji,
  showEmojiInput,
  newEmoji,
  inputRef,
  onNewEmojiChange,
  onAddEmoji,
  onCancelInput,
  onShowInput,
  error,
  onReorder
}) => /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "mb-4", children: [
  /* @__PURE__ */ jsxRuntimeExports.jsx(DragDropContext, { onDragEnd: onReorder, children: /* @__PURE__ */ jsxRuntimeExports.jsx(ConnectedDroppable, { droppableId: "emojis", direction: "horizontal", children: (provided) => /* @__PURE__ */ jsxRuntimeExports.jsxs(
    "div",
    {
      ref: provided.innerRef,
      ...provided.droppableProps,
      className: "flex flex-wrap gap-2 mb-4",
      children: [
        selectedEmojis.map((emoji, index2) => /* @__PURE__ */ jsxRuntimeExports.jsx(PublicDraggable, { draggableId: `emoji-${index2}`, index: index2, children: (provided2) => /* @__PURE__ */ jsxRuntimeExports.jsxs(
          "div",
          {
            ref: provided2.innerRef,
            ...provided2.draggableProps,
            className: "bg-indigo-100 rounded-md w-14 h-14 flex items-center justify-center cursor-default relative group",
            children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "text-lg", children: emoji }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                "button",
                {
                  onClick: () => onRemoveEmoji(index2),
                  className: "text-gray-400 hover:text-gray-600 absolute -top-0.5 -right-0.5 text-sm w-6 h-6",
                  children: "×"
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                "div",
                {
                  ...provided2.dragHandleProps,
                  className: "absolute left-1 top-1/2 -translate-y-1/2 text-gray-400 opacity-0 group-hover:opacity-100 transition-opacity cursor-grab",
                  children: /* @__PURE__ */ jsxRuntimeExports.jsx(GripVertical, { className: "h-3 w-3" })
                }
              )
            ]
          }
        ) }, `emoji-${index2}`)),
        provided.placeholder,
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "bg-indigo-100 rounded-md w-14 h-14 flex items-center justify-center relative", children: showEmojiInput ? /* @__PURE__ */ jsxRuntimeExports.jsx(
          Tooltip,
          {
            content: "Type an emoji, then hit enter",
            placement: "bottom",
            style: "light",
            className: "whitespace-nowrap min-w-[200px] text-center w-fit bg-white text-black-spicy",
            children: /* @__PURE__ */ jsxRuntimeExports.jsx(
              "input",
              {
                ref: inputRef,
                type: "text",
                value: newEmoji,
                onChange: (e2) => onNewEmojiChange(e2.target.value),
                className: "w-14 h-14 text-center text-lg bg-transparent border-none outline-none text-black rounded-md",
                maxLength: 2,
                onKeyDown: (e2) => {
                  if (e2.key === "Enter" && newEmoji) {
                    onAddEmoji();
                  } else if (e2.key === "Escape") {
                    onCancelInput();
                  }
                },
                onBlur: () => {
                  if (newEmoji) {
                    onAddEmoji();
                  } else {
                    onCancelInput();
                  }
                }
              }
            )
          }
        ) : /* @__PURE__ */ jsxRuntimeExports.jsx(
          "button",
          {
            onClick: onShowInput,
            className: "text-gray-400 hover:text-gray-600 text-2xl pb-1 w-full h-full rounded-md transition-colors duration-200",
            children: "+"
          }
        ) })
      ]
    }
  ) }) }),
  error && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text-red-500 text-sm mb-2", children: error })
] });
const TemplateSelector = ({
  isTemplateBarEnabled,
  onTemplateBarEnabledChange,
  onFoldersChange
}) => {
  var _a;
  const templateSettings = Recoil_index_20(templateSettingsSelector);
  const emojiSettings = Recoil_index_20(emojiSettingsSelector);
  const { updateTemplates } = useNetworkManager();
  const [folders, setFolders] = reactExports.useState([]);
  const [selectedFolderId, setSelectedFolderId] = reactExports.useState(null);
  const [newFolderName, setNewFolderName] = reactExports.useState("");
  const [newTemplate, setNewTemplate] = reactExports.useState("");
  const [updateMessage, setUpdateMessage] = reactExports.useState("");
  const [updateStatus, setUpdateStatus] = reactExports.useState("");
  const [hasChanges, setHasChanges] = reactExports.useState(false);
  const [editingFolder, setEditingFolder] = reactExports.useState(null);
  const [editFolderName, setEditFolderName] = reactExports.useState("");
  const [initialState, setInitialState] = reactExports.useState({
    folders: [],
    enabled: true
  });
  const setHasUnsavedChanges = Recoil_index_24(hasUnsavedChangesAtom);
  const scrollContainerRef = reactExports.useRef(null);
  const messageInputRef = reactExports.useRef(null);
  const [hasHorizontalScroll, setHasHorizontalScroll] = reactExports.useState(false);
  const [showFolderInput, setShowFolderInput] = reactExports.useState(false);
  const folderInputRef = reactExports.useRef(null);
  reactExports.useEffect(() => {
    if (templateSettings) {
      const foldersWithIds = templateSettings.folders.map((folder) => ({
        ...folder,
        id: folder._id,
        chatMessageTemplates: folder.chatMessageTemplates.map((template) => ({
          ...template,
          id: template._id
        }))
      }));
      setFolders(foldersWithIds);
      setInitialState({
        folders: foldersWithIds || [],
        enabled: templateSettings.templateBarEnabled || true
      });
      if (foldersWithIds.length === 0) {
        setShowFolderInput(true);
      }
    }
  }, [templateSettings]);
  reactExports.useEffect(() => {
    const foldersChanged = JSON.stringify(folders) !== JSON.stringify(initialState.folders);
    const enabledChanged = isTemplateBarEnabled !== initialState.enabled;
    const hasChanges2 = foldersChanged || enabledChanged;
    console.log("[template] different folders:", foldersChanged);
    console.log("[template] different enabled:", enabledChanged);
    console.log("[template] hasChanges:", hasChanges2);
    console.log("[template] folders:", folders);
    console.log("[template] initialState:", initialState);
    setHasChanges(hasChanges2);
    setHasUnsavedChanges(hasChanges2);
  }, [folders, isTemplateBarEnabled, initialState, setHasUnsavedChanges]);
  reactExports.useEffect(() => {
    onFoldersChange(folders);
  }, [folders]);
  reactExports.useEffect(() => {
    const checkForScroll = () => {
      if (scrollContainerRef.current) {
        const hasScroll = scrollContainerRef.current.scrollWidth > scrollContainerRef.current.clientWidth;
        setHasHorizontalScroll(hasScroll);
      }
    };
    checkForScroll();
    const resizeObserver = new ResizeObserver(checkForScroll);
    if (scrollContainerRef.current) {
      resizeObserver.observe(scrollContainerRef.current);
    }
    return () => {
      if (scrollContainerRef.current) {
        resizeObserver.unobserve(scrollContainerRef.current);
      }
    };
  }, [folders]);
  reactExports.useEffect(() => {
    if (selectedFolderId && messageInputRef.current) {
      messageInputRef.current.focus();
    }
  }, [selectedFolderId]);
  const onDragEnd3 = (result) => {
    if (!result.destination)
      return;
    const { source, destination, type } = result;
    if (type === "folder") {
      const reorderedFolders = Array.from(folders);
      const [removed] = reorderedFolders.splice(source.index, 1);
      reorderedFolders.splice(destination.index, 0, removed);
      const updatedFolders = reorderedFolders.map((folder, index2) => ({
        ...folder,
        order: index2
      }));
      setFolders(updatedFolders);
    } else if (type === "template" && selectedFolderId !== null) {
      const selectedFolder = folders.find((f2) => f2.id === selectedFolderId);
      if (!selectedFolder)
        return;
      const folderTemplates = Array.from(selectedFolder.chatMessageTemplates);
      const [removed] = folderTemplates.splice(source.index, 1);
      folderTemplates.splice(destination.index, 0, removed);
      const updatedTemplates = folderTemplates.map((template, index2) => ({
        ...template,
        order: index2
      }));
      const updatedFolders = folders.map((folder) => {
        if (folder.id === selectedFolderId) {
          return {
            ...folder,
            chatMessageTemplates: updatedTemplates
          };
        }
        return folder;
      });
      setFolders(updatedFolders);
    }
  };
  const onCancelFolderInput = () => {
    setNewFolderName("");
  };
  const onAddFolder = () => {
    if (!newFolderName.trim()) {
      onCancelFolderInput();
      return;
    }
    const newFolder = {
      id: `folder-${Math.random().toString(36).substr(2, 9)}`,
      name: newFolderName.trim(),
      order: folders.length,
      chatMessageTemplates: []
    };
    setFolders([...folders, newFolder]);
    setNewFolderName("");
    setShowFolderInput(false);
    onCancelFolderInput();
    setTimeout(() => {
      setSelectedFolderId(newFolder.id);
      if (scrollContainerRef.current) {
        scrollContainerRef.current.scrollTo({
          left: scrollContainerRef.current.scrollWidth,
          behavior: "smooth"
        });
      }
    }, 0);
  };
  const handleEditFolder = (folderId) => {
    const folder = folders.find((f2) => f2.id === folderId);
    if (folder) {
      setEditingFolder(folderId);
      setEditFolderName(folder.name);
    }
  };
  const handleSaveFolder = () => {
    if (!editFolderName.trim() || editingFolder === null)
      return;
    const updatedFolders = folders.map((folder) => {
      if (folder.id === editingFolder) {
        return {
          ...folder,
          name: editFolderName.trim()
        };
      }
      return folder;
    });
    setFolders(updatedFolders);
    setEditingFolder(null);
    setEditFolderName("");
  };
  const handleDeleteFolder = (folderId) => {
    const updatedFolders = folders.filter((folder) => folder.id !== folderId);
    const reorderedFolders = updatedFolders.map((folder, i2) => ({
      ...folder,
      order: i2
    }));
    setFolders(reorderedFolders);
    if (selectedFolderId === folderId) {
      setSelectedFolderId(null);
    }
    if (updatedFolders.length === 0) {
      setShowFolderInput(true);
    }
  };
  const handleAddTemplate = () => {
    if (!selectedFolderId || !newTemplate.trim())
      return;
    const updatedFolders = folders.map((folder) => {
      if (folder.id === selectedFolderId) {
        return {
          ...folder,
          chatMessageTemplates: [
            ...folder.chatMessageTemplates,
            {
              id: `template-${Math.random().toString(36).substr(2, 9)}`,
              message: newTemplate.trim(),
              order: folder.chatMessageTemplates.length
            }
          ]
        };
      }
      return folder;
    });
    setFolders(updatedFolders);
    setNewTemplate("");
  };
  const handleMessageKeyDown = (e2) => {
    if (e2.key === "Enter") {
      if (e2.shiftKey) {
        return;
      }
      e2.preventDefault();
      if (newTemplate.trim()) {
        handleAddTemplate();
      }
    }
  };
  const handleBannerHide = () => {
    setUpdateMessage("");
    setUpdateStatus("");
  };
  const handleSave = async () => {
    if (!hasChanges)
      return;
    try {
      const orderedFolders = folders.map((folder, folderIndex) => ({
        ...folder,
        order: folderIndex,
        chatMessageTemplates: folder.chatMessageTemplates.map((template, templateIndex) => ({
          ...template,
          order: templateIndex
        }))
      }));
      const response = await updateTemplates({
        folders: orderedFolders,
        templateBarEnabled: isTemplateBarEnabled
      });
      if (response.status === 200 && response.body) {
        setUpdateMessage("Chat templates updated successfully!");
        setUpdateStatus("success");
        setHasChanges(false);
        setHasUnsavedChanges(false);
        setSelectedFolderId(null);
        setTimeout(() => {
          setUpdateMessage("");
          setUpdateStatus("");
        }, 3e3);
      } else {
        console.error("Unexpected response:", response);
        setUpdateMessage("Failed to update template settings. Please try again.");
        setUpdateStatus("error");
      }
    } catch (error) {
      console.error("Error updating template settings:", error);
      setUpdateMessage(error.message || "An error occurred while updating template settings.");
      setUpdateStatus("error");
    }
  };
  const handleFolderSelect = (folderId) => {
    setSelectedFolderId(folderId === selectedFolderId ? null : folderId);
    setShowFolderInput(false);
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "mb-6", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "mb-4 flex items-center justify-between", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: "text-lg font-semibold", children: folders.length === 0 ? "Add chat templates" : "Edit chat templates" }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("label", { className: "flex items-center", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          "input",
          {
            type: "checkbox",
            checked: isTemplateBarEnabled,
            onChange: (e2) => onTemplateBarEnabledChange(e2.target.checked),
            className: "mr-2 rounded-sm text-base text-black-spicy accent-indigo-500 checked:border-indigo-500 checked:bg-indigo-500 focus:ring-indigo-500"
          }
        ),
        "Enable template bar"
      ] })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(DragDropContext, { onDragEnd: onDragEnd3, children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "mb-4", children: [
      folders.length > 0 && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "relative", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(ConnectedDroppable, { droppableId: "folders", direction: "horizontal", type: "folder", children: (provided) => /* @__PURE__ */ jsxRuntimeExports.jsx(
          "div",
          {
            ref: (el2) => {
              provided.innerRef(el2);
              scrollContainerRef.current = el2;
            },
            ...provided.droppableProps,
            className: `${!showFolderInput ? "-ml-10" : "-mx-10"} mb-4 overflow-x-auto pb-2 pl-10 hide-scrollbar ${hasHorizontalScroll ? "hover:mb-[5px] hover:show-scrollbar" : ""}`,
            children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex gap-2", children: [
              folders.map((folder, index2) => /* @__PURE__ */ jsxRuntimeExports.jsx(PublicDraggable, { draggableId: folder.id, index: index2, children: (provided2) => /* @__PURE__ */ jsxRuntimeExports.jsx(
                "div",
                {
                  ref: provided2.innerRef,
                  ...provided2.draggableProps,
                  className: "group flex-shrink-0",
                  children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center rounded-full bg-indigo-100 p-1", children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx(
                      "div",
                      {
                        ...provided2.dragHandleProps,
                        className: "cursor-move px-1 text-gray-700",
                        children: /* @__PURE__ */ jsxRuntimeExports.jsx(GripVertical, { className: "h-4 w-4" })
                      }
                    ),
                    editingFolder === folder.id ? /* @__PURE__ */ jsxRuntimeExports.jsx(
                      "input",
                      {
                        type: "text",
                        value: editFolderName,
                        onChange: (e2) => setEditFolderName(e2.target.value),
                        onKeyDown: (e2) => {
                          if (e2.key === "Enter")
                            handleSaveFolder();
                          if (e2.key === "Escape") {
                            setEditingFolder(null);
                            setEditFolderName("");
                          }
                        },
                        onBlur: handleSaveFolder,
                        className: "h-8 w-auto min-w-[6rem] rounded border bg-transparent px-2 text-sm",
                        style: { width: `${editFolderName.length + 2}ch` },
                        autoFocus: true
                      }
                    ) : /* @__PURE__ */ jsxRuntimeExports.jsx(
                      "button",
                      {
                        onClick: () => handleFolderSelect(folder.id),
                        className: `h-8 rounded-full px-3 text-sm transition-colors ${selectedFolderId === folder.id ? "bg-indigo-200 text-gray-900" : "text-gray-700 hover:bg-indigo-200"}`,
                        children: folder.name
                      }
                    ),
                    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex opacity-0 transition-opacity group-hover:opacity-100", children: [
                      /* @__PURE__ */ jsxRuntimeExports.jsx(
                        "button",
                        {
                          onClick: (e2) => {
                            e2.stopPropagation();
                            handleEditFolder(folder.id);
                          },
                          className: "flex h-6 w-6 items-center justify-center text-gray-500 hover:text-gray-700",
                          children: /* @__PURE__ */ jsxRuntimeExports.jsx(Pen, { className: "h-3 w-3" })
                        }
                      ),
                      /* @__PURE__ */ jsxRuntimeExports.jsx(
                        "button",
                        {
                          onClick: (e2) => {
                            e2.stopPropagation();
                            handleDeleteFolder(folder.id);
                          },
                          className: "flex h-6 w-6 items-center justify-center text-red-500 hover:text-red-700",
                          children: /* @__PURE__ */ jsxRuntimeExports.jsx(Trash2, { className: "h-3 w-3" })
                        }
                      )
                    ] })
                  ] })
                }
              ) }, folder.id)),
              provided.placeholder,
              /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "w-[116px] flex-shrink-0" })
            ] })
          }
        ) }),
        !showFolderInput && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "pointer-events-none absolute right-0 top-0 h-full w-48 bg-gradient-to-r from-transparent via-white-spicy/70 to-white-spicy" }),
        !showFolderInput && /* @__PURE__ */ jsxRuntimeExports.jsxs(
          "button",
          {
            onClick: () => {
              setSelectedFolderId(null);
              setShowFolderInput(true);
              setTimeout(() => {
                folderInputRef.current.focus();
              }, 0);
            },
            className: "text-white absolute right-0 top-0.5 flex items-center gap-2 rounded-md bg-indigo-500 px-4 py-2.5 text-xs hover:bg-indigo-600",
            children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(Plus, { className: "h-4 w-4" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: "Add folder" })
            ]
          }
        )
      ] }),
      showFolderInput && !selectedFolderId && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "mb-4 flex", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          "input",
          {
            ref: folderInputRef,
            type: "text",
            value: newFolderName,
            onChange: (e2) => setNewFolderName(e2.target.value),
            placeholder: "New folder name",
            className: "mr-2 flex-1 rounded-md border px-3 py-2 text-xs focus:outline-none focus:ring-2 focus:ring-indigo-500",
            onKeyDown: (e2) => {
              if (e2.key === "Enter" && newFolderName) {
                onAddFolder();
              } else if (e2.key === "Escape") {
                setShowFolderInput(false);
                setNewFolderName("");
              }
            }
          }
        ),
        !newFolderName.trim() ? /* @__PURE__ */ jsxRuntimeExports.jsx(
          Tooltip,
          {
            content: "Enter a folder name to create a new folder",
            placement: "bottom",
            style: "light",
            className: "whitespace-nowrap",
            children: /* @__PURE__ */ jsxRuntimeExports.jsx(
              "button",
              {
                onClick: onAddFolder,
                disabled: !newFolderName.trim(),
                className: `text-white flex items-center gap-2 rounded-md bg-indigo-500 px-4 py-2 transition-colors hover:bg-indigo-600`,
                children: /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: "Add folder" })
              }
            )
          }
        ) : /* @__PURE__ */ jsxRuntimeExports.jsx(
          "button",
          {
            onClick: onAddFolder,
            disabled: !newFolderName.trim(),
            className: `text-white flex items-center gap-2 rounded-md bg-indigo-500 px-4 py-2 transition-colors hover:bg-indigo-600`,
            children: /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: "Add folder" })
          }
        )
      ] }),
      selectedFolderId && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "mt-0", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "mb-2 flex flex-col items-start gap-0 text-base font-semibold", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("h2", { className: "text-left text-base font-semibold", children: [
            (_a = folders.find((f2) => f2.id === selectedFolderId)) == null ? void 0 : _a.name,
            " folder"
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "text-xs text-gray-500", children: "Messages" })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "mb-4 flex flex-col", children: [
          (emojiSettings == null ? void 0 : emojiSettings.emojiBarEnabled) && /* @__PURE__ */ jsxRuntimeExports.jsx(
            "div",
            {
              className: "flex items-center justify-between rounded-t-lg p-2",
              style: { background: "linear-gradient(to right, #D6E9FF, #EFE5FF)" },
              children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "no-scrollbar flex w-full flex-wrap overflow-auto", children: emojiSettings.emojisForToolbar.map((emoji, index2) => /* @__PURE__ */ jsxRuntimeExports.jsx(
                "button",
                {
                  className: "select-none px-2 py-0.5 text-[14px]",
                  style: {
                    WebkitTapHighlightColor: "transparent",
                    outline: "none"
                  },
                  onClick: () => {
                    var _a2;
                    setNewTemplate((prev) => prev + emoji);
                    (_a2 = messageInputRef.current) == null ? void 0 : _a2.focus();
                  },
                  children: emoji
                },
                index2
              )) })
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "textarea",
            {
              ref: messageInputRef,
              value: newTemplate,
              onChange: (e2) => setNewTemplate(e2.target.value),
              onKeyDown: handleMessageKeyDown,
              placeholder: "Type a message...",
              className: `w-full rounded-md border p-3 focus:border-indigo-500 focus:outline-none focus:ring-0 ${(emojiSettings == null ? void 0 : emojiSettings.emojiBarEnabled) ? "rounded-t-none" : ""}`,
              style: { minHeight: "60px" }
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex justify-end pt-2", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
            "button",
            {
              onClick: handleAddTemplate,
              disabled: !newTemplate.trim(),
              className: `text-white flex items-center gap-1 rounded-md bg-indigo-500 px-4 py-2 transition-colors hover:bg-indigo-600`,
              children: "Add template"
            }
          ) })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(ConnectedDroppable, { droppableId: "templates", type: "template", children: (provided) => {
          var _a2;
          return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { ref: provided.innerRef, ...provided.droppableProps, className: "space-y-2", children: [
            (_a2 = folders.find((f2) => f2.id === selectedFolderId)) == null ? void 0 : _a2.chatMessageTemplates.map((template, index2) => /* @__PURE__ */ jsxRuntimeExports.jsx(PublicDraggable, { draggableId: template.id, index: index2, children: (provided2) => /* @__PURE__ */ jsxRuntimeExports.jsx(
              "div",
              {
                ref: provided2.innerRef,
                ...provided2.draggableProps,
                className: "bg-white rounded-lg border shadow-sm",
                children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center p-2", children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx(
                    "div",
                    {
                      ...provided2.dragHandleProps,
                      className: "mr-2 cursor-move text-gray-500 hover:text-gray-600",
                      children: /* @__PURE__ */ jsxRuntimeExports.jsx(GripVertical, { className: "h-5 w-5" })
                    }
                  ),
                  /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex-grow", children: template.editMode ? /* @__PURE__ */ jsxRuntimeExports.jsx(
                    "textarea",
                    {
                      value: template.editMessage || template.message,
                      onChange: (e2) => {
                        const updatedFolders = folders.map((folder) => {
                          if (folder.id === selectedFolderId) {
                            return {
                              ...folder,
                              chatMessageTemplates: folder.chatMessageTemplates.map(
                                (t2) => {
                                  if (t2.id === template.id) {
                                    return {
                                      ...t2,
                                      editMessage: e2.target.value
                                    };
                                  }
                                  return t2;
                                }
                              )
                            };
                          }
                          return folder;
                        });
                        setFolders(updatedFolders);
                      },
                      onBlur: () => {
                        const updatedFolders = folders.map((folder) => {
                          if (folder.id === selectedFolderId) {
                            return {
                              ...folder,
                              chatMessageTemplates: folder.chatMessageTemplates.map(
                                (t2) => {
                                  if (t2.id === template.id) {
                                    return {
                                      ...t2,
                                      message: t2.editMessage || t2.message,
                                      editMessage: void 0,
                                      editMode: false
                                    };
                                  }
                                  return t2;
                                }
                              )
                            };
                          }
                          return folder;
                        });
                        setFolders(updatedFolders);
                      },
                      autoFocus: true,
                      className: "min-h-[100px] w-full rounded border p-2 focus:outline-none focus:ring-2 focus:ring-indigo-500"
                    }
                  ) : /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "whitespace-pre-wrap py-1 pl-8 text-left", children: template.message }) }),
                  /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "ml-2 flex items-center gap-2", children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx(
                      "button",
                      {
                        onClick: () => {
                          const updatedFolders = folders.map((folder) => {
                            if (folder.id === selectedFolderId) {
                              return {
                                ...folder,
                                chatMessageTemplates: folder.chatMessageTemplates.map(
                                  (t2) => {
                                    if (t2.id === template.id) {
                                      return {
                                        ...t2,
                                        editMode: true
                                      };
                                    }
                                    return t2;
                                  }
                                )
                              };
                            }
                            return folder;
                          });
                          setFolders(updatedFolders);
                        },
                        className: "p-1.5 text-gray-500 hover:text-gray-700",
                        children: /* @__PURE__ */ jsxRuntimeExports.jsx(Pen, { className: "h-4 w-4" })
                      }
                    ),
                    /* @__PURE__ */ jsxRuntimeExports.jsx(
                      "button",
                      {
                        onClick: () => {
                          const updatedFolders = folders.map((folder) => {
                            if (folder.id === selectedFolderId) {
                              return {
                                ...folder,
                                chatMessageTemplates: folder.chatMessageTemplates.filter(
                                  (t2) => t2.id !== template.id
                                )
                              };
                            }
                            return folder;
                          });
                          setFolders(updatedFolders);
                        },
                        className: "p-1.5 text-red-500 hover:text-red-700",
                        children: /* @__PURE__ */ jsxRuntimeExports.jsx(Trash2, { className: "h-4 w-4" })
                      }
                    )
                  ] })
                ] })
              }
            ) }, template.id)),
            provided.placeholder
          ] });
        } })
      ] })
    ] }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(SubmitButton, { title: "Save", onSubmit: handleSave, hasChanges }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      FloatingStatusBanner,
      {
        message: updateMessage,
        type: updateStatus === "success" ? "success" : "error",
        show: !!updateMessage,
        onHide: handleBannerHide,
        autoHideDelay: 5e3
      }
    )
  ] });
};
const PreviewSection = ({
  isEmojiBarEnabled,
  selectedEmojis,
  onEmojiClick,
  previewMessage,
  isTyping,
  onMessageFocus,
  onMessageBlur,
  onMessageInput,
  isTemplateBarEnabled = false,
  templates = []
}) => /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "mt-6", children: [
  /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: "mb-2 text-left text-lg font-semibold", children: "Preview" }),
  /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "rounded-lg bg-purple-100 p-4", children: [
    isTemplateBarEnabled && /* @__PURE__ */ jsxRuntimeExports.jsx(
      "div",
      {
        className: "flex items-center justify-between p-2",
        style: { background: "linear-gradient(to right, #D6E9FF, #EFE5FF)" },
        children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "no-scrollbar -mx-2 flex gap-3 overflow-x-auto whitespace-nowrap px-2", children: templates.length === 0 ? /* @__PURE__ */ jsxRuntimeExports.jsx(
          "button",
          {
            className: "text-white inline-flex h-[30px] flex-shrink-0 items-center justify-center rounded-[20px] bg-indigo-500 px-3 text-xs font-semibold leading-snug hover:bg-indigo-600",
            style: {
              WebkitTapHighlightColor: "transparent",
              outline: "none"
            },
            children: "+ chat template"
          }
        ) : templates.map((folder, index2) => /* @__PURE__ */ jsxRuntimeExports.jsx(
          "button",
          {
            className: "inline-flex h-[30px] flex-shrink-0 items-center justify-center rounded-[20px] bg-indigo-200 px-3 text-xs font-normal leading-snug text-gray-900  hover:bg-indigo-300",
            style: {
              WebkitTapHighlightColor: "transparent",
              outline: "none",
              fontFamily: "Roboto, sans-serif"
            },
            children: folder.name
          },
          index2
        )) })
      }
    ),
    isEmojiBarEnabled && /* @__PURE__ */ jsxRuntimeExports.jsxs(
      "div",
      {
        className: "flex items-center justify-between p-2",
        style: { background: "linear-gradient(to right, #D6E9FF, #EFE5FF)" },
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "no-scrollbar flex flex-wrap overflow-auto", children: selectedEmojis.map((emoji, index2) => /* @__PURE__ */ jsxRuntimeExports.jsx(
            "button",
            {
              className: "select-none px-2 py-0.5 text-[14px]",
              style: {
                WebkitTapHighlightColor: "transparent",
                outline: "none"
              },
              onClick: () => onEmojiClick(emoji),
              children: emoji
            },
            index2
          )) }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "px-2 text-[14px]", children: "⚙️" })
        ]
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "bg-white", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      "div",
      {
        className: `h-20 bg-gray-100 p-4 text-left text-base focus:outline-none focus:ring-0 ${isTyping ? "text-black" : "text-gray-400"}`,
        contentEditable: true,
        onFocus: onMessageFocus,
        onBlur: onMessageBlur,
        onInput: onMessageInput,
        suppressContentEditableWarning: true,
        children: previewMessage
      }
    ) })
  ] })
] });
const CustomizeShortcutsTab = () => {
  const emojiSettings = Recoil_index_20(emojiSettingsSelector);
  const templateSettings = Recoil_index_20(templateSettingsSelector);
  const setSubscriptionSettings = Recoil_index_24(subscriptionSettingsAtom);
  const { updateCreatorSettings } = useNetworkManager();
  const [selectedEmojis, setSelectedEmojis] = reactExports.useState([]);
  const [updateMessage, setUpdateMessage] = reactExports.useState("");
  const [updateStatus, setUpdateStatus] = reactExports.useState("");
  const [isEmojiBarEnabled, setIsEmojiBarEnabled] = reactExports.useState(true);
  const [isTemplateBarEnabled, setIsTemplateBarEnabled] = reactExports.useState(true);
  const [showEmojiInput, setShowEmojiInput] = reactExports.useState(false);
  const [newEmoji, setNewEmoji] = reactExports.useState("");
  const [error, setError] = reactExports.useState("");
  const inputRef = reactExports.useRef(null);
  const [previewMessage, setPreviewMessage] = reactExports.useState("Type a message...");
  const [isTyping, setIsTyping] = reactExports.useState(false);
  const [hasEmojiChanges, setHasEmojiChanges] = reactExports.useState(false);
  const [initialState, setInitialState] = reactExports.useState({
    emojis: [],
    enabled: true,
    templateBarEnabled: true
  });
  const setHasUnsavedEmojiChanges = Recoil_index_24(hasUnsavedChangesAtom);
  const [folders, setFolders] = reactExports.useState([]);
  reactExports.useEffect(() => {
    if (emojiSettings) {
      setSelectedEmojis(emojiSettings.emojisForToolbar);
      setInitialState({
        emojis: emojiSettings.emojisForToolbar,
        enabled: emojiSettings.emojiBarEnabled
      });
      setIsEmojiBarEnabled(emojiSettings.emojiBarEnabled);
    }
  }, [emojiSettings]);
  reactExports.useEffect(() => {
    if (templateSettings) {
      const foldersWithIds = templateSettings.folders.map((folder) => ({
        ...folder,
        id: folder._id,
        chatMessageTemplates: folder.chatMessageTemplates.map((template) => ({
          ...template,
          id: template._id
        }))
      }));
      setFolders(foldersWithIds);
      console.log(`[template] templateSettings: ${JSON.stringify(templateSettings, null, 2)}`);
      setIsTemplateBarEnabled(templateSettings.templateBarEnabled);
    }
  }, [templateSettings]);
  reactExports.useEffect(() => {
    if (showEmojiInput && inputRef.current) {
      inputRef.current.focus();
    }
  }, [showEmojiInput]);
  reactExports.useEffect(() => {
    const emojisChanged = JSON.stringify(selectedEmojis) !== JSON.stringify(initialState.emojis);
    const enabledChanged = isEmojiBarEnabled !== initialState.enabled;
    const hasChanges = emojisChanged || enabledChanged;
    setHasEmojiChanges(hasChanges);
    setHasUnsavedEmojiChanges(hasChanges);
  }, [selectedEmojis, isEmojiBarEnabled, initialState, setHasUnsavedEmojiChanges]);
  const handleRemoveEmoji = (indexToRemove) => {
    setSelectedEmojis(selectedEmojis.filter((_2, index2) => index2 !== indexToRemove));
  };
  const isEmoji = (str) => {
    if (/^[\s\w\x00-\x1F\x7F-\x9F]$/.test(str) || /^[\s\w\x00-\x1F\x7F-\x9F]{2}$/.test(str)) {
      return false;
    }
    return str.length === 1 || str.length === 2 || str.length === 4 && /[\u2764\uD800-\uDBFF][\uDC00-\uDFFF][\u2764\uD800-\uDBFF][\uDC00-\uDFFF]/.test(str) || str.length === 8 && /[\u2764\uD800-\uDBFF][\uDC00-\uDFFF][\u2764\uD800-\uDBFF][\uDC00-\uDFFF][\u2764\uD800-\uDBFF][\uDC00-\uDFFF][\u2764\uD800-\uDBFF][\uDC00-\uDFFF]/.test(
      str
    );
  };
  const handleAddEmoji = () => {
    if (!newEmoji) {
      setError("Please enter an emoji");
      return;
    }
    if (!isEmoji(newEmoji)) {
      setError("Please enter a valid emoji");
      return;
    }
    setSelectedEmojis([...selectedEmojis, newEmoji]);
    setNewEmoji("");
    setShowEmojiInput(false);
    setError("");
  };
  const handleBannerHide = () => {
    setUpdateMessage("");
    setUpdateStatus("");
  };
  const handleSave = async () => {
    if (!hasEmojiChanges)
      return;
    if (showEmojiInput) {
      setShowEmojiInput(false);
      setNewEmoji("");
      setError("");
    }
    try {
      const response = await updateCreatorSettings({
        emojisForToolbar: selectedEmojis,
        emojiBarEnabled: isEmojiBarEnabled
      });
      if (response.status === 200) {
        setSubscriptionSettings(response.body);
        setUpdateMessage("Emoji toolbar updated successfully!");
        setUpdateStatus("success");
        setInitialState({
          emojis: selectedEmojis,
          enabled: isEmojiBarEnabled
        });
        setHasEmojiChanges(false);
        setHasUnsavedEmojiChanges(false);
        setTimeout(() => {
          setUpdateMessage("");
          setUpdateStatus("");
        }, 3e3);
      } else {
        setUpdateMessage("Failed to update emoji toolbar. Please try again.");
        setUpdateStatus("error");
      }
    } catch (error2) {
      console.error("Error updating emoji toolbar:", error2);
      setUpdateMessage("An error occurred while updating emoji toolbar.");
      setUpdateStatus("error");
    }
  };
  const handleCancelEmojiInput = () => {
    setShowEmojiInput(false);
    setNewEmoji("");
    setError("");
  };
  const handlePreviewEmojiClick = (emoji) => {
    setIsTyping(true);
    setPreviewMessage((prev) => prev === "Type a message..." ? emoji : prev + emoji);
  };
  const handleReorderEmojis = (result) => {
    if (!result.destination)
      return;
    const items = Array.from(selectedEmojis);
    const [removed] = items.splice(result.source.index, 1);
    items.splice(result.destination.index, 0, removed);
    setSelectedEmojis(items);
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "w-full", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      TabHeader,
      {
        title: "Customize your shortcuts bar 😊",
        subtitle: "Your most used emojis are just a click away for easier access while you're chatting with fans. It's that much easier to give your messages ✨ personality ✨ ~"
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "mb-6", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "mb-4 flex items-center justify-between", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: "text-lg font-semibold", children: selectedEmojis.length === 0 ? "Add emojis" : "Edit emojis" }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("label", { className: "flex items-center", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "input",
            {
              type: "checkbox",
              checked: isEmojiBarEnabled,
              onChange: (e2) => setIsEmojiBarEnabled(e2.target.checked),
              className: "mr-2 rounded-sm text-base text-black-spicy accent-indigo-500 checked:border-indigo-500 checked:bg-indigo-500 focus:ring-indigo-500"
            }
          ),
          "Enable emoji bar"
        ] })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        EmojiSelector,
        {
          selectedEmojis,
          onRemoveEmoji: handleRemoveEmoji,
          showEmojiInput,
          newEmoji,
          inputRef,
          onNewEmojiChange: setNewEmoji,
          onAddEmoji: handleAddEmoji,
          onCancelInput: handleCancelEmojiInput,
          onShowInput: () => setShowEmojiInput(true),
          error,
          onReorder: handleReorderEmojis
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        SubmitButton,
        {
          title: "Save",
          onSubmit: handleSave,
          hasChanges: hasEmojiChanges,
          disabled: showEmojiInput && newEmoji
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        FloatingStatusBanner,
        {
          message: updateMessage,
          type: updateStatus === "success" ? "success" : "error",
          show: !!updateMessage,
          onHide: handleBannerHide,
          autoHideDelay: 5e3
        }
      )
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "mt-8", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      TemplateSelector,
      {
        isTemplateBarEnabled,
        onTemplateBarEnabledChange: setIsTemplateBarEnabled,
        folders,
        onFoldersChange: setFolders
      }
    ) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      PreviewSection,
      {
        isEmojiBarEnabled,
        selectedEmojis,
        onEmojiClick: handlePreviewEmojiClick,
        previewMessage,
        isTyping,
        onMessageFocus: () => {
          setIsTyping(true);
          if (previewMessage === "Type a message...") {
            setPreviewMessage("");
          }
        },
        onMessageBlur: (e2) => {
          const content = e2.target.textContent.trim();
          if (!content) {
            setIsTyping(false);
            setPreviewMessage("Type a message...");
          }
        },
        onMessageInput: (e2) => {
          setPreviewMessage(e2.target.textContent);
          const range2 = document.createRange();
          const sel = window.getSelection();
          range2.selectNodeContents(e2.target);
          range2.collapse(false);
          sel.removeAllRanges();
          sel.addRange(range2);
        },
        isTemplateBarEnabled,
        templates: folders
      }
    )
  ] });
};
const DebugConsoleTab = () => {
  const subscriptionSettings = Recoil_index_20(subscriptionSettingsAtom);
  const setSubscriptionSettings = Recoil_index_24(subscriptionSettingsAtom);
  const { updateSubscriptionSettings, getCreatorDataSync } = useNetworkManager();
  const { getAutoFollowFansEnabled } = useOnlyFansAPI();
  const [updateMessage, setUpdateMessage] = reactExports.useState("");
  const [formData, setFormData] = reactExports.useState({
    followBackSubscribersEnabled: false,
    followNewSubscribersImmediately: false,
    emojisForToolbar: [],
    managerEmails: [],
    ofCreatorIds: []
  });
  const [newManagerEmail, setNewManagerEmail] = reactExports.useState("");
  const [removeManagerEmail, setRemoveManagerEmail] = reactExports.useState("");
  const [newCreatorId, setNewCreatorId] = reactExports.useState("");
  const [removeCreatorId, setRemoveCreatorId] = reactExports.useState("");
  const [creatorSyncData, setCreatorSyncData] = reactExports.useState({});
  reactExports.useEffect(() => {
    if (subscriptionSettings) {
      setFormData({
        followBackSubscribersEnabled: subscriptionSettings.followBackSubscribersEnabled || false,
        followNewSubscribersImmediately: subscriptionSettings.followNewSubscribersImmediately || false,
        emojisForToolbar: subscriptionSettings.emojisForToolbar || [],
        managerEmails: subscriptionSettings.managerEmails || [],
        ofCreatorIds: subscriptionSettings.ofCreatorIds || []
      });
    }
  }, [subscriptionSettings]);
  reactExports.useEffect(() => {
    let isMounted = true;
    const fetchAutoFollowFansEnabled = async () => {
      try {
        const autoFollowEnabled = await getAutoFollowFansEnabled();
        if (isMounted) {
          setFormData((prevState) => ({
            ...prevState,
            followNewSubscribersImmediately: autoFollowEnabled
          }));
        }
      } catch (error) {
        console.error("Error fetching auto follow fans enabled:", error);
      }
    };
    fetchAutoFollowFansEnabled();
    return () => {
      isMounted = false;
    };
  }, []);
  reactExports.useEffect(() => {
    const fetchCreatorSyncData = async () => {
      var _a;
      if (!(subscriptionSettings == null ? void 0 : subscriptionSettings._id) || !((_a = formData.ofCreatorIds) == null ? void 0 : _a.length))
        return;
      const newSyncData = {};
      for (const creatorId of formData.ofCreatorIds) {
        try {
          const data = await getCreatorDataSync();
          newSyncData[creatorId] = data;
        } catch (error) {
          console.error(`Error fetching sync data for creator ${creatorId}:`, error);
        }
      }
      setCreatorSyncData(newSyncData);
    };
    fetchCreatorSyncData();
  }, [subscriptionSettings == null ? void 0 : subscriptionSettings._id, formData.ofCreatorIds]);
  const handleInputChange = (e2) => {
    const { name, value, type, checked } = e2.target;
    setFormData((prevState) => ({
      ...prevState,
      [name]: type === "checkbox" ? checked : name === "emojisForToolbar" ? value.split(",").map((emoji) => emoji.trim()) : value
    }));
  };
  const handleAddManager = async () => {
    try {
      const response = await updateSubscriptionSettings({ addManagerEmail: newManagerEmail });
      if (response.status === 200) {
        setSubscriptionSettings(response.body);
        setUpdateMessage("Manager added successfully!");
        setNewManagerEmail("");
      } else {
        setUpdateMessage("Failed to add manager. Please try again.");
      }
    } catch (error) {
      console.error("Error adding manager:", error);
      setUpdateMessage("An error occurred while adding manager.");
    }
  };
  const handleRemoveManager = async () => {
    try {
      const response = await updateSubscriptionSettings({
        removeManagerEmail
      });
      if (response.status === 200) {
        setSubscriptionSettings(response.body);
        setUpdateMessage("Manager removed successfully!");
        setRemoveManagerEmail("");
      } else {
        setUpdateMessage("Failed to remove manager. Please try again.");
      }
    } catch (error) {
      console.error("Error removing manager:", error);
      setUpdateMessage("An error occurred while removing manager.");
    }
  };
  const handleAddCreator = async () => {
    try {
      const response = await updateSubscriptionSettings({ addOfCreatorId: newCreatorId });
      if (response.status === 200) {
        setSubscriptionSettings(response.body);
        setUpdateMessage("Creator added successfully!");
        setNewCreatorId("");
      } else {
        setUpdateMessage("Failed to add creator. Please try again.");
      }
    } catch (error) {
      console.error("Error adding creator:", error);
      setUpdateMessage("An error occurred while adding creator.");
    }
  };
  const handleRemoveCreator = async () => {
    try {
      const response = await updateSubscriptionSettings({ removeOfCreatorId: removeCreatorId });
      if (response.status === 200) {
        setSubscriptionSettings(response.body);
        setUpdateMessage("Creator removed successfully!");
        setRemoveCreatorId("");
      } else {
        setUpdateMessage("Failed to remove creator. Please try again.");
      }
    } catch (error) {
      console.error("Error removing creator:", error);
      setUpdateMessage("An error occurred while removing creator.");
    }
  };
  const handleUpdateSettings = async () => {
    try {
      const response = await updateSubscriptionSettings(formData);
      if (response.status === 200) {
        setSubscriptionSettings(response.body);
        setUpdateMessage("Settings updated successfully!");
      } else {
        setUpdateMessage("Failed to update settings. Please try again.");
      }
    } catch (error) {
      console.error("Error updating settings:", error);
      setUpdateMessage("An error occurred while updating settings.");
    }
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "h-full overflow-y-auto rounded-lg bg-green-spicy p-4 shadow-md", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { className: "mb-4 text-xl font-bold text-darkGreen-spicy", children: "Settings" }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "mb-4 h-fit overflow-x-auto whitespace-nowrap text-left ", children: /* @__PURE__ */ jsxRuntimeExports.jsx("pre", { children: JSON.stringify(subscriptionSettings, null, 2) }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "space-y-4", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { children: /* @__PURE__ */ jsxRuntimeExports.jsxs("label", { className: "flex items-center", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          "input",
          {
            type: "checkbox",
            name: "followBackSubscribersEnabled",
            checked: formData.followBackSubscribersEnabled,
            onChange: handleInputChange,
            className: "mr-2"
          }
        ),
        "Follow back subscribers enabled"
      ] }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("label", { className: "flex items-center", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "input",
            {
              type: "checkbox",
              name: "followNewSubscribersImmediately",
              checked: formData.followNewSubscribersImmediately,
              onChange: handleInputChange,
              className: "mr-2",
              disabled: true
            }
          ),
          "Follow new subscribers immediately"
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { className: "mt-1 text-sm text-gray-600", children: [
          'This setting reflects your OnlyFans "Auto follow back my fans" option.',
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "a",
            {
              href: "https://onlyfans.com/my/settings/fans",
              target: "_blank",
              rel: "noopener noreferrer",
              className: "ml-1 text-ofBlue-spicy hover:underline",
              children: "Change it here"
            }
          )
        ] })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("label", { className: "mb-2 block", children: "Emojis for toolbar" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          "input",
          {
            type: "text",
            name: "emojisForToolbar",
            value: formData.emojisForToolbar.join(", "),
            onChange: handleInputChange,
            className: "w-full rounded border p-2",
            placeholder: "Enter emojis separated by commas"
          }
        )
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("label", { className: "mb-2 block", children: "Add manager" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          "input",
          {
            type: "email",
            value: newManagerEmail,
            onChange: (e2) => setNewManagerEmail(e2.target.value),
            className: "w-full rounded border p-2",
            placeholder: "Enter manager email"
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          "button",
          {
            onClick: handleAddManager,
            className: "text-white mt-2 rounded bg-blue-500 px-4 py-2 hover:bg-blue-600",
            children: "Add manager"
          }
        )
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("label", { className: "mb-2 block", children: "Remove manager" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          "input",
          {
            type: "email",
            value: removeManagerEmail,
            onChange: (e2) => setRemoveManagerEmail(e2.target.value),
            className: "w-full rounded border p-2",
            placeholder: "Enter manager email to remove"
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          "button",
          {
            onClick: handleRemoveManager,
            className: "text-white mt-2 rounded bg-red-500 px-4 py-2 hover:bg-red-600",
            children: "Remove manager"
          }
        )
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("label", { className: "mb-2 block", children: "Add creator" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          "input",
          {
            type: "text",
            value: newCreatorId,
            onChange: (e2) => setNewCreatorId(e2.target.value),
            className: "w-full rounded border p-2",
            placeholder: "Enter creator ID"
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          "button",
          {
            onClick: handleAddCreator,
            className: "text-white mt-2 rounded bg-blue-500 px-4 py-2 hover:bg-blue-600",
            children: "Add creator"
          }
        )
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("label", { className: "mb-2 block", children: "Remove creator" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          "input",
          {
            type: "text",
            value: removeCreatorId,
            onChange: (e2) => setRemoveCreatorId(e2.target.value),
            className: "w-full rounded border p-2",
            placeholder: "Enter creator ID to remove"
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          "button",
          {
            onClick: handleRemoveCreator,
            className: "text-white mt-2 rounded bg-red-500 px-4 py-2 hover:bg-red-600",
            children: "Remove creator"
          }
        )
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        "button",
        {
          onClick: handleUpdateSettings,
          className: "text-white mt-4 rounded bg-blue-500 px-4 py-2 hover:bg-blue-600",
          children: "Update settings"
        }
      ),
      updateMessage && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "mt-4 rounded bg-green-100 p-2 text-green-800", children: updateMessage })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "mb-4", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: "mb-2 text-lg font-semibold", children: "Creator sync status" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "mb-4 h-fit overflow-x-auto whitespace-nowrap text-left", children: /* @__PURE__ */ jsxRuntimeExports.jsx("pre", { children: JSON.stringify(creatorSyncData, null, 2) }) })
    ] })
  ] });
};
const featureCarouselIndexAtom = Recoil_index_8({
  key: "featureCarouselIndexAtom",
  default: 0
});
const carouselChargeback = "" + new URL("carousel-chargeback-796c3ac6.gif", import.meta.url).href;
const carouselChatLabels = "" + new URL("carousel-chat-labels-8d01cbe3.gif", import.meta.url).href;
const carouselLikes = "" + new URL("carousel-likes-43220d21.gif", import.meta.url).href;
const carouselMessageOnlineFans = "" + new URL("carousel-message-online-fans-f68622fd.gif", import.meta.url).href;
const carouselMessageTemplates = "" + new URL("carousel-message-templates-58d12f5b.gif", import.meta.url).href;
const carouselVaultLabels = "" + new URL("carousel-vault-labels-9969d24f.gif", import.meta.url).href;
const FeatureCarousel = ({ showBlocklistFeatures = false }) => {
  const [currentIndex, setCurrentIndex] = Recoil_index_22(featureCarouselIndexAtom);
  const carouselGifs = showBlocklistFeatures ? [carouselChargeback] : [
    carouselMessageOnlineFans,
    carouselChatLabels,
    carouselVaultLabels,
    carouselMessageTemplates,
    carouselLikes
  ];
  const carouselMessages = showBlocklistFeatures ? ["Get warned in chat about chargeback scammers"] : [
    "Mass message online fans to boost revenue",
    "See fan spending & subscription status instantly",
    "Never reuse vault content by mistake",
    "Save time with chat templates & emoji shortcuts",
    "Reward fans automatically for likes"
  ];
  reactExports.useEffect(() => {
    if (showBlocklistFeatures)
      return;
    const interval = setInterval(() => {
      setCurrentIndex((prevIndex) => (prevIndex + 1) % carouselGifs.length);
    }, 3e3);
    return () => clearInterval(interval);
  }, [carouselGifs.length, setCurrentIndex, showBlocklistFeatures]);
  const handleDotClick = (index2) => {
    setCurrentIndex(index2);
  };
  const getCardStyle = (index2) => {
    const effectiveCurrentIndex = showBlocklistFeatures ? 0 : currentIndex;
    const distance3 = Math.abs(index2 - effectiveCurrentIndex);
    const isCenter = distance3 === 0;
    const isAdjacent = distance3 === 1 || effectiveCurrentIndex === 0 && index2 === carouselGifs.length - 1 || effectiveCurrentIndex === carouselGifs.length - 1 && index2 === 0;
    if (isCenter) {
      return {
        transform: "translateX(0%) scale(1)",
        opacity: 1,
        filter: "blur(0px)",
        zIndex: 3
      };
    } else if (isAdjacent) {
      const isLeft = index2 < effectiveCurrentIndex && !(effectiveCurrentIndex === carouselGifs.length - 1 && index2 === 0) || effectiveCurrentIndex === 0 && index2 === carouselGifs.length - 1;
      return {
        transform: `translateX(${isLeft ? "-40%" : "40%"}) scale(0.9)`,
        opacity: 0.4,
        filter: "blur(2px)",
        zIndex: 1
      };
    } else {
      return {
        transform: "translateX(0%) scale(0.6)",
        opacity: 0.1,
        filter: "blur(4px)",
        zIndex: 0
      };
    }
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "relative w-full", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "relative h-80 w-full rounded-2xl", children: [
      carouselGifs.map((gif, index2) => /* @__PURE__ */ jsxRuntimeExports.jsx(
        "div",
        {
          className: "absolute inset-0 flex cursor-pointer items-center justify-center transition-all duration-700 ease-in-out",
          style: getCardStyle(index2),
          onClick: () => handleDotClick(index2),
          children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "relative", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "img",
              {
                src: gif,
                alt: `Feature showcase ${index2 + 1}`,
                className: "h-80 w-auto max-w-none rounded-lg border border-indigo-500/90 object-cover shadow-md"
              }
            ),
            currentIndex !== index2 && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "from-black/20 absolute inset-0 rounded-xl bg-gradient-to-t to-transparent" })
          ] })
        },
        index2
      )),
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "from-white/60 pointer-events-none absolute inset-y-0 left-0 z-10 w-8 bg-gradient-to-r to-transparent" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "from-white/60 pointer-events-none absolute inset-y-0 right-0 z-10 w-8 bg-gradient-to-l to-transparent" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "absolute -bottom-2 left-1/2 z-20 flex -translate-x-1/2 transform justify-center", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
        "div",
        {
          className: "rounded-full border-2 px-4 py-1.5 text-sm font-medium shadow-md backdrop-blur-sm transition-all duration-700",
          style: {
            color: "#585BE9",
            backgroundColor: "rgba(232, 232, 255, 0.95)",
            borderColor: "#8F91FF",
            fontSize: "14px",
            fontWeight: "bold",
            textAlign: "center",
            whiteSpace: "nowrap"
          },
          children: carouselMessages[showBlocklistFeatures ? 0 : currentIndex]
        }
      ) })
    ] }),
    showBlocklistFeatures ? /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "mt-3 flex justify-center" }) : /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "mt-5 flex justify-center", children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex items-center space-x-1 rounded-full border border-purple-100 bg-gradient-to-r from-purple-50 to-pink-50 px-3 py-2 shadow-sm", children: carouselGifs.map((_2, index2) => /* @__PURE__ */ jsxRuntimeExports.jsxs(
      "div",
      {
        className: `cursor-pointer transition-all duration-500 ease-out ${index2 === currentIndex ? "h-1.5 w-4" : index2 < currentIndex ? "h-1.5 w-1.5" : "h-1 w-1"}`,
        onClick: () => handleDotClick(index2),
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "div",
            {
              className: `h-full w-full rounded-full transition-all duration-500 ${index2 === currentIndex ? "animate-pulse bg-gradient-to-r from-purple-400 via-pink-400 to-purple-500 shadow-md shadow-purple-300/50" : index2 < currentIndex ? "bg-gradient-to-r from-purple-300 to-pink-300 opacity-80" : "bg-purple-200/60"}`
            }
          ),
          index2 === currentIndex && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "relative", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "absolute -right-0.5 -top-0.5 h-0.5 w-0.5 animate-ping rounded-full bg-pink-300 opacity-75" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "div",
              {
                className: "absolute -bottom-0.5 -left-0.5 h-0.5 w-0.5 animate-ping rounded-full bg-purple-300 opacity-75",
                style: { animationDelay: "0.5s" }
              }
            )
          ] })
        ]
      },
      index2
    )) }) })
  ] });
};
const AutoConfirmCloseWrapper = ({ children, onClose }) => {
  reactExports.useEffect(() => {
    const handleMessage = (event) => {
      if (event.data.type === "CHECK_UNSAVED_CHANGES") {
        onClose == null ? void 0 : onClose();
        window.parent.postMessage({ type: "CONFIRM_CLOSE" }, "*");
      }
    };
    window.addEventListener("message", handleMessage);
    return () => window.removeEventListener("message", handleMessage);
  }, [onClose]);
  return children;
};
const DowngradeToFreeConfirmTab = () => {
  const [isLoading, setIsLoading] = reactExports.useState(false);
  const [errorMessage, setErrorMessage] = reactExports.useState("");
  const { setActiveTab } = useTabNavigation();
  const { downgradeToFreePlan } = useNetworkManager();
  const handleBack = () => {
    setActiveTab("upgradeToPaid");
  };
  const handleConfirmDowngrade = async () => {
    var _a;
    setIsLoading(true);
    setErrorMessage("");
    try {
      const response = await downgradeToFreePlan();
      if (response.status === 200) {
        setActiveTab("home");
      } else {
        setErrorMessage(((_a = response.body) == null ? void 0 : _a.error) || "Failed to downgrade to free plan");
      }
    } catch (error) {
      console.error("Error downgrading subscription:", error);
      setErrorMessage("Unable to downgrade subscription. Please try again.");
    } finally {
      setIsLoading(false);
    }
  };
  const premiumFeatures = [
    { text: "Fan chat labels (spending, renewal, etc.)", emoji: "💰" },
    { text: "Chat emoji bar", emoji: "💕" },
    { text: "Chat templates", emoji: "📝" },
    { text: "Vault labels", emoji: "🏷️" },
    { text: "Mass message online fans", emoji: "💬" },
    { text: "Follow expired fans", emoji: "✅" },
    { text: "Automatic fan rewards", emoji: "⭐️" }
  ];
  return /* @__PURE__ */ jsxRuntimeExports.jsx(AutoConfirmCloseWrapper, { onClose: () => setActiveTab("home"), children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "bg-white flex w-full flex-col items-center overflow-y-auto overflow-x-hidden pb-8 pt-16", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs(
      "button",
      {
        onClick: handleBack,
        className: "absolute left-7 top-5 z-50 flex items-center text-gray-600 hover:text-gray-900",
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "svg",
            {
              className: "mr-2 h-5 w-5",
              fill: "none",
              strokeLinecap: "round",
              strokeLinejoin: "round",
              strokeWidth: "2",
              viewBox: "0 0 24 24",
              stroke: "currentColor",
              children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M10 19l-7-7m0 0l7-7m-7 7h18" })
            }
          ),
          "Back"
        ]
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex w-full max-w-5xl flex-col items-center px-4 md:px-12", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex w-full flex-col items-center justify-start", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex w-full flex-col items-center space-y-4", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex w-full max-w-xl items-center justify-center px-20 md:px-0", children: /* @__PURE__ */ jsxRuntimeExports.jsx(FeatureCarousel, { showBlocklistFeatures: false }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex flex-col items-center space-y-3 pb-4", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { className: "text-center text-2xl font-bold", children: "Are you sure you want to downgrade? 💔" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-center text-sm text-gray-500", children: "You'll lose access to all the premium features that help creators earn more on OnlyFans." })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "w-full max-w-2xl space-y-4", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center justify-center space-x-2", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "text-xl", children: "💔" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "font-bold text-red-500", children: "Premium features you'll lose" })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "rounded-lg bg-gradient-to-r from-red-50 to-orange-50 p-4", children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "grid grid-cols-1 gap-3 md:grid-cols-2", children: premiumFeatures.map((feature, index2) => /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-start space-x-2 text-gray-700", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: feature.emoji }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "text-left text-sm text-gray-700", children: feature.text })
          ] }, index2)) }) })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "w-full max-w-2xl space-y-4", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center justify-center space-x-2", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "text-xl", children: "✅" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "font-bold text-green-600", children: "What you'll still have for FREE" })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "rounded-lg bg-green-50 p-4", children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "space-y-2", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-start space-x-2", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "text-green-500", children: "🚫" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "text-left text-sm text-gray-700", children: "Scam protection in your DMs - Get notified about users who have done chargebacks" })
          ] }) }) })
        ] })
      ] }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "mt-10 w-full space-y-3 self-center", children: [
        errorMessage && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "rounded-md bg-red-50 p-3 text-center text-sm text-red-600", children: errorMessage }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs(
          "button",
          {
            onClick: handleConfirmDowngrade,
            className: `text-white w-full rounded-md bg-red-500 py-3 font-semibold ${isLoading ? "cursor-not-allowed opacity-50" : "hover:opacity-90"}`,
            disabled: isLoading,
            children: [
              isLoading ? "Processing downgrade..." : "Yes, lose subscription features",
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "ml-1.5", children: "💔" })
            ]
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsxs(
          "button",
          {
            onClick: handleBack,
            className: "bg-white w-full rounded-md border border-gray-300 py-3 font-semibold text-gray-700 hover:bg-gray-50",
            disabled: isLoading,
            children: [
              "Wait, take me back",
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "ml-1", children: "💕" })
            ]
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "mt-4 text-center", children: /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-xs text-gray-400", children: "You can always upgrade again later. Scam protection will always remain free." }) })
      ] })
    ] })
  ] }) });
};
const ofAPIOffsetAtom = Recoil_index_8({
  key: "ofAPIOffsetAtom",
  default: 0
});
const EXPIRED_FANS_LIST_ID_ATOM_KEY = "expiredFansListIdAtom";
const EXPIRED_FANS_LIST_ID_FAMILY_KEY = "expiredFansListIdFamily";
const SYNCHRONIZED_CREATOR_SELECTOR_KEY = "synchronizedCreatorSelector";
const expiredFansListIdFamily = Recoil_index_10({
  key: EXPIRED_FANS_LIST_ID_FAMILY_KEY,
  default: null,
  effects: [
    (ofUserId) => ({ setSelf, onSet }) => {
      if (ofUserId) {
        LocalStorageManager.getExpiredFansListId(ofUserId).then((listId) => {
          setSelf(listId);
        });
      }
      onSet((newValue) => {
        if (ofUserId) {
          LocalStorageManager.setExpiredFansListId(newValue, ofUserId);
        }
      });
    }
  ]
});
const expiredFansListIdAtom = Recoil_index_9({
  key: EXPIRED_FANS_LIST_ID_ATOM_KEY,
  get: ({ get: get2 }) => {
    console.log("[expiredFansListIdAtom] get");
    const ofUserId = get2(ofUserIdAtom);
    if (!ofUserId)
      return null;
    return get2(expiredFansListIdFamily(ofUserId));
  },
  set: ({ set, get: get2 }, newValue) => {
    console.log("[expiredFansListIdAtom] set", newValue);
    const ofUserId = get2(ofUserIdAtom);
    if (ofUserId) {
      set(expiredFansListIdFamily(ofUserId), newValue);
    }
  }
});
const synchronizedCreatorSelector = Recoil_index_9({
  key: SYNCHRONIZED_CREATOR_SELECTOR_KEY,
  get: ({ get: get2 }) => {
    const [ofUserId, expiredFansListId, ofAPIOffset] = get2(
      Recoil_index_18([ofUserIdAtom, expiredFansListIdAtom, ofAPIOffsetAtom])
    );
    return {
      ofUserId,
      expiredFansListId,
      ofAPIOffset
    };
  }
});
const followExpiredFansCounterAtom = Recoil_index_8({
  key: "followExpiredFansCounterAtom",
  default: 0
});
const followExpiredFansSelector = Recoil_index_9({
  key: "followExpiredFansSelector",
  get: ({ get: get2 }) => {
    const subscriptionSettings = get2(subscriptionSettingsAtom);
    const ofUserId = get2(ofUserIdAtom);
    if (!subscriptionSettings || !ofUserId) {
      return false;
    }
    const creatorSettings = subscriptionSettings.creatorSettings || {};
    console.log("creatorSettings", creatorSettings, ofUserId);
    const currentCreatorSettings = creatorSettings.find(
      (setting) => setting.ofCreatorId == ofUserId
    ) || {};
    console.log("currentCreatorSettings", currentCreatorSettings);
    return currentCreatorSettings.followBackSubscribersEnabled || false;
  }
});
const FollowExpiredFansTab = () => {
  const subscriptionSettingsId = Recoil_index_20(subscriptionSettingsIdSelector);
  const ofUserId = Recoil_index_20(ofUserIdAtom);
  const expiredFansListId = Recoil_index_20(expiredFansListIdAtom);
  const followExpiredFansSetting = Recoil_index_20(followExpiredFansSelector);
  const setSubscriptionSettings = Recoil_index_24(subscriptionSettingsAtom);
  const { updateCreatorSettings, getFollowExpiredFansCounter } = useNetworkManager();
  const [updateMessage, setUpdateMessage] = reactExports.useState("");
  const [updateStatus, setUpdateStatus] = reactExports.useState("");
  const [followEnabled, setFollowEnabled] = reactExports.useState(false);
  const [hasChanges, setHasChanges] = reactExports.useState(false);
  const [initialState, setInitialState] = reactExports.useState(false);
  const setHasUnsavedChanges = Recoil_index_24(hasUnsavedChangesAtom);
  const setFollowExpiredFansCounter = Recoil_index_24(followExpiredFansCounterAtom);
  const setOfAPIOffset = Recoil_index_24(ofAPIOffsetAtom);
  const followedCount = Recoil_index_20(followExpiredFansCounterAtom);
  const [isLoadingCounter, setIsLoadingCounter] = reactExports.useState(true);
  const currentOffset = Recoil_index_20(ofAPIOffsetAtom);
  const [buttonStatus, setButtonStatus] = reactExports.useState(null);
  reactExports.useEffect(() => {
    setFollowEnabled(followExpiredFansSetting);
    setInitialState(followExpiredFansSetting);
  }, [followExpiredFansSetting]);
  reactExports.useEffect(() => {
    const fetchCounter = async () => {
      console.log("[FollowExpiredFansTab] Fetching follow expired fans counter...");
      if (subscriptionSettingsId && ofUserId) {
        console.log("[FollowExpiredFansTab] Subscription settings ID:", subscriptionSettingsId);
        console.log("[FollowExpiredFansTab] OF User ID:", ofUserId);
        try {
          const counter = await getFollowExpiredFansCounter();
          console.log("[FollowExpiredFansTab] Counter fetched successfully:", counter);
          if (counter) {
            setFollowExpiredFansCounter(counter.count);
            setOfAPIOffset(counter.ofAPIOffset);
          }
        } catch (error) {
          console.error("Error fetching follow expired fans counter:", error);
        } finally {
          setIsLoadingCounter(false);
        }
      } else {
        console.log("[FollowExpiredFansTab] Missing required IDs to fetch counter");
        setIsLoadingCounter(false);
      }
    };
    fetchCounter();
  }, [ofUserId]);
  reactExports.useEffect(() => {
    const hasChanges2 = followEnabled !== initialState;
    setHasChanges(hasChanges2);
    setHasUnsavedChanges(hasChanges2);
  }, [followEnabled, initialState, setHasUnsavedChanges]);
  const handleToggleAutoFollow = (e2) => {
    setFollowEnabled(e2.target.checked);
  };
  const handleSave = async () => {
    if (!hasChanges || !ofUserId)
      return;
    setButtonStatus("saving");
    try {
      const response = await updateCreatorSettings({
        followBackSubscribersEnabled: followEnabled
      });
      if (response.status === 200) {
        setSubscriptionSettings(response.body);
        setUpdateMessage("Auto-follow setting updated successfully!");
        setUpdateStatus("success");
        setInitialState(followEnabled);
        setHasChanges(false);
        setHasUnsavedChanges(false);
        setButtonStatus("saved");
        setTimeout(() => {
          setButtonStatus(null);
          setUpdateMessage("");
          setUpdateStatus("");
        }, 2e3);
      } else {
        const errorMsg = "Failed to update auto-follow setting. Please try again.";
        setUpdateMessage(errorMsg);
        setUpdateStatus("error");
        setButtonStatus("error");
        setTimeout(() => {
          setButtonStatus(null);
          setUpdateMessage("");
          setUpdateStatus("");
        }, 3e3);
      }
    } catch (error) {
      console.error("Error updating auto-follow setting:", error);
      const errorMsg = "An error occurred while updating auto-follow setting.";
      setUpdateMessage(errorMsg);
      setUpdateStatus("error");
      setButtonStatus("error");
      setTimeout(() => {
        setButtonStatus(null);
        setUpdateMessage("");
        setUpdateStatus("");
      }, 3e3);
    }
  };
  const handleBannerHide = () => {
    setUpdateMessage("");
    setUpdateStatus("");
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "pb-20", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      TabHeader,
      {
        title: "Follow expired fans ✨",
        subtitle: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "font-bold", children: "Message any of your past fans" }),
          " by automatically following expired fans!"
        ] })
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex flex-col space-y-20", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text-left text-base font-normal text-gray-600", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: "flex flex-col gap-4", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: "OnlyFans only allows you to send mass messages to current subscribers, or accounts that you follow. Follow your expired fans so that you can continue marketing to them once their subscription ends." }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { children: [
          "Note: This feature only follows expired fans. To automatically follow new fans when they subscribe, turn on the",
          ' "',
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "a",
            {
              href: "https://onlyfans.com/my/settings/fans",
              target: "_blank",
              rel: "noopener noreferrer",
              className: "inline text-ofBlue-spicy hover:underline",
              children: "auto follow back my fans"
            }
          ),
          '" in your OnlyFans settings.'
        ] })
      ] }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex flex-row items-start space-x-6 text-left text-base text-gray-600", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("label", { className: "flex flex-row items-start space-x-6", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          "input",
          {
            type: "checkbox",
            checked: followEnabled,
            onChange: handleToggleAutoFollow,
            className: "mt-1 rounded-sm text-base text-black-spicy accent-indigo-500 checked:border-indigo-500 checked:bg-indigo-500 focus:ring-indigo-500"
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex flex-col space-y-2", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "font-bold text-black-spicy", children: "Follow expired subscribers" }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { children: [
            "Expired fans will be added to a collection named",
            " ",
            expiredFansListId ? /* @__PURE__ */ jsxRuntimeExports.jsx(
              "a",
              {
                href: `https://onlyfans.com/my/collections/user-lists/${expiredFansListId}`,
                target: "_blank",
                rel: "noopener noreferrer",
                className: "text-ofBlue-spicy hover:underline",
                children: "Expired fans"
              }
            ) : /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: "Expired fans" }),
            ". We will follow ~100-400 accounts per day."
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "space-y-1", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { className: "text-sm text-gray-500", children: [
              "Total expired fans followed:",
              " ",
              isLoadingCounter ? /* @__PURE__ */ jsxRuntimeExports.jsx(LoadingSpinner, { inline: true, size: 4 }) : /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "font-semibold", children: followedCount })
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { className: "text-sm text-gray-500", children: [
              "Fans processed so far:",
              " ",
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "font-semibold", children: currentOffset || 0 })
            ] })
          ] })
        ] })
      ] }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        FloatingActionButton,
        {
          onClick: handleSave,
          disabled: !hasChanges,
          buttonText: "Save",
          show: hasChanges || buttonStatus,
          status: buttonStatus
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        FloatingStatusBanner,
        {
          message: updateMessage,
          type: updateStatus === "success" ? "success" : "error",
          show: !!updateMessage && buttonStatus !== "error",
          onHide: handleBannerHide,
          autoHideDelay: 3e3
        }
      )
    ] })
  ] });
};
const ILLUSTRATIONS = {
  followExpired: "/assets/follow-expired-feature-illustration.svg",
  likes: "/assets/likes-feature-illustration.svg",
  msgOnlineFans: "/assets/msg-online-fans-illustration.svg",
  emojiBar: "/assets/emoji-bar-illustration.svg"
};
const FeatureCard = ({ title, description, buttonCta, targetTab, icon, illustration }) => {
  const { setActiveTab } = useTabNavigation();
  const handleClick = () => {
    setActiveTab(targetTab);
    const scrollableContainer = document.querySelector(".overflow-y-auto");
    if (scrollableContainer) {
      scrollableContainer.scrollTo({ top: 0, behavior: "instant" });
    }
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
    "div",
    {
      onClick: handleClick,
      className: "bg-white flex cursor-pointer flex-col justify-between rounded-lg border border-gray-200 p-6 pb-6 pt-4 text-left transition-all hover:border-ofBlue-spicy",
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("h3", { className: "mb-2 text-lg font-bold", children: [
            title,
            " ",
            icon
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-sm text-gray-600", children: description })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("img", { src: illustration, alt: title, className: "object-fit w-full py-4" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(SubmitButton, { title: buttonCta, onSubmit: handleClick, hasChanges: true, showArrow: true })
        ] })
      ]
    }
  );
};
const HomeTab = () => {
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      TabHeader,
      {
        title: "Use these tools to earn more on your spicy page 💁🏻‍♀️",
        subtitle: "Select a tool below to get started 👇"
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "-mt-1 flex justify-start", children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "w-full max-w-4xl overflow-x-auto", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "grid grid-cols-1 gap-5 sm:grid-cols-2", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        FeatureCard,
        {
          title: "Increase views on mass messages",
          description: "Drastically increase the amount of people who see your mass messages by automatically following expired fans.",
          buttonCta: "Follow expired fans",
          targetTab: "followExpiredFans",
          icon: "✨",
          illustration: ILLUSTRATIONS.followExpired
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        FeatureCard,
        {
          title: "Increase how many likes you get",
          description: "Let fans know they'll receive a freebie if they like a specific number of items on your wall 💕",
          buttonCta: "Set up fan rewards",
          targetTab: "createRewards",
          icon: "👍",
          illustration: ILLUSTRATIONS.likes
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        FeatureCard,
        {
          title: "Message online fans",
          description: "Want to say hi to your online fans? 👀 Fans who are online right now are more likely to read & respond 💁🏻‍♀️",
          buttonCta: "Message online fans",
          targetTab: "messageOnlineFans",
          icon: "👋",
          illustration: ILLUSTRATIONS.msgOnlineFans
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        FeatureCard,
        {
          title: "Customize shortcut bar",
          description: "A faster way to add chat templates and emojis while you chat with fans 😘",
          buttonCta: "Create shortcuts",
          targetTab: "shortcuts",
          icon: "✏️",
          illustration: ILLUSTRATIONS.emojiBar
        }
      )
    ] }) }) })
  ] });
};
let lastShowComponent = null;
const useStatusBar = () => {
  const showStatusBar = (message, componentId2, showShimmer = false) => {
    lastShowComponent = componentId2;
    chrome.tabs.query({ active: true, currentWindow: true }, (tabs) => {
      chrome.tabs.sendMessage(tabs[0].id, {
        type: "showStatusBar",
        message,
        componentId: componentId2,
        showShimmer
      });
    });
  };
  const hideStatusBar = (componentId2) => {
    if (!componentId2 || componentId2 === lastShowComponent) {
      chrome.tabs.query({ active: true, currentWindow: true }, (tabs) => {
        chrome.tabs.sendMessage(tabs[0].id, {
          type: "hideStatusBar",
          componentId: componentId2
        });
      });
      lastShowComponent = null;
    }
  };
  return { showStatusBar, hideStatusBar };
};
const QUEUE_MESSAGE_BATCH_SIZE = 100;
const useMessageSendingService = () => {
  const ofUserId = Recoil_index_20(ofUserIdAtom);
  const onlyFansAPI = useOnlyFansAPI();
  const { showStatusBar, hideStatusBar } = useStatusBar();
  const [isSending, setIsSending] = reactExports.useState(false);
  const [progress, setProgress] = reactExports.useState({ current: 0, total: 0 });
  const abortControllerRef = reactExports.useRef(null);
  reactExports.useEffect(() => {
    return () => {
      if (abortControllerRef.current) {
        abortControllerRef.current.abort();
        abortControllerRef.current = null;
        setIsSending(false);
        setProgress({ current: 0, total: 0 });
        hideStatusBar("MessageSendingService");
      }
    };
  }, [ofUserId]);
  const updateStatusBar = reactExports.useCallback(
    (current, total) => {
      showStatusBar(
        `💬 Sending messages: ${current} out of ${total} sent`,
        "MessageSendingService",
        true
      );
    },
    [showStatusBar]
  );
  const sendMessages = reactExports.useCallback(
    async (fans, message, price = 0, mediaIds = [], onComplete) => {
      var _a, _b, _c;
      if (isSending) {
        console.log("[useMessageSendingService] Already sending messages, skipping");
        return;
      }
      console.log("[useMessageSendingService] Starting to send messages", {
        numFans: fans.length,
        message,
        price,
        numMediaIds: mediaIds.length
      });
      abortControllerRef.current = new AbortController();
      setIsSending(true);
      setProgress({ current: 0, total: fans.length });
      updateStatusBar(0, fans.length);
      try {
        for (let i2 = 0; i2 < fans.length; i2 += QUEUE_MESSAGE_BATCH_SIZE) {
          if ((_a = abortControllerRef.current) == null ? void 0 : _a.signal.aborted) {
            console.log("[useMessageSendingService] Sending cancelled");
            break;
          }
          const userBatch = fans.slice(i2, i2 + QUEUE_MESSAGE_BATCH_SIZE);
          const userIds = userBatch.map((user) => user.id);
          try {
            console.log(
              `[useMessageSendingService] Sending message to batch of ${userBatch.length} users`
            );
            const queueResult = await onlyFansAPI.queueMessage(userIds, message, price, mediaIds);
            if (queueResult && !queueResult.error && queueResult.hasError === false && queueResult.isCanceled === false) {
              const newProgress = {
                current: Math.min(i2 + QUEUE_MESSAGE_BATCH_SIZE, fans.length),
                total: fans.length
              };
              setProgress(newProgress);
              updateStatusBar(newProgress.current, newProgress.total);
              console.log(
                `[useMessageSendingService] Successfully sent message to batch of ${userBatch.length} users`
              );
              await new Promise((resolve, reject) => {
                var _a2;
                const timeout = setTimeout(resolve, Math.random() * 3e3 + 3e3);
                (_a2 = abortControllerRef.current) == null ? void 0 : _a2.signal.addEventListener("abort", () => {
                  clearTimeout(timeout);
                  reject(new Error("Cancelled"));
                });
              });
            } else {
              const errorMessage = ((_b = queueResult == null ? void 0 : queueResult.error) == null ? void 0 : _b.message) || "Queue operation failed";
              console.error(
                "[useMessageSendingService] Queue operation failed for batch:",
                userIds,
                errorMessage
              );
              throw new Error(`Queue failed: ${errorMessage}`);
            }
          } catch (error) {
            console.error(
              "[useMessageSendingService] Error sending message to batch:",
              userIds,
              error
            );
            if ((_c = abortControllerRef.current) == null ? void 0 : _c.signal.aborted) {
              break;
            }
          }
        }
      } finally {
        console.log("[useMessageSendingService] Finished sending messages");
        abortControllerRef.current = null;
        setIsSending(false);
        setProgress({ current: 0, total: 0 });
        hideStatusBar("MessageSendingService");
        alert(
          "Yay! Your messages are queued to be sent! It might take a few minutes for them to be received."
        );
        if (onComplete) {
          onComplete();
        }
      }
    },
    [onlyFansAPI, isSending, updateStatusBar, hideStatusBar]
  );
  return {
    isSending,
    progress,
    sendMessages
  };
};
const FanFilters = ({
  includedFans,
  setIncludedFans,
  excludedFans,
  setExcludedFans,
  excludedCollections,
  setExcludedCollections,
  lists,
  isLoadingMoreLists,
  isLoading
}) => {
  const toggleIncludedFan = (fanType) => {
    setIncludedFans((prev) => ({ ...prev, [fanType]: !prev[fanType] }));
  };
  const toggleExcludedFan = (fanType) => {
    setExcludedFans((prev) => ({ ...prev, [fanType]: !prev[fanType] }));
  };
  const toggleExcludedCollection = (collectionId) => {
    setExcludedCollections((prev) => ({
      ...prev,
      [collectionId]: !prev[collectionId]
    }));
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "mb-6 flex text-left text-sm", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "mr-6 flex-1", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "mb-4", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: "mb-2 text-base font-medium", children: "Included fans" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "max-h-40 space-y-2 overflow-y-auto rounded border border-gray-300 px-6 py-4", children: Object.entries(includedFans).map(([fanType, isIncluded]) => /* @__PURE__ */ jsxRuntimeExports.jsxs("label", { className: "flex items-center", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "input",
            {
              type: "checkbox",
              checked: isIncluded,
              onChange: () => toggleIncludedFan(fanType),
              className: "mr-2 rounded-sm accent-indigo-500 checked:border-indigo-500 checked:bg-indigo-500 focus:ring-indigo-500"
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "capitalize", children: fanType.replace(/([A-Z])/g, " $1").trim() })
        ] }, fanType)) })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: "mb-2 text-base font-medium", children: "Excluded fans" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "max-h-40 space-y-2 overflow-y-auto rounded border border-gray-300 px-6 py-4", children: Object.entries(excludedFans).map(([fanType, isExcluded]) => /* @__PURE__ */ jsxRuntimeExports.jsxs("label", { className: "flex items-center", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "input",
            {
              type: "checkbox",
              checked: isExcluded,
              onChange: () => toggleExcludedFan(fanType),
              className: "mr-2 rounded-sm accent-indigo-500 checked:border-indigo-500 checked:bg-indigo-500 focus:ring-indigo-500"
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "capitalize", children: fanType.replace(/([A-Z])/g, " $1").trim() })
        ] }, fanType)) })
      ] })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex-1", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: "mb-2 text-base font-medium", children: "Excluded fan collections" }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "max-h-80 space-y-2 overflow-y-auto rounded border border-gray-300 px-6 py-4", children: [
        lists.map((list) => /* @__PURE__ */ jsxRuntimeExports.jsxs("label", { className: "flex items-center", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "input",
            {
              type: "checkbox",
              checked: excludedCollections[list.id],
              onChange: () => toggleExcludedCollection(list.id),
              className: "mr-2 rounded-sm accent-indigo-500 checked:border-indigo-500 checked:bg-indigo-500 focus:ring-indigo-500"
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "capitalize", children: list.name })
        ] }, list.id)),
        (isLoading || isLoadingMoreLists) && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center gap-2 pt-2 text-gray-600", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(LoadingSpinner, { inline: true, size: 4 }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: isLoading ? "Loading lists..." : "Loading more lists..." })
        ] })
      ] })
    ] })
  ] });
};
const ProgressBar = ({ progress }) => /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "mb-4", children: [
  /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "w-full bg-gray-200 rounded-full h-2.5 dark:bg-gray-700", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
    "div",
    {
      className: "bg-blue-600 h-2.5 rounded-full",
      style: { width: `${progress.current / progress.total * 100}%` }
    }
  ) }),
  /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { className: "text-center mt-2", children: [
    "Sending ",
    progress.current,
    " out of ",
    progress.total,
    " messages"
  ] })
] });
const SuccessView = ({ onSendAnother }) => {
  return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex h-full w-full p-10 xl:p-16", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex w-full flex-col items-center justify-center gap-4", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "mb-8 flex flex-col items-center gap-2", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { className: "text-2xl font-bold", children: "Yay! Your messages were queued to be sent 🎉" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-gray-600", children: "Your messages have been successfully queued and will be delivered shortly." })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex flex-col gap-4", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        "button",
        {
          onClick: onSendAnother,
          className: "text-white rounded-md bg-ofBlue-spicy px-4 py-2 font-medium transition-colors duration-300 hover:bg-ofBlue-spicy/80",
          children: "Send another message"
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        "a",
        {
          href: "https://onlyfans.com/my/mass_chats",
          target: "_blank",
          rel: "noopener noreferrer",
          className: "rounded-md border border-gray-300 px-4 py-2 font-medium transition-colors duration-300 hover:bg-gray-100",
          children: "Check your message statistics"
        }
      )
    ] })
  ] }) });
};
const MessageOnlineFansTab = () => {
  const [message, setMessage] = reactExports.useState("");
  const [price, setPrice] = reactExports.useState("");
  const [includedFans, setIncludedFans] = reactExports.useState({
    activeSubscribers: true,
    expiredSubscribers: true
  });
  const [excludedFans, setExcludedFans] = reactExports.useState({
    creators: false
  });
  const [excludedCollections, setExcludedCollections] = reactExports.useState({});
  const [lists, setLists] = reactExports.useState([]);
  const [isLoading, setIsLoading] = reactExports.useState(true);
  const [isLoadingMoreLists, setIsLoadingMoreLists] = reactExports.useState(false);
  const [allOnlineFans, setAllOnlineFans] = reactExports.useState([]);
  const [rawOnlineFans, setRawOnlineFans] = reactExports.useState([]);
  const onlyFansAPI = useOnlyFansAPI();
  const { isSending, progress, sendMessages } = useMessageSendingService();
  const [selectedImageIds, setSelectedImageIds] = reactExports.useState([]);
  const [priceError, setPriceError] = reactExports.useState("");
  const [isMessageSent, setIsMessageSent] = reactExports.useState(false);
  const [sendButtonStatus, setSendButtonStatus] = reactExports.useState(null);
  const fetchOnlineFans = reactExports.useCallback(async () => {
    let fans = [];
    let hasMore = true;
    let offset3 = 0;
    const limit = 100;
    while (hasMore) {
      const onlineFansResponse = await onlyFansAPI.getOnlineSubscribers(limit, offset3);
      fans = [...fans, ...onlineFansResponse.list];
      hasMore = onlineFansResponse.hasMore;
      offset3 += limit;
    }
    return fans;
  }, [onlyFansAPI]);
  const loadMoreLists = async () => {
    try {
      setIsLoadingMoreLists(true);
      const nextListsData = await onlyFansAPI.getLists(10, lists.length);
      setLists((prevLists) => [...prevLists, ...nextListsData.list]);
      if (lists.length + nextListsData.list.length < 20 && nextListsData.hasMore) {
        const remainingListsData = await onlyFansAPI.getLists(
          500,
          lists.length + nextListsData.list.length
        );
        setLists((prevLists) => [...prevLists, ...remainingListsData.list]);
      }
    } catch (error) {
      console.error("Error loading more lists:", error);
    } finally {
      setIsLoadingMoreLists(false);
    }
  };
  const fetchData = async () => {
    setIsLoading(true);
    try {
      const [initialListsData, onlineFans] = await Promise.all([
        onlyFansAPI.getLists(10, 0),
        fetchOnlineFans()
      ]);
      setLists(initialListsData.list);
      setRawOnlineFans(onlineFans);
      setAllOnlineFans(onlineFans.filter((fan) => !!fan.canReceiveChatMessage));
      const initialExcludedCollections = Object.fromEntries(
        initialListsData.list.map((list) => [list.id, false])
      );
      setExcludedCollections(initialExcludedCollections);
      if (initialListsData.hasMore) {
        loadMoreLists();
      }
    } catch (error) {
      console.error("Error fetching data:", error);
    } finally {
      setIsLoading(false);
    }
  };
  reactExports.useEffect(() => {
    fetchData();
  }, []);
  const filteredFans = reactExports.useMemo(() => {
    const excludedUserIds = new Set(
      lists.filter((list) => excludedCollections[list.id]).flatMap((list) => {
        var _a;
        return ((_a = list.users) == null ? void 0 : _a.map((user) => user.id)) || [];
      })
    );
    return allOnlineFans.filter((fan) => {
      if (excludedUserIds.has(fan.id))
        return false;
      if (excludedFans.creators && fan.isPerformer)
        return false;
      if (includedFans.activeSubscribers && fan.subscribedOn)
        return true;
      if (includedFans.expiredSubscribers && fan.subscribedOnExpiredNow)
        return true;
      return false;
    });
  }, [allOnlineFans, includedFans, excludedFans, excludedCollections, lists]);
  const handleImagesSelected = (imageIds) => {
    setSelectedImageIds(imageIds);
  };
  const handlePriceChange = (e2) => {
    const value = e2.target.value;
    setPrice(value);
    if (value === "") {
      setPriceError("");
    } else {
      const numValue = Number(value);
      if (numValue < 3 || numValue > 100) {
        setPriceError("Price must be free or between $3 and $100");
      } else {
        setPriceError("");
      }
    }
  };
  const handleSendMessage = reactExports.useCallback(() => {
    setSendButtonStatus("saving");
    const priceValue = price ? Number(price) : 0;
    try {
      sendMessages(
        filteredFans,
        message,
        priceValue,
        selectedImageIds,
        () => {
          setIsMessageSent(true);
          setSendButtonStatus("saved");
        },
        (error) => {
          console.error("Error sending messages:", error);
          setSendButtonStatus("error");
          setTimeout(() => {
            setSendButtonStatus(null);
          }, 3e3);
        }
      );
      alert(
        `We're sending your message out!

You can continue working on OnlyFans and we'll keep sending your message in the background. Just don't close OnlyFans or refresh the page until all of your messages have been sent ✨`
      );
    } catch (error) {
      console.error("Error initiating message sending:", error);
      setSendButtonStatus("error");
      setTimeout(() => {
        setSendButtonStatus(null);
      }, 3e3);
    }
  }, [filteredFans, message, price, sendMessages, selectedImageIds]);
  const handleSendAnother = reactExports.useCallback(() => {
    setMessage("");
    setPrice("");
    setIncludedFans({
      activeSubscribers: true,
      expiredSubscribers: true
    });
    setExcludedFans({
      creators: false
    });
    setExcludedCollections({});
    setSelectedImageIds([]);
    setPriceError("");
    setIsMessageSent(false);
    fetchData();
  }, []);
  const getDisabledReason = () => {
    if (isSending)
      return "Message sending is in progress";
    if (((allOnlineFans == null ? void 0 : allOnlineFans.length) ?? 0) === 0)
      return "No fans are online right now - try again later!";
    if (isLoading)
      return "Loading fan data...";
    if (filteredFans.length === 0)
      return "No fans selected to message";
    if (!message.trim())
      return "Write a message to enable sending";
    if (priceError)
      return priceError;
    return "";
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "w-full pb-20 text-left", children: isMessageSent ? /* @__PURE__ */ jsxRuntimeExports.jsx(SuccessView, { onSendAnother: handleSendAnother }) : /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      TabHeader,
      {
        title: "Message online fans 💬",
        subtitle: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { children: isLoading ? /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: "flex items-center gap-2 font-bold", children: [
          "Finding online subscribers ",
          /* @__PURE__ */ jsxRuntimeExports.jsx(LoadingSpinner, { inline: true, size: 4 })
        ] }) : /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "font-bold", children: `${allOnlineFans.length} subscribers are` }),
          ` online right now! Send them a message and see what they're up to 🍑`
        ] }) })
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex flex-col", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        MessageInput,
        {
          message,
          setMessage,
          onImagesSelected: handleImagesSelected,
          placeholder: "hiii what're you up to rn?👀"
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "my-7 h-px w-full bg-gray-100" }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "mb-10 flex w-full flex-row justify-between", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex flex-col", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: "mb-2 text-base font-semibold", children: "Set message price (optional)" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "mb-2 text-sm text-gray-600", children: "Set a price if you want to charge for this message. Price must be between $3-$100." })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex items-center justify-end", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          "input",
          {
            type: "number",
            value: price,
            onChange: handlePriceChange,
            className: "w-24 rounded-md border border-gray-300 bg-transparent px-3 py-2 text-right focus:outline-none focus:ring-2 focus:ring-blue-500",
            min: "0",
            placeholder: "Free"
          }
        ) })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        FanFilters,
        {
          includedFans,
          setIncludedFans,
          excludedFans,
          setExcludedFans,
          excludedCollections,
          setExcludedCollections,
          lists,
          isLoadingMoreLists,
          isLoading
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "mb-4 mt-4", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: "mb-2 text-base font-medium", children: "Selected fans:" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("pre", { className: "overflow-x-auto rounded-md bg-gray-100 p-2", children: filteredFans.map((fan) => fan.username).join(", ") })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "mb-4 mt-4", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: "mb-2 text-base font-medium", children: "All online fans status:" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "rounded-md bg-gray-100 p-2", children: rawOnlineFans.map((fan) => {
          let statusInfo = "";
          if (!fan.canReceiveChatMessage) {
            statusInfo = "(Cannot receive messages)";
          } else {
            const isExcluded = !filteredFans.some((f2) => f2.id === fan.id);
            if (isExcluded) {
              if (excludedFans.creators && fan.isPerformer) {
                statusInfo = "(Excluded: Is Creator)";
              } else if (!includedFans.activeSubscribers && fan.subscribedOn) {
                statusInfo = "(Excluded: Active Subscriber Filter Off)";
              } else if (!includedFans.expiredSubscribers && fan.subscribedOnExpiredNow) {
                statusInfo = "(Excluded: Expired Subscriber Filter Off)";
              } else {
                const excludedList = lists.find(
                  (list) => {
                    var _a;
                    return excludedCollections[list.id] && ((_a = list.users) == null ? void 0 : _a.some((user) => user.id === fan.id));
                  }
                );
                if (excludedList) {
                  statusInfo = `(Excluded: In List "${excludedList.name}")`;
                }
              }
            }
          }
          return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "py-1", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "font-medium", children: fan.username }),
            " ",
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "text-green-600", children: "● Online" }),
            statusInfo && /* @__PURE__ */ jsxRuntimeExports.jsx(
              "span",
              {
                className: `ml-2 ${!fan.canReceiveChatMessage ? "text-orange-500" : "text-red-500"}`,
                children: statusInfo
              }
            )
          ] }, fan.id);
        }) })
      ] }),
      isSending ? /* @__PURE__ */ jsxRuntimeExports.jsx(ProgressBar, { progress }) : /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "mt-4 text-center text-sm italic text-red-500", children: getDisabledReason() }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          FloatingActionButton,
          {
            onClick: handleSendMessage,
            disabled: isSending || !message.trim() || isLoading || filteredFans.length === 0 || !!priceError,
            isLoading,
            buttonText: `Send message to online fans${price ? ` ($${price})` : ""}`,
            loadingText: "Loading Fans...",
            disabledReason: getDisabledReason(),
            show: true,
            status: sendButtonStatus,
            errorMessage: "Failed to send messages",
            progressMessage: "Sending message...",
            successMessage: "Message sent!"
          }
        )
      ] })
    ] })
  ] }) });
};
const addCreditCardGif = "" + new URL("add-credit-card-82957ec3.gif", import.meta.url).href;
const UpgradeToPaidConfirmTab = () => {
  const [isLoading, setIsLoading] = reactExports.useState(false);
  const [error, setError] = reactExports.useState("");
  const { getPortalSession, upgradeToPaid, getSubscriptionInfo } = useNetworkManager();
  const { setActiveTab, payload } = useTabNavigation();
  const hasBillingInfo = Recoil_index_20(hasBillingInfoSelector);
  const setSubscriptionInfo = Recoil_index_24(subscriptionInfoAtom);
  const planType = Recoil_index_20(planTypeSelector);
  const isLastSeenActiveTab = Recoil_index_20(lastSeenActiveTabAtom);
  const isUpgradeMode = (payload == null ? void 0 : payload.is_upgrade) || false;
  const hasPaid = planType === "paid" && hasBillingInfo;
  const handleBackButton = () => {
    setActiveTab("upgradeToPaid", {
      ...payload
    });
  };
  const refreshSubscriptionInfo = async () => {
    const subscriptionInfo = await getSubscriptionInfo();
    setSubscriptionInfo(subscriptionInfo);
  };
  const handleAddPaymentMethod = async () => {
    setIsLoading(true);
    setError("");
    try {
      if (isUpgradeMode) {
        await upgradeToPaid();
      }
      if (hasBillingInfo) {
        await refreshSubscriptionInfo();
        return;
      }
      const response = await getPortalSession();
      const portalUrl = response.url;
      if (portalUrl) {
        window.open(portalUrl, "_blank");
      } else {
        setError("Payment portal session expired. Please try again.");
      }
    } catch (error2) {
      console.error("Error opening portal session:", error2);
      if (isUpgradeMode) {
        setError("An error occurred while upgrading to paid plan. Please try again.");
      } else {
        setError("An error occurred while accessing the payment portal. Please try again.");
      }
    } finally {
      setIsLoading(false);
    }
  };
  reactExports.useEffect(() => {
    if (isLastSeenActiveTab) {
      refreshSubscriptionInfo();
    }
  }, [isLastSeenActiveTab]);
  if (hasPaid) {
    return /* @__PURE__ */ jsxRuntimeExports.jsx(AutoConfirmCloseWrapper, { onClose: () => setActiveTab("home"), children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "bg-white flex w-full flex-col items-center overflow-y-auto overflow-x-hidden pb-8 pt-16", children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "w-full max-w-5xl px-4 md:px-12", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex w-full flex-col items-center space-y-6", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex flex-col items-center space-y-4", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex h-24 w-24 items-center justify-center rounded-full bg-green-100", children: /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "text-4xl", children: "🎉" }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { className: "text-center text-3xl font-bold text-gray-900", children: "Congratulations!" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-center text-lg text-gray-600", children: "You're now subscribed to Spicy Toolbox" })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "w-full max-w-2xl rounded-lg bg-gradient-to-r from-purple-50 to-indigo-50 p-6", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: "mb-4 text-center text-lg font-semibold text-gray-900", children: "You now have access to all paid features:" }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "grid grid-cols-1 gap-3 sm:grid-cols-2", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center space-x-3", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "text-xl", children: "💰" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "text-sm text-gray-700", children: "Fan chat labels" })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center space-x-3", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "text-xl", children: "💕" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "text-sm text-gray-700", children: "Chat emoji bar" })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center space-x-3", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "text-xl", children: "📝" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "text-sm text-gray-700", children: "Chat templates" })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center space-x-3", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "text-xl", children: "🏷️" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "text-sm text-gray-700", children: "Vault labels" })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center space-x-3", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "text-xl", children: "💬" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "text-sm text-gray-700", children: "Mass message online fans" })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center space-x-3", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "text-xl", children: "✅" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "text-sm text-gray-700", children: "Follow expired fans" })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center space-x-3", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "text-xl", children: "⭐️" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "text-sm text-gray-700", children: "Automatic fan rewards" })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center space-x-3", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "text-xl", children: "🚫" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "text-sm text-gray-700", children: "Scam protection (always free)" })
          ] })
        ] })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "text-center", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-sm text-gray-500", children: "Thank you for supporting Spicy Toolbox! 💕" }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { className: "text-sm text-gray-500", children: [
          "Questions or feedback? Email",
          " ",
          /* @__PURE__ */ jsxRuntimeExports.jsx("a", { href: "mailto:raquel@spicytoolbox.com", className: "text-indigo-500", children: "raquel@spicytoolbox.com" })
        ] })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs(
        "button",
        {
          onClick: () => setActiveTab("home"),
          className: "text-white w-full rounded-md bg-indigo-500 py-3 font-semibold hover:opacity-90",
          children: [
            "Explore Spicy Toolbox",
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "ml-1.5", children: "🌶️" })
          ]
        }
      )
    ] }) }) }) });
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsx(AutoConfirmCloseWrapper, { onClose: () => setActiveTab("home"), children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "bg-white flex w-full flex-col items-center overflow-y-auto overflow-x-hidden pb-8 pt-16", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs(
      "button",
      {
        onClick: handleBackButton,
        className: "absolute left-7 top-5 z-50 flex items-center text-gray-600 hover:text-gray-900",
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "svg",
            {
              className: "mr-2 h-5 w-5",
              fill: "none",
              strokeLinecap: "round",
              strokeLinejoin: "round",
              strokeWidth: "2",
              viewBox: "0 0 24 24",
              stroke: "currentColor",
              children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M10 19l-7-7m0 0l7-7m-7 7h18" })
            }
          ),
          "Back"
        ]
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex w-full max-w-5xl flex-col items-center px-4 md:px-12", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex w-full flex-col items-center justify-start", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex w-full flex-col items-center space-y-4", children: [
        hasBillingInfo ? /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex w-full max-w-xl items-center justify-center px-20 md:px-0", children: /* @__PURE__ */ jsxRuntimeExports.jsx(FeatureCarousel, { showBlocklistFeatures: false }) }) : /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex w-full flex-col items-center justify-center space-y-2 px-20 md:px-0", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "img",
            {
              src: addCreditCardGif,
              alt: "Add credit card",
              className: "h-80 w-auto max-w-none rounded-lg border border-indigo-500/90 object-cover shadow-md"
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-center text-sm italic text-gray-500", children: "Add a credit card on the next page after clicking 'Add payment method' below" })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex flex-col items-center space-y-3 pb-4", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("h2", { className: "text-center text-2xl font-bold", children: [
            hasBillingInfo ? "Click below to subscribe" : "Add a payment method to subscribe",
            " ",
            "☺️"
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-center text-sm text-gray-500", children: hasBillingInfo ? "Click below to get access to all the tools that help creators earn more money on OnlyFans" : "Click below and add a payment method to your account to activate your subscription" }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { className: "text-center text-sm font-semibold italic text-gray-500", children: [
            "Cancel anytime, if you don't love it email me at",
            " ",
            /* @__PURE__ */ jsxRuntimeExports.jsx("a", { href: "mailto:raquel@spicytoolbox.com", className: "text-indigo-500", children: "raquel@spicytoolbox.com" }),
            " ",
            "for a full refund within 90 days 💕"
          ] })
        ] })
      ] }) }),
      error && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "mb-4 mt-4 rounded-md bg-red-50 p-3 text-sm text-red-500", children: error }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "mt-10 w-full space-y-3 self-center", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs(
          "button",
          {
            onClick: handleAddPaymentMethod,
            className: `text-white w-full rounded-md bg-indigo-500 py-3 font-semibold ${isLoading ? "cursor-not-allowed opacity-50" : "hover:opacity-90"}`,
            disabled: isLoading,
            children: [
              isLoading ? hasBillingInfo ? "Upgrading to paid plan..." : "Opening payment portal..." : hasBillingInfo ? "Subscribe" : "Add payment method",
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "ml-1.5", children: "💳" })
            ]
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "mt-4 text-center", children: /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-xs text-gray-400", children: "Secure payment processing by PayPal. Cancel anytime." }) })
      ] })
    ] })
  ] }) });
};
const UpgradeToPaidTab = () => {
  const { setActiveTab, payload } = useTabNavigation();
  const isUpgradeMode = (payload == null ? void 0 : payload.is_upgrade) || false;
  const backButtonTab = (payload == null ? void 0 : payload.back_button_tab) || null;
  const handleContinue = () => {
    setActiveTab("upgradeToPaidConfirm", {
      ...payload
    });
  };
  const handleNoThanks = () => {
    setActiveTab("downgradeToFreeConfirm");
  };
  const handleBackButton = () => {
    if (backButtonTab) {
      setActiveTab(backButtonTab);
    } else {
      setActiveTab("home");
    }
  };
  const freeFeatures = [
    "Scam protection in your DMs - Get notified about users who have done chargebacks"
  ];
  const premiumFeatures = [
    { text: "Fan chat labels (spending, renewal, etc.)", emoji: "💰" },
    { text: "Chat emoji bar", emoji: "💕" },
    { text: "Chat templates", emoji: "📝" },
    { text: "Vault labels", emoji: "🏷️" },
    { text: "Mass message online fans", emoji: "💬" },
    { text: "Follow expired fans", emoji: "✅" },
    { text: "Automatic fan rewards", emoji: "⭐️" }
  ];
  return /* @__PURE__ */ jsxRuntimeExports.jsx(AutoConfirmCloseWrapper, { onClose: handleBackButton, children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "bg-white flex w-full flex-col items-center overflow-y-auto overflow-x-hidden pb-8 pt-16", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "w-full max-w-5xl px-4 md:px-12", children: [
    backButtonTab && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "mb-6 flex w-full justify-start", children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
      "button",
      {
        onClick: handleBackButton,
        className: "flex items-center space-x-2 text-sm text-gray-600 hover:text-gray-800",
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: "←" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: "Back" })
        ]
      }
    ) }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex w-full flex-col items-center space-y-4", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex w-full max-w-xl items-center justify-center px-20 md:px-0", children: /* @__PURE__ */ jsxRuntimeExports.jsx(FeatureCarousel, { showBlocklistFeatures: false }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex flex-col items-center space-y-3 pb-4", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { className: "text-center text-2xl font-bold", children: isUpgradeMode ? "Subscribe and earn more with premium features 💕" : "Subscribe to avoid losing features 💕" }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { className: "text-center text-sm text-gray-500", children: [
          isUpgradeMode ? "Get access to all the tools that help creators earn more money on OnlyFans. " : "Keep access to all the tools that help creators earn more money on OnlyFans. ",
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "font-bold italic", children: "Cancel anytime, scam protection will always remain 100% free." })
        ] })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex w-full max-w-4xl flex-col space-y-6 md:flex-row md:space-x-6 md:space-y-0", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex-1 space-y-4", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center justify-center space-x-2", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "text-xl", children: isUpgradeMode ? "✨" : "💔" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "font-bold text-indigo-500", children: isUpgradeMode ? "Premium features you'll unlock" : "Subscription features you'll lose" })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "rounded-lg bg-gradient-to-r from-purple-50 to-indigo-50 p-4", children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "grid grid-cols-2 gap-4", children: premiumFeatures.map((feature, index2) => /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-start space-x-2 text-gray-700", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: feature.emoji }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "text-left text-sm text-gray-700", children: feature.text })
          ] }, index2)) }) })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex-1 space-y-4", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center justify-center space-x-2", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "text-xl", children: "✅" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "font-bold text-green-600", children: isUpgradeMode ? "What you'll always keep for FREE" : "What you'll always keep for FREE" })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "rounded-lg bg-green-50 p-4", children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "space-y-2", children: freeFeatures.map((feature, index2) => /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-start space-x-2", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "text-green-500", children: "🚫" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "text-left text-sm text-gray-700", children: feature })
          ] }, index2)) }) })
        ] })
      ] })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "mt-10 w-full space-y-3 self-center", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs(
        "button",
        {
          onClick: handleContinue,
          className: `text-white w-full rounded-md bg-indigo-500 py-3 font-semibold ${"hover:opacity-90"}`,
          children: [
            "View subscription instructions",
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "ml-1.5", children: "👀" })
          ]
        }
      ),
      !isUpgradeMode && /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
        "button",
        {
          onClick: handleNoThanks,
          className: "bg-white w-full rounded-md border border-gray-300 py-3 font-semibold text-gray-700 hover:bg-gray-50",
          children: [
            "No thanks, lose subscription features",
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "ml-1", children: "💔" })
          ]
        }
      ) })
    ] })
  ] }) }) });
};
const TabContent = () => {
  const { activeTab } = useTabNavigation();
  const aiRepliesFeatureEnabled = Recoil_index_20(aiRepliesFeatureSelector);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    activeTab === "home" && /* @__PURE__ */ jsxRuntimeExports.jsx(HomeTab, {}),
    activeTab === "settings" && /* @__PURE__ */ jsxRuntimeExports.jsx(AccountTab, {}),
    activeTab === "apiPlayground" && /* @__PURE__ */ jsxRuntimeExports.jsx(APIPlaygroundTab, {}),
    activeTab === "debug" && /* @__PURE__ */ jsxRuntimeExports.jsx(DebugConsoleTab, {}),
    /* @__PURE__ */ jsxRuntimeExports.jsxs(FreeTrialDisabledFeatureWrapper, { children: [
      activeTab === "chatLabels" && /* @__PURE__ */ jsxRuntimeExports.jsx(ChatLabelsTab, {}),
      activeTab === "followExpiredFans" && /* @__PURE__ */ jsxRuntimeExports.jsx(FollowExpiredFansTab, {}),
      activeTab === "messageOnlineFans" && /* @__PURE__ */ jsxRuntimeExports.jsx(MessageOnlineFansTab, {}),
      activeTab === "shortcuts" && /* @__PURE__ */ jsxRuntimeExports.jsx(CustomizeShortcutsTab, {}),
      activeTab === "aiReplySuggestions" && aiRepliesFeatureEnabled && /* @__PURE__ */ jsxRuntimeExports.jsx(AIReplySuggestionsTab, {}),
      activeTab === "createRewards" && /* @__PURE__ */ jsxRuntimeExports.jsx(CreateRewardsTab, {})
    ] }),
    activeTab === "upgradeToPaid" && /* @__PURE__ */ jsxRuntimeExports.jsx(UpgradeToPaidTab, {}),
    activeTab === "upgradeToPaidConfirm" && /* @__PURE__ */ jsxRuntimeExports.jsx(UpgradeToPaidConfirmTab, {}),
    activeTab === "downgradeToFreeConfirm" && /* @__PURE__ */ jsxRuntimeExports.jsx(DowngradeToFreeConfirmTab, {})
  ] });
};
const CreatorSettingsWrapper = ({ children }) => {
  const ofUserId = Recoil_index_20(ofUserIdAtom);
  const subscriptionSettings = Recoil_index_20(subscriptionSettingsAtom);
  const currentCreatorSettings = Recoil_index_20(currentCreatorSettingsSelector);
  const isLoading = Recoil_index_20(isCreatorSettingsLoadingSelector);
  const hasCreatorSettings = Recoil_index_20(hasCreatorSettingsSelector);
  const [lastKnownOfUserId, setLastKnownOfUserId] = reactExports.useState(ofUserId);
  const [isTransitioning, setIsTransitioning] = reactExports.useState(false);
  reactExports.useEffect(() => {
    if (ofUserId !== lastKnownOfUserId) {
      console.log(
        "[CreatorSettingsWrapper] ofUserId changed from",
        lastKnownOfUserId,
        "to",
        ofUserId
      );
      setIsTransitioning(true);
      setLastKnownOfUserId(ofUserId);
    }
  }, [ofUserId, lastKnownOfUserId]);
  reactExports.useEffect(() => {
    if (hasCreatorSettings || currentCreatorSettings === null) {
      console.log(
        "[CreatorSettingsWrapper] CreatorSettings available for",
        ofUserId,
        "- clearing transition state"
      );
      setIsTransitioning(false);
    }
  }, [hasCreatorSettings, currentCreatorSettings, ofUserId]);
  if (!ofUserId || !subscriptionSettings || isLoading) {
    return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex h-full w-full items-center justify-center", children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text-sm text-gray-500", children: "Loading settings..." }) });
  }
  if (isTransitioning) {
    return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex h-full w-full items-center justify-center", children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text-sm text-gray-500", children: "Loading creator settings..." }) });
  }
  console.log("[CreatorSettingsWrapper] Rendering children for ofUserId:", ofUserId, {
    hasCreatorSettings,
    currentCreatorSettings: currentCreatorSettings ? "present" : "null",
    isTransitioning
  });
  return children;
};
class ChargebackSyncService {
  constructor(onlyFansAPI, networkManager, ofUserId) {
    this.onlyFansAPI = onlyFansAPI;
    this.networkManager = networkManager;
    this.ofUserId = ofUserId;
    this.aborted = false;
  }
  async syncChargebacks(subscriptionSettings) {
    if (!this.ofUserId) {
      console.log("[chargebackSync] No ofUserId, skipping sync");
      return;
    }
    if (!subscriptionSettings) {
      console.log("[chargebackSync] No subscriptionSettings, skipping sync");
      return;
    }
    if (this.aborted)
      return;
    const BATCH_SIZE = 100;
    const creatorInfo = await this.onlyFansAPI.getCreatorStartDate();
    console.log(`[chargebackSync] Creator start date: ${creatorInfo.startDate}`);
    const chargebackSync = await this.networkManager.getChargebackDataSync();
    console.log(`[chargebackSync] Current sync state: ${JSON.stringify(chargebackSync)}`);
    if (!chargebackSync) {
      console.log("[chargebackSync] No sync state found, aborting sync");
      return;
    }
    if (this.aborted)
      return;
    await this.performChargebackSync(BATCH_SIZE, chargebackSync, creatorInfo.startDate);
  }
  stopSync() {
    this.aborted = true;
  }
  async performChargebackSync(batchSize, chargebackSync, creatorStartDate) {
    if (this.aborted)
      return;
    try {
      console.log("[chargebackSync] Starting chargeback sync");
      let totalProcessed = 0;
      let syncPhase = "full";
      let isFullSyncComplete = false;
      let updatedSyncState = { ...chargebackSync };
      const fullSyncResults = await this.performFullSync(
        batchSize,
        chargebackSync,
        creatorStartDate
      );
      totalProcessed += fullSyncResults.processed;
      isFullSyncComplete = fullSyncResults.isComplete;
      if (fullSyncResults.syncState) {
        updatedSyncState = fullSyncResults.syncState;
      }
      if (isFullSyncComplete) {
        syncPhase = "delta";
        const deltaSyncResults = await this.performDeltaSync(
          batchSize,
          updatedSyncState
          // Use the updated sync state
        );
        totalProcessed += deltaSyncResults.processed;
        if (deltaSyncResults.syncState) {
          updatedSyncState = deltaSyncResults.syncState;
        }
      }
      console.log(
        `[chargebackSync] ${syncPhase.toUpperCase()} sync completed, processed ${totalProcessed} chargebacks total`
      );
    } catch (error) {
      console.error("[chargebackSync] Error syncing chargebacks:", error);
    }
  }
  async performFullSync(batchSize, chargebackSync, creatorStartDate) {
    var _a;
    console.log("[chargebackSync] Starting FULL historical sync");
    let fullSyncOffset = chargebackSync.fullSyncOffset || 0;
    let processedIds = /* @__PURE__ */ new Set();
    let totalProcessed = 0;
    let currentSyncState = { ...chargebackSync };
    let startDate = chargebackSync.fullSyncStartDate ? new Date(chargebackSync.fullSyncStartDate) : creatorStartDate ? new Date(creatorStartDate) : /* @__PURE__ */ new Date("2016-01-01");
    let endDate = /* @__PURE__ */ new Date();
    const fullSyncStartDate = !chargebackSync.fullSyncStartDate ? startDate : null;
    console.log(
      `[chargebackSync] Full sync from ${startDate.toISOString()} (startDate) to ${endDate.toISOString()} (endDate), offset: ${fullSyncOffset}`
    );
    const MAX_ITERATIONS = 100;
    let iterations = 0;
    let isFullSyncComplete = false;
    while (!isFullSyncComplete && !this.aborted && iterations < MAX_ITERATIONS) {
      iterations++;
      const result = await this.onlyFansAPI.getChargebacks(
        batchSize,
        fullSyncOffset,
        startDate.toISOString(),
        // Older date
        endDate.toISOString()
        // Newer date
      );
      console.log(
        `[chargebackSync] Full sync iteration ${iterations}: Fetched ${((_a = result.list) == null ? void 0 : _a.length) || 0} chargebacks, offset: ${fullSyncOffset}`
      );
      await new Promise((resolve) => setTimeout(resolve, Math.floor(Math.random() * 1500) + 1500));
      if (!result.list || result.list.length === 0) {
        console.log("[chargebackSync] No more historical chargebacks, full sync completed");
        await this.networkManager.upsertChargebacks(
          [],
          // Empty chargebacks array
          fullSyncStartDate ? fullSyncStartDate.toISOString() : null,
          null
          // don't pass fullSyncOffset if we're not processing any chargebacks
        );
        isFullSyncComplete = true;
        break;
      }
      const chargebacks = this.extractChargebacks(result.list);
      const chargebacksMap = /* @__PURE__ */ new Map();
      chargebacks.forEach((cb2) => {
        if (!chargebacksMap.has(cb2.id)) {
          chargebacksMap.set(cb2.id, cb2);
        }
      });
      const uniqueChargebacks = Array.from(chargebacksMap.values());
      const newChargebacks = uniqueChargebacks.filter((cb2) => !processedIds.has(cb2.id));
      newChargebacks.forEach((cb2) => processedIds.add(cb2.id));
      console.log(
        `[chargebackSync] Found ${newChargebacks.length} new chargebacks to process in full sync`
      );
      const nextOffset = fullSyncOffset + batchSize;
      if (newChargebacks.length > 0) {
        const response = await this.networkManager.upsertChargebacks(
          newChargebacks,
          fullSyncStartDate ? fullSyncStartDate.toISOString() : null,
          nextOffset
        );
        if (response == null ? void 0 : response.syncState) {
          currentSyncState = response.syncState;
          console.log(
            `[chargebackSync] Updated sync state from server: ${JSON.stringify(currentSyncState)}`
          );
        }
        const batchProcessed = (response == null ? void 0 : response.chargebacksProcessed) || 0;
        totalProcessed += batchProcessed;
        console.log(
          `[chargebackSync] Processed batch of ${batchProcessed}, total so far: ${totalProcessed}`
        );
      } else {
        const response = await this.networkManager.upsertChargebacks(
          [],
          // Empty chargebacks array
          fullSyncStartDate ? fullSyncStartDate.toISOString() : null,
          null
          // don't pass fullSyncOffset if we're not processing any chargebacks
        );
        if (response == null ? void 0 : response.syncState) {
          currentSyncState = response.syncState;
          console.log(
            `[chargebackSync] Updated sync state from server (empty batch): ${JSON.stringify(currentSyncState)}`
          );
        }
      }
      fullSyncOffset = currentSyncState.fullSyncOffset || nextOffset;
      if (result.list.length < batchSize) {
        console.log("[chargebackSync] Received incomplete batch, full sync is complete");
        isFullSyncComplete = true;
        break;
      }
    }
    if (iterations >= MAX_ITERATIONS) {
      console.log(
        "[chargebackSync] Reached maximum iterations limit for full sync, will continue next time"
      );
    }
    return {
      processed: totalProcessed,
      isComplete: isFullSyncComplete,
      syncState: currentSyncState
    };
  }
  async performDeltaSync(batchSize, chargebackSync) {
    var _a;
    console.log("[chargebackSync] Starting DELTA sync for new chargebacks");
    let startDate;
    if (chargebackSync.latestChargebackDate) {
      startDate = new Date(chargebackSync.latestChargebackDate);
      console.log(
        `[chargebackSync] Using latestChargebackDate as starting point: ${startDate.toISOString()}`
      );
    } else {
      startDate = new Date(Date.now() - 7 * 24 * 60 * 60 * 1e3);
      console.log(
        `[chargebackSync] No sync timestamps available, using one week ago: ${startDate.toISOString()}`
      );
    }
    let endDate = /* @__PURE__ */ new Date();
    let offset3 = 0;
    let totalProcessed = 0;
    let processedIds = /* @__PURE__ */ new Set();
    let foundExistingChargeback = false;
    let currentSyncState = { ...chargebackSync };
    console.log(
      `[chargebackSync] Delta sync from ${startDate.toISOString()} (startDate) to ${endDate.toISOString()} (endDate)`
    );
    const latestChargebackDate = chargebackSync.latestChargebackDate ? new Date(chargebackSync.latestChargebackDate) : null;
    if (latestChargebackDate) {
      console.log(
        `[chargebackSync] Will filter out chargebacks on or before ${latestChargebackDate.toISOString()}`
      );
    } else {
      console.log(
        `[chargebackSync] No latestChargebackDate available for duplicate detection, will rely on ID checking`
      );
    }
    const MAX_ITERATIONS = 20;
    let iterations = 0;
    while (!foundExistingChargeback && !this.aborted && iterations < MAX_ITERATIONS) {
      iterations++;
      const result = await this.onlyFansAPI.getChargebacks(
        batchSize,
        offset3,
        startDate.toISOString(),
        // Older date
        endDate.toISOString()
        // Newer date
      );
      console.log(
        `[chargebackSync] Delta sync iteration ${iterations}: Fetched ${((_a = result.list) == null ? void 0 : _a.length) || 0} chargebacks`
      );
      await new Promise((resolve) => setTimeout(resolve, Math.floor(Math.random() * 1500) + 1500));
      if (!result.list || result.list.length === 0) {
        console.log("[chargebackSync] No new chargebacks found in delta sync");
        break;
      }
      const chargebacks = this.extractChargebacks(result.list);
      const chargebacksMap = /* @__PURE__ */ new Map();
      chargebacks.forEach((cb2) => {
        if (!chargebacksMap.has(cb2.id)) {
          chargebacksMap.set(cb2.id, cb2);
        }
      });
      const uniqueChargebacks = Array.from(chargebacksMap.values());
      let filteredChargebacks = uniqueChargebacks;
      if (latestChargebackDate) {
        filteredChargebacks = uniqueChargebacks.filter((cb2) => {
          const chargebackDate = new Date(cb2.date);
          return chargebackDate > latestChargebackDate;
        });
        if (filteredChargebacks.length < uniqueChargebacks.length) {
          console.log(
            `[chargebackSync] Filtered out ${uniqueChargebacks.length - filteredChargebacks.length} chargebacks dated on or before our latest chargeback date`
          );
        }
        if (filteredChargebacks.length === 0 && uniqueChargebacks.length > 0) {
          console.log(
            "[chargebackSync] All chargebacks in this batch are older than or equal to our latest chargeback date, stopping delta sync"
          );
          foundExistingChargeback = true;
          break;
        }
      }
      const newChargebacks = filteredChargebacks.filter((cb2) => !processedIds.has(cb2.id));
      newChargebacks.forEach((cb2) => processedIds.add(cb2.id));
      console.log(
        `[chargebackSync] Found ${newChargebacks.length} new chargebacks to process in delta sync`
      );
      if (newChargebacks.length > 0) {
        const response = await this.networkManager.upsertChargebacks(
          newChargebacks,
          null,
          // don't pass fullSyncStartDate in a delta sync
          null
          // don't pass fullSyncOffset in a delta sync
        );
        if (response == null ? void 0 : response.syncState) {
          currentSyncState = response.syncState;
          console.log(
            `[chargebackSync] Updated delta sync state from server: ${JSON.stringify(currentSyncState)}`
          );
        }
        const batchProcessed = (response == null ? void 0 : response.chargebacksProcessed) || 0;
        totalProcessed += batchProcessed;
        console.log(
          `[chargebackSync] Processed batch of ${batchProcessed}, total so far: ${totalProcessed}`
        );
      }
      if (result.list.length < batchSize) {
        console.log("[chargebackSync] Received incomplete batch, delta sync is complete");
        break;
      }
      offset3 += batchSize;
    }
    if (iterations >= MAX_ITERATIONS) {
      console.log("[chargebackSync] Reached maximum iterations limit for delta sync");
    }
    return {
      processed: totalProcessed,
      syncState: currentSyncState
    };
  }
  extractChargebacks(chargebacksList) {
    return chargebacksList.map((chargeback) => {
      var _a, _b, _c, _d, _e2, _f, _g;
      const payment = chargeback.payment || {};
      const user = payment.user || {};
      const id2 = ((_a = payment.id) == null ? void 0 : _a.toString()) || ((_b = chargeback.id) == null ? void 0 : _b.toString());
      return {
        id: id2,
        amount: payment.amount || chargeback.amount || 0,
        username: user.username || ((_c = chargeback.fromUser) == null ? void 0 : _c.username) || "unknown",
        userId: ((_d = user.id) == null ? void 0 : _d.toString()) || ((_f = (_e2 = chargeback.fromUser) == null ? void 0 : _e2.id) == null ? void 0 : _f.toString()),
        date: payment.createdAt || chargeback.createdAt,
        description: `Chargeback of ${payment.amount || chargeback.amount || 0} from ${user.username || ((_g = chargeback.fromUser) == null ? void 0 : _g.username) || "unknown user"} - ${payment.description || chargeback.description || ""}`,
        rawData: chargeback
        // Store the raw data for debugging
      };
    });
  }
}
const useChargebackSync = () => {
  const subscriptionSettings = Recoil_index_20(subscriptionSettingsAtom);
  const ofUserId = Recoil_index_20(ofUserIdAtom);
  const onlyFansAPI = useOnlyFansAPI();
  const networkManager = useNetworkManager();
  const syncServiceRef = reactExports.useRef(null);
  const previousOfUserId = reactExports.useRef(ofUserId);
  reactExports.useEffect(() => {
    const syncChargebacks = async () => {
      if (previousOfUserId.current !== ofUserId && syncServiceRef.current) {
        console.log(
          `[chargebackSync] Stopping sync for previous ofUserId: ${previousOfUserId.current}`
        );
        syncServiceRef.current.stopSync();
      }
      syncServiceRef.current = new ChargebackSyncService(onlyFansAPI, networkManager, ofUserId);
      try {
        console.log(
          `[chargebackSync] Checking if sync should start: ${JSON.stringify(subscriptionSettings)}, ofUserId: ${ofUserId}`
        );
        if (shouldStartSync$1(subscriptionSettings, ofUserId)) {
          const syncState = await networkManager.getChargebackDataSync();
          if (shouldThrottleSync(syncState)) {
            console.log(
              "[chargebackSync] Sync throttled - last sync was too recent (< 4 hours ago)"
            );
            return;
          }
          console.log("[chargebackSync] Subscription settings available. Starting sync.");
          await syncServiceRef.current.syncChargebacks(subscriptionSettings);
        } else {
          console.log("[chargebackSync] Should not start sync. Skipping sync.");
        }
      } catch (error) {
        if (error.name === "AbortError") {
          console.log("[chargebackSync] Sync aborted due to ofUserId change");
        } else {
          console.error("[chargebackSync] Error in sync process:", error);
        }
      }
    };
    setTimeout(() => {
      syncChargebacks();
      previousOfUserId.current = ofUserId;
    }, 5e3);
    const intervalId = setInterval(
      () => {
        console.log("[chargebackSync] Running periodic sync (6-hour interval)");
        syncChargebacks();
      },
      6 * 60 * 60 * 1e3
      // 6 hours in milliseconds
    );
    return () => {
      if (syncServiceRef.current) {
        syncServiceRef.current.stopSync();
      }
      clearInterval(intervalId);
    };
  }, [ofUserId]);
};
function shouldThrottleSync(syncState) {
  if (!syncState || !syncState.lastSyncTimestamp) {
    return false;
  }
  const lastSyncTime = new Date(syncState.lastSyncTimestamp);
  const currentTime = /* @__PURE__ */ new Date();
  const hoursSinceLastSync = (currentTime - lastSyncTime) / (1e3 * 60 * 60);
  if (hoursSinceLastSync < 4) {
    console.log(
      `[chargebackSync] Last sync was ${hoursSinceLastSync.toFixed(2)} hours ago, minimum is 4 hours`
    );
    return true;
  }
  return false;
}
function shouldStartSync$1(subscriptionSettings, ofUserId) {
  if (!subscriptionSettings) {
    console.log(
      "[chargebackSync][shouldStartSync] Subscription settings not available. Skipping sync."
    );
    return false;
  }
  if (!ofUserId) {
    console.log("[chargebackSync][shouldStartSync] ofUserId not available. Skipping sync.");
    return false;
  }
  if (!subscriptionSettings.ofCreatorIds || subscriptionSettings.ofCreatorIds.length === 0) {
    console.log(
      "[chargebackSync][shouldStartSync] Subscription settings does not have any ofCreatorIds. Skipping sync."
    );
    return false;
  }
  return true;
}
const ChargebackSyncInjector = () => {
  useChargebackSync();
  return null;
};
const ChargebackWarningInjector = () => {
  const [currentChatId, setCurrentChatId] = reactExports.useState(null);
  const { getFanChargebacks } = useNetworkManager();
  const { getUserData } = useOnlyFansAPI();
  const { capture } = useAnalytics();
  const injectionInProgress = reactExports.useRef(false);
  const lastProcessedChatId = reactExports.useRef(null);
  const removalInProgress = reactExports.useRef(false);
  const removeChargebackWarning = reactExports.useCallback(() => {
    console.log("[ChargebackWarningInjector] Removing chargeback warning");
    removalInProgress.current = true;
    return new Promise((resolve) => {
      chrome.tabs.query({ active: true, currentWindow: true }, (tabs) => {
        if (!tabs[0]) {
          removalInProgress.current = false;
          resolve();
          return;
        }
        chrome.runtime.onMessage.addListener(function listener(message) {
          if (message.type === "CHARGEBACK_WARNING_REMOVAL_COMPLETE") {
            chrome.runtime.onMessage.removeListener(listener);
            removalInProgress.current = false;
            console.log("[ChargebackWarningInjector] Removal completed");
            resolve();
          }
        });
        chrome.tabs.sendMessage(tabs[0].id, {
          type: "removeChargebackWarning"
        });
      });
    });
  }, []);
  const removeSafeBanner = reactExports.useCallback(() => {
    console.log("[ChargebackWarningInjector] Removing safe banner");
    removalInProgress.current = true;
    return new Promise((resolve) => {
      chrome.tabs.query({ active: true, currentWindow: true }, (tabs) => {
        if (!tabs[0]) {
          removalInProgress.current = false;
          resolve();
          return;
        }
        chrome.runtime.onMessage.addListener(function listener(message) {
          if (message.type === "SAFE_BANNER_REMOVAL_COMPLETE") {
            chrome.runtime.onMessage.removeListener(listener);
            removalInProgress.current = false;
            console.log("[ChargebackWarningInjector] Safe banner removal completed");
            resolve();
          }
        });
        chrome.tabs.sendMessage(tabs[0].id, {
          type: "removeSafeBanner"
        });
      });
    });
  }, []);
  const injectChargebackWarning = reactExports.useCallback(
    async (chatId) => {
      var _a, _b;
      if (!chatId)
        return;
      try {
        if (removalInProgress.current) {
          console.log(
            "[ChargebackWarningInjector] Waiting for removal to complete before injection"
          );
          while (removalInProgress.current) {
            await new Promise((resolve) => setTimeout(resolve, 100));
          }
          console.log("[ChargebackWarningInjector] Removal completed, proceeding with injection");
        }
        console.log("[ChargebackWarningInjector] Checking chargebacks for:", chatId);
        injectionInProgress.current = true;
        let fanUsername = null;
        try {
          const maxRetries = 3;
          let retryCount = 0;
          while (fanUsername === null && retryCount < maxRetries) {
            const fanData = await getUserData(chatId);
            fanUsername = (fanData == null ? void 0 : fanData.username) || null;
            if (fanUsername === null) {
              retryCount++;
              console.log(
                `[ChargebackWarningInjector] Username is null, retry attempt ${retryCount}/${maxRetries}`
              );
              await new Promise((resolve) => setTimeout(resolve, 500));
            }
          }
          console.log("[ChargebackWarningInjector] Fetched fan username:", fanUsername);
        } catch (error) {
          console.error("[ChargebackWarningInjector] Error fetching fan data:", error);
        }
        const chargebackData = await getFanChargebacks(chatId, fanUsername);
        console.log("[ChargebackWarningInjector] Fetched chargeback data:", chargebackData);
        if (!((_a = chargebackData == null ? void 0 : chargebackData.summary) == null ? void 0 : _a.hasChargebacks)) {
          const totalChargebackCount = ((_b = chargebackData == null ? void 0 : chargebackData.summary) == null ? void 0 : _b.totalChargebackCount) || 0;
          if (totalChargebackCount > 0) {
            console.log(
              "[ChargebackWarningInjector] No chargebacks found for this fan, injecting safe banner"
            );
            await injectSafeBanner(chatId, totalChargebackCount);
          } else {
            console.log(
              "[ChargebackWarningInjector] No chargebacks in database, skipping safe banner"
            );
          }
          return;
        } else {
          const warningData = {
            reports: chargebackData.data,
            summary: chargebackData.summary,
            fanId: chatId
          };
          return new Promise((resolve) => {
            chrome.tabs.query({ active: true, currentWindow: true }, (tabs) => {
              var _a2, _b2, _c;
              if (!tabs[0]) {
                injectionInProgress.current = false;
                resolve();
                return;
              }
              chrome.runtime.onMessage.addListener(function listener(message) {
                if (message.type === "CHARGEBACK_WARNING_INJECTION_COMPLETE" && message.chatId === chatId) {
                  chrome.runtime.onMessage.removeListener(listener);
                  injectionInProgress.current = false;
                  console.log("[ChargebackWarningInjector] Injection completed");
                  resolve();
                }
              });
              chrome.tabs.sendMessage(tabs[0].id, {
                type: "injectChargebackWarning",
                warningData,
                chatId
              });
              capture("chargeback_warning_injected", {
                chat_id: chatId,
                chargeback_count: ((_a2 = chargebackData.data) == null ? void 0 : _a2.length) || 0,
                total_amount: ((_b2 = chargebackData.summary) == null ? void 0 : _b2.totalChargebackAmount) || 0,
                has_chargebacks: ((_c = chargebackData.summary) == null ? void 0 : _c.hasChargebacks) || false
              });
            });
          });
        }
      } catch (error) {
        console.error("[ChargebackWarningInjector] Error injecting chargeback warning:", error);
        injectionInProgress.current = false;
        return Promise.resolve();
      }
    },
    [getFanChargebacks, getUserData, capture]
  );
  const injectSafeBanner = reactExports.useCallback(
    async (chatId, totalChargebackCount) => {
      if (!chatId)
        return;
      try {
        if (removalInProgress.current) {
          console.log(
            "[ChargebackWarningInjector] Waiting for removal to complete before safe banner injection"
          );
          while (removalInProgress.current) {
            await new Promise((resolve) => setTimeout(resolve, 100));
          }
          console.log(
            "[ChargebackWarningInjector] Removal completed, proceeding with safe banner injection"
          );
        }
        console.log("[ChargebackWarningInjector] Injecting safe banner for:", chatId);
        injectionInProgress.current = true;
        return new Promise((resolve) => {
          chrome.tabs.query({ active: true, currentWindow: true }, (tabs) => {
            if (!tabs[0]) {
              injectionInProgress.current = false;
              resolve();
              return;
            }
            chrome.runtime.onMessage.addListener(function listener(message) {
              if (message.type === "SAFE_BANNER_INJECTION_COMPLETE" && message.chatId === chatId) {
                chrome.runtime.onMessage.removeListener(listener);
                injectionInProgress.current = false;
                console.log("[ChargebackWarningInjector] Safe banner injection completed");
                resolve();
              }
            });
            chrome.tabs.sendMessage(tabs[0].id, {
              type: "injectSafeBanner",
              chatId,
              totalChargebackCount
            });
            capture("safe_banner_injected", {
              chat_id: chatId
            });
          });
        });
      } catch (error) {
        console.error("[ChargebackWarningInjector] Error injecting safe banner:", error);
        injectionInProgress.current = false;
        return Promise.resolve();
      }
    },
    [capture]
  );
  const checkChatId = reactExports.useCallback(async () => {
    chrome.tabs.query({ active: true, currentWindow: true }, async (tabs) => {
      const currentTab = tabs[0];
      if (!(currentTab == null ? void 0 : currentTab.url))
        return;
      const chatUrlRegex = /https:\/\/onlyfans\.com\/my\/chats\/(chat\/(\d+))/;
      const mainChatsUrlRegex = /https:\/\/onlyfans\.com\/my\/chats\/?$/;
      const match2 = currentTab.url.match(chatUrlRegex);
      const isMainChatsPage = mainChatsUrlRegex.test(currentTab.url);
      if (match2) {
        const newChatId = match2[2];
        if (newChatId === lastProcessedChatId.current) {
          console.log(
            "[ChargebackWarningInjector] Skipping - already processed chat ID:",
            newChatId
          );
          return;
        }
        if (newChatId !== currentChatId) {
          console.log("[ChargebackWarningInjector] New chat ID:", newChatId);
          setCurrentChatId(newChatId);
          lastProcessedChatId.current = newChatId;
          if (currentChatId) {
            try {
              console.log(
                "[ChargebackWarningInjector] Removing existing banners/warnings before injection"
              );
              await Promise.all([removeChargebackWarning(), removeSafeBanner()]);
            } catch (error) {
              console.error("[ChargebackWarningInjector] Error removing banners/warnings:", error);
              removalInProgress.current = false;
            }
          }
          await injectChargebackWarning(newChatId);
        }
      } else if (isMainChatsPage) {
        console.log("[ChargebackWarningInjector] On main chats page");
        if (currentChatId) {
          setCurrentChatId(null);
          lastProcessedChatId.current = null;
          await Promise.all([removeChargebackWarning(), removeSafeBanner()]);
        }
      }
    });
  }, [
    currentChatId,
    injectChargebackWarning,
    removeChargebackWarning,
    injectSafeBanner,
    removeSafeBanner
  ]);
  reactExports.useEffect(() => {
    checkChatId();
    const handleTabUpdated = (tabId, changeInfo, tab2) => {
      if (changeInfo.url || changeInfo.status === "complete") {
        checkChatId();
      }
    };
    const handleTabActivated = () => {
      checkChatId();
    };
    chrome.tabs.onUpdated.addListener(handleTabUpdated);
    chrome.tabs.onActivated.addListener(handleTabActivated);
    return () => {
      chrome.tabs.onUpdated.removeListener(handleTabUpdated);
      chrome.tabs.onActivated.removeListener(handleTabActivated);
    };
  }, [checkChatId]);
  return null;
};
const ChatInfoPanelInjector = () => {
  const [currentChatId, setCurrentChatId] = reactExports.useState(null);
  const networkManager = useNetworkManager();
  const { capture } = useAnalytics();
  const injectionInProgress = reactExports.useRef(false);
  const removeChatInfoPanel = reactExports.useCallback(() => {
    console.log("[ChatInfoPanelInjector] Removing chat info panel");
    injectionInProgress.current = false;
    return new Promise((resolve) => {
      chrome.tabs.query({ active: true, currentWindow: true }, (tabs) => {
        if (!tabs[0]) {
          resolve();
          return;
        }
        chrome.runtime.onMessage.addListener(function listener(message) {
          if (message.type === "CHAT_INFO_PANEL_REMOVAL_COMPLETE") {
            chrome.runtime.onMessage.removeListener(listener);
            resolve();
          }
        });
        chrome.tabs.sendMessage(tabs[0].id, {
          type: "removeChatInfoPanel"
        });
      });
    });
  }, []);
  const showLoadingState = reactExports.useCallback((chatId) => {
    if (!chatId)
      return Promise.resolve();
    console.log("[ChatInfoPanelInjector] Showing loading state for:", chatId);
    return new Promise((resolve) => {
      chrome.tabs.query({ active: true, currentWindow: true }, (tabs) => {
        if (!tabs[0]) {
          resolve();
          return;
        }
        chrome.runtime.onMessage.addListener(function listener(message) {
          if (message.type === "CHAT_INFO_PANEL_LOADING_COMPLETE" && message.chatId === chatId) {
            chrome.runtime.onMessage.removeListener(listener);
            resolve();
          }
        });
        chrome.tabs.sendMessage(tabs[0].id, {
          type: "showChatInfoPanelLoading",
          chatId
        });
      });
    });
  }, []);
  const injectChatInfoPanel = reactExports.useCallback(
    async (chatId) => {
      if (!chatId)
        return;
      try {
        console.log("[ChatInfoPanelInjector] Injecting chat info panel for:", chatId);
        injectionInProgress.current = true;
        const fanInfo = await networkManager.getFanInfo(chatId);
        console.log("[ChatInfoPanelInjector] Fetched fan info:", fanInfo);
        const chatInfo = {
          name: "Fan Notes",
          notes: (fanInfo == null ? void 0 : fanInfo.notes) || "",
          fanId: chatId
        };
        return new Promise((resolve) => {
          chrome.tabs.query({ active: true, currentWindow: true }, (tabs) => {
            var _a;
            if (!tabs[0]) {
              injectionInProgress.current = false;
              resolve();
              return;
            }
            chrome.runtime.onMessage.addListener(function listener(message) {
              if (message.type === "CHAT_INFO_PANEL_INJECTION_COMPLETE" && message.chatId === chatId) {
                chrome.runtime.onMessage.removeListener(listener);
                injectionInProgress.current = false;
                resolve();
              }
            });
            chrome.tabs.sendMessage(tabs[0].id, {
              type: "injectChatInfoPanel",
              chatInfo,
              chatId
            });
            capture("chat_info_panel_injected", {
              chat_id: chatId,
              has_notes: Boolean(chatInfo.notes),
              notes_length: ((_a = chatInfo.notes) == null ? void 0 : _a.length) || 0
            });
          });
        });
      } catch (error) {
        console.error("[ChatInfoPanelInjector] Error injecting chat info panel:", error);
        injectionInProgress.current = false;
        return Promise.resolve();
      }
    },
    [networkManager, capture]
  );
  const checkChatId = reactExports.useCallback(async () => {
    if (injectionInProgress.current) {
      console.log("[ChatInfoPanelInjector] Skipping check - injection in progress");
      return;
    }
    chrome.tabs.query({ active: true, currentWindow: true }, async (tabs) => {
      const currentTab = tabs[0];
      if (!(currentTab == null ? void 0 : currentTab.url))
        return;
      const chatUrlRegex = /https:\/\/onlyfans\.com\/my\/chats\/(chat\/(\d+))/;
      const mainChatsUrlRegex = /https:\/\/onlyfans\.com\/my\/chats\/?$/;
      const match2 = currentTab.url.match(chatUrlRegex);
      const isMainChatsPage = mainChatsUrlRegex.test(currentTab.url);
      if (match2) {
        const newChatId = match2[2];
        if (newChatId !== currentChatId) {
          console.log("[ChatInfoPanelInjector] New chat ID:", newChatId);
          setCurrentChatId(newChatId);
          if (currentChatId) {
            await removeChatInfoPanel();
          }
          await showLoadingState(newChatId);
          await injectChatInfoPanel(newChatId);
        }
      } else if (isMainChatsPage) {
        console.log("[ChatInfoPanelInjector] On main chats page");
        if (currentChatId) {
          setCurrentChatId(null);
          await removeChatInfoPanel();
        }
      }
    });
  }, [currentChatId, injectChatInfoPanel, removeChatInfoPanel, showLoadingState]);
  reactExports.useEffect(() => {
    const handleMessage = (message, sender, sendResponse) => {
      if (message.type === "updateFanInfo" && message.fanId && message.notes !== void 0) {
        console.log("[ChatInfoPanelInjector] Updating fan info:", message);
        networkManager.updateFanInfo(message.fanId, message.notes).then((response) => {
          console.log("[ChatInfoPanelInjector] Fan info updated:", response);
          sendResponse({ success: true, data: response });
        }).catch((error) => {
          console.error("[ChatInfoPanelInjector] Error updating fan info:", error);
          sendResponse({ success: false, error: error.message });
        });
        return true;
      }
    };
    chrome.runtime.onMessage.addListener(handleMessage);
    return () => {
      chrome.runtime.onMessage.removeListener(handleMessage);
    };
  }, [networkManager]);
  reactExports.useEffect(() => {
    checkChatId();
    const handleTabUpdated = (tabId, changeInfo, tab2) => {
      if (changeInfo.url || changeInfo.status === "complete") {
        checkChatId();
      }
    };
    const handleTabActivated = () => {
      checkChatId();
    };
    chrome.tabs.onUpdated.addListener(handleTabUpdated);
    chrome.tabs.onActivated.addListener(handleTabActivated);
    return () => {
      chrome.tabs.onUpdated.removeListener(handleTabUpdated);
      chrome.tabs.onActivated.removeListener(handleTabActivated);
    };
  }, [checkChatId]);
  return null;
};
const componentId = "reward-messages-processor";
const processUserSubscriptionData$1 = (user) => {
  if (!(user == null ? void 0 : user.subscribedOnData))
    return null;
  const subscribeDate = new Date(user.subscribedOnData.subscribeAt);
  return {
    subscribeDate
  };
};
class FanLikeSyncService {
  constructor(onlyFansAPI, networkManager, ofUserId, messageDelay = null, apiRateLimitDelay = null) {
    this.onlyFansAPI = onlyFansAPI;
    this.networkManager = networkManager;
    this.messageDelay = messageDelay;
    this.apiRateLimitDelay = apiRateLimitDelay;
    this.aborted = false;
    this.ofUserId = ofUserId;
    this.statusBar = useStatusBar();
  }
  async syncFanLikes(subscriptionSettings, oldestRewardCreationDate) {
    if (!oldestRewardCreationDate) {
      console.log("[deltaSync] No oldestRewardCreationDate, skipping sync");
      return;
    }
    if (!this.ofUserId) {
      console.log("[deltaSync] No ofUserId, skipping sync");
      return;
    }
    if (!subscriptionSettings) {
      console.log("[deltaSync] No subscriptionSettings, skipping sync");
      return;
    }
    if (this.aborted)
      return;
    const BATCH_SIZE = 25;
    const creatorDataSync = await this.networkManager.getCreatorDataSync();
    console.log(`[deltaSync] creatorDataSync: ${JSON.stringify(creatorDataSync)}`);
    if (this.aborted)
      return;
    await this.performDeltaSync(BATCH_SIZE, creatorDataSync, oldestRewardCreationDate);
  }
  stopSync() {
    this.aborted = true;
  }
  async performDeltaSync(batchSize, creatorDataSync, oldestRewardCreationDate) {
    if (this.aborted)
      return;
    if (!creatorDataSync) {
      console.log("[deltaSync] No creatorDataSync, skipping sync");
      return;
    }
    console.log("[deltaSync] Starting delta sync");
    let hasMoreLikes = true;
    let mostRecentLikeTimestamp = null;
    let fromId = null;
    let isOldestLikeInBatchBeforeLatestSyncTimestamp = false;
    while (hasMoreLikes && !this.aborted) {
      const likeBatch = await this.fetchLikeBatch(fromId, batchSize);
      if (this.apiRateLimitDelay !== null) {
        await new Promise((resolve) => setTimeout(resolve, this.apiRateLimitDelay));
      } else {
        await new Promise(
          (resolve) => setTimeout(resolve, Math.floor(Math.random() * 3e3) + 2e3)
        );
      }
      if (!likeBatch.list || likeBatch.list.length === 0) {
        break;
      }
      console.log(
        `[deltaSync] likeBatch is: ${JSON.stringify(likeBatch)}, deltaSyncLatestSyncTimestamp: ${creatorDataSync.deltaSyncLatestSyncTimestamp}`
      );
      const filteredLikes = likeBatch.list.filter((like) => {
        const likeDate = new Date(like.createdAt);
        const latestSyncTimestamp2 = new Date(
          Math.max(
            new Date(creatorDataSync.deltaSyncLatestSyncTimestamp).getTime(),
            new Date(oldestRewardCreationDate).getTime()
          )
        );
        const shouldInclude = !latestSyncTimestamp2 || likeDate > latestSyncTimestamp2;
        console.log(
          `[deltaSync] Like ${like.id} from ${likeDate}: ${shouldInclude ? "including" : "filtering out"} because ${shouldInclude ? `it is after ${latestSyncTimestamp2}` : `it is before ${latestSyncTimestamp2}`}`
        );
        return shouldInclude;
      });
      console.log(
        `[deltaSync] Filtered ${likeBatch.list.length - filteredLikes.length} likes out of ${likeBatch.list.length} total`
      );
      console.log(`[deltaSync] filteredLikes is: ${JSON.stringify(filteredLikes)}`);
      if (filteredLikes.length > 0) {
        const response = await this.upsertLikeBatch(filteredLikes);
        if ((response == null ? void 0 : response.status) === 200) {
          const batchLatestTimestamp = new Date(filteredLikes[0].createdAt);
          if (!mostRecentLikeTimestamp || batchLatestTimestamp > mostRecentLikeTimestamp) {
            mostRecentLikeTimestamp = batchLatestTimestamp;
          }
        }
      }
      const oldestLikeInBatch = likeBatch.list[likeBatch.list.length - 1];
      const oldestLikeInBatchCreatedTimestamp = new Date(oldestLikeInBatch.createdAt);
      const latestSyncTimestamp = new Date(
        creatorDataSync.deltaSyncLatestSyncTimestamp || oldestRewardCreationDate
      );
      isOldestLikeInBatchBeforeLatestSyncTimestamp = oldestLikeInBatchCreatedTimestamp <= latestSyncTimestamp;
      console.log(
        `[deltaSync] is oldestLikeInBatchBeforeLatestSyncTimestamp: ${isOldestLikeInBatchBeforeLatestSyncTimestamp}, oldestLikeInBatchCreatedTimestamp: ${oldestLikeInBatchCreatedTimestamp}, deltaSyncLatestSyncTimestamp: ${latestSyncTimestamp}`
      );
      if (isOldestLikeInBatchBeforeLatestSyncTimestamp) {
        console.log("[deltaSync] Reached already synced likes");
        break;
      }
      hasMoreLikes = likeBatch.hasMore;
      fromId = oldestLikeInBatch.id;
    }
    if ((!hasMoreLikes || isOldestLikeInBatchBeforeLatestSyncTimestamp) && mostRecentLikeTimestamp) {
      await this.networkManager.updateCreatorDataSync({
        deltaSyncLatestSyncTimestamp: mostRecentLikeTimestamp.toISOString()
      });
    }
  }
  async fetchLikeBatch(fromId, limit) {
    console.log(`[deltaSync] Fetching likes, fromId: ${fromId}, limit: ${limit}`);
    const response = await this.onlyFansAPI.getLikeNotifications(limit, fromId);
    console.log("[deltaSync] getLikeNotifications response:", response);
    return response;
  }
  async upsertLikeBatch(likes) {
    try {
      console.log("[deltaSync] Starting upsertLikeBatch with:", {
        numberOfLikes: likes.length
      });
      const uniqueFanIds = Array.from(new Set(likes.map((like) => like.user.id.toString())));
      console.log("[deltaSync] Unique fan IDs:", uniqueFanIds);
      const usersDataMap = await this.onlyFansAPI.getUsers(uniqueFanIds);
      console.log("[deltaSync] Raw users data map:", usersDataMap);
      const fanSubscriptionDates = Object.values(usersDataMap).map((user) => {
        console.log("[deltaSync] User:", user);
        const subscriptionData = processUserSubscriptionData$1(user);
        console.log("[deltaSync] Processing user subscription:", {
          userId: user.id,
          subscribedOnData: user.subscribedOnData,
          finalSubscriptionDate: subscriptionData == null ? void 0 : subscriptionData.subscribeDate
        });
        return {
          fanId: user.id.toString(),
          subscriptionDate: subscriptionData == null ? void 0 : subscriptionData.subscribeDate,
          userData: user
        };
      });
      console.log("[deltaSync] Formatted fan subscription dates:", fanSubscriptionDates);
      console.log("[deltaSync] Making upsertFanLikes call with:", {
        numberOfLikes: likes.length,
        numberOfSubscriptionDates: fanSubscriptionDates.length
      });
      const response = await this.networkManager.upsertFanLikes(likes, fanSubscriptionDates);
      console.log("[deltaSync] Upsert response:", response);
      return response;
    } catch (err2) {
      console.error("[deltaSync] Error in upsertLikeBatch:", err2);
      console.error("[deltaSync] Error details:", {
        message: err2.message,
        stack: err2.stack,
        likes: likes == null ? void 0 : likes.length
      });
      throw err2;
    }
  }
  getLastLikeId(likes) {
    if (!likes || likes.length === 0)
      return null;
    return likes[likes.length - 1].id;
  }
  getLastLikeTimestamp(likes) {
    if (!likes || likes.length === 0)
      return null;
    return likes[0].ofTimestamp;
  }
  async processRewardMessages() {
    if (this.aborted)
      return;
    console.log("[deltaSync] Processing reward messages");
    try {
      let offset3 = 0;
      const limit = 100;
      let hasMore = true;
      let totalProcessed = 0;
      while (hasMore && !this.aborted) {
        const response = await this.networkManager.getPendingRewardMessages(limit, offset3);
        const { pendingRewards, hasMore: hasMoreResults } = response.body;
        console.log(
          `[deltaSync] Processing response for rewards batch of length: ${pendingRewards == null ? void 0 : pendingRewards.length}, offset: ${offset3}, hasMore: ${hasMoreResults}`
        );
        if (!pendingRewards || pendingRewards.length === 0) {
          break;
        }
        this.statusBar.showStatusBar("💰 Sending reward messages...", componentId, true);
        const rewardGroups = this.groupRewardsByType(pendingRewards);
        console.log(
          `[deltaSync] Grouped rewards into ${Object.keys(rewardGroups).length} distinct reward types`
        );
        for (const [rewardId, messages] of Object.entries(rewardGroups)) {
          try {
            const processedCount = await this.sendRewardMessageBatch(messages);
            totalProcessed += processedCount;
            this.statusBar.showStatusBar(
              `💰 Sending reward messages... (${totalProcessed} sent)`,
              componentId,
              true
            );
          } catch (error) {
            console.error("[deltaSync] Error sending reward message batch:", error);
            this.statusBar.showStatusBar(
              `🚨 Error sending reward messages, try refreshing the page`,
              componentId,
              false
            );
            setTimeout(() => {
              this.statusBar.hideStatusBar(componentId);
            }, 3e3);
          }
        }
        offset3 += limit;
        hasMore = !!hasMoreResults;
      }
      if (totalProcessed > 0) {
        this.statusBar.showStatusBar(
          `✅ Completed sending ${totalProcessed} reward messages`,
          componentId,
          false
        );
        setTimeout(() => {
          this.statusBar.hideStatusBar(componentId);
        }, 3e3);
      } else {
        this.statusBar.hideStatusBar(componentId);
      }
    } catch (error) {
      console.error("[deltaSync] Error processing reward messages:", error);
      this.statusBar.showStatusBar(
        "🚨 Error sending reward messages, try refreshing the page",
        componentId,
        false
      );
      setTimeout(() => {
        this.statusBar.hideStatusBar(componentId);
      }, 3e3);
      throw error;
    }
  }
  groupRewardsByType(pendingRewards) {
    return pendingRewards.reduce((groups, message) => {
      const rewardId = message.rewardId._id;
      if (!groups[rewardId]) {
        groups[rewardId] = [];
      }
      groups[rewardId].push(message);
      return groups;
    }, {});
  }
  async sendRewardMessageBatch(rewardMessages) {
    if (!rewardMessages || rewardMessages.length === 0)
      return 0;
    const reward = rewardMessages[0].rewardId;
    let successfulCount = 0;
    try {
      if (!reward.message) {
        console.log("[deltaSync] Skipping batch - no message content");
        return 0;
      }
      const fanIds = rewardMessages.map((message) => message.fanId);
      console.log("[deltaSync] Sending batch reward message to fans", {
        numberOfFans: fanIds.length,
        message: reward.message,
        price: reward.price,
        mediaIds: reward.mediaIds
      });
      const queueResult = await this.onlyFansAPI.queueMessage(
        fanIds,
        reward.message,
        reward.price,
        reward.mediaIds
      );
      if (queueResult && !queueResult.error && queueResult.hasError === false && queueResult.isCanceled === false) {
        const confirmationResults = await Promise.all(
          rewardMessages.map(async (message) => {
            try {
              await this.networkManager.confirmRewardMessageSent(message._id);
              return true;
            } catch (error) {
              console.error("[deltaSync] Error confirming reward message sent:", error);
              return false;
            }
          })
        );
        successfulCount = confirmationResults.filter((result) => result).length;
      } else {
        const errorMessage = `🚨 Reward messages failed to send, try refreshing the page`;
        this.statusBar.showStatusBar(errorMessage, componentId, false);
        setTimeout(() => {
          this.statusBar.hideStatusBar(componentId);
        }, 3e3);
      }
      console.log(`[deltaSync] Batch reward message sent to ${fanIds.length} fans`);
      const delay = this.messageDelay !== null ? this.messageDelay : Math.floor(Math.random() * (5e3 - 2e3 + 1)) + 2e3;
      await new Promise((resolve) => setTimeout(resolve, delay));
      return successfulCount;
    } catch (error) {
      console.error(`[deltaSync] Error sending batch reward message:`, error);
      throw error;
    }
  }
}
const useFanLikeSync = () => {
  const subscriptionSettings = Recoil_index_20(subscriptionSettingsAtom);
  const ofUserId = Recoil_index_20(ofUserIdAtom);
  const onlyFansAPI = useOnlyFansAPI();
  const networkManager = useNetworkManager();
  const syncServiceRef = reactExports.useRef(null);
  const previousOfUserId = reactExports.useRef(ofUserId);
  reactExports.useEffect(() => {
    const syncAndProcessRewards = async () => {
      if (previousOfUserId.current !== ofUserId && syncServiceRef.current) {
        console.log(`[deltaSync] Stopping sync for previous ofUserId: ${previousOfUserId.current}`);
        syncServiceRef.current.stopSync();
      }
      syncServiceRef.current = new FanLikeSyncService(onlyFansAPI, networkManager, ofUserId);
      try {
        console.log(
          `[deltaSync] Checking if sync should start: ${JSON.stringify(
            subscriptionSettings
          )}, ofUserId: ${ofUserId}`
        );
        const oldestRewardCreationDate = await shouldStartSync(
          subscriptionSettings,
          ofUserId,
          networkManager
        );
        if (oldestRewardCreationDate) {
          console.log("[deltaSync] Subscription settings available. Starting sync.");
          await syncServiceRef.current.syncFanLikes(subscriptionSettings, oldestRewardCreationDate);
          await syncServiceRef.current.processRewardMessages();
        } else {
          console.log("[deltaSync] Should not start sync. Skipping sync.");
        }
      } catch (error) {
        if (error.name === "AbortError") {
          console.log("[deltaSync] Sync aborted due to ofUserId change");
        } else {
          console.error("[deltaSync] Error in sync and process:", error);
        }
      }
    };
    setTimeout(() => {
      syncAndProcessRewards();
      previousOfUserId.current = ofUserId;
    }, 5e3);
    const intervalId = setInterval(
      () => {
        console.log("[deltaSync] Running periodic sync (30-minute interval)");
        syncAndProcessRewards();
      },
      30 * 60 * 1e3
    );
    return () => {
      if (syncServiceRef.current) {
        syncServiceRef.current.stopSync();
      }
      clearInterval(intervalId);
    };
  }, [ofUserId]);
};
function getEarliestRewardDate(rewards) {
  if (!rewards || rewards.length === 0)
    return null;
  const enabledRewards = rewards.filter((reward) => reward.enabled !== false);
  if (enabledRewards.length === 0)
    return null;
  return enabledRewards.reduce((earliest, reward) => {
    const rewardDate = new Date(reward.createdAt);
    return rewardDate < earliest ? rewardDate : earliest;
  }, /* @__PURE__ */ new Date());
}
async function shouldStartSync(subscriptionSettings, ofUserId, networkManager) {
  if (!subscriptionSettings) {
    console.log("[deltaSync][shouldStartSync] Subscription settings not available. Skipping sync.");
    return false;
  }
  if (!ofUserId) {
    console.log("[deltaSync][shouldStartSync] ofUserId not available. Skipping sync.");
    return false;
  }
  if (!subscriptionSettings.ofCreatorIds || subscriptionSettings.ofCreatorIds.length === 0) {
    console.log(
      "[deltaSync][shouldStartSync] Subscription settings does not have any ofCreatorIds. Skipping sync."
    );
    return false;
  }
  const rewards = await networkManager.getRewards();
  const oldestRewardCreationDate = getEarliestRewardDate(rewards);
  console.log("[deltaSync][shouldStartSync] oldestRewardCreationDate:", oldestRewardCreationDate);
  if (!oldestRewardCreationDate) {
    console.log("[deltaSync][shouldStartSync] No active rewards found. Skipping sync.");
    return false;
  }
  return oldestRewardCreationDate;
}
const FanLikeSyncInjector = () => {
  useFanLikeSync();
  return null;
};
const MessageSendingServiceInjector = () => {
  useMessageSendingService();
  return null;
};
const processUserSubscriptionData = (user) => {
  if (!(user == null ? void 0 : user.subscribedOnData))
    return null;
  const isRenewOn = !!user.subscribedOnData.renewedAt;
  const subscribeDate = new Date(user.subscribedOnData.subscribeAt);
  const subscriptionExpireDate = new Date(user.subscribedOnData.expiredAt);
  const now = /* @__PURE__ */ new Date();
  const todayDate = new Date(Date.UTC(now.getUTCFullYear(), now.getUTCMonth(), now.getUTCDate()));
  const expireDate = new Date(
    Date.UTC(
      subscriptionExpireDate.getUTCFullYear(),
      subscriptionExpireDate.getUTCMonth(),
      subscriptionExpireDate.getUTCDate()
    )
  );
  const isTodayExpirationDate = todayDate.getTime() === expireDate.getTime();
  const daysSinceSubscribe = (now - subscribeDate) / (1e3 * 60 * 60 * 24);
  const isExpired = subscriptionExpireDate < now;
  const isUnsubscribed = isExpired && !(isTodayExpirationDate && isRenewOn);
  return {
    // Data for MessagesLabelInjector
    totalSpend: user.subscribedOnData.totalSumm || 0,
    isUnsubscribed,
    isSubscribed: !isUnsubscribed,
    // If not unsubscribed, they are considered subscribed
    isRenewEnabled: isRenewOn,
    isRenewDisabled: !isRenewOn,
    isNew: !!user.subscribedOnData.subscribeAt && daysSinceSubscribe <= 7,
    // Data for SubscriptionDurationInjector
    expireDate: user.subscribedOnData.expiredAt
  };
};
const MINIMUM_INITIAL_CHATS_TO_FETCH = 20;
const DUMMY_USER_ID = 99999999999;
const REAPPLY_INTERVAL = 500;
const FORCE_REAPPLY_DEBOUNCE = 1e3;
const checkForMissingLabels = () => {
  return new Promise((resolve) => {
    chrome.tabs.query({ active: true, currentWindow: true }, (tabs) => {
      if (tabs[0]) {
        chrome.tabs.sendMessage(tabs[0].id, { type: "checkForMissingLabels" }, (response) => {
          resolve((response == null ? void 0 : response.hasMissingLabels) || false);
        });
      } else {
        resolve(false);
      }
    });
  });
};
const createLtvDataFromUsers = (usersData) => {
  const ltvData = {};
  Object.entries(usersData).forEach(([userId, user]) => {
    const processedData = processUserSubscriptionData(user);
    if (processedData) {
      ltvData[userId] = processedData;
    }
  });
  if (Object.keys(ltvData).length === 0) {
    ltvData[DUMMY_USER_ID] = {};
  }
  return ltvData;
};
const MessagesLabelInjector = () => {
  const isMessagesTabOpen = reactExports.useRef(false);
  const [ltvDataCache, setLtvDataCache] = reactExports.useState({ recent: {} });
  const lastFilterRef = reactExports.useRef("recent");
  const sessionIdRef = reactExports.useRef(0);
  const abortControllerRef = reactExports.useRef(null);
  const userDataCacheRef = reactExports.useRef({});
  const lastAppliedTimestampRef = reactExports.useRef(0);
  const onlyFansAPI = useOnlyFansAPI();
  const { showStatusBar, hideStatusBar } = useStatusBar();
  const ofCreatorId = Recoil_index_20(ofUserIdAtom);
  const chatLabelsEnabled = Recoil_index_20(chatLabelsEnabledSelector);
  const { capture } = useAnalytics();
  const resetAbortController = reactExports.useCallback(() => {
    if (abortControllerRef.current) {
      abortControllerRef.current.abort();
    }
    abortControllerRef.current = new AbortController();
    sessionIdRef.current++;
  }, []);
  const loadCachedLabelData = reactExports.useCallback(async () => {
    try {
      if (!ofCreatorId)
        return;
      const cachedData = await LocalStorageManager.getMessageLabelsCache(ofCreatorId);
      if (cachedData) {
        console.log("[MessagesLabelInjector] Loaded cached label data from storage:", cachedData);
        const currentFilter = lastFilterRef.current;
        setLtvDataCache((prevCache) => ({
          ...prevCache,
          [currentFilter]: {
            ...prevCache[currentFilter] || {},
            ...cachedData
          }
        }));
        Object.entries(cachedData).forEach(([userId, userData]) => {
          userDataCacheRef.current[userId] = userData;
        });
        const newTimestamp = Date.now();
        lastAppliedTimestampRef.current = newTimestamp;
        chrome.tabs.query({ active: true, currentWindow: true }, (tabs) => {
          if (tabs[0]) {
            chrome.tabs.sendMessage(tabs[0].id, {
              type: "injectMessageLabelData",
              messageLabelData: cachedData,
              timestamp: newTimestamp
            });
          }
        });
        capture("chat_labels_loaded", {
          count: Object.keys(cachedData).length,
          creator_id: ofCreatorId
        });
      }
    } catch (error) {
      console.error("[MessagesLabelInjector] Error loading cached label data:", error);
    }
  }, [ofCreatorId, capture]);
  const persistLabelData = reactExports.useCallback(
    async (data) => {
      try {
        if (!ofCreatorId)
          return;
        await LocalStorageManager.setMessageLabelsCache(ofCreatorId, data);
        console.log(
          "[MessagesLabelInjector] Persisted label data to storage for creator:",
          ofCreatorId
        );
        capture("chat_labels_persisted", {
          count: Object.keys(data).length,
          creator_id: ofCreatorId
        });
      } catch (error) {
        console.error("[MessagesLabelInjector] Error persisting label data:", error);
      }
    },
    [ofCreatorId, capture]
  );
  reactExports.useEffect(() => {
    if (ofCreatorId) {
      loadCachedLabelData();
    }
  }, [ofCreatorId, loadCachedLabelData]);
  const updateCacheFromRef = reactExports.useCallback((userIds) => {
    const currentFilter = lastFilterRef.current;
    const cachedData = {};
    userIds.forEach((userId) => {
      if (userDataCacheRef.current[userId]) {
        cachedData[userId] = userDataCacheRef.current[userId];
      }
    });
    if (Object.keys(cachedData).length > 0) {
      console.log(
        "[MessagesLabelInjector] Updating cache from ref data for filter:",
        currentFilter,
        "with cached data:",
        cachedData
      );
      setLtvDataCache((prevCache) => ({
        ...prevCache,
        [currentFilter]: {
          ...prevCache[currentFilter] || {},
          ...cachedData
        }
      }));
    }
  }, []);
  const forceReapplyLabels = reactExports.useCallback(async () => {
    if (!isMessagesTabOpen.current || !chatLabelsEnabled)
      return;
    const hasMissingLabels = await checkForMissingLabels();
    if (!hasMissingLabels) {
      console.log("[MessagesLabelInjector] No missing labels detected, skipping reapply");
      return;
    }
    const currentFilter = lastFilterRef.current;
    const currentCache = ltvDataCache[currentFilter];
    if (currentCache && Object.keys(currentCache).length > 0) {
      console.log(
        "[MessagesLabelInjector] Missing labels detected, force reapplying LTV data from cache for filter:",
        currentFilter
      );
      const cacheCopy = JSON.parse(JSON.stringify(currentCache));
      if (Object.keys(cacheCopy).length === 1) {
        delete cacheCopy[DUMMY_USER_ID];
      }
      const newTimestamp = Date.now();
      lastAppliedTimestampRef.current = newTimestamp;
      chrome.tabs.query({ active: true, currentWindow: true }, (tabs) => {
        if (tabs[0]) {
          chrome.tabs.sendMessage(tabs[0].id, {
            type: "injectMessageLabelData",
            messageLabelData: cacheCopy,
            timestamp: newTimestamp
          });
        }
      });
      capture("chat_labels_reapplied", {
        count: Object.keys(cacheCopy).length,
        filter: currentFilter
      });
    }
  }, [ltvDataCache, chatLabelsEnabled, capture]);
  reactExports.useEffect(() => {
    const checkMessagesTab = () => {
      chrome.tabs.query({ active: true, currentWindow: true }, (tabs) => {
        var _a, _b;
        const currentTab = tabs[0];
        const isMessages = (currentTab == null ? void 0 : currentTab.url) === "https://onlyfans.com/my/chats" || (currentTab == null ? void 0 : currentTab.url) === "https://onlyfans.com/my/chats/" || ((_a = currentTab == null ? void 0 : currentTab.url) == null ? void 0 : _a.startsWith("https://onlyfans.com/my/chats/chat")) || ((_b = currentTab == null ? void 0 : currentTab.url) == null ? void 0 : _b.startsWith("https://onlyfans.com/my/chats/?"));
        if (isMessages !== isMessagesTabOpen.current) {
          isMessagesTabOpen.current = isMessages;
          if (!isMessages) {
            resetAbortController();
          }
        }
      });
    };
    checkMessagesTab();
    chrome.tabs.onUpdated.addListener(checkMessagesTab);
    chrome.tabs.onActivated.addListener(checkMessagesTab);
    return () => {
      chrome.tabs.onUpdated.removeListener(checkMessagesTab);
      chrome.tabs.onActivated.removeListener(checkMessagesTab);
      if (abortControllerRef.current) {
        abortControllerRef.current.abort();
      }
    };
  }, []);
  reactExports.useEffect(() => {
    if (!chatLabelsEnabled) {
      console.log("[MessagesLabelInjector] Chat labels disabled, not applying labels");
      return;
    }
    const currentFilter = lastFilterRef.current;
    const currentCache = ltvDataCache[currentFilter];
    if (currentCache && Object.keys(currentCache).length > 0) {
      console.log(
        "[MessagesLabelInjector] Applying LTV data from cache for filter:",
        currentFilter,
        currentCache
      );
      const cacheCopy = JSON.parse(JSON.stringify(currentCache));
      if (Object.keys(cacheCopy).length === 1) {
        delete cacheCopy[DUMMY_USER_ID];
      }
      const newTimestamp = Date.now();
      lastAppliedTimestampRef.current = newTimestamp;
      persistLabelData(cacheCopy);
      chrome.tabs.query({ active: true, currentWindow: true }, (tabs) => {
        if (tabs[0]) {
          chrome.tabs.sendMessage(tabs[0].id, {
            type: "injectMessageLabelData",
            messageLabelData: cacheCopy,
            timestamp: newTimestamp
          });
        }
      });
      capture("chat_labels_applied", {
        count: Object.keys(cacheCopy).length,
        filter: currentFilter
      });
    }
  }, [ltvDataCache, persistLabelData, chatLabelsEnabled, capture]);
  reactExports.useEffect(() => {
    if (!chatLabelsEnabled)
      return;
    const intervalId = setInterval(() => {
      if (isMessagesTabOpen.current) {
        const timeSinceLastApply = Date.now() - lastAppliedTimestampRef.current;
        if (timeSinceLastApply > FORCE_REAPPLY_DEBOUNCE) {
          console.log("[MessagesLabelInjector] Periodic check to reapply labels");
          forceReapplyLabels();
        }
      }
    }, REAPPLY_INTERVAL);
    const handleVisibilityChange = () => {
      if (document.visibilityState === "visible" && isMessagesTabOpen.current) {
        console.log("[MessagesLabelInjector] Tab became visible, reapplying labels");
        forceReapplyLabels();
      }
    };
    document.addEventListener("visibilitychange", handleVisibilityChange);
    return () => {
      clearInterval(intervalId);
      document.removeEventListener("visibilitychange", handleVisibilityChange);
    };
  }, [forceReapplyLabels, chatLabelsEnabled]);
  const fetchAndCacheLtvData = reactExports.useCallback(
    async (chats, currentSessionId) => {
      if (!chats || chats.length === 0)
        return;
      const userIds = chats.map((chat) => chat.withUser.id.toString());
      console.log("[MessagesLabelInjector] Fetching LTV data for users:", userIds);
      updateCacheFromRef(userIds);
      try {
        const usersData = await onlyFansAPI.getUsers(userIds);
        console.log("[MessagesLabelInjector] Users data:", usersData);
        if (sessionIdRef.current !== currentSessionId) {
          console.log("[MessagesLabelInjector] Session changed, aborting update");
          return;
        }
        const newLtvData = createLtvDataFromUsers(usersData);
        Object.entries(newLtvData).forEach(([userId, userData]) => {
          userDataCacheRef.current[userId] = userData;
        });
        if (sessionIdRef.current === currentSessionId) {
          const currentFilter = lastFilterRef.current;
          console.log(
            "[MessagesLabelInjector] Updating LTV data cache for filter:",
            currentFilter,
            "with new data:",
            newLtvData
          );
          setLtvDataCache((prevCache) => ({
            ...prevCache,
            [currentFilter]: {
              ...prevCache[currentFilter] || {},
              ...newLtvData
            }
          }));
        }
      } catch (error) {
        if (error.name === "AbortError") {
          console.log("[MessagesLabelInjector] Request aborted");
          return;
        }
        console.error("[MessagesLabelInjector] Error fetching LTV data:", error);
      }
    },
    [onlyFansAPI, updateCacheFromRef]
  );
  const handleSwipeoutListMutation = reactExports.useCallback(
    async (data, onlyFansAPI2, previousCache, setLtvDataCache2) => {
      const { previousCount, currentCount, addedIds, allCurrentIds } = data;
      const idsNotInPreviousCache = allCurrentIds.filter((id2) => !previousCache[id2]);
      {
        try {
          updateCacheFromRef(idsNotInPreviousCache);
          console.log(
            "[MessagesLabelInjector] fetching for idsNotInPreviousCache:",
            idsNotInPreviousCache
          );
          const userData = await onlyFansAPI2.getUsers(idsNotInPreviousCache);
          if (userData && Object.keys(userData).length > 0) {
            const newLtvData = createLtvDataFromUsers(userData);
            Object.entries(newLtvData).forEach(([userId, userData2]) => {
              userDataCacheRef.current[userId] = userData2;
            });
            const currentFilter = lastFilterRef.current;
            setLtvDataCache2((prevCache) => ({
              ...prevCache,
              [currentFilter]: {
                ...prevCache[currentFilter] || {},
                ...newLtvData
              }
            }));
          }
        } catch (error) {
          console.error("[MessagesLabelInjector] Error fetching user data:", error);
        }
      }
    },
    [updateCacheFromRef]
  );
  const handleChatsApiCall = reactExports.useCallback(
    async (params) => {
      var _a;
      if (!isMessagesTabOpen.current)
        return;
      try {
        console.log("[MessagesLabelInjector] Handling chats API call with params:", params);
        showStatusBar(
          "🔍 Spicy Toolbox is updating your chat labels - while we do this, what we display may be outdated.",
          "MessagesLabelInjector",
          true
        );
        const currentFilter = params.filter || "recent";
        if (currentFilter !== lastFilterRef.current || ((_a = params.query) == null ? void 0 : _a.length) > 1) {
          console.log(
            "[MessagesLabelInjector] Filter changed from",
            lastFilterRef.current,
            "to",
            currentFilter
          );
          resetAbortController();
          lastFilterRef.current = currentFilter;
          setLtvDataCache((prevCache) => ({
            ...prevCache,
            [currentFilter]: prevCache[currentFilter] || {}
          }));
        }
        const currentSessionId = sessionIdRef.current;
        const isInitialLoad = parseInt(params.offset) === 0;
        console.log(
          "[MessagesLabelInjector][handleChatsApiCall] isInitialLoad:",
          isInitialLoad,
          "params:",
          params
        );
        let chatsResult;
        if (isInitialLoad) {
          const [firstTenChats, secondTenChats] = await Promise.all([
            onlyFansAPI.getChats(
              10,
              0,
              params.skip_users,
              params.filter,
              params.order,
              params.query
            ),
            onlyFansAPI.getChats(
              10,
              10,
              params.skip_users,
              params.filter,
              params.order,
              params.query
            )
          ]);
          chatsResult = {
            list: [...firstTenChats.list, ...secondTenChats.list]
          };
        } else {
          const limit = parseInt(params.limit) || 10;
          chatsResult = await onlyFansAPI.getChats(
            limit,
            parseInt(params.offset) || 0,
            params.skip_users,
            params.filter,
            params.order,
            params.query
          );
        }
        const offsetFromZero = (parseInt(params.limit) || 0) + (parseInt(params.offset) || 0);
        console.log("[MessagesLabelInjector][handleChatsApiCall] offsetFromZero:", offsetFromZero);
        if (!isInitialLoad && offsetFromZero <= MINIMUM_INITIAL_CHATS_TO_FETCH) {
          return;
        }
        console.log(
          `[MessagesLabelInjector][handleChatsApiCall] fetching chats:`,
          chatsResult.list
        );
        if (sessionIdRef.current === currentSessionId) {
          await fetchAndCacheLtvData(chatsResult.list, currentSessionId);
        }
        hideStatusBar("MessagesLabelInjector");
      } catch (error) {
        if (error.name === "AbortError") {
          console.log("[MessagesLabelInjector] Request aborted");
          return;
        }
        console.error("[MessagesLabelInjector] Error handling chats API call:", error);
        hideStatusBar("MessagesLabelInjector");
      }
    },
    [
      isMessagesTabOpen,
      onlyFansAPI,
      fetchAndCacheLtvData,
      showStatusBar,
      hideStatusBar,
      resetAbortController
    ]
  );
  reactExports.useEffect(() => {
    const messageListener = async (request, sender, sendResponse) => {
      if (!chatLabelsEnabled)
        return;
      if (request.type === "messagesListFetched" && request.params) {
        handleChatsApiCall(request.params);
      } else if (request.type === "swipeoutListMutation") {
        console.log("[MessagesLabelInjector] Swipeout list mutation:", request.data);
        const { addedIds, removedIds } = request.data;
        if (addedIds.length === 1 || removedIds.length === 1) {
          showStatusBar(
            "🔍 Spicy Toolbox is updating your chat labels - while we do this, what we display may be outdated.",
            "MessagesLabelInjector",
            true
          );
          await handleSwipeoutListMutation(
            request.data,
            onlyFansAPI,
            ltvDataCache,
            setLtvDataCache
          );
          hideStatusBar("MessagesLabelInjector");
        }
      }
    };
    chrome.runtime.onMessage.addListener(messageListener);
    return () => chrome.runtime.onMessage.removeListener(messageListener);
  }, [onlyFansAPI]);
  reactExports.useEffect(() => {
    console.log("[MessagesLabelInjector] Chat labels enabled changed to:", chatLabelsEnabled);
    if (!chatLabelsEnabled) {
      console.log("[MessagesLabelInjector] Removing all chat labels");
      chrome.tabs.query({ active: true, currentWindow: true }, (tabs) => {
        if (tabs[0]) {
          chrome.tabs.sendMessage(tabs[0].id, {
            type: "removeAllMessageLabels"
          });
        }
      });
    } else {
      const currentFilter = lastFilterRef.current;
      const currentCache = ltvDataCache[currentFilter];
      if (currentCache && Object.keys(currentCache).length > 0) {
        console.log("[MessagesLabelInjector] Reapplying chat labels from cache");
        const cacheCopy = JSON.parse(JSON.stringify(currentCache));
        if (Object.keys(cacheCopy).length === 1) {
          delete cacheCopy[DUMMY_USER_ID];
        }
        const newTimestamp = Date.now();
        lastAppliedTimestampRef.current = newTimestamp;
        chrome.tabs.query({ active: true, currentWindow: true }, (tabs) => {
          if (tabs[0]) {
            chrome.tabs.sendMessage(tabs[0].id, {
              type: "injectMessageLabelData",
              messageLabelData: cacheCopy,
              timestamp: newTimestamp
            });
          }
        });
      }
    }
  }, [chatLabelsEnabled, ltvDataCache]);
  return null;
};
const OFPageStyleInjector = () => {
  const stylesApplied = reactExports.useRef(false);
  const applyMessagesTabStyle = reactExports.useCallback(() => {
    if (stylesApplied.current)
      return;
    console.log("[OFPageStyleInjector] Applying wide message tab style");
    chrome.tabs.query({ active: true, currentWindow: true }, (tabs) => {
      if (!tabs[0])
        return;
      chrome.tabs.sendMessage(tabs[0].id, {
        type: "applyMessagesTabStyle"
      });
      stylesApplied.current = true;
    });
  }, []);
  const removeMessagesTabStyle = reactExports.useCallback(() => {
    if (!stylesApplied.current)
      return;
    console.log("[OFPageStyleInjector] Removing wide message tab style");
    chrome.tabs.query({ active: true, currentWindow: true }, (tabs) => {
      if (!tabs[0])
        return;
      chrome.tabs.sendMessage(tabs[0].id, {
        type: "removeMessagesTabStyle"
      });
      stylesApplied.current = false;
    });
  }, []);
  const checkUrl = reactExports.useCallback(() => {
    chrome.tabs.query({ active: true, currentWindow: true }, (tabs) => {
      const currentTab = tabs[0];
      if (!(currentTab == null ? void 0 : currentTab.url))
        return;
      const isMessagesPage = currentTab.url.includes("/my/chats/");
      if (isMessagesPage) {
        applyMessagesTabStyle();
      } else {
        removeMessagesTabStyle();
      }
    });
  }, [applyMessagesTabStyle, removeMessagesTabStyle]);
  reactExports.useEffect(() => {
    checkUrl();
    const handleTabUpdated = (tabId, changeInfo, tab2) => {
      if (changeInfo.url || changeInfo.status === "complete") {
        if (changeInfo.url) {
          const isLeavingMessagesPage = stylesApplied.current && !changeInfo.url.includes("/my/chats/");
          if (isLeavingMessagesPage) {
            removeMessagesTabStyle();
          }
        }
        checkUrl();
      }
    };
    const handleTabActivated = () => {
      checkUrl();
    };
    chrome.tabs.onUpdated.addListener(handleTabUpdated);
    chrome.tabs.onActivated.addListener(handleTabActivated);
    return () => {
      chrome.tabs.onUpdated.removeListener(handleTabUpdated);
      chrome.tabs.onActivated.removeListener(handleTabActivated);
    };
  }, [checkUrl, removeMessagesTabStyle]);
  return null;
};
const suggestionsCache = /* @__PURE__ */ new Map();
const pendingRequests = /* @__PURE__ */ new Map();
const filterMessages = (messages) => {
  return messages.map((message) => ({
    // Base fields (always included)
    text: message.text,
    ofCreatorId: message.fromUser.id,
    // Additional contextual fields
    createdAt: message.createdAt,
    mediaCount: message.mediaCount,
    price: message.price,
    lockedText: message.lockedText,
    isTip: message.isTip,
    isFromQueue: message.isFromQueue
  }));
};
const useReplySuggestion = () => {
  const { getReplySuggestions } = useNetworkManager();
  const { getChatMessagesMultiPage, clearFirstPageCache } = useOnlyFansAPI();
  const ofUserId = Recoil_index_20(ofUserIdAtom);
  const subscriptionSettingsId = Recoil_index_20(subscriptionSettingsIdSelector);
  const aiRepliesEnabled = Recoil_index_20(aiRepliesEnabledSelector);
  const currentChatIdRef = reactExports.useRef(null);
  const checkChatIdTimeoutRef = reactExports.useRef(null);
  const lastFetchTimeRef = reactExports.useRef(0);
  reactExports.useEffect(() => {
    console.log("[useReplySuggestion] AI replies enabled:", aiRepliesEnabled);
  }, [aiRepliesEnabled]);
  const setChatSuggestions = reactExports.useCallback(
    (suggestions, ofRecipientId) => {
      if (!aiRepliesEnabled) {
        console.log("[useReplySuggestion] AI replies disabled, not setting chat suggestions");
        return;
      }
      chrome.tabs.query({ active: true, currentWindow: true }, (tabs) => {
        chrome.tabs.sendMessage(tabs[0].id, {
          type: "setChatSuggestions",
          suggestions
        });
      });
      notifyReplyStatus("COMPLETE", ofRecipientId);
    },
    [aiRepliesEnabled]
  );
  const notifyReplyStatus = reactExports.useCallback(
    (status, chatId) => {
      if (!aiRepliesEnabled) {
        console.log("[useReplySuggestion] AI replies disabled, not notifying reply status");
        return;
      }
      chrome.tabs.query({ active: true, currentWindow: true }, (tabs) => {
        if (status === "IN_PROGRESS") {
          chrome.tabs.sendMessage(tabs[0].id, {
            type: "setChatSuggestions",
            suggestions: []
          });
        }
        chrome.tabs.sendMessage(tabs[0].id, {
          type: "replyGenerationStatus",
          status,
          chatId
        });
      });
    },
    [aiRepliesEnabled]
  );
  const fetchAndFilterMessages = reactExports.useCallback(
    async (ofUserId2, ofRecipientId, replyToMessage = null, force = false) => {
      if (!aiRepliesEnabled) {
        console.log("[useReplySuggestion] AI replies disabled, not fetching messages");
        return;
      }
      try {
        if (!subscriptionSettingsId) {
          console.error("[useReplySuggestion] No subscription settings found");
          notifyReplyStatus("ERROR", ofRecipientId);
          return;
        }
        const now = Date.now();
        if (!force && now - lastFetchTimeRef.current < 2e3) {
          console.log("[useReplySuggestion] Rate limiting fetch, skipping");
          return;
        }
        lastFetchTimeRef.current = now;
        notifyReplyStatus("IN_PROGRESS", ofRecipientId);
        const response = await getChatMessagesMultiPage(ofRecipientId, 5, force);
        const messages = filterMessages(response.list);
        console.log(
          `[useReplySuggestion] Fetched ${messages.length} messages for chat ${ofRecipientId}`
        );
        let effectiveReplyToMessage = replyToMessage;
        if (!effectiveReplyToMessage && messages.length > 0) {
          const lastFanMessage = messages.find((msg) => msg.ofCreatorId != ofUserId2);
          console.log("[useReplySuggestion] Last fan message:", lastFanMessage);
          const isLastMessageFromFan = messages.length > 0 && messages[0].ofCreatorId != ofUserId2;
          if (lastFanMessage && isLastMessageFromFan) {
            effectiveReplyToMessage = lastFanMessage.text;
            console.log(
              "[useReplySuggestion] Automatically using last fan message as reply context:",
              effectiveReplyToMessage.substring(0, 50) + (effectiveReplyToMessage.length > 50 ? "..." : "")
            );
          } else {
            if (!isLastMessageFromFan) {
              console.log(
                "[useReplySuggestion] Last message is not from fan, leaving reply context blank"
              );
            } else {
              console.log(
                "[useReplySuggestion] No fan messages found, leaving reply context blank"
              );
            }
            effectiveReplyToMessage = null;
          }
        }
        const cacheKey = effectiveReplyToMessage ? `${ofUserId2}-${ofRecipientId}-reply-${effectiveReplyToMessage}` : `${ofUserId2}-${ofRecipientId}-${messages.map((m2) => m2.text).join("~")}`;
        if (!effectiveReplyToMessage && !force && suggestionsCache.has(cacheKey)) {
          console.log("[useReplySuggestion] Using cached suggestions");
          const suggestions = suggestionsCache.get(cacheKey);
          setChatSuggestions(suggestions, ofRecipientId);
          return suggestions;
        }
        if (pendingRequests.has(cacheKey)) {
          console.log("[useReplySuggestion] Request in progress, waiting...");
          const suggestions = await pendingRequests.get(cacheKey);
          setChatSuggestions(suggestions, ofRecipientId);
          return suggestions;
        }
        console.log("[useReplySuggestion] Creating new request");
        const requestPromise = (async () => {
          try {
            const { suggestions } = await getReplySuggestions(
              messages,
              ofRecipientId,
              false,
              effectiveReplyToMessage
            );
            suggestionsCache.set(cacheKey, suggestions);
            setChatSuggestions(suggestions, ofRecipientId);
            pendingRequests.delete(cacheKey);
            return suggestions;
          } catch (error) {
            console.error("[useReplySuggestion] Error generating suggestions:", error);
            notifyReplyStatus("ERROR", ofRecipientId);
            pendingRequests.delete(cacheKey);
            throw error;
          }
        })();
        pendingRequests.set(cacheKey, requestPromise);
        return requestPromise;
      } catch (error) {
        console.error("[useReplySuggestion] Error in message fetching:", error);
        notifyReplyStatus("ERROR", ofRecipientId);
        throw error;
      }
    },
    [
      getChatMessagesMultiPage,
      notifyReplyStatus,
      setChatSuggestions,
      subscriptionSettingsId,
      getReplySuggestions,
      aiRepliesEnabled
    ]
  );
  reactExports.useEffect(() => {
    if (!aiRepliesEnabled) {
      console.log("[useReplySuggestion] AI replies disabled, not setting up injection listener");
      return () => {
      };
    }
    const handleInjectionComplete = (message) => {
      if (message.type === "CHAT_BAR_INJECTION_COMPLETE") {
        console.log(
          "[useReplySuggestion] Chat bar injection complete with chatId:",
          message.chatId
        );
        console.log("[useReplySuggestion] Generating chat suggestions for chatId:", message.chatId);
        currentChatIdRef.current = message.chatId;
        fetchAndFilterMessages(ofUserId, message.chatId);
      }
    };
    chrome.runtime.onMessage.addListener(handleInjectionComplete);
    return () => {
      chrome.runtime.onMessage.removeListener(handleInjectionComplete);
    };
  }, [fetchAndFilterMessages, ofUserId, aiRepliesEnabled]);
  reactExports.useEffect(() => {
    if (!aiRepliesEnabled) {
      console.log("[useReplySuggestion] AI replies disabled, not setting up chat ID listener");
      return () => {
      };
    }
    const checkChatId = () => {
      if (checkChatIdTimeoutRef.current) {
        clearTimeout(checkChatIdTimeoutRef.current);
      }
      checkChatIdTimeoutRef.current = setTimeout(() => {
        chrome.tabs.query({ active: true, currentWindow: true }, (tabs) => {
          var _a;
          const currentTab = tabs[0];
          const chatUrlRegex = /https:\/\/onlyfans\.com\/my\/chats\/(chat\/(\d+))/;
          const match2 = (_a = currentTab == null ? void 0 : currentTab.url) == null ? void 0 : _a.match(chatUrlRegex);
          if (match2) {
            const newChatId = match2[2];
            if (newChatId && newChatId !== currentChatIdRef.current) {
              console.log(
                "[useReplySuggestion] Chat ID changed from",
                currentChatIdRef.current,
                "to",
                newChatId
              );
              if (currentChatIdRef.current) {
                const keysToDelete = [];
                for (const key of suggestionsCache.keys()) {
                  if (key.includes(`-${currentChatIdRef.current}-`)) {
                    keysToDelete.push(key);
                  }
                }
                keysToDelete.forEach((key) => suggestionsCache.delete(key));
                console.log(
                  `[useReplySuggestion] Cleared ${keysToDelete.length} cached suggestions for previous chat`
                );
              }
              currentChatIdRef.current = newChatId;
              fetchAndFilterMessages(ofUserId, newChatId);
            }
          }
        });
      }, 300);
    };
    checkChatId();
    const handleTabUpdate = (tabId, changeInfo, tab2) => {
      if (changeInfo.url && tab2.active) {
        checkChatId();
      }
    };
    chrome.tabs.onUpdated.addListener(handleTabUpdate);
    chrome.tabs.onActivated.addListener(checkChatId);
    return () => {
      if (checkChatIdTimeoutRef.current) {
        clearTimeout(checkChatIdTimeoutRef.current);
      }
      chrome.tabs.onUpdated.removeListener(handleTabUpdate);
      chrome.tabs.onActivated.removeListener(checkChatId);
    };
  }, [fetchAndFilterMessages, ofUserId, aiRepliesEnabled]);
  reactExports.useEffect(() => {
    if (!aiRepliesEnabled) {
      console.log("[useReplySuggestion] AI replies disabled, not setting up regenerate listener");
      return () => {
      };
    }
    const handleRegenerateSuggestions = (message) => {
      if (message.type === "REGENERATE_SUGGESTIONS" && message.chatId) {
        if (!aiRepliesEnabled) {
          console.log("[useReplySuggestion] AI replies disabled, not regenerating suggestions");
          return;
        }
        console.log(
          "[useReplySuggestion] Regenerating suggestions for specific message:",
          message.replyToMessage
        );
        fetchAndFilterMessages(ofUserId, message.chatId, message.replyToMessage, true);
      }
    };
    chrome.runtime.onMessage.addListener(handleRegenerateSuggestions);
    return () => {
      chrome.runtime.onMessage.removeListener(handleRegenerateSuggestions);
    };
  }, [fetchAndFilterMessages, ofUserId, aiRepliesEnabled]);
  reactExports.useEffect(() => {
    if (!aiRepliesEnabled) {
      console.log("[useReplySuggestion] AI replies disabled, not setting up new message listener");
      return () => {
      };
    }
    const handleNewMessage = (message) => {
      if (message.type === "NEW_MESSAGE_DETECTED" && message.chatId) {
        console.log("[useReplySuggestion] New message detected in chat:", message.chatId);
        clearFirstPageCache(message.chatId);
        console.log(`[useReplySuggestion] Cleared first page cache for chat ${message.chatId}`);
        if (message.chatId === currentChatIdRef.current) {
          setTimeout(() => {
            fetchAndFilterMessages(ofUserId, message.chatId, null, true);
          }, 500);
        }
      }
    };
    chrome.runtime.onMessage.addListener(handleNewMessage);
    return () => {
      chrome.runtime.onMessage.removeListener(handleNewMessage);
    };
  }, [fetchAndFilterMessages, ofUserId, clearFirstPageCache, aiRepliesEnabled]);
  return {};
};
const ShortcutBarInjector = () => {
  const [currentChatId, setCurrentChatId] = reactExports.useState(null);
  const emojiSettings = Recoil_index_20(emojiSettingsSelector);
  const templateSettings = Recoil_index_20(templateSettingsSelector);
  const { capture } = useAnalytics();
  useReplySuggestion();
  const injectChatShortcutCarousel = reactExports.useCallback(
    (emojis, height, templates, emojiBarEnabled, templateBarEnabled, currentChatId2) => {
      chrome.tabs.query({ active: true, currentWindow: true }, (tabs) => {
        console.log(
          "[ShortcutBarInjector] injectChatShortcutCarousel",
          emojis,
          height,
          templates,
          emojiBarEnabled,
          templateBarEnabled,
          currentChatId2
        );
        chrome.tabs.sendMessage(tabs[0].id, {
          type: "injectChatShortcutCarousel",
          emojis,
          height,
          templates,
          emojiBarEnabled,
          templateBarEnabled,
          currentChatId: currentChatId2
        });
        capture("shortcut_bar_injected", {
          type: "chat",
          emoji_count: (emojis == null ? void 0 : emojis.length) || 0,
          template_count: (templates == null ? void 0 : templates.length) || 0,
          emoji_enabled: emojiBarEnabled,
          template_enabled: templateBarEnabled,
          chat_id: currentChatId2
        });
      });
    },
    [capture]
  );
  const injectHomeShortcutCarousel = reactExports.useCallback((emojis, templates) => {
    chrome.tabs.query({ active: true, currentWindow: true }, (tabs) => {
      console.log("[ShortcutBarInjector] injectHomeShortcutCarousel", emojis, templates);
      chrome.tabs.sendMessage(tabs[0].id, {
        type: "injectHomeShortcutCarousel",
        emojis,
        templates
      });
      capture("shortcut_bar_injected", {
        type: "home",
        emoji_count: (emojis == null ? void 0 : emojis.length) || 0,
        template_count: (templates == null ? void 0 : templates.length) || 0
      });
    });
  }, [capture]);
  const checkChatId = reactExports.useCallback(() => {
    chrome.tabs.query({ active: true, currentWindow: true }, (tabs) => {
      var _a;
      const currentTab = tabs[0];
      const chatUrlRegex = /https:\/\/onlyfans\.com\/my\/chats\/(chat\/(\d+)|send)/;
      const match2 = (_a = currentTab == null ? void 0 : currentTab.url) == null ? void 0 : _a.match(chatUrlRegex);
      if (match2) {
        const chatIdMatch = match2[1].match(/\d+/);
        const newChatId = chatIdMatch ? chatIdMatch[0] : null;
        setCurrentChatId(newChatId);
        const templateBarEnabled = templateSettings == null ? void 0 : templateSettings.templateBarEnabled;
        const emojiBarEnabled = emojiSettings == null ? void 0 : emojiSettings.emojiBarEnabled;
        if (templateBarEnabled || emojiBarEnabled) {
          console.log("[ShortcutBarInjector][checkChatId] injecting chat shortcuts");
          injectChatShortcutCarousel(
            (emojiSettings == null ? void 0 : emojiSettings.emojisForToolbar) || [],
            templateBarEnabled ? "144px" : void 0,
            (templateSettings == null ? void 0 : templateSettings.folders) || [],
            emojiBarEnabled,
            templateBarEnabled,
            newChatId
          );
        }
      }
    });
  }, [currentChatId, emojiSettings, templateSettings, injectChatShortcutCarousel]);
  const checkHomeOrCreatePost = reactExports.useCallback(() => {
    chrome.tabs.query({ active: true, currentWindow: true }, (tabs) => {
      const currentTab = tabs[0];
      const homeUrlRegex = /https:\/\/onlyfans\.com\/?$/;
      const newPostUrlRegex = /https:\/\/onlyfans\.com\/posts\/create/;
      if (homeUrlRegex.test(currentTab == null ? void 0 : currentTab.url) || newPostUrlRegex.test(currentTab == null ? void 0 : currentTab.url)) {
        if (emojiSettings == null ? void 0 : emojiSettings.emojiBarEnabled) {
          console.log(
            "[ShortcutBarInjector][checkHomeOrCreatePost] injecting home shortcuts: ",
            emojiSettings.emojisForToolbar,
            emojiSettings.emojiBarEnabled
          );
          injectHomeShortcutCarousel(emojiSettings.emojisForToolbar);
        }
      }
    });
  }, [emojiSettings, templateSettings, injectHomeShortcutCarousel]);
  reactExports.useEffect(() => {
    checkChatId();
    checkHomeOrCreatePost();
    chrome.tabs.onUpdated.addListener(checkChatId);
    chrome.tabs.onActivated.addListener(checkChatId);
    chrome.tabs.onUpdated.addListener(checkHomeOrCreatePost);
    chrome.tabs.onActivated.addListener(checkHomeOrCreatePost);
    return () => {
      chrome.tabs.onUpdated.removeListener(checkChatId);
      chrome.tabs.onActivated.removeListener(checkChatId);
      chrome.tabs.onUpdated.removeListener(checkHomeOrCreatePost);
      chrome.tabs.onActivated.removeListener(checkHomeOrCreatePost);
    };
  }, [checkChatId, checkHomeOrCreatePost]);
  return null;
};
const SubscriptionDurationInjector = () => {
  const [currentChatId, setCurrentChatId] = reactExports.useState(null);
  const onlyFansAPI = useOnlyFansAPI();
  const { capture } = useAnalytics();
  const injectSubscriptionDuration = reactExports.useCallback(
    async (userId) => {
      var _a, _b, _c;
      if (!userId)
        return;
      try {
        console.log("[SubscriptionDurationInjector] Fetching user data for:", userId);
        const userData = await onlyFansAPI.getUsers([userId]);
        console.log("[SubscriptionDurationInjector] User data:", userData);
        if (userData && userData[userId]) {
          const user = userData[userId];
          console.log("[SubscriptionDurationInjector] User data:", user);
          const subscriptionData = processUserSubscriptionData(user);
          console.log("[SubscriptionDurationInjector] Subscription data:", subscriptionData);
          console.log(
            "[SubscriptionDurationInjector] User subscribedOnData:",
            user == null ? void 0 : user.subscribedOnData
          );
          if (subscriptionData) {
            let duration = null;
            if ((_a = user.subscribedOnData) == null ? void 0 : _a.subscribeAt) {
              const subscribedDate = new Date(user.subscribedOnData.subscribeAt);
              const now = /* @__PURE__ */ new Date();
              const daysDiff = Math.floor((now - subscribedDate) / (1e3 * 60 * 60 * 24));
              duration = daysDiff === 0 ? "<1 day" : `${daysDiff} days`;
            }
            const subscriptionInfo = {
              isSubscribed: subscriptionData.isSubscribed,
              expireDate: subscriptionData.expireDate,
              duration: ((_b = user.subscribedOnData) == null ? void 0 : _b.subscribedOnDuration) || ((_c = user.subscribedOnData) == null ? void 0 : _c.duration) || duration || "<1 day"
            };
            chrome.tabs.query({ active: true, currentWindow: true }, (tabs) => {
              chrome.tabs.sendMessage(tabs[0].id, {
                type: "injectSubscriptionDuration",
                subscriptionInfo,
                userId
              });
            });
            capture("subscription_duration_injected", {
              user_id: userId,
              is_subscribed: subscriptionData.isSubscribed,
              duration: subscriptionInfo.duration
            });
          } else {
            chrome.tabs.query({ active: true, currentWindow: true }, (tabs) => {
              chrome.tabs.sendMessage(tabs[0].id, {
                type: "removeSubscriptionDuration",
                userId
              });
            });
          }
        } else {
          chrome.tabs.query({ active: true, currentWindow: true }, (tabs) => {
            chrome.tabs.sendMessage(tabs[0].id, {
              type: "removeSubscriptionDuration",
              userId
            });
          });
        }
      } catch (error) {
        console.error("[SubscriptionDurationInjector] Error fetching user data:", error);
      }
    },
    [onlyFansAPI, currentChatId, capture]
  );
  const checkChatId = reactExports.useCallback(() => {
    chrome.tabs.query({ active: true, currentWindow: true }, (tabs) => {
      const currentTab = tabs[0];
      if (!(currentTab == null ? void 0 : currentTab.url))
        return;
      const chatUrlRegex = /https:\/\/onlyfans\.com\/my\/chats\/(chat\/(\d+))/;
      const mainChatsUrlRegex = /https:\/\/onlyfans\.com\/my\/chats\/?$/;
      const match2 = currentTab.url.match(chatUrlRegex);
      const isMainChatsPage = mainChatsUrlRegex.test(currentTab.url);
      if (match2) {
        const newChatId = match2[2];
        if (newChatId !== currentChatId) {
          console.log("[SubscriptionDurationInjector] New chat ID:", newChatId);
          setCurrentChatId(newChatId);
          injectSubscriptionDuration(newChatId);
        }
      } else if (isMainChatsPage) {
        console.log("[SubscriptionDurationInjector] On main chats page");
        if (currentChatId) {
          setCurrentChatId(null);
          chrome.tabs.query({ active: true, currentWindow: true }, (tabs2) => {
            chrome.tabs.sendMessage(tabs2[0].id, {
              type: "removeSubscriptionDuration",
              userId: currentChatId
            });
          });
        }
      }
    });
  }, [currentChatId, injectSubscriptionDuration]);
  reactExports.useEffect(() => {
    checkChatId();
  }, []);
  reactExports.useEffect(() => {
    chrome.tabs.onUpdated.addListener(checkChatId);
    chrome.tabs.onActivated.addListener(checkChatId);
    return () => {
      chrome.tabs.onUpdated.removeListener(checkChatId);
      chrome.tabs.onActivated.removeListener(checkChatId);
    };
  }, [checkChatId]);
  return null;
};
const VaultMediaLabelInjector = () => {
  const onlyFansAPI = useOnlyFansAPI();
  const { showStatusBar, hideStatusBar } = useStatusBar();
  const { capture } = useAnalytics();
  const chatIdRef = reactExports.useRef(null);
  const injectVaultMediaLabels = reactExports.useCallback(
    async (chatId, list = "all") => {
      const loadAllMedia = async (chatId2, list2) => {
        let allMedia = [];
        let offset3 = 0;
        const limit = 20;
        let hasMore = true;
        let nextLastId = null;
        while (hasMore) {
          try {
            const response = await onlyFansAPI.getMediaWithPurchaseStatus(
              chatId2,
              limit,
              null,
              list2,
              nextLastId
            );
            allMedia = [...allMedia, ...response.list];
            chrome.tabs.query({ active: true, currentWindow: true }, (tabs) => {
              console.log("[VaultMediaLabelInjector] Sending media data batch to content script");
              chrome.tabs.sendMessage(tabs[0].id, {
                type: "injectVaultMediaLabels",
                media: allMedia
              });
            });
            nextLastId = response.nextLastId;
            if (nextLastId) {
              offset3 += limit;
            } else {
              hideStatusBar("VaultMediaLabelInjector");
              hasMore = false;
            }
          } catch (error) {
            console.error("Error fetching vault media batch:", error);
            showStatusBar(
              "🚨 Error loading vault media. Please try again.",
              "VaultMediaLabelInjector",
              false
            );
            setTimeout(() => hideStatusBar("VaultMediaLabelInjector"), 3e3);
            hasMore = false;
          }
        }
        console.log(`[getMessagesWithMedia] Loaded ${allMedia.length} total media items`, allMedia);
        capture("vault_media_labels_loaded", {
          chat_id: chatId2,
          media_count: allMedia.length,
          list_type: list2
        });
        return allMedia;
      };
      try {
        showStatusBar(
          "🔍 Spicy Toolbox is updating your vault labels - while we do this, what we display may be outdated.",
          "VaultMediaLabelInjector",
          true
        );
        await loadAllMedia(chatId, list);
      } catch (error) {
        console.error("Error in media loading process:", error);
        showStatusBar(
          "🚨 Error loading vault media. Please try again.",
          "VaultMediaLabelInjector",
          false
        );
      }
    },
    [onlyFansAPI, showStatusBar, hideStatusBar, capture]
  );
  reactExports.useEffect(() => {
    console.log("[VaultMediaLabelInjector] Setting up message listener");
    const messageListener = (request, sender, sendResponse) => {
      var _a, _b;
      if (request.type === "vaultModalOpened") {
        console.log("[VaultMediaLabelInjector] Vault modal opened, chat ID:", request.chatId);
        chatIdRef.current = request.chatId;
        injectVaultMediaLabels(request.chatId, "all");
      }
      if (request.type === "vaultMediaFetched" && ((_a = request.params) == null ? void 0 : _a.list) && ((_b = request.params) == null ? void 0 : _b.list) !== "all") {
        console.log("[VaultMediaLabelInjector] Vault media fetched, params:", request.params);
        if (chatIdRef.current)
          ;
      }
    };
    chrome.runtime.onMessage.addListener(messageListener);
    return () => {
      chrome.runtime.onMessage.removeListener(messageListener);
    };
  }, [injectVaultMediaLabels, showStatusBar]);
  return null;
};
const InjectorWrapper = ({ children }) => {
  const planType = Recoil_index_20(planTypeSelector);
  const isFreePlan = planType === "free";
  const freePlanInjectors = /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(ChargebackSyncInjector, {}),
    /* @__PURE__ */ jsxRuntimeExports.jsx(ChargebackWarningInjector, {})
  ] });
  if (isFreePlan) {
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
      freePlanInjectors,
      children
    ] });
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    freePlanInjectors,
    /* @__PURE__ */ jsxRuntimeExports.jsx(FanLikeSyncInjector, {}),
    /* @__PURE__ */ jsxRuntimeExports.jsx(MessagesLabelInjector, {}),
    /* @__PURE__ */ jsxRuntimeExports.jsx(ShortcutBarInjector, {}),
    /* @__PURE__ */ jsxRuntimeExports.jsx(VaultMediaLabelInjector, {}),
    /* @__PURE__ */ jsxRuntimeExports.jsx(MessageSendingServiceInjector, {}),
    /* @__PURE__ */ jsxRuntimeExports.jsx(SubscriptionDurationInjector, {}),
    /* @__PURE__ */ jsxRuntimeExports.jsx(ChatInfoPanelInjector, {}),
    /* @__PURE__ */ jsxRuntimeExports.jsx(OFPageStyleInjector, {}),
    children
  ] });
};
class AutoFollowExpiredFansService {
  constructor(onlyFansAPI, networkManager, bannerManager, ofUserId, setOfAPIOffset = null, setFollowExpiredFansCounter = null) {
    this.onlyFansAPI = onlyFansAPI;
    this.networkManager = networkManager;
    this.bannerManager = bannerManager;
    this.ofUserId = ofUserId;
    this.setOfAPIOffset = setOfAPIOffset;
    this.setFollowExpiredFansCounter = setFollowExpiredFansCounter;
    this.aborted = false;
    this.isProcessing = false;
    this.MAX_RETRIES = 3;
  }
  stopSync() {
    this.aborted = true;
    this.isProcessing = false;
    this.bannerManager.hideBanner();
  }
  async initializeCounterValues() {
    try {
      const counter = await this.networkManager.getFollowExpiredFansCounter();
      console.log(`[AutoFollowExpiredFansService] counter received`, counter);
      if (counter) {
        const lastSync = counter.lastFollowSyncAt ? new Date(counter.lastFollowSyncAt) : null;
        const fiveMinutesAgo = new Date(Date.now() - 5 * 60 * 1e3);
        const lastSyncIsMoreThanFiveMinutesAgo = !lastSync || lastSync < fiveMinutesAgo;
        if (lastSyncIsMoreThanFiveMinutesAgo) {
          return {
            canStart: true,
            counter: counter.count,
            ofAPIOffset: counter.ofAPIOffset || 0
          };
        } else {
          console.log(
            "[AutoFollowExpiredFansService] Another client is currently syncing fans, waiting..."
          );
          return { canStart: false };
        }
      }
      return { canStart: false };
    } catch (error) {
      console.error("[AutoFollowExpiredFansService] Failed to initialize counter values:", error);
      return { canStart: false };
    }
  }
  async findOrCreateExpiredFansList(retryCount = 0) {
    if (!this.ofUserId) {
      return { success: false, listId: null };
    }
    try {
      let offset3 = 0;
      const limit = 10;
      let foundList = null;
      while (true) {
        try {
          const response = await this.onlyFansAPI.getLists(limit, offset3);
          const lists = response.list || [];
          if (lists.length === 0) {
            break;
          }
          foundList = lists.find((list) => list.name === "Expired fans");
          if (foundList) {
            console.log(
              '[AutoFollowExpiredFansService] Found existing "Expired fans" list for creator:',
              this.ofUserId,
              foundList
            );
            return { success: true, listId: foundList.id };
          }
          offset3 += limit;
        } catch (error) {
          console.error("[AutoFollowExpiredFansService] Error getting lists:", error);
          if (retryCount < this.MAX_RETRIES) {
            console.log(
              `[AutoFollowExpiredFansService] Retry attempt ${retryCount + 1}/${this.MAX_RETRIES}`
            );
            const delayMs = Math.pow(2, retryCount) * 1e3;
            await new Promise((resolve) => setTimeout(resolve, delayMs));
            return this.findOrCreateExpiredFansList(retryCount + 1);
          }
          throw error;
        }
      }
      if (!foundList) {
        console.log(
          '[AutoFollowExpiredFansService] Creating new "Expired fans" list for creator:',
          this.ofUserId
        );
        try {
          const newList = await this.onlyFansAPI.createList("Expired fans");
          if (newList.error) {
            throw new Error(newList.error);
          }
          return { success: true, listId: newList.id };
        } catch (createError) {
          console.error("[AutoFollowExpiredFansService] Error creating list:", createError);
          if (retryCount < this.MAX_RETRIES) {
            console.log(
              `[AutoFollowExpiredFansService] Retry attempt ${retryCount + 1}/${this.MAX_RETRIES}`
            );
            const delayMs = Math.pow(2, retryCount) * 1e3;
            await new Promise((resolve) => setTimeout(resolve, delayMs));
            return this.findOrCreateExpiredFansList(retryCount + 1);
          }
          throw createError;
        }
      }
    } catch (error) {
      console.error(
        "[AutoFollowExpiredFansService] Error finding/creating list for creator:",
        this.ofUserId,
        error
      );
      return { success: false, listId: null };
    }
  }
  getRandomInterval() {
    {
      return Math.floor(Math.random() * (5e3 - 2e3 + 1) + 4e3);
    }
  }
  async startAutoFollow(subscriptionSettingsId, expiredFansListId, initialOffset) {
    if (!this.ofUserId) {
      console.log("[AutoFollowExpiredFansService] No creator ID, skipping auto-follow");
      return;
    }
    console.log(
      "[AutoFollowExpiredFansService] fetch latest subscribers with offset",
      initialOffset
    );
    if (this.isProcessing)
      return;
    this.isProcessing = true;
    try {
      if (!expiredFansListId) {
        console.error("[AutoFollowExpiredFansService] No list ID available for current creator");
        this.isProcessing = false;
        this.bannerManager.hideBanner();
        return;
      }
      console.log("[AutoFollowExpiredFansService] Marking sync as started by updating timestamp");
      await this.updateCounter(initialOffset, false);
      await this.fetchAndProcessBatch(
        subscriptionSettingsId,
        expiredFansListId,
        initialOffset,
        false,
        // isRecentSync
        null
        // lastSyncTimestamp
      );
    } catch (error) {
      console.error("[AutoFollowExpiredFansService] Failed to setup list:", error);
      this.isProcessing = false;
    }
  }
  async fetchAndProcessBatch(subscriptionSettingsId, expiredFansListId, currentBatchStartOffset, isRecentSync = false, lastSyncTimestamp = null) {
    if (this.aborted || !this.ofUserId) {
      console.log("[AutoFollowExpiredFansService] Aborted or creator changed, stopping");
      this.isProcessing = false;
      this.bannerManager.hideBanner();
      return;
    }
    try {
      console.log(
        "[AutoFollowExpiredFansService] fetch expired subscribers with offset",
        currentBatchStartOffset,
        isRecentSync ? "(recent sync mode)" : "(historical sync mode)"
      );
      const response = await this.onlyFansAPI.getLatestExpiredSubscribers(
        currentBatchStartOffset > 0 ? currentBatchStartOffset + 1 : 0
        // offset
      );
      const expiredSubscribers = response.list || [];
      console.log(
        "[AutoFollowExpiredFansService] Found expired subscribers:",
        expiredSubscribers.length,
        "out of original",
        response.originalLength,
        "at offset",
        currentBatchStartOffset
      );
      let filteredSubscribers = expiredSubscribers;
      if (isRecentSync && lastSyncTimestamp) {
        const lastSyncDate = new Date(lastSyncTimestamp);
        filteredSubscribers = expiredSubscribers.filter((subscriber) => {
          var _a;
          if ((_a = subscriber.subscribedOnData) == null ? void 0 : _a.expiredAt) {
            const expiredDate = new Date(subscriber.subscribedOnData.expiredAt);
            const isRecentlyExpired = expiredDate >= lastSyncDate;
            if (!isRecentlyExpired) {
              console.log(
                `[AutoFollowExpiredFansService] Skipping user ${subscriber.id} - expired ${expiredDate.toISOString()} before last sync ${lastSyncDate.toISOString()}`
              );
            }
            return isRecentlyExpired;
          }
          return true;
        });
        if (filteredSubscribers.length === 0 && expiredSubscribers.length > 0) {
          console.log(
            "[AutoFollowExpiredFansService] Recent sync complete - all remaining subscribers expired before last sync"
          );
          this.bannerManager.hideBanner();
          this.isProcessing = false;
          return;
        }
        console.log(
          `[AutoFollowExpiredFansService] Recent sync filtered: ${filteredSubscribers.length}/${expiredSubscribers.length} subscribers are recent`
        );
      }
      const userIds = filteredSubscribers.map((subscriber) => subscriber.id);
      if (response.originalLength === 0) {
        if (!isRecentSync) {
          if (currentBatchStartOffset === 0 || response.hasMore) {
            console.log(
              "[AutoFollowExpiredFansService] No results in first batch, trying again with offset 20"
            );
            await new Promise((resolve) => setTimeout(resolve, this.getRandomInterval()));
            await this.fetchAndProcessBatch(
              subscriptionSettingsId,
              expiredFansListId,
              10,
              false,
              lastSyncTimestamp
            );
            return;
          }
          console.log(
            "[AutoFollowExpiredFansService] Historical sync complete, starting recent sync..."
          );
          await this.startRecentSync(subscriptionSettingsId, expiredFansListId);
          return;
        } else {
          console.log("[AutoFollowExpiredFansService] Recent sync complete, stopping");
          this.bannerManager.hideBanner();
          this.isProcessing = false;
          return;
        }
      }
      if (!isRecentSync && !response.hasMore && response.originalLength > 0) {
        console.log(
          "[AutoFollowExpiredFansService] Historical sync will complete after this batch, preparing for recent sync..."
        );
      }
      const nextOffset = currentBatchStartOffset + 10;
      this.bannerManager.showBanner(
        isRecentSync ? "🔄 Syncing recent expired fans..." : "➡️ Following expired fans..."
      );
      if (userIds.length === 0 || response.hasMore) {
        try {
          const updateResult = await this.updateCounter(
            nextOffset,
            false
            // Don't increment follow counter
          );
          console.log(
            "[AutoFollowExpiredFansService] Offset updated for empty batch:",
            updateResult
          );
        } catch (error) {
          console.error(
            "[AutoFollowExpiredFansService] Failed to update offset for empty batch:",
            error
          );
          return {
            counter: null,
            ofAPIOffset: null
          };
        }
      }
      if (userIds.length === 0) {
        console.log(
          "[AutoFollowExpiredFansService] No users to process, updating offset to prevent loop..."
        );
      } else {
        await this.processUsers(userIds, expiredFansListId, currentBatchStartOffset);
        console.log(
          "[AutoFollowExpiredFansService] Batch processing complete, offset updated per user"
        );
      }
      if (!this.aborted && this.ofUserId) {
        if (!isRecentSync && !response.hasMore) {
          console.log(
            "[AutoFollowExpiredFansService] Historical sync complete, starting recent sync..."
          );
          await new Promise((resolve) => setTimeout(resolve, this.getRandomInterval()));
          await this.startRecentSync(subscriptionSettingsId, expiredFansListId);
        } else {
          console.log("[AutoFollowExpiredFansService] Adding delay before next batch...");
          await new Promise((resolve) => setTimeout(resolve, this.getRandomInterval()));
          await this.fetchAndProcessBatch(
            subscriptionSettingsId,
            expiredFansListId,
            nextOffset,
            isRecentSync,
            lastSyncTimestamp
          );
        }
      }
      return {
        counter: null,
        ofAPIOffset: nextOffset
      };
    } catch (error) {
      console.error("[AutoFollowExpiredFansService] Error fetching expired subscribers:", error);
      this.isProcessing = false;
      throw error;
    }
  }
  async processUsers(userIds, expiredFansListId, currentBatchStartOffset) {
    const results = {
      counter: null,
      ofAPIOffset: null
    };
    for (const userId of userIds) {
      if (this.aborted || !this.ofUserId) {
        console.log("[AutoFollowExpiredFansService] Aborted or creator changed, stopping");
        this.isProcessing = false;
        this.bannerManager.hideBanner();
        return results;
      }
      let followSuccessful = true;
      try {
        const addToListSuccess = await this.addUserToList(userId, expiredFansListId);
        if (!addToListSuccess) {
          followSuccessful = false;
        }
        const followUserSuccess = await this.followUser(userId);
        if (!followUserSuccess) {
          followSuccessful = false;
        }
        const currentItemOffset = currentBatchStartOffset + userIds.indexOf(userId) + 1;
        const counterResult = await this.updateCounter(currentItemOffset, followSuccessful);
        results.counter = counterResult.counter;
        results.ofAPIOffset = counterResult.ofAPIOffset;
        if (currentBatchStartOffset > 0) {
          console.log(
            "[AutoFollowExpiredFansService] Adding delay between users, currentBatchStartOffset: ",
            currentBatchStartOffset
          );
          await new Promise((resolve) => setTimeout(resolve, this.getRandomInterval()));
        } else {
          console.log(
            "[AutoFollowExpiredFansService] No delay between users, currentBatchStartOffset: ",
            currentBatchStartOffset
          );
        }
      } catch (error) {
        console.error(
          `[AutoFollowExpiredFansService] Following cancelled. Error following user ${userId}:`,
          error
        );
        break;
      }
    }
    return results;
  }
  async addUserToList(userId, expiredFansListId) {
    var _a, _b;
    try {
      const addToExpiredFansListResponse = await this.onlyFansAPI.addUsersToList(
        expiredFansListId,
        userId
      );
      this.bannerManager.showBanner(`➡️ Following expired fans... added ${userId} to list`);
      console.log(
        `[AutoFollowExpiredFansService] Added user to Expired fans list: listId: ${expiredFansListId}, userId: ${userId}, response: ${JSON.stringify(addToExpiredFansListResponse, null, 2)}`
      );
      if ((_b = (_a = addToExpiredFansListResponse.error) == null ? void 0 : _a.message) == null ? void 0 : _b.length) {
        let displayName = userId;
        const errorMessage = addToExpiredFansListResponse.error.message;
        const nameMatch = errorMessage.match(/Unable to add (.+?) to Expired fans/);
        if (nameMatch && nameMatch[1]) {
          displayName = nameMatch[1];
        }
        this.bannerManager.showBanner(
          `Skipping user ${displayName} - already in Expired fans list`,
          "onlyFansApi"
        );
        return false;
      }
      return true;
    } catch (listError) {
      console.error(
        `[AutoFollowExpiredFansService] Failed to add user ${userId} to Expired fans list:`,
        listError
      );
      return false;
    }
  }
  async followUser(userId) {
    var _a, _b, _c, _d;
    try {
      console.log("[AutoFollowExpiredFansService] attempting to follow user", userId);
      const followResponse = await this.onlyFansAPI.followUser(userId);
      console.log("[AutoFollowExpiredFansService] follow completed for user", userId);
      if ((_b = (_a = followResponse.error) == null ? void 0 : _a.message) == null ? void 0 : _b.length) {
        if ((_d = (_c = followResponse.error) == null ? void 0 : _c.message) == null ? void 0 : _d.includes("Daily limit exceeded")) {
          console.log(
            "[AutoFollowExpiredFansService] Daily limit exceeded, waiting 1 hour before retrying"
          );
          this.bannerManager.showBanner(
            `Daily follow fans limit reached, waiting before resuming`,
            "onlyFansApi"
          );
          await new Promise((resolve) => setTimeout(resolve, 60 * 60 * 1e3));
        } else {
          this.bannerManager.showBanner(
            `Skipping following user ${userId} - user already followed`,
            "onlyFansApi"
          );
        }
        return false;
      }
      return true;
    } catch (followError) {
      console.error(`[AutoFollowExpiredFansService] Failed to follow user ${userId}:`, followError);
      return false;
    }
  }
  async updateCounter(currentItemOffset, followSuccessful) {
    var _a, _b;
    try {
      const response = await this.networkManager.incrementFollowExpiredFansCounter(
        currentItemOffset,
        followSuccessful
      );
      console.log(
        `[AutoFollowExpiredFansService] Counter updated${followSuccessful ? "" : " (offset only)"}:`,
        response
      );
      const result = {
        counter: (_a = response == null ? void 0 : response.counter) == null ? void 0 : _a.count,
        ofAPIOffset: ((_b = response == null ? void 0 : response.counter) == null ? void 0 : _b.ofAPIOffset) || 0
      };
      if (this.setOfAPIOffset && result.ofAPIOffset !== null) {
        this.setOfAPIOffset(result.ofAPIOffset);
        console.log(
          "[AutoFollowExpiredFansService] UI offset atom updated to:",
          result.ofAPIOffset
        );
      }
      if (this.setFollowExpiredFansCounter && result.counter !== null && result.counter !== void 0) {
        this.setFollowExpiredFansCounter(result.counter);
        console.log("[AutoFollowExpiredFansService] UI counter atom updated to:", result.counter);
      }
      return result;
    } catch (error) {
      console.error(
        `[AutoFollowExpiredFansService] Failed to ${followSuccessful ? "increment" : "update"} counter:`,
        error
      );
      return { counter: null, ofAPIOffset: null };
    }
  }
  async startRecentSync(subscriptionSettingsId, expiredFansListId) {
    try {
      const counter = await this.networkManager.getFollowExpiredFansCounter();
      const lastSyncTimestamp = counter == null ? void 0 : counter.lastFollowSyncAt;
      if (!lastSyncTimestamp) {
        console.log(
          "[AutoFollowExpiredFansService] No lastFollowSyncAt found, skipping recent sync"
        );
        this.bannerManager.hideBanner();
        this.isProcessing = false;
        return;
      }
      console.log(
        "[AutoFollowExpiredFansService] Starting recent sync from current date back to:",
        lastSyncTimestamp
      );
      await this.fetchAndProcessBatch(
        subscriptionSettingsId,
        expiredFansListId,
        0,
        true,
        lastSyncTimestamp
      );
    } catch (error) {
      console.error("[AutoFollowExpiredFansService] Error starting recent sync:", error);
      this.bannerManager.hideBanner();
      this.isProcessing = false;
    }
  }
}
const useAutoFollowExpiredFans_v2 = (enabled, subscriptionSettingsId) => {
  console.log("[useAutoFollowExpiredFans_v2][enabled]", enabled, subscriptionSettingsId);
  const { ofUserId, expiredFansListId, ofAPIOffset } = Recoil_index_20(synchronizedCreatorSelector);
  const { showBanner, hideBanner } = useInAppBanner();
  const setFollowExpiredFansCounter = Recoil_index_24(followExpiredFansCounterAtom);
  const setOfAPIOffset = Recoil_index_24(ofAPIOffsetAtom);
  const setExpiredFansListId = Recoil_index_24(expiredFansListIdAtom);
  const [isInitialized, setIsInitialized] = reactExports.useState(false);
  const [serviceInstance, setServiceInstance] = reactExports.useState(null);
  const onlyFansAPI = useOnlyFansAPI();
  const networkManager = useNetworkManager();
  const bannerManager = { showBanner, hideBanner };
  reactExports.useEffect(() => {
    const initialize = async () => {
      if (!enabled || !ofUserId) {
        setIsInitialized(false);
        setExpiredFansListId(null);
        if (serviceInstance) {
          serviceInstance.stopSync();
        }
        return;
      }
      const service = new AutoFollowExpiredFansService(
        onlyFansAPI,
        networkManager,
        bannerManager,
        ofUserId,
        setOfAPIOffset,
        setFollowExpiredFansCounter
      );
      setServiceInstance(service);
      const counterResult = await service.initializeCounterValues();
      if (!counterResult.canStart) {
        console.error(
          "[useAutoFollowExpiredFans_v2] Not starting fan sync because counter returns canStart: false"
        );
        setIsInitialized(false);
        return;
      }
      if (counterResult.counter !== void 0) {
        setFollowExpiredFansCounter(counterResult.counter);
      }
      if (counterResult.ofAPIOffset !== void 0) {
        setOfAPIOffset(counterResult.ofAPIOffset);
      }
      let currentRetryCount = 0;
      let listResult = null;
      while (currentRetryCount < 3) {
        listResult = await service.findOrCreateExpiredFansList();
        if (listResult.success) {
          break;
        }
        currentRetryCount++;
        console.log(
          `[useAutoFollowExpiredFans_v2] List initialization failed, attempt ${currentRetryCount}/3`
        );
        if (currentRetryCount < 3) {
          const delayMs = Math.pow(2, currentRetryCount - 1) * 1e3;
          await new Promise((resolve) => setTimeout(resolve, delayMs));
        }
      }
      if (listResult && listResult.success && listResult.listId) {
        setExpiredFansListId(listResult.listId);
      }
      setIsInitialized(listResult && listResult.success);
      if (listResult && !listResult.success) {
        console.error("[useAutoFollowExpiredFans_v2] Failed to initialize after 3 retries");
      }
    };
    setTimeout(() => {
      initialize();
    }, 5e3);
    return () => {
      setIsInitialized(false);
      if (serviceInstance) {
        serviceInstance.stopSync();
      }
    };
  }, [ofUserId, enabled, subscriptionSettingsId]);
  reactExports.useEffect(() => {
    if (!isInitialized || !serviceInstance) {
      console.log(
        `[useAutoFollowExpiredFans_v2] Not initialized yet, skipping auto-follow setup: isInitialized: ${isInitialized} serviceInstance: ${serviceInstance}`
      );
      return;
    }
    const startAutoFollowProcess = async () => {
      if (enabled && ofUserId && expiredFansListId) {
        console.log("[useAutoFollowExpiredFans_v2] Starting auto-follow");
        await serviceInstance.startAutoFollow(
          subscriptionSettingsId,
          expiredFansListId,
          ofAPIOffset
        );
      } else {
        console.log("[useAutoFollowExpiredFans_v2] disabled");
        serviceInstance.stopSync();
      }
    };
    startAutoFollowProcess();
    const intervalId = setInterval(
      () => {
        console.log("[useAutoFollowExpiredFans_v2] Running periodic check (15-minute interval)");
        if (enabled && ofUserId && expiredFansListId) {
          startAutoFollowProcess();
        }
      },
      15 * 60 * 1e3
    );
    return () => {
      clearInterval(intervalId);
      if (serviceInstance) {
        serviceInstance.stopSync();
      }
    };
  }, [
    enabled,
    ofUserId,
    subscriptionSettingsId,
    expiredFansListId,
    isInitialized,
    serviceInstance
  ]);
};
const websiteOriginAtom = Recoil_index_8({
  key: "websiteOriginState",
  default: {
    site: "www.spicyblocklist.com",
    timestamp: (/* @__PURE__ */ new Date()).toISOString()
  }
});
const ConfirmCreatorAddedView = ({ onDismiss }) => {
  var _a, _b, _c;
  const ofUserId = Recoil_index_20(ofUserIdAtom);
  const { getUserData } = useOnlyFansAPI();
  const [creatorInfo, setCreatorInfo] = reactExports.useState(null);
  const websiteOrigin = Recoil_index_20(websiteOriginAtom);
  const fetchedUserIdRef = reactExports.useRef(null);
  const [showSecondStep, setShowSecondStep] = reactExports.useState(false);
  reactExports.useEffect(() => {
    if (!ofUserId || fetchedUserIdRef.current === ofUserId)
      return;
    fetchedUserIdRef.current = ofUserId;
    let isMounted = true;
    const fetchCreatorInfo = async () => {
      let attempts = 0;
      const maxAttempts = 3;
      while (attempts < maxAttempts && isMounted) {
        try {
          const userData = await getUserData(ofUserId);
          if (isMounted) {
            console.log(`[SpicyToolboxEnabledView] creatorInfo for ${ofUserId}:`, userData);
            setCreatorInfo(userData);
            break;
          }
        } catch (error) {
          attempts++;
          console.error(
            `[SpicyToolboxEnabledView] Error fetching creator info (attempt ${attempts}/${maxAttempts}):`,
            error
          );
          if (attempts < maxAttempts && isMounted) {
            await new Promise((resolve) => setTimeout(resolve, 1e3));
          }
        }
      }
    };
    fetchCreatorInfo();
    return () => {
      isMounted = false;
    };
  }, [ofUserId, getUserData]);
  const handleDismiss = () => {
    if (onDismiss) {
      onDismiss();
    }
  };
  const handleContinue = () => {
    setShowSecondStep(true);
  };
  const isSpicyBlocklist = (_a = websiteOrigin == null ? void 0 : websiteOrigin.site) == null ? void 0 : _a.includes("spicyblocklist");
  return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "bg-white/90 flex min-h-screen w-full items-center justify-center backdrop-blur-xl", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex w-full flex-col items-center", children: [
    showSecondStep && /* @__PURE__ */ jsxRuntimeExports.jsxs(
      "button",
      {
        onClick: () => setShowSecondStep(false),
        className: "absolute left-7 top-5 flex items-center text-gray-600 hover:text-gray-900",
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "svg",
            {
              className: "mr-2 h-5 w-5",
              fill: "none",
              strokeLinecap: "round",
              strokeLinejoin: "round",
              strokeWidth: "2",
              viewBox: "0 0 24 24",
              stroke: "currentColor",
              children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M10 19l-7-7m0 0l7-7m-7 7h18" })
            }
          ),
          "Back"
        ]
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "bg-white mx-4 mb-8 mt-8 w-full max-w-5xl px-8 md:px-20", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "justify-s flex max-w-4xl flex-col items-center space-y-10", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("h1", { className: "text-2xl font-bold", children: "Spicy Toolbox 🌶️" }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex flex-col items-center space-y-3", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "mb-6 flex w-full max-w-xl items-center justify-center", children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "w-full max-w-xl", children: /* @__PURE__ */ jsxRuntimeExports.jsx(FeatureCarousel, { showBlocklistFeatures: !showSecondStep && isSpicyBlocklist }) }) }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex flex-col items-center space-y-3", children: !showSecondStep ? /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs("h2", { className: "text-center text-2xl font-bold", children: [
              isSpicyBlocklist ? "Yay! Automatic chargeback protection is enabled for" : "Yay! Spicy Toolbox is enabled for",
              " ",
              (creatorInfo == null ? void 0 : creatorInfo.username) ? `@${creatorInfo == null ? void 0 : creatorInfo.username}` : "this creator page",
              " ✅"
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-center text-sm italic text-gray-500", children: isSpicyBlocklist ? "You'll see a warning when chatting with someone with a chargeback history" : "Click 'Explore Spicy Toolbox' below to explore all the helpful tools I've built to help creators earn more 💕" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "mt-2 text-center text-sm italic text-gray-500", children: isSpicyBlocklist ? /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "font-bold", children: "Want to enable scam protection on a linked page?" }),
              " ",
              "Just switch to that page, and open Spicy Toolbox to link it and get free scam protection 💜"
            ] }) : /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "font-bold", children: "Want to use Spicy Toolbox on a linked page?" }),
              " ",
              "Just switch to that page and open Spicy Toolbox to link an additional creator page 💜"
            ] }) })
          ] }) : /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { className: "text-center text-2xl font-bold", children: "Enjoy some other goodies for free 🥰" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-center text-sm italic text-gray-500", children: "Check out all the helpful tools I've built to help creators earn more 💕" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "mt-2 text-center text-sm italic text-gray-500", children: "Try them free for a month, if you enjoy them you can subscribe after the free trial ends." }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-center text-sm font-bold italic text-gray-500", children: "The scam protection features will always remain 100% free!" })
          ] }) })
        ] })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "mt-10 w-full self-center", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
        "button",
        {
          onClick: ((_b = websiteOrigin == null ? void 0 : websiteOrigin.site) == null ? void 0 : _b.includes("spicyblocklist")) && !showSecondStep ? handleContinue : handleDismiss,
          className: "text-white w-full rounded-md bg-gradient-to-r from-purple-500 to-indigo-500 py-3 font-semibold hover:opacity-90",
          children: ((_c = websiteOrigin == null ? void 0 : websiteOrigin.site) == null ? void 0 : _c.includes("spicyblocklist")) && !showSecondStep ? "Continue" : "Explore Spicy Toolbox 🌶️"
        }
      ) })
    ] })
  ] }) });
};
const ReferralCreatorNotAddedView = ({
  creatorInfo,
  onAddCreator,
  onLogout,
  isAddingCreator,
  errorMessage
}) => {
  var _a, _b;
  const [showTeamMessage, setShowTeamMessage] = reactExports.useState(false);
  const [price, setPrice] = reactExports.useState(null);
  const [duration, setDuration] = reactExports.useState("month");
  const [isInitializing, setIsInitializing] = reactExports.useState(false);
  const [error, setError] = reactExports.useState("");
  const { getPrice, createSubscriptionSettings } = useNetworkManager();
  const subscriptionSettings = Recoil_index_20(subscriptionSettingsAtom);
  const websiteOrigin = Recoil_index_20(websiteOriginAtom);
  const isSpicyToolbox = (_a = websiteOrigin == null ? void 0 : websiteOrigin.site) == null ? void 0 : _a.includes("spicytoolbox");
  reactExports.useEffect(() => {
    if (!subscriptionSettings)
      return;
    const fetchPrice = async () => {
      try {
        const priceData = await getPrice();
        if (priceData.shouldShowPrice) {
          setPrice(priceData.unitPrice);
          setDuration(priceData.duration);
        } else {
          setPrice(null);
          setDuration(null);
        }
      } catch (error2) {
        console.error("Error fetching price:", error2);
      }
    };
    fetchPrice();
  }, [subscriptionSettings == null ? void 0 : subscriptionSettings._id, getPrice]);
  const handleJoinTeamClick = () => {
    setShowTeamMessage(true);
  };
  const handleBackClick = () => {
    setShowTeamMessage(false);
  };
  const handleLinkCreator = async () => {
    console.log("[BlocklistCreatorNotAddedView] handleLinkCreator called", {
      hasSubscriptionSettings: !!subscriptionSettings,
      creatorInfo
    });
    if (subscriptionSettings) {
      console.log(
        "[BlocklistCreatorNotAddedView] Subscription settings already exist, calling onAddCreator directly"
      );
      onAddCreator();
      return;
    }
    console.log(
      "[BlocklistCreatorNotAddedView] No subscription settings found, creating new settings"
    );
    setIsInitializing(true);
    setError("");
    try {
      console.log("[BlocklistCreatorNotAddedView] Calling createSubscriptionSettings API");
      const response = await createSubscriptionSettings();
      console.log("[BlocklistCreatorNotAddedView] createSubscriptionSettings response:", response);
      if (response.status !== 200) {
        console.error(
          "[BlocklistCreatorNotAddedView] Error creating subscription settings:",
          response
        );
        setError("Failed to initialize your account. Please try again.");
        setIsInitializing(false);
        return;
      }
      console.log(
        "[BlocklistCreatorNotAddedView] Successfully created subscription settings, calling onAddCreator"
      );
      onAddCreator(response.body._id);
    } catch (error2) {
      console.error("[BlocklistCreatorNotAddedView] Error initializing subscription:", error2);
      console.error("[BlocklistCreatorNotAddedView] Error details:", {
        message: error2.message,
        stack: error2.stack,
        name: error2.name
      });
      setError("Something went wrong. Please try again later.");
    } finally {
      setIsInitializing(false);
      console.log("[BlocklistCreatorNotAddedView] Finished handleLinkCreator execution");
    }
  };
  const getButtonText = () => {
    if (isInitializing || isAddingCreator)
      return "Linking creator...";
    const baseText = (creatorInfo == null ? void 0 : creatorInfo.username) ? `Link @${creatorInfo.username} to Spicy Toolbox` : "Link creator to Spicy Toolbox";
    if (price) {
      return `${baseText} (+$${price.toFixed(2)}/${duration})`;
    }
    return baseText;
  };
  if (showTeamMessage) {
    return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "bg-white flex h-full w-full flex-col overflow-y-auto", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "w-full max-w-2xl self-center rounded-lg p-9", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "mb-8 flex flex-col items-center", children: /* @__PURE__ */ jsxRuntimeExports.jsx("h1", { className: "text-center text-2xl font-bold", children: "Spicy Toolbox 🌶️" }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs(
        "button",
        {
          onClick: handleBackClick,
          className: "absolute left-8 top-8 flex items-center text-gray-600 hover:text-gray-900",
          children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "svg",
              {
                className: "mr-2 h-5 w-5",
                fill: "none",
                strokeLinecap: "round",
                strokeLinejoin: "round",
                strokeWidth: "2",
                viewBox: "0 0 24 24",
                stroke: "currentColor",
                children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M10 19l-7-7m0 0l7-7m-7 7h18" })
              }
            ),
            "Back"
          ]
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "mb-6 flex items-center justify-center px-20", children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "w-full max-w-xl", children: /* @__PURE__ */ jsxRuntimeExports.jsx(FeatureCarousel, { showBlocklistFeatures: !isSpicyToolbox }) }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "mb-7 text-center", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { className: "mb-2 text-xl font-bold", children: "Request Team Access" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-sm italic text-gray-500", children: "Please ask your team admin to add you to the team using the email you used to sign up. After you're added by your team admin, refresh this page." })
      ] })
    ] }) });
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "bg-white flex h-full w-full flex-col overflow-y-auto", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "w-full max-w-2xl self-center rounded-lg p-9", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "invisible absolute left-8 top-8 flex items-center", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        "svg",
        {
          className: "mr-2 h-5 w-5",
          fill: "none",
          strokeLinecap: "round",
          strokeLinejoin: "round",
          strokeWidth: "2",
          viewBox: "0 0 24 24",
          stroke: "currentColor",
          children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M10 19l-7-7m0 0l7-7m-7 7h18" })
        }
      ),
      "Back"
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "mb-8 flex flex-col items-center", children: /* @__PURE__ */ jsxRuntimeExports.jsx("h1", { className: "text-center text-2xl font-bold", children: "Spicy Toolbox 🌶️" }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      "div",
      {
        className: `${isSpicyToolbox ? "mb-4" : ""} flex h-fit items-center justify-center px-20`,
        children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "w-full max-w-xl", children: /* @__PURE__ */ jsxRuntimeExports.jsx(FeatureCarousel, { showBlocklistFeatures: !isSpicyToolbox }) })
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "mb-6 text-center", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { className: "mb-2 text-xl font-bold", children: ((_b = subscriptionSettings == null ? void 0 : subscriptionSettings.ofCreatorIds) == null ? void 0 : _b.length) >= 1 ? `Add ${(creatorInfo == null ? void 0 : creatorInfo.username) ? `@${creatorInfo.username}` : "this creator"} to Spicy Toolbox! 🔗` : `Link ${(creatorInfo == null ? void 0 : creatorInfo.username) ? `@${creatorInfo.username}` : "this creator"} to get started! 🔗` }),
      errorMessage && !errorMessage.includes("not subscribed") ? /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "-mb-4 mt-3 text-sm text-red-500", children: errorMessage }) : /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
        isSpicyToolbox ? /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex flex-col items-center space-y-1", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-sm italic text-gray-500", children: "Click below to start using Spicy Toolbox on this creator page." }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-sm italic text-gray-500", children: "You can disable Spicy Toolbox on your creator page at any time." })
        ] }) : /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-sm italic text-gray-500", children: "We'll let you know when someone in your chat has a chargeback history - whether it's with you or with another creator using Spicy Toolbox." }),
        error && /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "-mb-4 mt-1 text-sm text-red-500", children: error })
      ] })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "mx-auto flex w-fit flex-col gap-3", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        "button",
        {
          onClick: handleLinkCreator,
          disabled: isInitializing || isAddingCreator,
          className: `text-white w-full rounded-md bg-ofBlue-spicy px-5 py-2 font-medium transition ${isInitializing || isAddingCreator ? "cursor-not-allowed" : "hover:opacity-90"}`,
          children: getButtonText()
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        "button",
        {
          onClick: handleJoinTeamClick,
          className: "w-full rounded-md border border-gray-300 px-5 py-2 font-medium transition hover:bg-gray-100",
          children: "Join an existing team"
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        "button",
        {
          onClick: onLogout,
          className: "w-full rounded-md border border-gray-300 px-5 py-2 font-medium transition hover:bg-gray-100",
          children: "Logout"
        }
      )
    ] })
  ] }) });
};
const CreatorNotAddedView = (props) => {
  var _a, _b;
  const websiteOrigin = Recoil_index_20(websiteOriginAtom);
  const ofUserId = Recoil_index_20(ofUserIdAtom);
  const { getUserData } = useOnlyFansAPI();
  const [creatorInfo, setCreatorInfo] = reactExports.useState(null);
  const [isLoadingCreator, setIsLoadingCreator] = reactExports.useState(true);
  const fetchedUserIdRef = reactExports.useRef(null);
  const isSpicyBlocklist = (_a = websiteOrigin == null ? void 0 : websiteOrigin.site) == null ? void 0 : _a.includes("spicyblocklist");
  const isSpicyToolbox = (_b = websiteOrigin == null ? void 0 : websiteOrigin.site) == null ? void 0 : _b.includes("spicytoolbox");
  reactExports.useEffect(() => {
    if (!ofUserId || fetchedUserIdRef.current === ofUserId)
      return;
    fetchedUserIdRef.current = ofUserId;
    let isMounted = true;
    const fetchCreatorInfo = async () => {
      setIsLoadingCreator(true);
      let attempts = 0;
      const maxAttempts = 3;
      while (attempts < maxAttempts && isMounted) {
        try {
          const userData = await getUserData(ofUserId);
          if (isMounted) {
            console.log(`[CreatorNotAddedView] creatorInfo for ${ofUserId}:`, userData);
            setCreatorInfo(userData);
            break;
          }
        } catch (error) {
          attempts++;
          console.error(
            `[CreatorNotAddedView] Error fetching creator info (attempt ${attempts}/${maxAttempts}):`,
            error
          );
          if (attempts < maxAttempts && isMounted) {
            await new Promise((resolve) => setTimeout(resolve, 1e3));
          }
        }
      }
      if (isMounted) {
        setIsLoadingCreator(false);
      }
    };
    fetchCreatorInfo();
    return () => {
      isMounted = false;
    };
  }, [ofUserId]);
  if (isSpicyBlocklist) {
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      ReferralCreatorNotAddedView,
      {
        ...props,
        creatorInfo,
        isLoadingCreator,
        subtext: "We’ll let you know when someone in your chat has a chargeback history - whether it’s with you or with another creator using Spicy Toolbox."
      }
    );
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    ReferralCreatorNotAddedView,
    {
      ...props,
      creatorInfo,
      isLoadingCreator,
      isSpicyToolbox
    }
  );
};
const LoadingProgressPepper = ({ subtext, errorMessage }) => {
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex flex-col items-center justify-center text-2xl font-semibold space-y-5", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "relative text-6xl animate-bounce mb-1", children: "🌶️" }),
      subtext && /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: subtext })
    ] }),
    errorMessage && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "font-normal italic text-gray-500 text-base", children: errorMessage })
  ] });
};
const LoadingView = () => {
  return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex h-full w-full items-center justify-center p-10 xl:p-16", children: /* @__PURE__ */ jsxRuntimeExports.jsx(LoadingProgressPepper, { subtext: "Loading your account..." }) });
};
const OnlyFansLoginRequiredView = ({ onLogout }) => {
  return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex h-full w-full  p-10 xl:p-16", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex w-full flex-col items-center justify-center gap-4", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      LoadingProgressPepper,
      {
        subtext: "Login to OnlyFans to use Spicy Toolbox!",
        errorMessage: /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: "You need to be logged in to OnlyFans to use Spicy Toolbox." }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "mt-2", children: "If you're already logged in, refresh the page or log out and log back in to continue." })
        ] })
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex flex-col gap-4", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      "button",
      {
        onClick: onLogout,
        className: "rounded-md border border-gray-300 px-4 py-2 font-medium transition-colors duration-300 hover:bg-gray-100",
        children: "Logout"
      }
    ) })
  ] }) });
};
const SubscriptionSettingsLoader = ({ children }) => {
  var _a;
  const ofUserId = Recoil_index_20(ofUserIdAtom);
  Recoil_index_20(websiteOriginAtom);
  const [subscriptionSettings, setSubscriptionSettings] = Recoil_index_22(subscriptionSettingsAtom);
  const isLastSeenActiveTab = Recoil_index_20(lastSeenActiveTabAtom);
  const { getSubscriptionSettings, updateSubscriptionSettings } = useNetworkManager();
  const [isLoading, setIsLoading] = reactExports.useState(true);
  const [errorMessage, setErrorMessage] = reactExports.useState("");
  const [isAddingCreator, setIsAddingCreator] = reactExports.useState(false);
  const [showConfirmCreatorAddedView, setShowConfirmCreatorAddedView] = reactExports.useState(false);
  const setIsLoggedIn = Recoil_index_24(isLoggedInAtom);
  const hasLoadedRef = reactExports.useRef(false);
  const loadingRequestRef = reactExports.useRef(false);
  const checkConfirmCreatorAddedView = reactExports.useCallback(
    async (subscriptionSettings2) => {
      var _a2;
      if (((_a2 = subscriptionSettings2 == null ? void 0 : subscriptionSettings2.ofCreatorIds) == null ? void 0 : _a2.includes(ofUserId)) && !isLoading) {
        const hasExplored = await LocalStorageManager.getConfirmCreatorAddedDismissed() || false;
        const createdAtDate = (subscriptionSettings2 == null ? void 0 : subscriptionSettings2.createdAt) instanceof Date ? subscriptionSettings2 == null ? void 0 : subscriptionSettings2.createdAt : new Date(subscriptionSettings2 == null ? void 0 : subscriptionSettings2.createdAt);
        const oneDayAgo = new Date(Date.now() - 1e3 * 60 * 60 * 24);
        const isNewUser = createdAtDate > oneDayAgo;
        console.log(
          `[SubscriptionSettingsLoader] hasExplored: ${hasExplored}, isNewUser: ${isNewUser}, subscriptionSettings.createdAt: ${createdAtDate}, comparison: ${oneDayAgo}`
        );
        return !hasExplored && isNewUser;
      }
      return false;
    },
    [ofUserId, isLoading]
  );
  reactExports.useEffect(() => {
    if (subscriptionSettings) {
      checkConfirmCreatorAddedView(subscriptionSettings).then((shouldShow) => {
        setShowConfirmCreatorAddedView(shouldShow);
      });
    }
  }, [subscriptionSettings, checkConfirmCreatorAddedView]);
  const loadSubscriptionSettings = reactExports.useCallback(
    async (isReload = false) => {
      if (!ofUserId || loadingRequestRef.current || !isLoading && !isReload && hasLoadedRef.current)
        return;
      loadingRequestRef.current = true;
      console.log(
        `[SubscriptionSettingsLoader][DEBUG] Loading subscription settings for ${ofUserId}, isLoading: ${isLoading}`
      );
      try {
        console.log(`[SubscriptionSettingsLoader] Fetching settings for user ${ofUserId}`);
        const response = await getSubscriptionSettings();
        console.log(`[SubscriptionSettingsLoader] Got response:`, response);
        if (response.status >= 400 && response.status < 500) {
          console.log(
            `[SubscriptionSettingsLoader] Client error ${response.status}:`,
            response.body
          );
          setErrorMessage(`${response.body.error}: ${response.body.message}`);
          setSubscriptionSettings(null);
        } else if (response.status === 200) {
          console.log("[SubscriptionSettingsLoader] Successfully loaded settings:", response.body);
          setSubscriptionSettings(response.body);
          setErrorMessage("");
        }
      } catch (error) {
        console.error("[SubscriptionSettingsLoader] Error loading subscription settings:", error);
        setSubscriptionSettings(null);
        setErrorMessage("Unable to access your account. Please try refreshing the page.");
      } finally {
        console.log(
          `[SubscriptionSettingsLoader][DEBUG] Finished loading subscription settings for ${ofUserId}`
        );
        setIsLoading(false);
        hasLoadedRef.current = true;
        loadingRequestRef.current = false;
      }
    },
    [ofUserId, getSubscriptionSettings, setSubscriptionSettings]
  );
  const handleAddCreator = reactExports.useCallback(
    async (subscriptionSettingsIdOverride = void 0) => {
      setIsAddingCreator(true);
      try {
        const updateData = { addOfCreatorId: ofUserId };
        if (subscriptionSettingsIdOverride !== void 0) {
          updateData.subscriptionSettingsId = subscriptionSettingsIdOverride;
        }
        const response = await updateSubscriptionSettings(updateData, true);
        if (response.status === 200) {
          const shouldShowConfirmCreatorAddedView = await checkConfirmCreatorAddedView(
            response.body
          );
          setShowConfirmCreatorAddedView(shouldShowConfirmCreatorAddedView);
          await new Promise((resolve) => setTimeout(resolve, 50));
          setSubscriptionSettings(response.body);
          setErrorMessage("");
        } else if (response.status >= 400) {
          console.error("Error adding creator:", response.body);
          setErrorMessage(response.body.message);
          throw new Error(response.body.message);
        }
      } catch (error) {
        console.error("Error adding creator:", error);
        if (error.message) {
          setErrorMessage(error.message);
        } else {
          setErrorMessage("Failed to add creator. Please try again.");
        }
      } finally {
        setIsAddingCreator(false);
      }
    },
    [ofUserId, updateSubscriptionSettings, checkConfirmCreatorAddedView, setSubscriptionSettings]
  );
  const handleLogout = reactExports.useCallback(async () => {
    try {
      setIsLoggedIn(false);
      await LocalStorageManager.clear();
    } catch (error) {
      console.error("Error during logout:", error);
    }
  }, [setIsLoggedIn]);
  const handleConfirmCreatorAddedDismiss = reactExports.useCallback(() => {
    setShowConfirmCreatorAddedView(false);
    LocalStorageManager.setConfirmCreatorAddedDismissed(true);
  }, []);
  reactExports.useEffect(() => {
    if (ofUserId && isLoading && !hasLoadedRef.current) {
      loadSubscriptionSettings();
    }
  }, [ofUserId, loadSubscriptionSettings]);
  reactExports.useEffect(() => {
    let didCancel = false;
    if (isLastSeenActiveTab && ofUserId && !hasLoadedRef.current && !loadingRequestRef.current) {
      console.log(
        `[SubscriptionSettingsLoader][DEBUG] Became active, loading subscription settings for ${ofUserId}`
      );
      const timeoutId2 = setTimeout(() => {
        if (!didCancel && !hasLoadedRef.current) {
          loadSubscriptionSettings(true);
        }
      }, 100);
      return () => {
        didCancel = true;
        clearTimeout(timeoutId2);
      };
    } else if (!isLastSeenActiveTab && ofUserId) {
      console.log(
        `[SubscriptionSettingsLoader][DEBUG] Became inactive, not loading subscription settings for ${ofUserId}`
      );
      hasLoadedRef.current = false;
    } else if (!ofUserId) {
      console.log(
        `[SubscriptionSettingsLoader][DEBUG] No ofUserId, not loading subscription settings`
      );
    }
  }, [isLastSeenActiveTab, ofUserId, loadSubscriptionSettings]);
  if (!ofUserId) {
    return /* @__PURE__ */ jsxRuntimeExports.jsx(AutoConfirmCloseWrapper, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(OnlyFansLoginRequiredView, { onLogout: handleLogout }) });
  }
  if (isLoading && ofUserId) {
    return /* @__PURE__ */ jsxRuntimeExports.jsx(AutoConfirmCloseWrapper, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(LoadingView, {}) });
  }
  if (!((_a = subscriptionSettings == null ? void 0 : subscriptionSettings.ofCreatorIds) == null ? void 0 : _a.includes(ofUserId))) {
    return /* @__PURE__ */ jsxRuntimeExports.jsx(AutoConfirmCloseWrapper, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      CreatorNotAddedView,
      {
        onAddCreator: handleAddCreator,
        onLogout: handleLogout,
        isAddingCreator,
        errorMessage,
        subscriptionSettingsId: subscriptionSettings == null ? void 0 : subscriptionSettings._id
      }
    ) });
  }
  if (showConfirmCreatorAddedView) {
    return /* @__PURE__ */ jsxRuntimeExports.jsx(AutoConfirmCloseWrapper, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(ConfirmCreatorAddedView, { onDismiss: handleConfirmCreatorAddedDismiss }) });
  }
  return children;
};
const isFreeTrialConversion = (activeTab) => {
  return activeTab === "upgradeToPaid" || activeTab === "upgradeToPaidConfirm" || activeTab === "downgradeToFreeConfirm";
};
const BannerAwareWrapper = ({ children }) => {
  const bannerState = Recoil_index_20(inAppBannerAtom);
  const subscriptionSettingsId = Recoil_index_20(subscriptionSettingsIdSelector);
  const enabled = Recoil_index_20(followExpiredFansSelector);
  useAutoFollowExpiredFans_v2(enabled, subscriptionSettingsId);
  return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: `flex h-full w-full ${bannerState.isVisible ? "mt-4" : ""}`, children });
};
const NavigationWithRef = () => {
  const { setTabNavigationRef } = useFloatingButton();
  const navRef = reactExports.useRef(null);
  const { activeTab } = useTabNavigation();
  reactExports.useEffect(() => {
    if (navRef.current) {
      setTabNavigationRef(navRef.current);
    }
  }, [setTabNavigationRef]);
  if (isFreeTrialConversion(activeTab)) {
    return null;
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { ref: navRef, children: /* @__PURE__ */ jsxRuntimeExports.jsx(TabNavigation, {}) });
};
const LoggedInView = () => {
  const subscriptionSettingsId = Recoil_index_20(subscriptionSettingsIdSelector);
  const { activeTab } = useTabNavigation();
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(LastSeenActiveTabTracker, {}),
    /* @__PURE__ */ jsxRuntimeExports.jsx(CreatorNotLinkedStatusBarManager, {}),
    /* @__PURE__ */ jsxRuntimeExports.jsx(SubscriptionSettingsLoader, { children: subscriptionSettingsId ? /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(SubscriptionStatusBarManager, {}),
      /* @__PURE__ */ jsxRuntimeExports.jsxs(FloatingButtonProvider, { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(InAppStatusBanner, {}),
        /* @__PURE__ */ jsxRuntimeExports.jsx(CreatorSettingsWrapper, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(InjectorWrapper, { children: isFreeTrialConversion(activeTab) ? /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex w-full flex-grow flex-col items-center justify-center", children: /* @__PURE__ */ jsxRuntimeExports.jsx(TabContent, {}) }) : /* @__PURE__ */ jsxRuntimeExports.jsxs(BannerAwareWrapper, { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(NavigationWithRef, {}),
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "scrollbar-hide relative flex w-full flex-grow flex-col space-y-2 overflow-y-auto p-10 xl:p-16", children: /* @__PURE__ */ jsxRuntimeExports.jsx(TabContent, {}) })
        ] }) }) })
      ] })
    ] }) : /* @__PURE__ */ jsxRuntimeExports.jsx("div", { children: "Loading settings..." }) })
  ] });
};
const ReferralLoggedOutView = ({
  title = "Set up your automatic scam protection 💕",
  subtext = "Create a free Spicy Toolbox account so we can warn you about scammers while you chat. Your chargebacks will get added to our shared blocklist that keeps other creators safe too 💜"
}) => {
  var _a;
  const [email, setEmail] = reactExports.useState("");
  const [firstName, setFirstName] = reactExports.useState("");
  const [lastName, setLastName] = reactExports.useState("");
  const [otp, setOtp] = reactExports.useState("");
  const [showOtpInput, setShowOtpInput] = reactExports.useState(false);
  const [showNameInput, setShowNameInput] = reactExports.useState(false);
  const [isLoading, setIsLoading] = reactExports.useState(false);
  const [error, setError] = reactExports.useState("");
  const [lastSubmittedOtp, setLastSubmittedOtp] = reactExports.useState("");
  const { signUpOrContinueWithOTP, login } = useNetworkManager();
  const setIsLoggedIn = Recoil_index_24(isLoggedInAtom);
  const emailInputRef = reactExports.useRef(null);
  const websiteOrigin = Recoil_index_20(websiteOriginAtom);
  const isEmailValid = email.trim().length > 0 && /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(email);
  const isNameValid = firstName.trim().length > 0 && lastName.trim().length > 0;
  const isOtpValid = otp.trim().length >= 6;
  const isSpicyBlocklist = (_a = websiteOrigin == null ? void 0 : websiteOrigin.site) == null ? void 0 : _a.includes("spicyblocklist");
  reactExports.useEffect(() => {
    const handleMessage = (event) => {
      var _a2;
      if (event.data.type === "FOCUS_EMAIL" && !showNameInput && !showOtpInput) {
        (_a2 = emailInputRef.current) == null ? void 0 : _a2.focus();
      }
    };
    window.addEventListener("message", handleMessage);
    return () => window.removeEventListener("message", handleMessage);
  }, [showNameInput, showOtpInput]);
  reactExports.useEffect(() => {
    if (showOtpInput && otp.length === 6 && otp !== lastSubmittedOtp && !isLoading) {
      setLastSubmittedOtp(otp);
      handleOtpSubmit({ preventDefault: () => {
      } });
    }
    if (otp.length < 6) {
      setLastSubmittedOtp("");
    }
  }, [otp, showOtpInput, lastSubmittedOtp, isLoading]);
  const handleEmailSubmit = async (e2) => {
    e2.preventDefault();
    setIsLoading(true);
    setError("");
    try {
      const response = await signUpOrContinueWithOTP(email, true);
      if (response.status === 200) {
        if (response.body.accessToken && response.body.refreshToken) {
          await LocalStorageManager.setAccessToken(response.body.accessToken);
          await LocalStorageManager.setRefreshToken(response.body.refreshToken);
          setIsLoggedIn(true);
          return;
        }
        if (response.body.shouldPromptForName) {
          setShowNameInput(true);
          setShowOtpInput(response.body.shouldPromptForOTP);
        } else if (response.body.shouldPromptForOTP) {
          setShowOtpInput(true);
          setShowNameInput(false);
        } else {
          setError("Something went wrong. Please try again.");
        }
      } else {
        setError("Failed to process your request. Please try again.");
      }
    } catch (error2) {
      setError("An error occurred. Please try again later.");
      console.error("Error during login request:", error2);
    } finally {
      setIsLoading(false);
    }
  };
  const handleNameSubmit = (e2) => {
    e2.preventDefault();
    setShowNameInput(false);
    setShowOtpInput(true);
  };
  const handleOtpSubmit = async (e2) => {
    e2.preventDefault();
    setIsLoading(true);
    setError("");
    console.log(
      `[DEBUG] Submitting OTP: ${otp}, email: ${email}, firstName: ${firstName}, lastName: ${lastName}`
    );
    try {
      const response = await login({
        email,
        otp,
        ...{ firstName, lastName }
      });
      if (response.status === 200) {
        const accessToken = response.body.accessToken;
        const refreshToken = response.body.refreshToken;
        await LocalStorageManager.setAccessToken(accessToken);
        await LocalStorageManager.setRefreshToken(refreshToken);
        setIsLoggedIn(true);
      } else {
        setError("Login failed. Please check your OTP and try again.");
        setLastSubmittedOtp("");
        setOtp("");
      }
    } catch (error2) {
      setError("An error occurred. Please try again later.");
      setLastSubmittedOtp("");
      setOtp("");
      console.error("Error during login:", error2);
    } finally {
      setIsLoading(false);
    }
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsx(AutoConfirmCloseWrapper, { children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "bg-white/90 flex h-full min-h-screen w-full items-center justify-center backdrop-blur-xl", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex w-full flex-col items-center", children: [
    (showOtpInput || showNameInput) && /* @__PURE__ */ jsxRuntimeExports.jsxs(
      "button",
      {
        onClick: () => {
          if (showNameInput) {
            setShowOtpInput(false);
            setShowNameInput(false);
          } else if (showOtpInput) {
            setShowOtpInput(false);
            setShowNameInput(false);
          }
        },
        className: "absolute left-7 top-5 flex items-center text-gray-600 hover:text-gray-900",
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "svg",
            {
              className: "mr-2 h-5 w-5",
              fill: "none",
              strokeLinecap: "round",
              strokeLinejoin: "round",
              strokeWidth: "2",
              viewBox: "0 0 24 24",
              stroke: "currentColor",
              children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M10 19l-7-7m0 0l7-7m-7 7h18" })
            }
          ),
          "Back"
        ]
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "bg-white mx-4 mb-8 mt-6 max-w-5xl px-8 sm:mt-2 md:px-20", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex max-w-4xl flex-col items-center justify-start", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("h1", { className: "mb-2 text-2xl font-bold sm:mb-8", children: "Spicy Toolbox 🌶️" }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex flex-col items-center space-y-3", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "div",
            {
              className: `${showNameInput ? "mb-3" : "mb-6"} flex w-full max-w-xl items-center justify-center px-20`,
              children: /* @__PURE__ */ jsxRuntimeExports.jsx(FeatureCarousel, { showBlocklistFeatures: isSpicyBlocklist })
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex flex-col items-center space-y-3", children: !showNameInput && !showOtpInput ? /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { className: "text-center text-2xl font-bold", children: title }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-center text-sm italic text-gray-500", children: subtext })
          ] }) : showNameInput ? /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { className: "text-center text-2xl font-bold", children: "What's your name?" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-center text-sm italic text-gray-500", children: "This will show up in your account settings. Fans will never see this information 👀" })
          ] }) : /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { className: "text-center text-2xl font-bold", children: "Enter your login code" }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { className: "text-center text-sm italic text-gray-500", children: [
              "Check your email ",
              email,
              " for your code. If you don't see it soon, check your spam folder 🙏"
            ] })
          ] }) })
        ] })
      ] }),
      error && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "mb-4 mt-4 rounded-md bg-red-50 p-3 text-sm text-red-500", children: error }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: `${showNameInput ? "mt-6" : "mt-10"} w-full self-center`, children: !showNameInput && !showOtpInput ? (
        // Email form
        /* @__PURE__ */ jsxRuntimeExports.jsxs("form", { onSubmit: handleEmailSubmit, className: "space-y-3", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "relative w-full", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
            "input",
            {
              ref: emailInputRef,
              type: "email",
              value: email,
              onChange: (e2) => setEmail(e2.target.value),
              placeholder: "Email",
              className: `w-full rounded-md border px-4 py-3 focus:outline-none focus:ring-0 ${isEmailValid ? "border-emerald-500 focus:border-emerald-500" : "border-gray-400 focus:border-indigo-500 focus:bg-gray-100"}`,
              required: true,
              disabled: isLoading,
              autoFocus: true
            }
          ) }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "button",
            {
              type: "submit",
              className: `text-white w-full rounded-md bg-gradient-to-r from-purple-500 to-indigo-500 py-3 font-semibold ${isLoading || !isEmailValid ? `cursor-not-allowed ${isLoading ? "opacity-50" : ""}` : "hover:opacity-90"}`,
              disabled: isLoading || !isEmailValid,
              children: isLoading ? "Logging in..." : "Continue with email"
            }
          )
        ] })
      ) : showNameInput ? (
        // Name form (if we need to show it based on the Figma flow)
        /* @__PURE__ */ jsxRuntimeExports.jsxs("form", { onSubmit: handleNameSubmit, className: "space-y-3", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "space-y-3", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "input",
              {
                type: "text",
                value: firstName,
                onChange: (e2) => setFirstName(e2.target.value),
                placeholder: "First name",
                className: `w-full rounded-md border px-4 py-3 focus:outline-none focus:ring-0 ${firstName.trim().length > 0 ? "border-emerald-500 focus:border-emerald-500" : "border-gray-400 focus:border-indigo-500 focus:bg-gray-100"}`,
                required: true,
                disabled: isLoading
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "input",
              {
                type: "text",
                value: lastName,
                onChange: (e2) => setLastName(e2.target.value),
                placeholder: "Last name",
                className: `w-full rounded-md border px-4 py-3 focus:outline-none focus:ring-0 ${lastName.trim().length > 0 ? "border-emerald-500 focus:border-emerald-500" : "border-gray-400 focus:border-indigo-500 focus:bg-gray-100"}`,
                required: true,
                disabled: isLoading
              }
            )
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "button",
            {
              type: "submit",
              className: `text-white w-full rounded-md bg-gradient-to-r from-purple-500 to-indigo-500 py-3 font-semibold ${isLoading || !isNameValid ? `cursor-not-allowed ${isLoading ? "opacity-50" : ""}` : "hover:opacity-90"}`,
              disabled: isLoading || !isNameValid,
              children: isLoading ? "Saving..." : "Continue"
            }
          )
        ] })
      ) : (
        // OTP form
        /* @__PURE__ */ jsxRuntimeExports.jsxs("form", { onSubmit: handleOtpSubmit, className: "space-y-3", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "relative w-full", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
            "input",
            {
              type: "text",
              value: otp,
              onChange: (e2) => setOtp(e2.target.value),
              placeholder: "Enter OTP",
              className: `w-full rounded-md border px-4 py-3 focus:outline-none focus:ring-0 ${isOtpValid ? "border-emerald-500 focus:border-emerald-500" : "border-gray-400 focus:border-indigo-500 focus:bg-gray-100"}`,
              required: true,
              disabled: isLoading
            }
          ) }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "button",
            {
              type: "submit",
              className: `text-white w-full rounded-md bg-gradient-to-r from-purple-500 to-indigo-500 py-3 font-semibold ${isLoading || !isOtpValid ? `cursor-not-allowed ${isLoading ? "opacity-50" : ""}` : "hover:opacity-90"}`,
              disabled: isLoading || !isOtpValid,
              children: isLoading ? "Logging in..." : "Continue"
            }
          )
        ] })
      ) })
    ] })
  ] }) }) });
};
const LoggedOutView = () => {
  const websiteOrigin = Recoil_index_20(websiteOriginAtom);
  const ofUserId = Recoil_index_20(ofUserIdAtom);
  reactExports.useEffect(() => {
    let timeoutId2;
    console.log("[LoggedOutView] websiteOrigin", websiteOrigin);
    if ((websiteOrigin.site.includes("spicyblocklist") || websiteOrigin.site.includes("spicytoolbox")) && ofUserId) {
      timeoutId2 = setTimeout(() => {
        window.parent.postMessage(
          {
            type: "TOGGLE_MODAL",
            fadeIn: true,
            forceOpenModal: true
          },
          "*"
        );
      }, 750);
    }
    return () => {
      if (timeoutId2) {
        clearTimeout(timeoutId2);
      }
    };
  }, [websiteOrigin, ofUserId]);
  if (websiteOrigin.site.includes("spicyblocklist")) {
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      ReferralLoggedOutView,
      {
        title: "Set up your automatic scam protection 💕",
        subtext: "Create a free Spicy Toolbox account so we can warn you about scammers while you chat. Your chargebacks will get added to our shared blocklist that keeps other creators safe too 💜"
      }
    );
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    ReferralLoggedOutView,
    {
      title: "Try Spicy Toolbox for free and start earning more 💕",
      subtext: "Create a free Spicy Toolbox account and access the tools creators use every day to maximize their revenue 💜"
    }
  );
};
const fallbackRules = {
  static_param: "r0COhCenVY6tUCrcnkbwz727f1m0UHsv",
  format: "36587:{}:{:x}:67a0ec50",
  checksum_indexes: [
    1,
    1,
    1,
    2,
    2,
    5,
    5,
    6,
    6,
    7,
    7,
    11,
    12,
    12,
    13,
    14,
    14,
    16,
    17,
    20,
    20,
    20,
    21,
    23,
    24,
    25,
    25,
    25,
    29,
    30,
    31,
    39
  ],
  checksum_constant: 118,
  app_token: "33d57ade8c02dbc5a333db99ff9ae26a",
  revision: "202502031617-af2daeeb87"
};
const requiredFields = [
  "static_param",
  "format",
  "checksum_indexes",
  "checksum_constant",
  "app_token",
  "revision"
];
function rulesAreDifferent(existingRules, newRules) {
  if (!existingRules || !newRules)
    return true;
  const differences = {
    static_param: existingRules.static_param !== newRules.static_param,
    format: existingRules.format !== newRules.format,
    checksum_constant: existingRules.checksum_constant !== newRules.checksum_constant,
    app_token: existingRules.app_token !== newRules.app_token,
    revision: existingRules.revision !== newRules.revision,
    checksum_indexes: !arraysEqual(existingRules.checksum_indexes, newRules.checksum_indexes)
  };
  const isDifferent = Object.values(differences).some((diff) => diff);
  if (isDifferent) {
    console.log("[OfAuthRulesSyncer] Found differences in rules:", differences);
  }
  return isDifferent;
}
function arraysEqual(a2, b2) {
  if (!Array.isArray(a2) || !Array.isArray(b2))
    return false;
  if (a2.length !== b2.length)
    return false;
  return a2.every((val, index2) => val === b2[index2]);
}
function validateRules(rules) {
  if (!rules || typeof rules !== "object") {
    console.error("[OfAuthRulesSyncer] Invalid rules object:", rules);
    return false;
  }
  const isValid = requiredFields.every((field) => {
    const value = rules[field];
    if (value === void 0 || value === null) {
      console.error(`[OfAuthRulesSyncer] Missing required field: ${field}`);
      return false;
    }
    switch (field) {
      case "static_param":
      case "format":
      case "app_token":
      case "revision":
        if (typeof value !== "string" || !value.trim()) {
          console.error(`[OfAuthRulesSyncer] Invalid ${field}, expected non-empty string:`, value);
          return false;
        }
        break;
      case "checksum_indexes":
        if (!Array.isArray(value) || !value.length || !value.every((num) => typeof num === "number")) {
          console.error(
            `[OfAuthRulesSyncer] Invalid checksum_indexes, expected non-empty array of numbers:`,
            value
          );
          return false;
        }
        break;
      case "checksum_constant":
        if (typeof value !== "number") {
          console.error(`[OfAuthRulesSyncer] Invalid checksum_constant, expected number:`, value);
          return false;
        }
        break;
    }
    return true;
  });
  return isValid;
}
function OfAuthRulesSyncer() {
  const networkManager = useNetworkManager();
  const hasInitializedRef = reactExports.useRef(false);
  reactExports.useEffect(() => {
    const syncRules = async () => {
      try {
        const storedRules = await LocalStorageManager.getOfAuthRules();
        if (storedRules && validateRules(storedRules)) {
          console.log("[OfAuthRulesSyncer] Using stored rules:", storedRules);
          chrome.runtime.sendMessage({
            type: "UPDATE_OF_AUTH_RULES",
            rules: storedRules
          });
        } else {
          console.log("[OfAuthRulesSyncer] Using fallback rules");
          await LocalStorageManager.setOfAuthRules(fallbackRules);
          chrome.runtime.sendMessage({
            type: "UPDATE_OF_AUTH_RULES",
            rules: fallbackRules
          });
        }
        if (!hasInitializedRef.current) {
          console.log("[OfAuthRulesSyncer] Fetching rules from API for first time this session");
          const newRules = await networkManager.getOfAuthRules();
          hasInitializedRef.current = true;
          if (validateRules(newRules)) {
            console.log("[OfAuthRulesSyncer] Received valid new rules:", newRules);
            const currentRules = await LocalStorageManager.getOfAuthRules();
            if (rulesAreDifferent(currentRules, newRules)) {
              await LocalStorageManager.setOfAuthRules(newRules);
              chrome.runtime.sendMessage({
                type: "UPDATE_OF_AUTH_RULES",
                rules: newRules
              });
            } else {
              console.log("[OfAuthRulesSyncer] Rules have not changed, skipping update");
            }
          } else {
            console.error("[OfAuthRulesSyncer] Received invalid rules from API:", newRules);
          }
        }
      } catch (error) {
        console.error("[OfAuthRulesSyncer] Error syncing OF auth rules:", error);
      }
    };
    syncRules();
    const syncInterval = setInterval(() => {
      console.log("[OfAuthRulesSyncer] Running periodic sync");
      hasInitializedRef.current = false;
      syncRules();
    }, 6e4);
    return () => {
      clearInterval(syncInterval);
    };
  }, [networkManager]);
  return null;
}
const OfRequestHeaderSyncer = () => {
  reactExports.useEffect(() => {
    const handleMessage = async (message, sender, sendResponse) => {
      if (message.type === "onlyFansHeadersUpdated") {
        console.log("[OfRequestHeaderSyncer] onlyFansHeadersUpdated:", message.headers);
        await LocalStorageManager.setOnlyFansHeaders(message.headers);
      }
    };
    chrome.runtime.onMessage.addListener(handleMessage);
    return () => {
      chrome.runtime.onMessage.removeListener(handleMessage);
    };
  }, []);
  return null;
};
const OFUserIdSyncer = () => {
  const [ofUserId, setOfUserId] = Recoil_index_22(ofUserIdAtom);
  reactExports.useEffect(() => {
    let pollingInterval = null;
    const requestCurrentUserIdFromBackground = async () => {
      try {
        const [tab2] = await chrome.tabs.query({ active: true, currentWindow: true });
        if (tab2 == null ? void 0 : tab2.id) {
          console.log(`[OFUserIdSyncer] Requesting user ID for tab ${tab2.id}`);
          chrome.runtime.sendMessage(
            {
              type: "GET_CURRENT_OF_USER_ID",
              tabId: tab2.id
            },
            (response) => {
              if (chrome.runtime.lastError) {
                console.error(
                  "[OFUserIdSyncer] Error requesting user ID:",
                  chrome.runtime.lastError
                );
                return;
              }
              console.log("[OFUserIdSyncer] Got response from background:", response);
              if (response && response.ofUserId) {
                console.log("[OFUserIdSyncer] Setting user ID from background:", response.ofUserId);
                setOfUserId(response.ofUserId);
                if (pollingInterval) {
                  clearInterval(pollingInterval);
                  pollingInterval = null;
                }
              }
            }
          );
        }
      } catch (error) {
        console.error("[OFUserIdSyncer] Error in request:", error);
      }
    };
    const handleMessage = async (message, sender, sendResponse) => {
      if (message.type === "ofUserIdChanged") {
        console.log("[OFUserIdSyncer] ofUserIdChanged:", message.ofUserId);
        setOfUserId(message.ofUserId);
        if (pollingInterval) {
          clearInterval(pollingInterval);
          pollingInterval = null;
        }
      }
    };
    chrome.runtime.onMessage.addListener(handleMessage);
    if (!ofUserId) {
      requestCurrentUserIdFromBackground();
      pollingInterval = setInterval(() => {
        if (!ofUserId) {
          console.log("[OFUserIdSyncer] Retrying background request...");
          requestCurrentUserIdFromBackground();
        } else {
          clearInterval(pollingInterval);
          pollingInterval = null;
        }
      }, 500);
    }
    return () => {
      chrome.runtime.onMessage.removeListener(handleMessage);
      if (pollingInterval) {
        clearInterval(pollingInterval);
      }
    };
  }, [ofUserId, setOfUserId]);
  return null;
};
const ReferrerWebsiteDetector = () => {
  const setWebsiteOrigin = Recoil_index_24(websiteOriginAtom);
  reactExports.useEffect(() => {
    const checkReferralWebsites = () => {
      console.log("[ReferrerWebsiteDetector] Initiating referral cookie check");
      chrome.runtime.sendMessage({ type: "checkReferralWebsites" }, (response) => {
        const error = chrome.runtime.lastError;
        if (error) {
          console.error("[ReferrerWebsiteDetector] Error checking referrals:", error);
          return;
        }
        if (response && response.success && response.referralData) {
          console.log("[ReferrerWebsiteDetector] Received referral data:", response.referralData);
          setWebsiteOrigin({
            site: response.referralData.site,
            timestamp: response.referralData.timestamp
          });
        } else {
          console.log("[ReferrerWebsiteDetector] No referral data found or error occurred");
        }
      });
    };
    checkReferralWebsites();
  }, [setWebsiteOrigin]);
  return null;
};
function App() {
  const isLoggedIn = Recoil_index_20(isLoggedInAtom);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "text-spicy-black flex h-full w-full", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(IconSprite, {}),
    /* @__PURE__ */ jsxRuntimeExports.jsx(OFUserIdSyncer, {}),
    /* @__PURE__ */ jsxRuntimeExports.jsx(OfRequestHeaderSyncer, {}),
    /* @__PURE__ */ jsxRuntimeExports.jsx(OfAuthRulesSyncer, {}),
    /* @__PURE__ */ jsxRuntimeExports.jsx(ReferrerWebsiteDetector, {}),
    /* @__PURE__ */ jsxRuntimeExports.jsx(LoginStatusHandler, {}),
    /* @__PURE__ */ jsxRuntimeExports.jsx(EnvStatusBarManager, {}),
    isLoggedIn ? /* @__PURE__ */ jsxRuntimeExports.jsx(LoggedInView, {}) : /* @__PURE__ */ jsxRuntimeExports.jsx(LoggedOutView, {})
  ] });
}
const index = "";
const originalConsole = {
  log: console.log,
  error: console.error,
  warn: console.warn,
  info: console.info
};
let isEndpointAvailable = null;
let endpointCheckPromise = null;
async function checkEndpointAvailability() {
  if (isEndpointAvailable !== null) {
    return isEndpointAvailable;
  }
  if (endpointCheckPromise) {
    return endpointCheckPromise;
  }
  endpointCheckPromise = new Promise((resolve) => {
    fetch("http://localhost:3025/health", {
      method: "HEAD",
      // Short timeout to avoid hanging
      signal: AbortSignal.timeout(500)
    }).then(() => {
      isEndpointAvailable = true;
      resolve(true);
    }).catch(() => {
      isEndpointAvailable = false;
      resolve(false);
    }).finally(() => {
      endpointCheckPromise = null;
    });
  });
  return endpointCheckPromise;
}
async function sendLogToMCP(type, args) {
  try {
    const available = await checkEndpointAvailability();
    if (!available) {
      return;
    }
    const formattedArgs = Array.from(args).map((arg) => {
      if (typeof arg === "object") {
        try {
          return JSON.stringify(arg);
        } catch (e2) {
          return String(arg);
        }
      }
      return String(arg);
    }).join(" ");
    fetch("http://localhost:3025/custom-log", {
      method: "POST",
      headers: {
        "Content-Type": "application/json"
      },
      body: JSON.stringify({
        type,
        message: `[ReactApp] ${formattedArgs}`,
        timestamp: Date.now(),
        url: "react-app"
      })
    }).catch((err2) => {
      originalConsole.error("Error sending log to server:", err2);
      isEndpointAvailable = false;
    });
  } catch (e2) {
    originalConsole.error("Error formatting log:", e2);
  }
}
const mcpLogger = {
  log: function() {
    sendLogToMCP("log", arguments);
    originalConsole.log.apply(console, arguments);
  },
  error: function() {
    sendLogToMCP("error", arguments);
    originalConsole.error.apply(console, arguments);
  },
  warn: function() {
    sendLogToMCP("warn", arguments);
    originalConsole.warn.apply(console, arguments);
  },
  info: function() {
    sendLogToMCP("info", arguments);
    originalConsole.info.apply(console, arguments);
  }
};
function enableGlobalMCPLogging() {
  console.log = function() {
    sendLogToMCP("log", arguments);
    originalConsole.log.apply(console, arguments);
  };
  console.error = function() {
    sendLogToMCP("error", arguments);
    originalConsole.error.apply(console, arguments);
  };
  console.warn = function() {
    sendLogToMCP("warn", arguments);
    originalConsole.warn.apply(console, arguments);
  };
  console.info = function() {
    sendLogToMCP("info", arguments);
    originalConsole.info.apply(console, arguments);
  };
}
enableGlobalMCPLogging();
mcpLogger.log("React app initialized");
client.createRoot(document.getElementById("root")).render(
  /* @__PURE__ */ jsxRuntimeExports.jsx(React.StrictMode, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(Recoil_index_5, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(App, {}) }) })
);
//# sourceMappingURL=main-0c60659a.js.map
